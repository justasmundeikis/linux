---
title: "BASH pažengusiems"
execute:
  daemon: false
  enabled: false
format:
  html:
    code-copy: true
    eval: false
    echo: true
    css: ../styles.css
---

## Įvadas

Praėjusiame skyriuje susipažinai su įvairiomis CLI (**command line interface**) komandomis, suteikiančiomis pagrindinius įrankius darbui su shell aplinka. Išmokai naudoti `echo`, `cat`, `head`, `tail`, `less`, `wc`, `touch`, `mkdir`, `cp`, `mv`, `rm`, `grep`, `cut`, `sort`, `sed`, taip pat operatorius `>`, `>>`, bei `|`. Šios komandos leidžia dirbti su failais, kurti direktorijas, atlikti filtravimą pagal eilutes ir stulpelius bei automatizuoti užduotis.

### Šiame skyriuje

Šiame skyriuje dar gilinsimės į failų valdymą ir apdorojimą. Sužinosi:

* **Pagalbos komandas** - mokysiesi naudotis `help`, `man` ir `tldr`, kad greitai rastum informaciją apie komandas.
* **Tinklo komandas** - išmoksi naudoti `ping`, `wget` ir `curl`  kad galėtum patikrinti ryšį bei atsisiųsti duomenis.
* **Kaip ieškoti failų** - naudosi `find`, `locate` ir `whereis`, kad efektyviai surastum failus ir suprastum jų vietą.
* **Teksto apdorojimą** - susipažinsi su `uniq` bei `jq` komandomis, kad galėtum analizuoti tekstinius ir JSON failus.
* **Failų teises ir savininkystę** - sužinosi apie `chmod`, `chown` ir `chgrp`, kurie padės valdyti failų teises ir naudotojus.
* **Procesų valdymą** - sužinosi, kaip stebėti ir valdyti procesus naudojant `ps` ir `top` ir `htop`.
* **Nano editorius ir alias** - išmoksi naudoti `nano` ir `alias`, kad galėtum redaguoti tekstinius failus terminale ir kurti komandų trumpinius.

Šis skyrius suteiks tvirtesnį pagrindą darbui su Linux aplinka, padės efektyviau valdyti failus ir suprasti esminius failų teisių, procesų bei tinklo valdymo aspektus. Tai leis tau dirbti su Linux savarankiškiau ir produktyviau.

### ChatGPT Naudojimas

Šiame skyriuje vis dažniau bus pateikiamos nuorodos naudotis ChatGPT. Svarbiausia - išmokti naudotis šiuo įrankiu ne tam, kad jis už tave spręstų problemas, bet kad padėtų greičiau rasti tinkamiausią sprendimą. Štai keletas patarimų:

*   **Konsultantas ir patarėjas** - naudok ChatGPT kaip priemonę savo idėjų ir sprendimų tikrinimui.
*   **Tikslūs klausimai** - suformuluok aiškius ir tikslius klausimus, kurie padės greičiau rasti atsakymą.
*   **Eksperimentavimas** - nebijok išbandyti skirtingus užklausų formatus, jei atsakymas neaiškus ar nepakankamas.
*   **Mokymasis per tobulinimą** - naudok ChatGPT kaip pagalbininką tobulinant savo darbo rezultatus ir įgyjant naujų žinių.

### Refleksijos Metodika

Po kiekvienos dalies perskaitymo atlik šiuos veiksmus:

*   **Užrašyk, ką išmokai** - pasistenk glaustai užfiksuoti pagrindinius aspektus.
*   **Pritaikymas praktikoje** - sugalvok, kur galėtum pritaikyti šias žinias realiose situacijose.
*   **Analizuok sunkumus** - užfiksuok, kas buvo sudėtinga, ir galvok, kaip tai galėtum įveikti ateityje.
*   **Konspektuok** - pradėk kurti savo mokymosi užrašus patogiame įrankyje, pvz., Obsidian. Suskirstyk juos pagal temas ir pateik konkrečius komandų pavyzdžius. Tai padės tau greičiau rasti reikalingą informaciją.

::: {.callout-tip title="Praktika"}
Savo namų direktorijoje susikurk mokymuisi skirtą subdirektoriją, pvz., **bash_advanced**. Pereik į ją ir visus šiame skyriuje reikalingus failus ir duomenis laikyk joje.
:::


## Pagalbos Komandos: `help`, `man` ir `tldr`

Naudojant Linux, komandos gali turėti daugybę nustatymų bei opcijų, kurių kartais sunku prisiminti. Pavyzdžiui, gali kilti klausimas, ar `sort` komandai reikia naudoti `-d` ar `-t` flagą, arba norisi prisiminti, kuo `sed` skiriasi nuo `grep`. Šiame skyriuje išmoksi, kaip efektyviai naudotis pagalbos įrankiais, kurie padės greitai rasti informaciją apie komandas ir jų naudojimo būdus, kai kyla klausimų.

**Kodėl svarbu mokėti rasti informaciją?**

Net patyrę Linux vartotojai retai kada iškart prisimena visus flagus ar argumentus. Mokėjimas greitai rasti informaciją - vienas svarbiausių įgūdžių dirbant su terminalu. Šiame skyriuje išmoksi naudotis pagalbos įrankiais, kad greitai rastum informaciją apie komandas ir jų naudojimo būdus. Tai apims:

* `--help` - greita pagalba komandai: santrauka apie dažniausiai naudojamus nustatymus ir sintaksę.
* `man` -  išsamus komandų vadovas su skyriais, struktūruotais pagal oficialią dokumentaciją.
* `tldr` - paprasti pavyzdžiai ir scenarijai, pateikiantys svarbiausias komandos savybes.
* **ChatGPT** - kaip naudoti jį sudėtingesnėms problemoms aiškintis.

**Scenarijus**

Šioje dalyje pasikartosi prieš tai išmoktas komandas analizuojant fizinių asmenų elektros suvartojimo duomenis naudojant bash.

* Parsisiųsk duomenis

```bash
curl https://get.data.gov.lt/datasets/gov/eso/fizin_asm_elektros_suvartojimas/FizinAsmElektraSuvartojimas/:format/csv -o raw_data_hh_customers.csv
```

* Failas yra apie 2 GB - tai prilygsta maždaug 130 000 puslapių Word dokumentų. Tad kantreybė tavo sąjungininkė. Pasidaryk ☕

![](../img/bash_advanced/5_min_later.jpg)

* Nusprendei susipažinti su duomenimis, analizuojant pirmas **15** eilučių terminale, tačiau pamiršai, kokie flagai naudojami su `wc`, `head` ir `cut` komandomis 🤦🏻. Šioje dalyje išmoksi gauti reikiamą pagalbą.
* Konspektavimas: Tekstiniame dokumente užsirašyk, ką bandei padaryti, kokie naudingi flagai, ir pateik pavyzdines komandas.


### `--help`

Dauguma komandų turi flagą (opciją) `--help`, kuris pateikia santrauką apie komandos veikimą ir galimus flagus. Kai kurios komandos taip pat turi trumpesnį `-h` flagą. Jei `--help` neveikia, pabandyk `-h`. Atmink, kad `--help` veikia tik pagrindinei komandai (pvz., `apt --help`), tačiau subkomandoms (pvz., `apt update --help`) ji gali neveikti.

Išbandyk `ls --help`.
 
![](../img/bash_advanced/help_ls.png)

::: {.callout-tip title="Praktika"}
Kiek eilučių yra **raw_data_hh_customers.csv** faile? Naudok `wc --help`, kad sužinotum flagą, skirtą eilučių skaičiavimui.
:::

### `man`: manual pages

Kartais reikia daugiau informacijos, kad suprastum, kaip kas veikia. Būtent šią funkciją atlieka `man` komanda. Jos pagalba gali peržiūrėti išsamius komandų aprašymus. Kadangi `man` puslapiai yra ilgesni nei `--help`, jie atspausdinami naudojant `less`, kurį jau pažįsti iš ankstesnio skyriaus. Keisti puslapius gali su `space` klavišu, o išeiti su `q`.

`man` puslapis įprastai turi tokią struktūrą: 

* NAME - komandos pavadinimas ir trumpas aprašymas.
* SYNOPSIS - pagrindinė komandos sintaksė, įskaitant flagus ir argumentus.
* DESCRIPTION - detali informacija apie naudojimą.
* OPTIONS - visų galimų flagų paaiškinimai.
* EXAMPLES - kartais pateikiami praktiniai pavyzdžiai.


```bash
man ls
```
![](../img/bash_advanced/man_ls.png)



::: {.callout-tip title="Praktika"}
* Prisimeni, jog su `head` ir `tail` galėjai nurodyti kiek eilučių spausdinti? Pvz., `head -n 15` atspausdina pirmas 15 eilučių. Atsiversk `man head` ir susirask `-n`. Ten aprašytas naudojimas `-` skaičiaus. Dabar pažiūrėk man `tail` ir rask `-n` su `+` naudojimu.
* Dabar tavo failas **raw_data_hh_customers.csv** turi antraštes (header) ir duomenis. Pasinaudojus `head` arba `tail` (pagalvok, kuri čia labiau tinka) bei išmoktais flagais, sukurk naują failą **pure_data.csv**, kuriame būtų visos originalaus failo eilutės, bet ne antraštė.
* Palygink su `wc` eilučių skaičių viename ir kitame faile ir įsitikink, jog skirtumas tik 1 eilutė.
* Su `ls -lh` arba `ls -l` palygink, kiek sutaupei vietos, atsisakius vienos eilutės “duomenų”.
* Konspektuok `head` ir `tail` tame pačiame dokumente, kaip ir `wc`.
:::


### `tldr`

`man` puslapiai yra labai išsamūs, tačiau kartais jie gali pasirodyti per ilgi. `--help` gali suteikti trumpą ir aiškią informaciją, tačiau net ir šie puslapiai gali būti per daug sudėtingi pradedantiesiems. Čia į pagalbą ateina `tldr` - programa, kuri pateikia dažniausiai naudojamus scenarijus ir labai trumpą paaiškinimą apie komandą. Tai dar viena priemonė tavo arsenale, jei pamiršai, kaip veikia komanda.

::: {.callout-tip title="Praktika"}
* Pasitikrink, ar turi `tldr` naudodant `which tldr`.
* Prisimink žingsnius, kuriuos reikia atlikti, norint įdiegti programą.
* Įdiek tldr.
* Jeigu reikia, konspektuokis!
:::


`tldr` komanda priima kaip argumentą kitą komandą. Daugumai standartinių komandų, `tldr` terminale atspausdins dažniausiai naudojamus flagus bei kelis jų taikymo pavyzdžius.

Pabandyk:

* `tldr head`
* `tldr wc`
* `tldr cut`
* `tldr tldr`

![](../img/bash_advanced/tldr_tldr.png)

Kaip matai, `tldr` aprašo ir pačią `tldr` komandą.


::: {.callout-tip title="Praktika"}
* Norėtum palaipsniui išnagrinėti **raw_data_hh_customers.csv** failą, bet pamiršai, kaip pasirinkti tam tikrą stulpelį. Pasinaudok `tldr cut`.
* Jei paleisi `cut ... raw_data_hh_customers.csv`, komanda tau atspausdins daug eilučių. Tai būtų neefektyvu. Prisimink, kaip sujungti skirtingas komandas ir pagalvok, kaip galėtum inspektuoti kiekvieną stulpelį atskirai, matant tik pirmas 15 eilučių. Inspektuok terminale pirmus 10 stulpelių, pabandyk suprasti, ar jie būtų vertingi analizei ar ne.
:::

### ChatGPT

ChatGPT yra naudingas įrankis Linux naudotojams. Jis nėra labai protingas, bet gana efektyvus, jog padėtų tau dirbti. Keli svarbūs dalykai:

* po registracijos tu gali naudotis geresniu modeliu (yra limitas užklausoms, po to įsijungia paprastensis modelis)
* po registracijos išsisaugo tavo užklausų istorija, o tai padeda turėti ilgesnes sesijas. Ilgesnės sesijos yra naudingos, nes ChatGPT reaguoja į visą sesijos kontekstą.

Svarbu pratintis rašyti užklausas ChatGPT. Štai keli patarimai:

* Angliškai ChatGPT supranta ir atsako geriau nei lietuviškai dėl didesnio duomenų kiekio anglų kalba, iš kurio ChatGPT mokėsi.
* Pradėk užklausą suteikiant kontekstą, o ne tik rašant klausimą.
* Kartais gali norėti, jog ChatGPT elgtųsi kaip tam tikras asmuo. Tai gali suformuluoti savo užklausoje.



::: {.callout-tip title="Praktika"}
Prieš tai tu panaudojai 

* `head 15 raw_data_hh_customers.csv | cut -d "," -f 1`  arba  
* `cut -d "," -f 1 raw_data_hh_customers.csv | head 15`

Tačiau kuris variantas yra geresnis? Išbandyk šias užklausas ir palygink jų atsakymus. Rašyk užklausas pradedant vis naują chat’ą, tai simuliuos atskiras užklausas ir neleis ChatGPT mokytis einamojoje sesijoje.


1. *"Ar galima naudoti `cut -d "," -f 1 raw_data_hh_customers.csv | head 1`"*
2. *"Kuri komanda yra efektyvesnė: `head 15 raw_data_hh_customers.csv | cut -d "," -f 1` ar  `cut -d "," -f 1 raw_data_hh_customers.csv | head 15`"*
3. Dabar suteik daugiau konteksto ir įvertink GPT atsakymą į klausimą: *"Aš dirbu su 4 mln. eilučių failu raw_data_hh_customers.csv. Mano tikslas yra peržiūrėti pirmas 15 eilučių kiekvieno stulpelio. Koks komandų head ir cut eiliškumas šioje situacijoje būtų geriausias? Paaiškink savo atsakymą. Elkis taip, tarsi būtum labai patyręs shell (bash) programuotojas."*

Ar pastebėjai skirtumą? Pateikus kontekstą bei paprašius argumentuoti savo pasirinkimą, GPT pateikia kur kas tikslesnį atsakymą. Papildomas prašymas veikti kaip patyręs bash programuotojas dažnai duoda naudingesnę informaciją.
:::



Įsimink:

*   **Kontekstas**: ką tu darai
*   **Tikslas**: kokį rezultatą nori gauti
*   **Problemos**: ką gauni vietoj to, ko negauni, arba kur matai problemą
*   **Prašymas paaiškinti savo pasirinkimą**
*   "**Agento**" kūrimas, pasakant, kaip turėtų elgtis GPT

Yra žingsniai, kurie padės efektyviau dirbti.

### Konspektavimas

Galbūt jau pastebi, kad prisiminti visas komandas nėra lengva. Kai kurios taps įprasta ir nuolat naudojama atmintimi, tačiau kitos gali pranykti iš atminties. Dirbant analitikoje ar programavime, niekada neprisiminsi visko. Tiesiog reikia įprasti naudotis savo "antrinėmis smegenimis" - konspektuotis viską taip, kad prireikus galėtum greitai rasti reikiamą informaciją.

Pavyzdžiui, analitikai dažnai išsisaugo ilgus duomenų užklausų kodų gabalus (**code chunks**), ypač jei jų prireikia reguliariai. Programuotojai taip pat dažnai naudoja įrankius kaip Obsidian ar Joplin konspektams.

Aš dažnai naudoju Obsidian arba Joplin, kad konspektuočiausi apie kilusias problemas, kaip jas sprendžiau, kas veikė ir kas ne. Konspektavimas prasideda dar tebesitęsiant problemai. Pvz., kai mano kompiuteris negalėjo sukurti VPN tunelio, kartu su ChatGPT bandžiau spręsti kilusias problemas. Visa šį procesą aš užfiksavau, kad ateityje galėčiau greičiau rasti sprendimus.

Kitas scenarijus - kaip aš įdiegiu savo Linux sistemą. Kadangi mano kompiuteris naudojamas tiek darbo, tiek asmeniniais tikslais, man svarbu turėti gerai aprašytą procesą, ką turiu instaliuoti, po ko ir kodėl. Po instaliavimo proceso, nuolat pridedu naujas programas į šį dokumentą, kad visada turėčiau aktualiausią jo versiją. Nedarydamas to, sukuriu techninę skolą (**tech debt**) - terminą, naudojamą IT pasaulyje, kai kažkas padaroma greitai, paliekant problemas ateičiai. Visada venk *tech debt*, nes dažnai sutaupai tuo metu 5 minutes, kurios paskui tau kainuos 55.


1. Peržiūrėk [Getting Started](https://help.obsidian.md/Home) pirmus 4 skyrius apie Obsidian.
1. Įdiek Obsidian naudojant Flatpak. Susikurk "vault" (direktoriją, kurioje bus visi Obsidian užrašai, idealu - į savo namų serverį Nextcloud).
1. Perkelk savo konspektus kaip naujus užrašus. Pagalvok, kokia būtų geriausia aplankų ir failų struktūra. Nebijok, ji keisis ateityje.

Obsidian naudoja Markdown formatą. Peržiūrėk šį [Cheat Sheet](https://www.markdownguide.org/cheat-sheet/), kaip jis naudojamas.

Taip pat rekomenduoju peržiūrėti / skaityti:

* [I learned a system for remembering everything
](https://youtu.be/Rvey9g0VgY0)

* [I learned a productivity system for organizing life
](https://youtu.be/0_44XEVOwek)

* [TF kanale: PARA metdas- 4 video](https://youtube.com/playlist?list=PLVNXAaej57W6qCYoMb_hbzDhX9et_GVlj)



## Tinklo komandos

Šioje dalyje išmoksi naudoti `ping`, `curl` ir `wget`, kad galėtum patikrinti ryšį bei atsisiųsti duomenis.

### `ping` komanda

Filmuose apie povandeninius laivus dažnai girdime sonarų "**ping**" garsą, kuris naudojamas sekant objektus po vandeniu. Panašiai ir tu gali naudoti `ping` komandą, kuri padeda patikrinti, ar turi prieigą prie interneto, ir ar tavo norimas pasiekti serveris yra pasiekiamas.

{{< video ../img/bash_advanced/OP2.mp4 >}}

Jeigu nėra garso, originalas [Youtube](https://www.youtube.com/watch?v=UeO4SV-wghs)


Linux sistemoje komanda `ping <host>` leidžia nurodyti norimą URL ar IP adresą. Skirtingai nei Windows sistemoje, Linux ping komanda nesustoja automatiškai, todėl rekomenduojama naudoti `-c` (count) flagą, kad nurodytum, kiek ping signalų turėtų būti siunčiama, pvz., 5.

Pabandyk

```bash
ping -c 5 infraplanas.lt
```

Tu turėtum pamatyti panašią išvestį:

![](../img/bash_advanced/ping.png)

Ping išvestis

* ping nurodo, kokį adresą pingina, ir pateikia IP adresą (pvz., 65.108.247.94).
* Turėtum gauti 5 eilutes ping'ų atgal su meta duomenimis, tarp jų - kiek laiko užtruko signalui nueiti ir grįžti.
* ping komanda sustos po 5 kartų

Dabar tu gali pabandyti naudoti šį adresą norint atsidaryti tinklapį:


```bash
brave-browser 65.108.247.94
```

Gali `brave-browser` pakeisti `firefox` ar kita sistemoje įdiegta interneto naršykle.

{{< video ../img/bash_advanced/open_ping.mp4 >}}

Kaip matai, tai veikia. Bet taip nebus visada. Pateiksiu trumpą paaiškinimą po praktikos.

::: {.callout-tip title="Praktika"}
* Pasinaudok `tldr` ir identifikuok pagrindinius `ping` flagus. Kada ir kokius naudotum? Konspektuokis.
* Pabandyk pinginti 3 kartus **vinted.lt**.
* Bandyk atsidaryti pingintą IP su `brave-browser <host ip>`.
:::

**Kodėl ping veikia, bet atidaryti tinklapį pagal IP kartais nepavyksta?**

Trumpai apie tai, kodėl tau pavyko pingtini vinted.lt, bet nepavyko atsidaryti 172.64.150.26. 

![](../img/bash_advanced/ping_cloudflare.png)

Kai naršyklėje įrašai, pvz., vinted.lt, tavo kompiuteris dar neturi informacijos, koks tai konkretus IP adresas. Todėl jis siunčia užklausą į DNS (**Domain Name System**) serverį, kuris pasako, koks IP adresas atitinka tą domeną. Kai žinai IP, tavo kompiuteris gali siųsti užklausas tiesiai į tą serverį.

Kai kurie tinklapiai, kaip infraplanas.lt, gali būti pasiekiami tiesiogiai per IP, nes jie yra paprasti ir neturi papildomų saugumo sluoksnių. Tačiau dauguma šiuolaikinių svetainių naudoja apsaugos priemones, kaip Cloudflare, kurios veikia kaip ugniasienė ir apsaugo serverius nuo kenkėjiškų veiksmų. Kai bandai pasiekti tokį serverį tiesiai per IP, Cloudflare gali neleisti užmegzti ryšio, nes IP užklausos neperduoda visos būtinos kontekstinės informacijos, pvz., kokiame URL kontekste užklausa buvo atlikta, t.y. trūksta tam tikros informarijos užklausos **header** dalyje.

![](../img/bash_advanced/no_no.jpg)


::: {.callout-tip title="Praktika"}
* Pabandyk atjungti savo Wi-Fi ryšį ir pinginti, pvz., **lrt.lt**. Gauni kitokią išvestį. Pagalvok, ar tai yra **stdout** ar **stderr**? Ar galėtum skirtingai nukreipti išvestis? Paeksperimentuok.

![](../img/bash_advanced/ping_failed.png)
:::

## curl ir wget

`curl` ir `wget` yra įrankiai darbui su tinklo užklausomis, tačiau jų paskirtis skiriasi. `wget` yra orientuotas į failų atsisiuntimą, palaiko rekursyvų atsisiuntimą ir automatiškai atnaujina nutrauktus parsisiuntimus. `curl` yra universalesnis ir tinka ne tik failų atsisiuntimui, bet ir duomenų siuntimui (pvz., **API** užklausoms). Pagal nutylėjimą, `curl` išveda duomenis į terminalą.


#### wget

Atsidaryk [https://data.gov.lt/](https://data.gov.lt) ir surask "Transporto priemonių valstybiniai numeriai pagal markę ir modelį" duomenis. 

Papaudus ant "Duomenys" ir "Atsiųsti", tu suprantama gali atsisiųsti duomenis. Bet toks būdas nebūtų automatizuojamas ateityje, kai norėsi atnaujinti duomenis.

![](../img/bash_advanced/get_data.png)

Nueik į API skiltį, nusikopijuok adresą esančios užklausos adrese.

![](../img/bash_advanced/wget_1.png)
 
 Terminale irašyk ir paleisk šią komandą:
 
 ```bash
 wget https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris
 ```

 ![](../img/bash_advanced/wget_2.png)

Peržiūrėk išvestį. `wget` iš pradžių rezolvin'a URL adresą ir gauna IP (pvz., 193.219.12.192), tada jungiasi prie jo. Gauni atsakymą, kad prisijungti pavyko (200 OK), ir tada duomenys pradeda parsisiųsti. Failas išsaugomas kaip **ValstybinisNumeris**.

![](../img/bash_advanced/wget_3.png)


Tačiau, jei bandysi naudoti komandą `head ValstybinisNumeris`, pastebėsi, kad terminalas nesustoja spausdinti išvesties. Taip yra dėl to, kad duomenys yra JSON formatu, kuriame visi duomenys yra įrašyti **vienoje** eilutėje. **JSON** formatas yra labai naudingas duomenų mainams, tačiau šiuo atveju jis nėra tinkamas, kai nori peržiūrėti duomenis eilutėmis. Šis formatas bus aptartas išsamiau vėliau.

Net ir naudojant flagą `--output-document ValstybinisNumeris.csv`, kuris leidžia nurodyti pageidaujamą failo pavadinimą, po .csv failu vis tiek slėpsis JSON formatu užkoduoti duomenys. Pabandyk dar kartą atsisiųsti failą su komanda:

 ```bash
 wget https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris --output-document ValstybinisNumeris.csv
 ```

Kai atidarysi šį failą naudojant LibreOffice Calc, pastebėsi, kad duomenys nėra tinkamai suformatuoti:

```bash
libreoffice --calc ValstybinisNumeris.csv
```

![](../img/bash_advanced/wget_4.png).

Panašu, kad duomenys serveryje saugomi ne visai tokiu formatu, koks mums būtų patogiausias. Priežastis ta, kad [https://data.gov.lt/](https://data.gov.lt/) veikia kaip vartotojui draugiškas fasadas, tačiau už jo slepiasi sudėtingesnė sistema, pavadinta **duomenų spinta**. Ši sistema gali pateikti duomenis įvairiais formatais.

Norint pasiekti tą mažiau gražią "spintą", sek šias nuorodas:

![](../img/bash_advanced/wget_5.png).

Viršuje pamatysi visus galimus duomenų parsisiuntimo formatus. Jei naršyklėje paspausi kairės pelės mygtuku ant CSV, pradėsi automatiškai atsisiųsti failą **ValstybinisNumeris.csv**. Norint gauti nuorodą, kurią gali panaudoti `wget` komandoje, spausk dešiniu pelės mygtuku ant CSV ir meniu pasirink "Kopijuoti nuorodą" (**copy link**).

![](../img/bash_advanced/wget_6.png).

Nuoroda, kurią turėtum gauti, atrodo taip:

`https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris/:format/csv`

Kaip matai, ji nedaug tesiskiria nuo tos kurią turėjai:

`https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris`

Matomas skirtumas yra `/:format/csv` dalelė URL adrese, kuri nurodo, jog duomenys turi būti parsiunčiami CSV formatu. Šis papildymas užtikrina teisingą duomenų formatą tavo naudojimui.

Tai užtikrins, kad naudojant `wget` komandą, gausi duomenis būtent CSV formatu - tokiu, kuris yra lengvai analizuojamas ir atidaromas su įprastinėmis programomis, tokiomis kaip LibreOffice Calc ar Excel.

::: {.callout-tip title="Praktika"}
* Naudojant `rm` išsivalyk darbo direktoriją nuo nereikalingų failų.
* Naudodajant `wget` ir nukopijuotą nuorodą, parsiųsk duomenis su `--output-document ValstybinisNumeris.csv`.
* Kol duomenys siunčiasi - pasidaryk kavos ☕.
* Atspausdink pirmas 5 **ValstybinisNumeris.csv** failo eilutes ir įsitikink, jog duomenys tokie, kokių tikėjaisi.

![](../img/bash_advanced/wget_7.png)
:::

### curl

`curl` yra universalesnė programa, tinkama ne tik failų atsisiuntimui, bet ir duomenų siuntimui (pvz., API užklausoms). Ji veikia su daugiau tinklo protokolų ir pagal nutylėjimą išveda duomenis į terminalą, o ne į failą.

Jei paleistum curl be nustatymų, kaip pvz.,:

```bash
curl https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris/:format/csv
```
pamatytum, kaip duomenys skrieja terminale:

![](../img/bash_advanced/curl_1.png)


::: {.callout-tip title="Praktika"}
* Naudok `tldr curl`, `curl --help` ir ChatGPT, kad identifikuotum pagrindinius flagus `curl` komandai
* Naudojant `curl`, parsisiųsk **ValstybinisNumeris.csv** failą.
* Tinklapyje [https://data.gov.lt](https://data.gov.lt) susirask duomenis **Valstybės apdovanojimai**. Parsisiųsk juos .csv formatu su `wget` ir išsaugok pavadinimu **apdovanojimai.csv**. Prisimink, jog URL adresą gali pasiimti iš API skiltyje esančios užklausos adreso, tik turėtum pridėti `/:format/csv`.
* Su `curl` parsisiųsk "Pacientų registracijos paslaugoms Žalgirio klinikoje" ir išsaugok kaip **reg_zalgiris.csv**.
:::


## Failų Redagavimas ir Apdorojimas

Praeitame skyriuje tu jau išmokai naudotis komanda sed, kuri yra labai galinga apdorojant raw duomenis. Dabar dar praplėsi savo supratimą, kaip gali išnaudoti uniq, kad geriau susipažintum su failo struktūra ar netgi atliktum mini analizes. Taip pat susipažinsi su JSON formatu, nes ne visada gali pavykti jo išvengti, o apdoroti JSON duomenis nėra labai sudėtinga net ir naudojant bash. Tiesa, Python tai padaryti lengviau.

### uniq 

Tu jau moki surūšiuoti failo eilutes su komanda `sort`, tiek didėjančia (A-Z), tiek mažėjančia (Z-A) tvarka, taip pat surūšiuoti pagal skaičius. `uniq` komanda leidžia tau parodyti unikalias eilutes ir, jei reikia, jas suskaičiuoti.

Šis komandų junginys `head reg_zalgiris.csv | cut -d "," -f 13 | sort` paima pirmas 10 eilučių iš **reg_zalgiris.csv** failo, supjaustydamas pagal `,` kaip skirtuką tarp stulpelių, pasirenka 13-ą stulpelį, o sort surikiuoja duomenis didėjančia tvarka (A-Z).

![](../img/bash_advanced/uniq_1.png)

Komanda `uniq` leidžia pamatyti unikalias reikšmes, tik `uniq` aptinka duplikatus tik tada, kai jie yra šalia. Todėl `uniq` beveik visada naudojama kartu su `sort`. Pvz., `head reg_zalgiris.csv | cut -d "," -f 13 | sort | uniq`.

![](../img/bash_advanced/uniq_2.png)

Retais atvejais tau gali būti įdomu sužinoti tik eilutes, kurios **neturi duplikatų**. Tada naudotum flagą `-u`. Šiuo atveju, jei „gydytojo_specialybe“ kartojasi tik vieną kartą (natūralu, nes tai duomenų antraštė), todėl `uniq -u` grąžina tik šią eilutę.

![](../img/bash_advanced/uniq_3.png)

Kur kas praktiškesnis yra flagas `-c`, kuris suskaičiuoja, kiek yra vienodų eilučių.

![](../img/bash_advanced/uniq_4.png)

Kaip matai, turime problemą - stulpelio antraštė (header) figūruoja kaip duomenys. Jei tau tik reikia grubiai įvertinti duomenų teisingumą ir juos geriau suprasti, tai gali netrukdyti. Bet galima ir išsivalyti.

::: {.callout-tip title="Praktika"}
1. Kokias 2 strategijas (komandas) **reg_zalgiris.csv** turi savo arsenale, kad neįtrauktum eilutės su gydytojo_specialybe į tolimesnius veiksmus? Prisimink, ką išmokai `--help` dalyje, bei prisimink komandą, kuri filtruoja eilutes - `grep`.
2. Pasinaudok viena iš šių strategijų ir suskaičiuok, pas kokių specialybių daktarus buvo daugiausiai ir mažiausiai registracijų.

Turėtum gauti šį rezultatą:

![](../img/bash_advanced/uniq_5.png)

Kaip matai, rezultatas nėra tobulas, nes dabar turi 6622 "Ortodontė" ir 6727 "Ortodontas". Nors specialybė ta pati. Jei tave domintų, kiek buvo registracijų pagal specialybes, reikėtų sukurti taisykles su `sed` komanda, kur suvienodintum profesijų pavadinimus ir padarytum juos neutralius lyčiai.
:::


### JSON

#### JSON Duomenų Formatas


JSON (JavaScript Object Notation) yra dažnai naudojamas duomenų formatas IT pasaulyje, nes jis leidžia hierarchiškai organizuoti duomenis viename tekstiniame dokumente su `.json` plėtiniu. Tai ypač naudinga, kai pavieniai objektai gali turėti skirtingą atributų kiekį.

Pavyzdžiui, JSON struktūroje galėtume turėti tokius duomenis:

```json
{
  "Tėtis": {
    "amžius": 30,
    "lytis": "V"
  },
  "Mama": {
    "amžius": 30,
    "lytis": "V",
    "profesija": "IT analitikė",
    "buvusios_darbovietės": {
      "AUDI": {"profesija": "IT testuotoja"},
      "BMW": {"profesija": "Inžinierė"}
    }
  },
  "Vaikas": {
    "amžius": 3,
    "lytis": "M"
  }
}
```

Jeigu bandytum tokią hierarchinę struktūrą perkelti į tabuliarinę lentelę, tai būtų gana sudėtinga. Analitikoje tai vyksta su duomenų bazėmis, kur tam tikri atributai yra tam tikrose atskirose lentelėse. Tačiau interneto platformose kartais reikia paprasto ir greito būdo atvaizduoti panašius hierarchinius duomenis.

JSON dažnai naudojamas duomenų perdavimui tarp kliento ir serverio, nes jis yra plačiai palaikomas daugelyje programavimo kalbų. Todėl su šiuo formatu susiduria tiek „back-end“ inžinieriai, turintys jį integruoti į duomenų bazes, tiek „front-end“ kūrėjai, kurie šį formatą naudoja tinklapių atvaizdavimui, tiek dažnai ir duomenų analitikai, kurie turi mokėti konvertuoti (angl. **parse**) šiuos duomenis į tabuliarinius duomenis analizei.

#### JSON Struktūros Pagrindinės Savybės

* JSON duomenys organizuojami „raktas:vertė“ (key:value) poromis, pvz., "amžius": 30, "lytis": "V".
* JSON palaiko paprastas ir sudėtingas duomenų struktūras, tokias kaip objektai ir masyvai.
* Aiškiai struktūrizuota forma leidžia lengvai suprasti duomenis ir jų kontekstą, padedant vizualizuoti hierarchiją, kaip panašu žemiau aprašytuose pavyzdžiuose.


JSON Reikšmių Tipai

* **Tekstas** (**string**): "Ruprechtas"
* **Skaičius** (**number**): pvz., 10, 55, 99
* **Loginė reikšmė** (**boolean**): `true`, `false`
* **Jokia reikšmė**: `null`
* **Objektas** - prasideda ir baigiasi `{}`, viduje turinčios key-value poras (dar vadinama dictionary kai kuriose kalbose, pvz., Python).
* **Masyvas** - prasideda ir baigiasi `[]`, angliškai vadinamas **array** arba **list**; tai yra sąrašas su bet kokio tipo duomenimis, įskaitant objektus, skaičius ir tekstą.


**JSON Objektas**

* Tai struktūra, kuri sudaryta iš raktų ir reikšmių porų.
* Kiekvienas raktas (**key**) yra unikalus ir turi susietą reikšmę (**value**).
* JSON objektas naudojamas apibūdinti vieną dalyką arba vieną įrašą (pvz., žmogų, knygą, įmonę ir t.t.).
* Tai panašu į "laukai ir reikšmės" formą lentelėje.
* Puikiai tinka, kai reikia saugoti susijusią informaciją (pvz., žmogaus vardas, amžius, el. paštas).

```json
{
  "name": "Jonas",
  "age": 30,
  "email": "jonas@example.com"
}
```

**JSON Masyvas**

* Struktūra, sudaryta iš reikšmių sąrašo (reikšmės gali būti objektai, skaičiai, tekstai ir kt.).
* Reikšmės masyve nėra unikalios, bet turi tvarką (indeksus).

```json
[
  {"name": "Jonas", "age": 30},
  {"name": "Petras", "age": 25},
  {"name": "Ona", "age": 28}
]
```

**JSON Objekto ir Masyvo Naudojimas Kartu**

JSON dažnai jungia objektus ir masyvus, kad galėtų lanksčiai aprašyti struktūras, pvz., studentų sąrašą:

```json
{
  "students": [
    {"name": "Jonas", "age": 30, "food": ["Ledai", "Lazanija"]},
    {"name": "Petras", "age": 25, "food": ["Vištiena"]},
    {"name": "Ona", "age": 28, "food": ["Vištiena", "Suši"]}
  ]
}
```

JSON Naudojimas API

Su JSON formatu tu susidursi tada, kai dirbsi su front-end ir back-end, o taip pat, jeigu turėsi komunikuoti duomenis per API (An application programming interface).

API yra įrankių ir protokolų rinkinys, leidžiantis skirtingoms programoms bendrauti vienai su kita. Tai kaip „tiltas“, leidžiantis vienai programai naudoti kitos funkcijas arba duomenis, nesigilinant į jų vidinį veikimą.

Pvz., programa gali bendrauti su meteorologine tarnyba ir gauti orų prognozes. API nurodo, kaip siųsti užklausas ir kaip bus pateikiami atsakymai. Programai nesvarbu, kaip tarnyba suranda informaciją duomenų bazėje. Svarbiausia, kad ji supranta API taisykles.

Populiarūs API stiliai:

* REST (Representational State Transfer) – dažno naudojimo API dizaino stilius, naudojantis HTTP protokolą dėl savo paprastumo ir flexibilumo.
* SOAP (Simple Object Access Protocol)
* GraphQL
WebSocket



### `jq` 

`jq` yra galingas komandinės eilutės įrankis, skirtas JSON duomenų apdorojimui Linux aplinkoje. Šis įrankis leidžia lengvai analizuoti, filtruoti, modifikuoti ir formatuoti JSON duomenis tiesiogiai terminale. Tai ypač naudinga dirbant su API atsakymais arba duomenų failais, pateiktais JSON formatu.

Pirmiausia įsitikink, kad `jq` yra įdiegtas tavo sistemoje. Jei ne,  instaliuok su `sudo apt install jq`.


`jq` komandos sintaksė yra paprasta:

```bash
jq <filtras> <failas>
```
Čia <filtras> nurodo, kurie duomenys ir kaip turėtų būti apdorojami, o <failas> – tai JSON failo pavadinimas, kuriuo dirbi.

Jei JSON duomenys ateina iš kitos komandos:

```bash
komanda | jq <filtras>
```

JSON Duomenų Gražinimas

JSON objekto duomenis galima išvesti gražiai suformatuotus. Paprasčiausias filtras yra `.` - jis išveda `visą` JSON struktūrą. Verta prisiminti, kad `jq` filtrų tekstą reikia įdėti į viengubas kabutes `'<filtras>'`, kad išvengtum sintaksės konfliktų su komanda.


#### Darbas su JSON Objektais


JSON objektas dažniausiai sudarytas iš raktų (key) ir verčių (value) porų.

Pavyzdinis JSON objektas: Sukurk failą `user.json`.


```bash
echo '{
  "name": "Jonas",
  "age": 30,
  "email": "jonas@example.com"
}' > user.json
```

**Gražus Atvaizdavimas**

Naudojant `jq .`, gali išvesti visą JSON turinį suformuotą skaitymui. `.` čia reiškia visą objektą, ir `jq` jį „gražina" su lygiavimo tarpais, kad būtų lengviau perskaityti.

```bash
jq '.' user.json
```


**Pavienių Verčių Gavimo Technika**

Norint ištraukti konkrečią informaciją, galime nurodyti konkretų raktą. Tai išspausdina tik to rakto vertę, šiuo atveju - "Jonas".

```bash
jq '.name' user.json
```

**Kelių Rakčių Vertės**

Jei nori gauti kelias reikšmes, gali jas atskirti kableliais. Ši komanda atspausdina vardą ir amžių kaip dvi atskiras eilutes.

```bash
jq '.name, .age' user.json
```

**Raktų ir Reikšmių Poros Atrinkimas**

Kai nori išvesti ne tik vertę, bet ir raktą su verte, gali suformuoti naują objektą. Tai sukuria JSON objektą tik su pasirinktais raktais, šiuo atveju name arba name ir age.

```bash
jq '. | {name}' user.json
jq '. | {name, age}' user.json
```

#### Darbas su JSON Masyvais

JSON masyvas leidžia sukaupti kelis objektus arba vertes į vieną struktūrą.

Sukurk JSON masyvą `students.json`, apimantį kelis žmonių objektus.

```bash
echo '[
  {"name": "Jonas", "age": 30},
  {"name": "Petras", "age": 25},
  {"name": "Ona", "age": 28}
]' > students.json
```

**Viso Masyvo Atvaizdavimas**

Norint gražiai peržiūrėti masyvą, naudok:

```bash
jq '.' students.json
```

Tai pateikia visą JSON failo turinį, tinkamu formatu.

**Atskirų Elementų Atrinkimas**

Pasirink pirmą masyvo objektą (atkreipk dėmesį į nulio indeksavimą). Tai duoda pirmąją masyvo vertę, kuris yra Jonas objektas.

```bash
jq '.[0]' students.json
```
Gali apsirinkti ir kelis objektus

```bash
jq '.[0,1]' students.json
```

**Visų Elementų Iteracija**

Norint atspausdinti visus name elementus:

```
jq '.[] | .name' students.json
```

`.` ir `[]` nurodo, kad nori peržvelgti (iteruoti) per visus masyvo elementus.


::: {.callout-tip title="Praktika"}

Šioje užduotyje dirbsi su JSON objektu, kuriame yra raktų ir reikšmių poros, taip pat masyvas ir objektas kaip reikšmė. Sukurk failą `info.json` ir dirbk su juo atliekant užduotis pateiktas žemiau.

```json
{
  "name": "Jonas",
  "age": 30,
  "email": "jonas@example.com",
  "isStudent": false,
  "courses": [
    "Matematika",
    "Informatika",
    "Fizika"
  ],
  "address": {
    "street": "Gedimino pr. 1",
    "city": "Vilnius",
    "country": "Lietuva"
  }
}
```

1. **Surask JSON objekte esantį rakto „name“ vertę ir atspausdink ją terminale.**
   - Turėtum gauti: `"Jonas"`

2. **Grąžink vardo rakto ir reikšmės porą kaip JSON objektą.**
   - Tikimasi gauti: `{"name": "Jonas"}`

3. **Išvesk masyvą su vardo ir amžiaus reikšmėmis.**
   - Kaip rezultatą turėtum matyti masyvą: `["Jonas", 30]`

4. **Grąžink objektą su vardo ir amžiaus raktais bei reikšmėmis.**
   - Rezultatas turi būti: `{"name": "Jonas", "age": 30}`

5. **Atvaizduok visą „courses” masyvą.**
   - Turėtum gauti masyvą: `["Matematika", "Informatika", "Fizika"]`

6. **Išvesk pirmąjį „courses“ masyvo elementą.**
   - Tikimasi pamatyti pirmą kursą: `"Matematika"`

7. **Išvesk „address“ objektą.**
   - Rezultatas: `{"street": "Gedimino pr. 1", "city": "Vilnius", "country": "Lietuva"}`

8. **Gauk „street” reikšmę iš „address“ objekto.**
   - Turėtum matyti adresą: `"Gedimino pr. 1"`

9. **Sukurk objektą su „city” ir „country“ iš „address“ objekto.**
   - Rezultatas turi būti: `{"city": "Vilnius", "country": "Lietuva"}`
:::

#### JSON Filtravimas

Grįžkime prie įrašo `students.json`. JSON filtravimo dažnai reikia tam, kad atrinktum specifines duomenų dalis, atitinkančias tam tikras sąlygas. Naudodjant `jq`, gali pritaikyti filtrus tiesiogiai JSON masyvuose.

```json
[
  {"name": "Jonas", "age": 30},
  {"name": "Petras", "age": 25},
  {"name": "Ona", "age": 28}
]
```


Kai nori atrinkti tik tuos studentus, kurių amžius yra didesnis nei 26, naudok `select` funkciją. `select` leidžia taikyti sąlygas, atrenkančias tik tas masyvo dalis, kurios atitinka nustatytą kriterijų. Atkreipk dėmesį, kad `select` funkcija veikia tik masyvo elementuose, todėl rezultatą reikia apdirbti iš masyvo konteksto.


```bash
jq '.[] | select(.age > 26)' students.json
```
Ši komanda:

* Naudoja `.[]`, kad pasiektų (iteruotų per) kiekvieną masyvo elementą.
* Naudoja `select(.age > 26)` vidinėje komandoje, kad pasirinktų tik tuos objektus, kurių age yra didesnis nei 26.


**Kombinuoti Filtrai**

Kelių sąlygų derinimas leidžia atlikti išsamesnę analizę ir atrinkti dar tikslesnius duomenis. Pavyzdžiui, pasirink studentus, kurie yra vyresni nei 26 metai ir kurių vardas yra Ona:

```bash
jq '.[] | select(.age > 26 and .name == "Ona")' students.json
```
Naudojant `and`, `or`, tu gali derinti kelias sąlygas. Kiekvienas masyvo elementas bus filtruojamas pagal abi nurodytas sąlygas.


#### JSON Plošktinimas

Po filtro pritaikymo dažnai reikia JSON duomenis supaprastinti (suplokštinti) iš JSON struktūros į paprastesnį formatą, pavyzdžiui, `CSV` ar `TSV`. Tai yra naudinga, jei nori duomenis pateikti lenteliniu formatu, kuris yra lengviau interpretuojamas ar eksportuojamas į kitas sistemas.

Plokštinimas taikomas tik masyvams `[]`, ne atskiriems objektams `{}`. Kai duomenys yra objekto formatu, reikia fiksuoti specifines reikšmes, kurias nori paversti plokščiu formatu. Pavertus objekto reikšmes į masyvą, galima tiksliai nurodyti, kas bus įtraukta į galutinį rezultatą:


Vieno objekto pavertimas į masyvą:

```bash
jq '[.name, .age, .email] | @csv' user.json
```

**Masyvo** duomenų pavertimas CSV formatu
Tai suformuos lentelę, kurioje bus pateikti studentų vardai ir amžiai atskirti kableliais.


```bash
jq '.[] | [.name, .age] | @csv' students.json
```

**Vidinio masyvo plokštinimas**

Kartais gali turėti masyvą JSON objekte ir nori jį paversti CSV formatu:

```bash
echo '{
  "courses": ["Matematika", "Informatika", "Fizika"]
}' | jq '.courses | @csv'
```

**Sudėtingo objekto masyvinimas prieš plokštinimą**

Jei turi JSON struktūrą su vidiniu objektu, pirmiausia suformuok masyvą iš reikšmių, o tuomet įvykdyk plokštinimą:

```bash
echo '{
  "address": {
    "street": "Gedimino pr. 1",
    "city": "Vilnius",
    "country": "Lietuva"
  }
}' | jq '.address | [.street, .city, .country] | @csv'
```

**Kada rinktis @csv ir kada @tsv?**

* Eksportui ir duomenų mainams tarp programų: @csv yra dažniausiai pasirenkamas dėl jo suderinamumo su daugeliu programų.
* Tiesioginiam naudojimui terminale ir skriptams: @tsv dažnai pranašesnis, ypač kai dirbama su duomenimis, kuriuose gali būti daug kablelių.


#### -r

Dažnai norėsi, kad tekstinės reikšmės nebūtų apgaubtos dvigubomis kabutėmis CSV ar TSV formatuose. Flagas `-r` leidžia gauti "raw" arba neapdorotą tekstą be papildomų kabučių.

Palygink:

* Be `-r` flag'o tekstinės reikšmės bus su kabutėmis.
* Su `-r` flag'o bus grąžintas tikrasis tekstas.

```bash
| jq '.courses | @csv'         # Išsaugotų kabutės
| jq -r '.courses | @csv'      # Neįtrauks kabučių
| jq '.courses | @tsv'         # Išsaugotų kabutės TSV formatu
| jq -r '.courses | @tsv'      # Neįtrauks kabučių
```

::: {.callout-tip title="Praktika"}

1. Su `curl` arba `wget` parsisiųsk `https://get.data.gov.lt/datasets/gov/vulzk/registracija/Registracija`. Išvesties failo pavadinimą nurodyk kaip **reg_zalgiris.json**. Jei reikia pagalbos su komandų sintakse, naudok `curl --help` arba `tldr curl`.

Duomenų formatas:

```json
{
  "_data": [
    {
      "_type": "datasets/gov/vulzk/registracija/Registracija",
      "_id": "d3cf2132-dd72-459a-9624-e17e62419050",
      "_revision": "f77c9ebd-f2d3-483b-ae76-fd3c6a1f91d8",
      "_base": null,
      "registracijos_id": "355549",
      "gydymo_registracijos_data": "2013-11-28T08:00:00",
      "registracijos_iraso_sukurimo_data": "2013-07-02T00:00:00",
      "registracijos_iraso_keitimo_data": "2013-11-27T13:11:00",
      "paciento_id": "1978fdae338a6ca",
      "paciento_lytis": "V",
      "paciento_gimimo_metai": "1977-01-01T00:00:00",
      "gydytojo_id": "99",
      "gydytojo_specialybe": "Endotontologė"
    }
  ],
  "_page": {
    "next": "WyIzNTU1NDkiLCAiZDNjZjIxMzItZGQ3Mi00NTlhLTk2MjQtZTE3ZTYyNDE5MDUwIl0="
  }
}
```
1. Filtruok registracijas pagal gydytojo specialybę:
  * Filtruok tik tas registracijas, kur gydytojo_specialybe yra "Ortopedas".
  * Išrink tik du laukus: gydytojo_id ir gydytojo_specialybe.
  * Filtruotus duomenis išsaugok CSV formatu.
  * Galiausiai, su sort ir uniq nustatyk, kiek skirtingų ortopedų (pagal gydytojo_id) buvo.

![](../img/bash_advanced/jq_6.png)

1. Identifikuok reikšmingus laukus analizei
  * Peržiūrėk JSON struktūrą, nuspręsk, kurie laukai yra naudingi tolesnei analizei (pvz., registracijos datos, paciento lytis, gimimo metai, gydytojo specialybė ir kt.).
  * Konvertuok visus pasirinktus laukus į CSV formatą.

5. Pridėk antraštes į CSV failą:
  * Jei po `head` pastebi, kad CSV faile trūksta antraščių, jas galima pridėti rankiniu būdu arba sujungiant `echo` ir `cat`. Praktikuokis bendravimą su ChatGPT ir rask sprendimą.

:::






##  Failų Paieška

Šiame skyriuje susipažinsi su svarbiomis komandomis, kurios padės tau rasti failus tavo sistemoje. `find` komanda suteikia galimybę ieškoti failų ir direktorijų naudojant detalius paieškos kriterijus, tokius kaip pavadinimas, tipas, data ir kt. `locate` komanda naudoja Linux sistemose generuojamą failų indeksą greitai failų paieškai. `whereis` yra skirta rasti vykdomojo failo (**binary**), dokumentacijos ir kitos susijusios informacijos vietą.


### find

Komanda `find` yra naudojama ieškoti failų ir direktorijų pagal pavadinimą, dydį, datą, teises ir kitus kriterijus.

Bazinė `find` komanda atrodo taip: 

```bash
find /path/to/search -options criteria -options criteria
```

Pažiūrėk savo dabartinę darbinę direktoriją. Kokius failus joje turi, ir kokie yra jų dydžiai. 

Kadangi šiuo atveju tik keli failai, tai gali pasirodyti ne itin įdomu. Patikrink, ar turi **shell_part_2** savo namų direktorijoje. Jei ne, paleisk skriptą, kad ji vėl būtų sukurta (žr. praėjusio skyriaus pradžią).


Ieškoti failų esamoje darbinėje direktorijoje (t.y. "čia") galima naudojant taško notaciją `.`. Tačiau dažniau dirbsi su `~`, t.y. nuoroda į savo namų direktoriją. Tavo ir mano terminalo išvestys gali skirtis, tad nenustebk, jei matysi daugiau ar mažiau failų.

Pakeisk savo darbinę direktoriją į namų su `cd ~` arba tiesiog `cd`.

Komandai `find` pirmasis argumentas yra **kur** ieškoti. Dažniausiai tai gali būti:

* `find .` - ieškoti aktyvioje direktorijoje
* `find ~` - ieškoti namų direktorijoje
* `find /` - ieškoti root direktorijoje (t.y. visame kompiuteryje)
* `find ~/Downloads` - ieškoti vartotojo Downloads direktorijoje arba kitoje konkrečiai nurodytoje direktorijoje
 

`find` priima daug skirtingų nustatymų (flagų), vienas pagrindinių yra `-name`.

Pavyzdžiui, suraskime, kur yra failas su registracijomis į Žalgirio kliniką. Tarkime, prisimeni tik, kad ten buvo "**zalgiris**" pavadinime. Pirmoji komanda negražina jokio failo, nes jo nerado. `find`, kaip ir dauguma bash komandų, gali veikti su "wildcards" (pakaitos simboliais):

```bash
find ~ -name zalgiris
find ~ -name *zalgiris*
```

![](../img/bash_advanced/find_wildcard.png)

Dabar, jei nori surasti failą su valstybiniais numeriais, tačiau `find ~ -name *valstyb*` nieko negrąžina, tai yra todėl, kad find yra "case-sensitive", kaip ir visa BASH aplinka. Panašiai kaip ir su kitomis komandomis, gali pasinaudoti `-iname`, kad paieška nebūtų jautri raidžių dydžiui:

```bash
find ~ -name *valstyb*
find ~ -iname *valstyb*
```

![](../img/bash_advanced/find_iname.png)


Jei nenurodysi `-name <pavadinimas>`, tada find komanda ieškos visų failų ar direktorijų, atitinkančių kitus nurodytus kriterijus; jei nebus jokio kriterijaus, tada ji suras tiesiog visus failus ir direktorijas bei nuorodas. Sekančioje komandoje `find` ieško visų failų, direktorijų ir nuorodų **bash_advanced** dirkeotrijos viduje.

```bash
find bash_advanced/
```

![](../img/bash_advanced/find_noargs.png)

Kartais gali norėti, kad `find` grąžintų ne tik rastų failų adresus, bet ir daugiau informacijos. Tada gali panaudoti `-ls` flagą. Jis iš esmės panašus tau įprastą `ls` komandą.

```bash
find bash_advanced/ -ls
```

![](../img/bash_advanced/find_ls.png)

Gali apriboti paiešką pagal tai, ko ieškai: ar tai yra failas (`f`), direktorija (`d`), ar nuoroda (`l`). Ši komanda ieško tipo - direktorijos, kurios pavadinime yra žodis prasidedantis "Do".

```bash
find ~ -type d -name "Do*"
```

Kaip matai `find` grąžina ir direktorijas, kurios yra paslėptos.

![](../img/bash_advanced/find_type.png)

Jei tave domina rasti failus, kurie užima daug arba labai mažai vietos, šiuo atveju tau padės `-size` flagas. Jis priima skaičius žmonėms suprantamu formatu, pvz., 10M = 10 megabaitų, 1G = 1 gigabaitas ir t.t. Norint nurodyti failų dydį, gali naudoti `-` arba `+` prieš skaičių, kad sakytum "mažesnis nei" arba "didesnis nei".

Jei nurodysi skaičių be pliuso ar minuso, `find` ieškos failų, kurių dydis lygus nurodytam skaičiui.

```bash
find -type f -size -300M
find -type f -size 300M
find -type f -size +300M
```

[]

Gali norėti ieškoti failų pagal jų:

*   Sukūrimo datą `c`
*   Modifikavimo datą `m`
*   Prieigos datą `a`

Tokiu atveju turėtum naudoti flagus -`[acm]time` (pasirink reikiamą raidę) ir nurodyti dienas. `-n` reikš per paskutines n dienų, `+n` reikš "daugiau kaip n dienų". Turėk omenyje, jog dienas find vertina kaip kalendorines. Taip pat, jei nori, gali sujungti kelis reikalavimus į vieną, pavyzdžiui: ieškoti failų, kurie buvo sukurti daugiau kaip prieš 2 dienas `-ctime +2`, bet (ir) mažiau kaip prieš 7 dienas `-ctime -7`.

```bash
find ~ -type f -ctime +2 -ctime -7
```

Paleidus šią komandą, pamatysi, kad tikėtina, turi nemažai failų, ir galbūt norėsi apriboti, kaip "giliai" `find` turėtų ieškoti. Pabandyk panaudoti `-maxdepth` arba `-mindepth`. Šie argumentai yra globalus, todėl juos turėtum rašyti iškart po `find ~`.

```bash
find ~ -maxdepth 1 -type f -ctime +2 -ctime -7 
```

[]

Komanda `find` priima ir loginius operatorius: `-and`, `-or`, ir `!` (šauktukas, kuris reiškia "ne"). Nenustebk, jei kartais pamatysi trumpinius `-a` ir `-o`.

Štai komandos, kurios ieško failų, kurie yra sukurti daugiau nei prieš 2, bet mažiau nei prieš 7 dienas, ARBA ir IR kai jų dydis yra daugiau nei 300MB.

```bash
find ~ -maxdepth 2 -type d -ctime +2 -ctime -7 -or -size +300M
find ~ -maxdepth 2 -type d -ctime +2 -ctime -7 -and -size +300M
```
Kaip matai, `-or` leidžia rasti daugiau, nes užtenka, kad bent viena sąlyga būtų patenkinta, tuo tarpu `-and` reikalauja, kad visos sąlygos būtų patenkintos.


![](../img/bash_advanced/find_and_or.png)_

Ką daryti, jei nori sujungti daugiau sąlygų arba sukurti sudėtingesnį loginį algoritmą? Tam gali išnaudoti skliaustus. Tačiau juos turėsi pabėgti su \( ir \), kad `find` ieškotų ne skliaustelių pavadinime.

Štai kaip galima ieškoti failų, kurie yra didesni nei 2M **ir** mažesni nei 100M **IR ARBA** .csv, arba .txt formato:

```bash
find ~ -size +2M -size -100M \( -iname *.txt -or -iname *.csv \)
```

Svarbu paminėti, kad **būtina turėti tarpus aplink skliaustus**! Jei sujungi kelis reikalavimus, kaip `-size +2M`, `-size -100M`, jie sujungiami pagal nulytijimą su `-and`, todėl nebūtina jo nurodyti aiškiai.


Dabar prieikime prie pavojingesnių komandų!

`find` turi nustatymą `-delete`, kuris visus surastus failus, rastus pagal nurodytus parametrus, ištrins. Naudok `-delete` tik tada, kai esi visiškai tikras, kad viskas, kas randama, gali būti trinama.

```bash
find ~ -name "*.txt" -delete
```
![](../img/bash_advanced/find_delete.png)


`find` komanda jau yra labai galinga, bet dar nežinai jos stipriausios pusės! Su `find` gali perduoti rastus failus tolesniam apdorojimui. Tiesa, tai neveikia taip, kaip su pipe `|`. Sintaksė yra tokia:

```bash
find ... -exec <komanda> {} \;
```

* `-exec` nurodo, kad su tuo, ką radai, dabar vykdysi kitą komandą.
* `<komanda>` gali būti bet kuri, tik turi būti tinkama pasirinktiems failams.
* `{}` naudojama vietoj failų pavadinimo.
* Kad baigi komandą, nurodai su `\;`.

Įsivaizduok, kad nori atspausdinti visas eilutes, kuriose yra žodis "apie". Bet nepameni, kuriame būtent faile, tik žinai, kad tas failas buvo .txt formato.

```bash
find ~ -type f -iname "*.txt" -exec grep -iH "apie" {} \;
```

* taigi `find` suranda visus tekstinius failus, tiklsiau tuos failus, kurių pavadinimas baigiasi **.txt** 
* `-exec` perleidžia juos `grep` komandai
* grep ieško case insensitive `-i` bet kartu ir atspasdina failo, kuriam priklauso rasti eilutė adresą `-H`

![](../img/bash_advanced/find_exec.png)

Taip, galima perduoti rastus failus ir kitoms komandoms, pvz., `rm`, `cp`, `mv`.

Kaip matai, perduoti failus `-exec` gali būti pavojinga. Alternatyva, kur tavęs prašys patvirtinti kiekvienam failui taikomą komandą, yra `-ok`. Štai komanda, kuri suras visus failus, kurių pavadinime yra .csv ir padarys jų kopiją į aplanką **~/copy.**

```bash
mkdir ~/copy
find ~ -iname "*.csv" -ok cp {} ~/copy/ \;
```
Kaip matai, prieš kiekvieną operaciją, terminalas reikalauja patvirtinimo, kurį turi įrašyti kaip `y` arba `yes`, kad patvritinti. Įrašius `n`, `no` , arba tiesiog paspaudus Enter, tai atitiks **no** ir komanda tam failui nebus įvykdyta.

{{< video ../img/bash_advanced/find_ok_copy.mp4 >}}

Vykdant šią operaciją, `find` rado tuos pačius failus dar kartą, ten, kur jie jau buvo nukopijuoti, t.y., pačioje **copy** direktorijoje. Kad išvengtum to, gali find nurodyti, kur neieškoti su `-not -path "/home/justas/copy/*"` arba `! -path "/home/justas/copy/*"`. 
Atkreipk dėmesį į tai, kad nurodant `-not -path`, reikia **absoliutaus adreso** ir **\***, kad ten rasti failai (jų adresai) nebūtų įtraukti.



::: {.callout-tip title="Praktika"}
* Parašyk komandą, kuri ieško visų failų tavo namų direktorijoje, kurių pavadinimas baigiasi .csv arba .txt.
* Tą pačią komandą, tik perduok rezultatus į `grep`, atspausdink tas eilutes, kuriose yra "2024".
* Surask visus failus, kurių sukūrimo data yra daugiau nei prieš 14 dienų, kurių pavadinimas baigiasi .mp4, ir kurie yra dwhelper arba Downloads direktorijose bei kurių dydis yra didesnis nei 100M.
* Tą pačią komandą, tik panaudok -ok su rm {}. Dabar komanda perklaus, ar trinti kiekvieną failą. Ši komanda turėtų padėti tau apsivalyti įvairius senus video.
:::


Kaip matai, galima ieškoti ir pagal failo savininką, jo grupę, ar failo teises. 


| Opcija          | Reikšmė                                                      |
|-----------------|--------------------------------------------------------------|
| `-name`         | Ieškoti pagal failo pavadinimą, jautrus raidžių dydžiui.     |
| `-iname`        | Ieškoti pagal failo pavadinimą, nejautrus raidžių dydžiui.   |
| `-type`         | Ieškoti pagal failo tipą (`f` - failas, `d` - direktorija, `l` - nuoroda). |
| `-size`         | Ieškoti pagal failo dydį (`+` didesnis, `-` mažesnis, be ženklo - lygus). |
| `-ctime`        | Ieškoti pagal sukūrimo datą (dienomis).                      |
| `-mtime`        | Ieškoti pagal modifikavimo datą (dienomis).                  |
| `-atime`        | Ieškoti pagal prieigos datą (dienomis).                      |
| `-maxdepth`     | Nustatyti maksimalų paieškos gylį (nuo pradinės direktorijos).|
| `-mindepth`     | Nustatyti minimalų paieškos gylį (nuo pradinės direktorijos).|
| `-ls`           | Išvesti papildomą informaciją apie rastus failus.            |
| `-not -path`    | Neįtraukti nurodyto kelio į paiešką.                         | 
| `-and`/`-a`     | Loginis operatorius "ir" (and).                              |
| `-or`/`-o`      | Loginis operatorius "arba" (or).                             |
| `!`             | Loginis operatorius "ne" (not).                              |
| `-user`         | Ieškoti pagal failo savininką.                               |
| `-group`        | Ieškoti pagal failo grupę.                                   |
| `-perm`         | Ieškoti pagal failų teises (permisijas).                     |


### locate

Linux operacinė sistema turi mechanizmą, kuris reguliariai indeksuoja visus failus, todėl `locate <pavadinimas>` komanda leidžia labai greitai surasti failą, kurio pavadinimą žinai. Galima naudoti pakaitos simbolius (wildcards) *, kad paieška apimtų įvairias pavadinimo variacijas.

![](../img/bash_advanced/locate.png)

Keli `locate` trūkumai:

* Neatnaujintų failų rodymas: `locate` nerodo neseniai sukurtų arba pervadintų failų, kol nėra atnaujinama failų duomenų bazė. Duomenų bazės atnaujinimui naudok komandą `updatedb`.
* Paieškos kriterijų trūkumas: `locate` nesuteikia galimybės naudoti paieškos kriterijų, tokių kaip failo dydis, amžius ir kt., kuriuos siūlo find.

{{< video ../img/bash_advanced/updatedb.mp4 >}}


### whereis

Komandos `whereis` paskirtis yra rasti informaciją apie programas, įskaitant jų vykdomuosius failus (binary files), dokumentaciją (pavyzdžiui, man puslapius) ir, jei įmanoma, šaltinio kodą (**source code**). Ji naudinga, kai nori sužinoti, kur yra įdiegta programa ir kokie susiję failai yra tavo sistemoje.

* **Vykdomieji failai**: whereis parodo kelią iki programų vykdomųjų failų.
* **Dokumentacija**: Parodo, kur yra susiję dokumentacijos failai, tokie kaip man puslapiai.
* **Šaltinio failai**: Jei yra, parodo kelią iki programos šaltinio failų.

![](../img/bash_advanced/whereis.png)

### which

Komanda `which` rodo, kurioje iš tavo aplinkos kintamajame **PATH** nurodytų vietų yra pirmasis rastas vykdomasis failas. Įvedus komandos pavadinimą terminale, `which` pateikia pirmą rastą failo kelią:

* Pateikia tik **pirmą rastą** vykdomąjį failą nurodytame PATH.
* Naudinga patikrinti, ar programa, pvz., „Python“, yra įdiegta ir kuri versija bus vykdoma.

Jei reikia sužinoti visas vietas, kur yra vykdomasis failas ir susiję failai (pvz., kelios „Python“ versijos), verčiau naudoti `whereis`, nes jis pateikia išsamesnę informaciją.


![](../img/bash_advanced/which.png)


### Intarpas: Kas yra PATH?

Ši tema gali pasirodyti šiek tiek sudėtingesnė, bet ją pravartu žinoti norint geriau suprasti, kaip veikia Linux komandinė eilutė (CLI).

Kai tu įvedi komandą, pvz., `ls`, kaip Shell žino, kokią programą paleisti? Shell negali peržiūrėti visų tavo failų ieškodama programos `ls` - tai būtų neefektyvu ir užtruktų labai ilgai. Vietoje to, Bash naudoja **aplinkos kintamąjį**, vadinamą **PATH**, kuris yra saugomas visų direktorijų sąrašas, kurias Bash tikrina ieškodama vykdomųjų programų.

Kai tu įvedi `ls`, Bash tikrina šias direktorijas pagal eiliškumą:


```bash
/usr/local/sbin
/usr/local/bin
/usr/sbin
/usr/bin
/sbin
/bin
/usr/games
/usr/local/games
/snap/bin
```

Šis tikrinimo procesas vyksta taip: jei programa nerandama pirmojoje direktorijoje, tikrinama kita iš eilės, kol galiausiai programa randama. Jei programa nerandama visame PATH sąraše, terminalas išveda pranešimą, kuris gali siūlyti šią programą įdiegti.

Retais atvejais tau gali reikėti pridėti naujų direktorijų prie **PATH** kintamojo, tačiau tai yra pažangesnė tema, ir pradedančiajam Linux naudotojui dažniausiai to nereikės. Dabar žinai, kaip Bash naudoja PATH norėdama greitai surasti ir paleisti programas.

Nori sužinoti kaip atrodo tavo PATH? Pabandyk:

```bash
echo $PATH
```

## Failo teisių valdymas

Ankstesniame skyriuje tu jau susipažinai su tuo, kad kiekvienas failas ir direktorija turi nustatytą savininką. Taip pat nurodomos savininko, jo grupės ir kitų vartotojų teisės. Šiame skyriuje išmoksi, kaip keisti šias teises ir atlikti kitus su failų savininkais susijusius veiksmus.

### Failo Teisių Struktūra

Failų teises galima pamatyti, naudojant `ls -l` komandą, kuri išveda informaciją apie failus, įskaitant jų teises:

```bash
drwxrwxr-x 4 justas justas 4096 Sep 27 18:28 backup
drwxrwxr-x 2 justas justas 4096 Sep 28 18:45 data
-rw-rw-r-- 1 justas justas   45 Sep 28 16:28 list_du_home.sh
-rw-rw-r-- 1 justas justas  635 Sep 28 13:33 list.txt
drwxrwxr-x 2 justas justas 4096 Sep 27 21:42 mix
drwxrwxr-x 2 justas justas 4096 Sep 28 18:34 text
```

Kiekviena eilutė parodo failo teises:

* `r` - skaitymo teisė
* `w` - rašymo teisė
* `x` - vykdymo teisė
* `-` - nėra teisių

Pirmoji tripleto grupė priklauso savininkui, antroji - grupei, trečioji - kitiems vartotojams. Suprantama pirmas ženklas (`d`, `-`, `l`) indikuoja ar tai direktorija, failas ar nuoroda.

### Keisti Failo Teises su chmod

`chmod` komanda leidžia keisti failo teises. Naudojami du būdai - skaitmeninis ir simbolinis.

**Skaitmeninis Būdas**

Kiekvienai teisei priskiriama skaitinė reikšmė:

* `4` - skaityti (read)
* `2` - rašyti (write)
* `1` - vykdyti (execute)
* `0` - jokių teisių (`-`)

Norint nustatyti teises, skaičiuoji reikšmes, pvz:

* Vartotojui (**user**): skaityti, rašyti, vykdyti (4+2+1 = 7)
* Grupei (**group**): skaityti, vykdyti (4+0+1 = 5)
* Kitiems: skaityti (4+0+0 = 4)

Pavyzdys, kaip nustatyti teises su chmod:

```bash
chmod 754 failas.txt
```

Šios komandos rezultatas - **user** gali skaityti, rašyti, vykdyti; **grupė** gali tik skaityti ir vykdyti, o kiti tik skaityti.

**Simbolinis Būdas**

Simboliniame būde naudoji raides ir simbolius:

* `u`: savininkas (user)
* `g`: grupė (group)
* `o`: kiti (others)
* `a`: visi (all)
* `+`: pridėti teisę
* `-`: pašalinti teisę
* `=`: nustatyti tikslias teises

Ši komanda prideda vykdymo teisę savininkui.

```bash
chmod u+x failas.txt
```

### Keisti Savininką su chown ir Grupę su chgrp

Nors dažniausiai šių komandų nereikia naudoti, mokėti jomis naudotis gali būti naudinga:

* `chown <user> <file>` - keičia failo savininką.
* `chgrp <group> <file>` - keičia failo grupę.
* `chown <user>:<group> <file> `- keičia tiek savininką, tiek grupę.
* `chown -R <user>:<group> <directory>` - keičia visų failų nurodytoje direktorijoje savininką ir grupę **rekursyviai**.

Svarbu: Jei keiti sisteminių failų savininką ar grupę, gali prireikti administratoriaus teisių (sudo).


### Kada Reikia Keisti Teises?

Yra kelios situacijos, kai gali reikėti keisti failo teises:

**Skriptų Paleidimas
**

Jei sukuri skriptą, pavyzdžiui, `senu_video_valymas.sh`, ir nori jį paleisti, gali reikėti suteikti sau vykdymo teisės:

```bash
chmod 744 senu_video_valymas.sheet
```

Failas tapęs skriptu pakeičia spalvą į žalią.

![](../img/bash_advanced/chmod.png)


**AppImage Programų Paleidimas
**

**AppImage** yra programa, patalpinta viename faile. Parsisiuntus AppImage gali pamatyti, kad jis neturi vykdymo teisių. 

Nors tu tiktėtina jau turi Freetube, nueik į [https://freetubeapp.io/#download](https://freetubeapp.io/#download) ir paspausk ant AppImage, kad jį atsisiųsti.

![](../img/bash_advanced/appimage_1.png)

kaip matai, failas neturi executbale teisių.

![](../img/bash_advanced/appimage_2.png).

Norint paleisti failą, reiktų susirasti failą per failų naršyklę, o tada pasirenkant "Properties" > "Permissions" ir pažymėti "Allow executing file as program".

{{< video ../img/bash_advanced/chmod_free.mp4 >}}

Arba sutieki tokias pat teises su `chmod` naudojant terminalą:

```bash
chmod 774 freetube_0.22.0_amd64.AppImage
```

## Procesų Valdymas

Norint efektyviai valdyti kompiuterio išteklius, svarbu suprasti, kokie procesai veikia tavo sistemoje. Tai ypač svarbu sistemų administravime ir duomenų analitikoje. Šiame skyriuje susipažinsi su pagrindinėmis komandomis, kurios padės tau stebėti veikiančius procesus ir identifikuoti galimas problemas.

### `ps` - Procesų Sąrašas

`ps` komanda leidžia pamatyti veikiančių procesų sąrašą statiniu vaizdu. Tai reiškia, kad ji parodo procesų būseną tam tikru momentu. Ši komanda ypač naudinga, kai reikia sužinoti, kas vyksta tavo sistemoje, arba rasti konkretaus proceso informaciją. Pagrindinės `ps` subkomandos:

* `a`: Parodo visus procesus su terminalais.
* `u`: Parodo procesus su vartotojo lygio informacija.
* `x`: Parodo procesus, neprisirišusius prie terminalo.

Ką Parodo ps Išvestis?

* **USER**: Kas paleido procesą (pvz., justas, root).
* **PID**: Proceso identifikatorius - unikalus skaičius, skirtas kiekvienam procesui.
* **%CPU**: Kiek procesoriaus resursų naudoja procesas.
* **%MEM**: Kiek RAM atminties naudoja procesas.
* **COMMAND**: Proceso paleidimo komanda (pvz., python analysis.py).

#### Tipiniai Scenarijai

**Ieškoti Konkretaus Proceso** 

Jei dirbi su dideliu Python skriptu, kuris užstringa, ir tau reikia jį sustabdyti:

```bash
ps aux | grep python
```

Ši komanda parodys visus procesus, susijusius su python. Suradus proceso **PID**, jį gali sustabdyti su komanda `kill`:

```bash
kill <PID>
```

### `kill` komanda

`kill` komanda naudojama procesui sustabdyti arba nutraukti siunčiant jam signalą. Signalai yra mechanizmas, leidžiantis programuotojams siųsti instrukcijas procesams apie tai, kaip elgtis. Signalai gali būti siunčiami įvairiais būdais, siekiant subtiliai sustabdyti procesą arba jį prievarta nutraukti.

* Pagrindinė sintaksė: `kill [option] <PID>`, kur <PID> yra proceso identifikatorius.

* Signalai: Kiekvienas signalas turi numerį ir pavadinimą.Dažniausiai naudojami signalai yra:

* SIGTERM (15): Mandagus proceso prašymas nutraukti darbą. Procesui suteikiama galimybė uždaryti atviras bylas ir atlikti kitus būtinus uždarymo veiksmus. 
    * `kill -15 <PID>`
* SIGKILL (9): Prievartinis proceso nutraukimas be galimybės atlikti uždarymo veiksmus. Procesas sustabdomas iš karto.
    * `kill -9 <PID>`



**Rūšiuoti Pagal Procesoriaus Naudojimą**

Jei kompiuteris veikia lėtai, gali išsiaiškinti, kuris procesas labiausiai apkrauna CPU:

```bash
ps aux --sort=-%cpu | head
```

**Atminties Naudojimo Analizė**

Jei RAM greitai užsipildo analizuojant didelius duomenis:

```bash
ps aux --sort=-%mem | head
```




### `top`

Komanda `top` parodo visus aktyvius procesus dinaminėje aplinkoje, pateikiant bazinę sistemos informaciją. `top` yra įdiegta beveik visuose Linux distribucijose, tačiau jos sąsaja nėra itin vizualiai patraukli.

### `htop`

`htop` yra interaktyvus įrankis, skirtas stebėti procesus realiu laiku. Jis suteikia spalvotą, aiškią sąsają, leidžiančią filtruoti, rūšiuoti ir valdyti procesus tiesiogiai.

**Pagrindinės Funkcijos**

* Paleidimas: Įvesk `htop` terminale.
* Rodo procesus pagal resursų naudojimą: Leidžia matyti, kurie procesai suvartoja daugiausiai resursų.
* Leidžia sustabdyti procesus: Gali nutraukti procesus neišeidamas iš sąsajos.
* Dinamiškai atnaujina informaciją.

**Valdymas `htop` Viduje**

* Rodyklių Klavišai: Naršymui tarp procesų.
* F3: Ieškoti proceso pagal pavadinimą (pvz., python).
* F9: Užbaigti pasirinktą procesą (kill).
* F10: Išeiti iš htop.

**Tipiniai Scenarijai:**

**Surasti Procesą, Kuris Apkrauna CPU**

Dirbant su dideliais duomenų failais, htop padeda pamatyti, ar tavo skriptas naudoja per daug CPU. Ieškok proceso, rūšiuok paspaudžiant `p`.

**Valdyti Strigusį Procesą**

Jei R arba Python procesas užstringa, rask jį naudojant `htop`, pasirink rodyklėmis ir paspausk F9.

**Atminties Stebėjimas Realiu Laiku**

Vykdant sudėtingus skaičiavimus (pvz., mokant mašininio mokymosi modelį), stebėti atminties naudojimą. Jei procesas per daug apkrauna sistemą, gali jį sustabdyti.

Šios komandos suteikia reikalingus įrankius efektyviai valdyti procesus, stebėti išteklių naudojimą ir spręsti problemas, susijusias su kompiuterių našumu.


::: {.callout-tip title="Praktika"}

1. Surastk ir nutrauk procesą su `ps aux` ir `kill`
    * Paleisk procesą miegoti: `sleep 600`. Ši komanda leis terminalui "miegoti" 600 sekundžių.
    * Atidaryk kitą terminalo langą ir surask šį procesą, naudojant `ps aux | grep sleep`. Tada nusiųsk `kill -9 <PID>`, kur <PID> yra proceso ID, kurį rasi prieš tai atliktoje komandoje.
    * Pasitikrink ar proceso nebėra.

1. Surastk ir nutrauk procesą su `htop` 
    * Paleisk procesą miegoti: `sleep 600`. 
    * Paleisk `htop` terminalo kitame lange. Surask `sleep` procesą sąraše.
    * Naudojant rodyklių klavišus pasirink procesą ir nutrauk jį paspausdus `F9`, tada pasirink `9` (SIGKILL), kad prievarta nutrauktum procesą.
    * Pasitikrink ar proceso nebėra.
:::



## `nano` Tekstinio Redaktoriaus Naudojimas

`nano` yra patogus teksto redaktorius, skirtas tiek pradedantiesiems, tiek pažengusiems Linux naudotojams. 

* Atidaryti esamą arba sukurti naują failą: 
```bash
nano <failas>
```

Jei failas egzistuoja, jis bus atidarytas redagavimui. Jei failo nėra, jį išsaugant bus sukurtas naujas failas.

* Redaguoti **sisteminius** failus su administracinėmis teisėmis: 

```bash
sudo nano <failas>`
```

Jeigu paleisi `nano` be failo, jis sukurs naują buferį. Gali pradėti rašyti tekstą iš karto. Naudok rodyklių klavišus, kad judėtum tekste.Išsaugant, bus sukurtas failas tuo pavadinimu, kurį nurodysi.

**Keli naudingi flagai:**

* Rodyti žymeklio padėtį `nano -c <failas>`
* Kurti atsarginę kopiją prieš išsaugant: `nano -B <failas>`
* Įjungti pelės palaikymą: `nano -m <failas>`
* Rodyti eilutes: `nano -l <failas>`


**Pagrindinės Redagavimo Komandos**

* Išsaugoti ir Uždaryti
    *   Išsaugoti pakeitimus: `Ctrl + O` (paspausk Enter, kad patvirtintum).
    * Išeiti iš nano:` Ctrl + X`.
* Teksto Redagavimas
    * Ieškoti teksto: `Ctrl + W`.
    * Iškirpti teksto eilutę: `Ctrl + K`.
    * Įklijuoti iškirptą tekstą: `Ctrl + U`.
* Navigacija
    * Pereiti į eilutės pradžią: `Ctrl + A`.
    * Pereiti į eilutės pabaigą: `Ctrl + E`.
    * Slinkti aukštyn: `Ctrl + Y`.
    * Slinkti žemyn: `Ctrl + V`.




::: {.callout-tip title="Praktika"}
### Praktikos Uždaviniai su `nano`

1. **Sukurti ir Redaguoti Tekstinį Failą**

   - Sukurk ir atidaryk failą **mano_uzrasai.txt**:
   - Įrašyk tekstą: "Sveiki atvykę į Linux mokymus!", išsaugok su `Ctrl + O`, ir išeik su `Ctrl + X`.
   - Vėl atidaryk failą, pridėk tekstą: "Šiandien mokysimės nano redaktoriaus.", išsaugok ir išeik.
   - Atspausdink failo turinį su `cat`

2. **Redaguoti Esamą Failą su Administratoriaus Teisėmis**

   - Atidaryk `/etc/hosts` su `sudo`:
   - Pridėk komentarą "# Redagavimas tekste" viršuje, išsaugok ir išeik.
   - Atspausdink failo turinį su `cat` (jokio redagavimo, tad `sudo` nereikia):
   - Vėl atidaryk failą su `sudo` ir ištrink įrašytą komentarą, išsaugok ir išeik:
:::


## Alias

Užbaikime šį skyrių pasitelkę nedidelį "programavimą". Nors tai dar nėra pilnai skriptų rašymas, tačiau toks metodas padės palengvinti kasdienį darbą terminale, sukuriant trumpinius dažnai naudojamoms komandoms. Trumpniai vadinamai **alias**.

![](../img/bash_advanced/alias.jpg)

Tu išmokai ieškoti didelių video failų ir tavo komanda atrodė taip:

```bash
find ~/Downloads/ ~/dwhelper/ -type f -iname "*.mp4" -size +100M -atime +14
```

Jei tau reikėtų šią komandą įrašyti kaskart, tai užimtų daug laiko. Nors automatinis skriptų paleidimas, pvz., kompiuterio įjungimo metu, yra sprendimas, tačiau paprastesnis būdas yra sukurti **alias** - tai leidžia greitai paleisti ilgas komandas, naudojant trumpinius.

**Alias Apibrėžimas**

Norint sukurti alias, turi redaguoti savo namų direktorijoje esantį **.bashrc** failą. Štai kaip tai padaryti:

* Atidaryk .bashrc failą: `nano ~/.bashrc`
* Failo pabaigoje pridėk naują alias naudojant šią sintaksę:

```bash
alias alias_name='command'
```
Pavyzdžiui, sukurk alias komandai, kuri ieško didelių video failų:

```bash
alias lnuf='find ~/Downloads/ ~/dwhelper/ -type f -iname "*.mp4" -size +100M -atime +14'
```
* Išsaugok ir išeik iš redaktoriaus (naudok Ctrl + O, Enter, Ctrl + X).

**Alias Paleidimas**

Jei dabar terminale įrašysi `lnuf`, gali pastebėti, kad terminalas nesupranta šios komandos. Taip yra todėl, kad **.bashrc** failo pakeitimai dar nėra užkrauti į aktyvią terminalo sesiją. Štai ką padaryk:

* Atnaujink Bash Shell nustatymus: Naudok `source` komandą, kad iš naujo užkrautum **.bashrc** nustatymus, neperkraunant visos terminalo programos.

```bash
source ~/.bashrc
```

Dabar tu gali tiesiog naudoti komandą `lnuf`, kad paleistum visą ilgąją komandą.

Alias leidžia greitai ir efektyviai valdyti kasdieninių užduočių komandas, sutaupant laiko ir pastangų. Tai nedidelis, bet labai naudingas "programavimo" elementas, kurį gali pritaikyti įvairiose situacijose, norint optimizuoti savo darbo eigą terminale.

Jeigu pastebėsi, kad tam tikro alias nebereikia - visada gali jį ištrinti ir atnaujinus perkrauk bash panaudojant `source ~/.bashrc`




## Projektai

### Projektas 1: Orų prognozė Terminal lange

Sveikinu tapus junior software developer'e nedidelėje kompanijoje, kuri specializuojasi kurdama bash skriptus Linux vartotojams. Paprastai tokia kompanija dirba su įvairiais projektais, kuriuose reikia kūrybingumo ir techninių įgūdžių. 

![](../img/bash_advanced/sd.jpg)

Tavo komandos produkto vadovas (product manager - PM) pasidalino pastebėjimu: 

>„Mūsų klientai dažnai peršąla, nes išeina nepažiūrėję, kokia temperatūra lauke. Jie taip įnykę į savo terminalus, kad aplinkinio pasaulio nemato.“

![](../img/bash_advanced/linux_nerds.jpeg)

> "Ar galėtum sukurti programą, kuri terminale rodytų artimiausių 12 valandų orų prognozę?“.

PM'as tau pateikė idėjų eskizą, o tavo užduotis - sukurti pirmąją programos versiją, vadinamą MVP (Minimum Viable Product). Kaip dažnai nutinka programuotojų darbe, pagrindinė tavo užduotis yra paversti idėjas į veikiančius sprendimus, naudojant technologijas ir kūrybingumą.

![](../img/bash_advanced/mvp.png)

#### Projekto Pradžia  {.unnumbered}

Pradėk nuo projekto aplanko sukūrimo, kad galėtum patogiai struktūrizuoti savo darbą. Tai padės išlaikyti tvarką, kadangi, kaip žinome, programuotojai linkę eksperimentuoti ir generuoti daugybę tarpinio kodo.

Keliauk į Lietuvos hidrometeorologijos tarnybos svetainę ([https://www.meteo.lt/](https://www.meteo.lt/)), kur gali rasti API dokumentaciją. Pirmiausia, sukurk užklausą, kuri atsiųs visas galimas vietoves. Atsispausdink pirmąją vietovę, kad suprastum, kaip yra struktūrizuoti duomenys. Tai yra svarbus žingsnis, kai dirbi su naujais duomenimis arba API - suprasti jų struktūrą ir galimybes.

![](../img/bash_advanced/wf_1.png)


#### Duomenų Apdorojimas {.unnumbered}

Kadangi tave domina tik Lietuvos vietovės, reikės filtruoti duomenis. Naudok JSON apdorojimo įrankius, kaip `jq`, susiaurink duomenų masyvą tik į Lietuvą ir išsaugok rezultatus kaip TSV failą su vietovių pavadinimais bei kodais, pavadintą **lt_places.tsv**. Kiek iš viso yra vietovių, kurių pavadinimas prasideda „Viln“? Suradus atsakymą, nusprendei savo MVP naudoti Vilniaus rajoną **Lazdynus**. Sužinok, koks yra šios vietovės kodas, nes jis bus būtinas tolimesniam darbui su API.

![](../img/bash_advanced/wf_2.png)


#### Orų Prognozės Gavimo Procesas  {.unnumbered}

Grįžk prie API dokumentacijos ir sužinok, kaip parašyti užklausą orų prognozei gauti. Parsisiųsk duomenis ir išsaugok juos kaip **data_forecast.json**. Naudojant JSON apdorojimo įrankius, atspausdink prognozę gražiu JSON formatu ir pasirink tinkamą masyvą bei submasyvus, kurie pateiks reikalingą informaciją apie orą. Išrink šiuos elementus: **.forecastTimeUtc**, **.airTemperature**, **.conditionCode**, ir suformatuok juos kaip CSV failą, pavadindamu **filtered_data_forecast.csv**.

![](../img/bash_advanced/wf_3.png)

#### Estetiniai Pataisymai {.unnumbered}

Kad galutinis produktas būtų vizualiai patrauklus, naudok įrankius kaip `column` išlyginimui. Jei dar nežinai šios komandos - gali pasinaudoti ChatGPT ar kitais šaltiniais, kad sužinotum, kaip ji veikia. Tavo pristatomas failas vadinsis **final_output**.

![](../img/bash_advanced/wf_4.png)

PM pamatęs tavo MVP, tiesiog negalėjo sulaikyti džiaugsmo:

![](../img/bash_advanced/XR9Dp54ZC4dji.webp)

Jis paprašė pakeisti terminą „Debesuotumas“ į „Oro sąlygos“ ir pridėti emodžius, kad išvestis būtų žaismingesnė. Tu nusprendei grįžti į API puslapį ieškoti visų galimų orų sąlygų ir paprašyti ChatGPT sukurti `sed` komandas, kurios pakeis orų sąlygas emodžiais. Galiausiai, produktą pristatei vadovui:

![](../img/bash_advanced/wf_5.png)

Ir PM'as buvo sužavėtas:

![](../img/bash_advanced/giphy-106588401.webp)

Dabar tau beliko sudėti visas komandas į vieną skriptą, kuris veiktų tik atmintyje, nesukuriant fizinių failų. Stenkis jungti kuo daugiau su pipes `|`. Gali būti kad su kokiu `sublime-text` editoriumi taudirbti būtų papraščiau. Nors ne terminalo lange, o papildoma programa, bet ji palengvins darbą.

Išsaugok skriptą kaip **lazdynai_temp.sh**, patikrink failo teises, suteik vykdymo leidimą ir paleisk skriptą, kad įsitikintum, ar jis generuoja atitinkamą prognozę. 

Skriptą paleisti gali su `./lazdynai_temp.sh`

Tai yra ne tik naudinga programa, bet ir puikus pavyzdys, kaip kūrybingas programuotojas gali prisidėti prie kasdienio gyvenimo patogumo!

Skyriuose apie bash skriptų rašymą išmoksi naudotis bash logika, užduoti klausimus vartotojams ir pritaikyti šio skripto logiką priklausomai nuo gautų atsakymų.


p.S. metei.lt tinklpayje prie API dokumentacijos yra aprašyta licenzija. Kokia ji būtent? 
Susipažink su CC licenzijomis [https://creativecommons.org/](https://creativecommons.org/). Ir atsakyk į šiuos klausimus:

* ar tavo įmonė gali naudoti šiuos duomenis kuriant komercinius produktus?
* ar sukūrus produktą, tu turi nurodyti, kas yra duomenų šalintinis?
* ar tu gali pakeisti licenciją į kitokią? ką tai reiškia šiam produktui?


---


[data.gov.lt](https://data.gov.lt/datasets/2762/data/SeskinesPoliklinika)



### Projektas 2 Šeškinės poliklinos radiologiniai tyrimai

![moira.lt](../img/bash_advanced/moira-seskines-poliklinika-moira-post-14.jpg)

Buvo gražus rytas, kai Šeškinės poliklinikos CTO, Ruprechtas, sukruto spręsti svarbių klausimų. Poliklinika buvo užimta kaip niekada, o radiologinių tyrimų kiekis augo kasdien. Ruprechtas žinojo, kad norint užtikrinti sklandų poliklinikos darbą, reikia rasti būdą, kaip efektyviai stebėti ir analizuoti šiuos tyrimus. Tad kreipėsi į "Linux consulting UAB" pagalbos.

![Dall-E](../img/bash_advanced/cat_cto.webp)

Justina,produktų vadovė (PM) turėjo viziją, kaip automatizuoti kasdienines ataskaitas, ir nedelsiant susitiko su tavimi suderinti darbo eigos.

>„Klausyk, mums reikia, kad kasdien būtų pateikiama ataskaita apie atliktus tyrimus pagal kūno dalis,“ - sako Justina, tvirtai traukdama tave į projektą. „Reikia panaudoti duomenis iš data.gov.lt. Galėsi tai padaryti?“

Tu žvilgtelėjai į pateiktą informaciją ir iš karto susidėliojai galvoje planą. 

>„Taip, Justina, aš tuo pasirūpinsiu. Bus įdomus projektas.“

Pasiruošei kibti į darbus, žinant, kad šis projektas padės poliklinikai ne tik optimizuoti kasdienius procesus, bet ir pagerinti ligonių priežiūrą. Be to šis projektas - puiki galimybė parodyti savo sugebėjimus ir prisidėti prie Ruprecht'o naujovių poliklinikoje.

![Dall-E](../img/bash_advanced/meeting.webp)

---


* **Duomenų šaltinis**: [data.gov.lt](https://data.gov.lt/datasets/2762/data/SeskinesPoliklinika)
* **Duomenų struktūra**:

| Kodas                      | Reikšmė                                                  | Formatas                |
|----------------------------|----------------------------------------------------------|-------------------------|
| vda_id                     | Valstybės Duomenų Agentūros įrašo identifikatorius       | string                  |
| paciento_asm_k             | Nuasmenintas paciento asmens kodas                       | string                  |
| tyrimo_studijos_uuid       | Tyrimo studijos identifikatorius                         | string                  |
| tyrimo_studijos_data       | Tyrimo studijos data                                     | date (ref: D)           |
| paciento_gimimo_metai      | Paciento gimimo metai                                    | date (ref: Y)           |
| paciento_lytis             | Paciento lytis                                           | string                  |
| paciento_svoris            | Paciento kūno svoris kilogramais                         | number (ref: kg)        |
| paciento_ugis              | Paciento ūgis metrais                                    | number (ref: m)         |
| tyrimo_serijos_uuid        | Tyrimo serijos identifikatorius                          | string                  |
| tirta_kuno_dalis           | Tirta kūno dalis                                         | string                  |
| tyrimo_serijos_modalumas   | Tyrimo serijos modalumas                                 | string                  |
| tyrimo_serijos_aprasymas   | Tyrimo serijos aprašymas                                 | string                  |
| atvaizdo_uuid              | Atvaizdo unikalus identifikatorius                       | string                  |
| apsvita                    | Apšvita arksekundėmis                                    | number (ref: ″)         |
| spinduliuote               | Spinduliuotė decigrėjais kvadratiniame centimetre        | number (ref: dGy/cm²)   |
| fotometrine_interpretacija | Fotometrinė interpretacija                               | string                  |

* **Tiskslas**: Galėti kasdien Terminale gauti naujausius duomenis apie altiktų radiologinių tyrimų skaičių pagal kūno vietos.

####  Sprendimo gairės {.unnumbered}

Šie klausimai ir žingsniai padės tau sėkmingai atlikti užduotį. Nepamiršk, kad tai tik orientyrai, tad skirk laiko ir savarankiškai gilinkis į temą.

#### Gilinkis į data.gov.lt {.unnumbered}

1. API pasirinkimai:
    * Eik į API puslapį ir ištyrinėk `getall`, `getone`, `changes`.
    * Suprask, kaip kiekvienas variantas keičia JSON struktūrą. Apmastyk, ką jie kiekvienas reiškia tau ir ar ir kaip gali būti pritaikomi tavo projekte.
1. Duomenų Filtravimas:
    * Eik į „Duomenys“ lapą ir panaudok filtrą (select(*)).
    * Pasirink keletą tau reikalingų stulpelių ir pažiūrėk, kaip tai paveikia užklausas
    * Patikrink, kaip pasikeičia URL struktūra, kai pasirenki konkretų filtrą.

1. Duomenų tyrinėjimas ir analizė:
    * Naudok galimybę rūšiuoti ir filtruoti lentelės duomenis „Duomenys“ lape
    * Atsakyk sau į šiuos klausimus:
        * Kokia yra seniausia ir naujausia tyrimų data?
        * Ar yra tuščių reikšmių?
        * Ar yra skirtumas parsiuntimo greityje, priklausomai nuo mano padarytų pasirinkimų?
    * Užbaigus filtravimą, grįžk į API lapą ir analizuok, kaip keitėsi užklausa. 
    * Naudok tekstinį redaktorių pvz. Sublime, kad galėtum geriau pamatyti URL tvarką ir surpasti sistemą.



#### Programavimo etapas {.unnumbered}

* Sukurk projekto direktoriją
* Sukurk README.md failą, kuriame aprašyk projekto informaciją ir tikslus.
* Sukurk skriptą `recent_radiological_seskines_pol.sh`:
    * Skriptas turi atsisiųsti duomenis JSON formatu.
    * Pasirinkti reikalingus stulpelius: Tyrimo studijos data ir Tirta kūno dalis
    * Filtruoti duomenis pagal nustatytą datą, pvz., 2024-11-28. arba datos intervalą
    * Suskaičiuoti tyrimų skaičių pagal kūno dalis.
    * Suplokštinti duomenis į TSV formatą.


**Pastaba**: Kol dirbi su sintakse ir lygiavimu, sukurk laikinus failus, kad galėtum pamatyti, kur yra tabai ar tarpai. Tai padės teisingai supaprastinti duomenų apdorojimą ir išvengti klaidų. Vėliau tuos failus ištrinsi.


#### MVP vertinimas {.unnumbered}

Dienos pabaigoje, kai PM Justina grįžta, tu su nerimu ir pasididžiavimu parodai savo atliktą darbą. Justina, garsėjanti savo atidumu detalėms ir griežtumu, kritiškai apžvelgia rodmenis. Laikui bėgant, jos veide atsiranda šypsena.

>„Puiku, man labai patinka, ką padarei“, - pagiria ji, nuleisdamažiūrėjusi į tavo kruopščiai parengtą rezultatą. „Tačiau, žinodama Ruprechtą, norėčiau, kad galėtume į projektą įtraukti daugiau aiškumo ir paprastumo. Gal gali parengti:

>* Išsami README.md failo versiją: Aprašyk jame kiekvieną projekto dalį - nuo duomenų gavimo iki galutinio rezultato pateikimo. Būtų puiku, jei įtrauktum ir pastebėtas prielaidas bei pasiūlymus tobulinimui.

>* Vienos eilutės komandą (Oneliner): Tokio tipo komanda turėtų tiesiog terminale pateikti vienos pasirinktos dienos rezultatus, kad mūsų techninis personalas galėtų greitai ir patogiai gauti reikiamą informaciją.

>* Pilną skriptą: Jis turėtų būti išsamus, kad galėtų išgauti ir išfiltruoti duomenis už tam tikrą laikotarpį ir išsaugoti juos formatu, tinkamu atidaryti su libreoffice. Tai leis mūsų komandai lengvai tvarkytis su duomenimis ir rengti ataskaitas.“


#### Pratęsimas {.unnumbered}

Pamąstyk, kaip iš esamos darbo atlikimo strategijos sukurti:
* Skriptą, kuris išsaugo duomenis, kuriuos galima atsidaryti su libreoffice --calc <failas>.
* Vienos eilutės komandą, skirtą rezultatais naudotis terminale.

Detaliai aprašyk atliktus veiksmus README.MD faile.



::: {.callout-important title="Pagalba"}

Kai mokeisi apie redirektorius `>`, `>>`, buvo paminėtas ir atgalinis redirektorius `<`.  ChatGPT arba interneto pagalba išsiakink, ką daro ši komanda ir pagalvok, kaip jos sintaksę galėtum pritaikyti savo projekte.

```bash
echo "labas rytas" | cat - <(echo "labas vakaras")
```

* ką reiškia `-`?
* kodėl ir kam panaudojamas `<`
:::


---

::: {.callout-important title="PagalbaL kaip alėtų atrodyti README.MD"}

`<!-- -->` Žymi komentarus. Juos reiktų ištrintiir vietoj jų užpildyti tavo turiniu.

```md
# Šeškinės Poliklinikos Radiologinių Tyrimų Ataskaita

## Projekto Aprašymas

<!-- Aprašykite pagrindinį projekto tikslą ir ką jis daro. Tai svarbu, kad skaitytojai suprastų, apie ką yra projektas. -->

## Pradžia

### Reikalavimai

<!-- Išvardinkite būtiną programinę įrangą ir jų versijas. Tai padės užtikrinti, kad projektas veiks skirtinguose įrenginiuose. -->

### Diegimas

<!-- Aprašykite diegimo instrukcijas, kaip naudotojas gali klonuoti ir pradėti naudotis projektu. Aiškios instrukcijos padės vartotojams lengviau pradėti. -->

1. Klonuokite projektą:
   `git clone <repo-url> && cd <repo>` 

## Naudojimas

#### Vienos Eilutės Komanda

<!-- Įrašykite vienos eilutės komandos sintaksę. Ši dalis svarbi, kad vartotojai galėtų greitai išbandyti pagrindines funkcijas. -->

#### Pilnas Skriptas

<!-- Pateikite skripto sintaksę. Tai svarbu, kad būtų galima atlikti išsamesnę analizę ar duomenų tvarkymą. -->

## Struktūra

<!-- Aprašykite projekto failų struktūrą. Tai padės naudotojams geriau suprasti projekto organizaciją ir rasti reikiamus failus. -->

- `README.md`: Dokumentacija
- `recent_radiological_seskines_pol.sh`: Skriptas

## Prielaidos

<!-- Nurodykite visas prielaidas, kuriomis remiasi projektas. Tai svarbu, kad vartotojai žinotų, kas yra numatyta ir ką jie turi turėti ar atlikti prieš naudojant projektą. -->

## Tolesni Plėtros Tikslai

<!-- Apibūdinkite galimus ateities atnaujinimus ir plėtros kryptis. Tai gali įtraukti naujas funkcijas ar planuojamus patobulinimus. Padeda pateikti ilgalaikę projekto viziją. -->

## Papildomi Ištekliai

<!-- Pateikite nuorodas į papildomus išteklius, pavyzdžiui, naudojimo dokumentaciją ar technologijų, kurias naudavote, vadovus. Tai naudinga papildomai informacijai gauti. -->

Daugiau informacijos apie Markdown: [Markdown Guide](https://www.markdownguide.org/basic-syntax/)
```
:::