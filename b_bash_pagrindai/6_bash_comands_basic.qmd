---
title: "BASH komandos"
execute:
  daemon: false
  enabled: false
format:
  html:
    code-copy: true
    eval: false
    echo: true
---

## FailÅ³ ir direktorijÅ³ valdymas

PraÄ—jusiame skyriuje iÅ¡mokai naviguoti terminale naudojant komandas `pwd` ir `cd`. SuÅ¾inojai apie Linux failÅ³ sistemÄ…: kaip matyti visÅ³ failÅ³ ir katalogÅ³ sÄ…raÅ¡Ä… naudojant `ls` komandÄ…, bei tai, kad Linux sistemoje vartotojai turi skirtingas teises, priklauso grupÄ—ms, ir kiekvienas failas turi savininko, grupÄ—s, bei kitÅ³ vartotojÅ³ teises naudotis tuo failu ar katalogu. Taip pat iÅ¡mokai svarbiÅ³ klaviatÅ«ros trumpiniÅ³, kaip perÅ¡okti Ä¯ komandinÄ—s eilutÄ—s pradÅ¾iÄ… (`Ctrl-A`), pabaigÄ… (`Ctrl-E`), nutrinti dalÄ¯ (`Ctrl-U`), kaip kopijuoti ir Ä¯klijuoti Ä¯ terminalÄ… naudojant `Ctrl-Shift-C` ir `Ctrl-Shift-V`. IÅ¡mokai dirbti su terminalo istorija naudojant `history` ir kartoti komandas su `!n`.

Å iame skyriuje skirsi dÄ—mesÄ¯ darbui su failais ir direktorijomis. Tu iÅ¡moksi kurti failus ir direktorijas, juos kopijuoti, perkelti, iÅ¡trinti. Taip pat iÅ¡moksi sujungti kelias komandas. Ir Å¡io skyriaus pabaigoje pamatysi, kad tavo BASH Ä¯gÅ«dÅ¾iai tampa dar stipresni!

![By J. Howard Miller - [U.S. National Archives and Records Administration](https://commons.wikimedia.org/w/index.php?curid=80242715)](../img/shell_adv/We_Can_Do_It!.jpg)

PrieÅ¡ pradedant, Ä¯sitikink, kad turi keletÄ… svarbiÅ³ programÅ³: `jq` ir `curl`. Kaip ir praÄ—jusiame skyriuje, kai ieÅ¡kojai` which $SHELL`, komanda tau parodÄ—, kur yra binary failas (programa). Dabar padaryk tÄ… patÄ¯:

* Patikrink, ar turi `curl`, su `which curl`.
* Patikrink, ar turi `jq`, su `which jq`.

Jei tavo kompiuteris aptinka Å¡ias programas, terminalas atspausdins vietÄ…, kur jos yra Ä¯diegtos. Jei terminalas jÅ³ neranda, Ä¯diek `curl` ir `jq` kaip sisteminius paketus naudojant `apt`. Jei pamirÅ¡ai, kaip tai daryti, pakartok ankstesnÄ™ medÅ¾iagÄ….

![](../img/shell_adv/which_curl_jq.png)

Kai tai atliksi, nukopijuok ir paleisk Å¡iÄ… komandÄ… savo terminale - ji sukurs direktorijÄ… **shell_2_dalis** tavo namÅ³ direktorijoje kartu su visais Å¡iam skyriui reikalingais failais:

```bash
curl -s https://gist.githubusercontent.com/justasmundeikis/b4bfc0d672a859afc0fe28f1e721e167/raw | bash
```

Jeigu viskas gerai, turÄ—tum pamatyti:

![](../img/shell_adv/all_created.png)

::: {.callout-tip}
Pasikartok komandas `cd`, prisimink absoliutÅ³ ir reliatyvÅ³ keliÄ…, bei kÄ… reiÅ¡kia `~`, `.` ir `..`. Å iame skyriuje taip pat daÅ¾nai reikÄ—s naudoti `ls`, tad pasikartok Å¡iÄ… komandÄ… ir jos nustatymus dabar.
:::

Su `ls` komanda atspausdink *long* formatu savo *home directory* turinÄ¯. PaaiÅ¡kink visas Å¡ios eilutÄ—s reikÅ¡mes.

![](../img/shell_adv/initial.png)

Pakeisk savo darbinÄ™ direktorijÄ… Ä¯ **~/shell_2_dalis**. Kaip pasikeitÄ— tavo *prompt*? PaaiÅ¡kink, kas Äia yra kas.

![](../img/shell_adv/initial_prompt.png)

### echo

Komanda `echo` naudojama norint atspausdinti vartotojo Ä¯vestÄ¯ (**input**) terminale (dar vadinamÄ… standartine iÅ¡vestimi, angl. **standard output**). Tai paprasta, bet galinga komanda, daÅ¾nai naudojama skriptuose praneÅ¡imams rodyti arba kintamÅ³jÅ³ reikÅ¡mÄ—ms tikrinti.

Nors nÄ—ra bÅ«tina tekstÄ… apskliausti kabutÄ—mis, dÄ—l geresnio aiÅ¡kumo ir Ä¯skaitomumo patartina tai daryti.

```bash
echo Hello World!
echo 'Hello World!'
echo "Hello World!"
```

ReikÄ—tÅ³ atkreipti dÄ—mesÄ¯, jog dvigubos kabutÄ—s (`" "`) ir viengubos kabutÄ—s (`' '`') Å¡iek tiek skiriasi. Tekstas, esantis viengubose kabutÄ—se (`' '`), atspausdinamas paraidÅ¾iui, nepaisant ten esanÄiÅ³ kintamÅ³jÅ³. Tuo tarpu tekstas, esantis dvigubose kabutÄ—se (`" "`), yra interpretuojamas, ir Shell leidÅ¾ia naudoti kintamÅ³jÅ³ vertes.

Pabandyk Å¡ias komandas, kurios naudoja kintamÄ…jÄ¯ `$USER`, atspausdinantÄ¯ shell sesijos vartotojo vardÄ…:

```bash
echo My username is $USER
echo 'My username is $USER'
echo "My username is $USER"
```
Ar pastebi, kuo skiriasi iÅ¡vestis?

![](../img/shell_adv/echo.png)


### `>` ir `>>` operatoriai

`>` ir `>>` operatoriai naudojami iÅ¡vesties nukreipimui (angl. **output redirection**). Jie nukreipia komandos iÅ¡vestÄ¯ (angl. **output**) Ä¯ failÄ…, o ne Ä¯ terminalÄ…. Å ie operatoriai yra esminiai dirbant su failais ir automatizuojant uÅ¾duotis skriptuose.

`>` operatorius nukreipia komandos iÅ¡vestÄ¯ Ä¯ failÄ…, perraÅ¡ydamas jo turinÄ¯, jei failas jau egzistuoja. Jei failas neegzistuoja, jis bus sukurtas.

Å i komanda sukuria (arba perraÅ¡o) failÄ… **hello_world.txt** su tekstu "Hello World!".

```bash
echo "Hello World!" > hello_world.txt
```

Kaip `echo` komanda ir jos argumentas "Hello World!" buvo nukreipti Ä¯ tekstinÄ¯ failÄ…, taip galime nukreipti ir kitÅ³ komandÅ³ iÅ¡vestis Ä¯ failus. Operatoriaus `>` argumentas nebÅ«tinai turi bÅ«ti tik failo pavadinimas, tai gali bÅ«ti ir failo pavadinimas su absoliuÄiu ar reliatyviu adresu.

```BASH
ls > mix/direktorijos_turinys.txt
```

Å i komanda nukreipia `ls` komandos iÅ¡vestÄ¯ Ä¯ failÄ… **direktorijos_turinys.txt**, kuris yra **mix** subdirektorijoje. Atsidaryk Å¡Ä¯ failÄ… ir patikrink, ar jis susikÅ«rÄ— teisingai. TurÄ—tum matyti kaÅ¾kÄ… panaÅ¡aus Ä¯ Å¡Ä¯ vaizdÄ…:

![](../img/shell_adv/echo_result.png)

::: {.callout-tip title="Praktika"}
Liekant **shell_part_2** direktorijoje, atspausdink namÅ³ direktorijos (angl. **home directory**) turinÄ¯ su visais paslÄ—ptais failais, ilguoju formatu ir Å¾monÄ—ms geriau suprantamais failÅ³ ir direktorijÅ³ dydÅ¾iais, ir nukreipk iÅ¡vestÄ¯ Ä¯ **mix** subdirektorijoje esantÄ¯ failÄ… **direktorijos_turinys.txt**, jÄ¯ perraÅ¡ant.
:::

----

**Intarpas**

Hey, kÄ… tik gavai uÅ¾duotÄ¯. Ateityje gausi panaÅ¡ias ir dar sudÄ—tingesnes uÅ¾duotis. TodÄ—l Å¡ioje vietoje padarykime intarpÄ…. PakalbÄ—kime apie vienÄ… svarbiausiÅ³ darbo bÅ«dÅ³ programavime (ir ne tik!) - darbÅ³ skaidymÄ… (angl. break down).

Kartais gali gauti labai sudÄ—tingÄ… uÅ¾duotÄ¯, kuri iÅ¡ pradÅ¾iÅ³ atrodys neÄ¯veikiama ar nesuprantama. Tai visiÅ¡kai normalu. Nestresuok - giliai Ä¯kvÄ—pk, iÅ¡kvÄ—pk, jei reikia, pasiimk popieriÅ³ ir pieÅ¡tukÄ… ir pradÄ—k skaidyti darbus Ä¯ logines sekas. Pvz., prieÅ¡ tai buvusiÄ… uÅ¾duotÄ¯ galima suskaidyti Ä¯ tris dalis:

* reikia failÅ³ ir direktorijÅ³ sÄ…raÅ¡o
* atspausdinti perraÅ¡ant
* failo pavdinimas


![](../img/shell_adv/break_1.png)

Dabar galima skaidyti ar toliau detalizuoti kiekvienÄ… iÅ¡ Å¡iÅ³ daliÅ³.

* ls -alh pagamina sÄ…raÅ¡Ä… ilguoju, Å¾monÄ—ms suprantamÅ³ dydÅ¾iÅ³ formatu
* `>` perraÅ¡o
* **direktorijos_turinys.txt** bus pavadinimas

![](../img/shell_adv/break_2.png)

TaÄiau dabartinÄ— darbinÄ— direktorija yra **~/shell_part_2**, todÄ—l reikia

* `ls -alh` kaip argumentÄ… paduoti `~` arba atitinmai `/home/username`
* **direktorijos_turinys.txt** turi bÅ«ti **mix** subdirektorijoje

![](../img/shell_adv/break_3.png)

Skaidant uÅ¾duotÄ¯ Ä¯ maÅ¾esnes dalis, vis labiau suprasi, kÄ… reikia padaryti. Turint daugiau patirties, geriau Å¾inosi, kiek laiko gali prireikti kiekvienam Å¾ingsniui.

Pvz., duomenÅ³ analitikas gali gauti uÅ¾duotÄ¯: suprognozuoti sekanÄiÅ³ metÅ³ ledÅ³ pardavimus. Analitikas, Å¾inodamas, kad ledÅ³ pardavimai priklauso nuo lauko temperatÅ«ros, gali suskaidyti darbus taip:

* Importuoti istorinius tam tikros vietos temperatÅ«ros duomenis
* Prognozuoti sekanÄiÅ³ metÅ³ kiekvienos dienos temperatÅ«ras
* ApskaiÄiuoti kiekvienos dienos pardavimus
* ApraÅ¡yti duomenis ir pateikti juos uÅ¾sakovui suprantamu formatu

![Photo by [Kamaji Ogino](https://www.pexels.com/photo/asian-mother-with-daughter-pointing-at-signboard-with-ice-cream-5094361/)](../img/shell_adv/pexels-kamaji-ogino-5094361.jpg)

KiekvienÄ… iÅ¡ Å¡iÅ³ Å¾ingsniÅ³ analitikas gali suskaidyti Ä¯ dar daugiau maÅ¾esniÅ³ uÅ¾duoÄiÅ³.

KodÄ—l tai svarbu? VisÅ³ pirma, tai padeda geriau suprasti, kÄ… reikia padaryti, ir kiek tai gali uÅ¾trukti. Kiekvienas Å¾ingsnis tampa atskiru procesu, ir jei nepavyksta vienas metodas, gali bandyti kitÄ….

DarbÅ³ skaidymas yra intuityvus procesas kasdieniame darbe ir tu jau Å¡Ä¯ metodÄ… ir taip taikai pasÄ…moningai, bet kai gauname naujas ir labai sudÄ—tingas uÅ¾duotis, vis tiek verta prisiminti Å¡iÄ… strategijÄ…, nes kartais mes pamirÅ¡tame, kaip ji padeda iÅ¡vengti pasimetimo.

----

`>>` operatorius nukreipia komandos iÅ¡vestÄ¯ Ä¯ failÄ…, pridedant (angl. **append**) prie failo turinio. Jei failas neegzistuoja, jis bus sukurtas.


```BASH
echo "What a beatiful morning" >> day.txt
echo "What a beatiful day" >> day.txt
echo "What a beatiful evening" >> day.txt
```

Å ios komandos prideda tekstÄ… "What a beautiful morning", "What a beautiful day" ir "What a beautiful evening" prie failo **day.txt** galo, neperraÅ¡ydamos esamo turinio. Jei tokio failo nÄ—ra, jis bus sukurtas.

::: {.callout-tip title="Praktika"}
* Susirask tau patinkanÄios dainos tekstÄ… internete.
* Naudojant komandÄ… `echo` ir operatoriÅ³ `>`, sukurk failÄ… **favorite_song.txt**. Failo turinys turÄ—tÅ³ bÅ«ti panaÅ¡us Ä¯ "My favorite song is <name>".
* Pirmas keturias dainos eilutes atspausdink Ä¯ failÄ… **song_text.txt** naudojant `echo` ir `>>`. NepamirÅ¡k, kokie klaviatÅ«ros trumpiniai naudojami kopijuojant ir Ä¯keliant tekstÄ… Ä¯ terminalÄ…!
:::


### cat

Komanda `cat` (angl. **concatenate**, liet. â€sujungtiâ€œ) naudojama perÅ¾iÅ«rÄ—ti, sujungti ir atspausdinti failus. Tai viena iÅ¡ pagrindiniÅ³ Linux komandÅ³, nes leidÅ¾ia greitai perÅ¾iÅ«rÄ—ti failÅ³ turinÄ¯, Ä¯vesti turinÄ¯ Ä¯ kitus failus arba sujungti kelis failus Ä¯ vienÄ….

Praeitame skyriuje sukÅ«rei du failus **favorite_song.txt** ir **song_text.txt**. Dabar juos ir naudosime.

Atspausdink failo **favorite_song.txt** turinÄ¯ Ä¯ terminalÄ…:

```bash
cat favorite_song.txt
```

Pas mane tai atrodo taip:

![](../img/shell_adv/cat_fav_song.png)


`cat` leidÅ¾ia sujungti keliÅ³ failÅ³ turinÄ¯ ir atspausdinti rezultatÄ… terminale:

```bash
cat favorite_song.txt song_text.txt

```
![](../img/shell_adv/cat_fav_song_text.png)


Kaip praeitame skyriuje iÅ¡mokai, komandos iÅ¡vestÄ¯ (nesvarbu, ar tai bÅ«tÅ³ `echo`, ar `ls`) galima nukreipti Ä¯ failÄ…. Lygiai taip pat gali nukopijuoti failÄ… naudojant `cat` ir `>` arba `>>`:

```bash
cat favorite_song.txt > favorite_song_2.txt
```

Å i komanda nukopijuoja failo **favorite_song.txt** turinÄ¯ Ä¯ naujÄ… failÄ… **favorite_song_2.txt**, perraÅ¡ydama jo turinÄ¯, jei toks failas jau egzistuoja.


::: {.callout-tip title="Praktika"}
* Naudojant `echo` ir `>>`, Ä¯raÅ¡yk dar 4 eilutes mÄ—gstamiausios dainos teksto Ä¯ failÄ… **song_text_2.txt**.

* Sujunk failus **song_text.txt** ir **song_text_2.txt**, nukreipiant rezultatÄ… Ä¯ **song_text_full.txt**:

* Pagalvok, kaip naudojant visas iki Å¡iol Å¾inomas komandas, bÅ«tÅ³ galima gauti **song_text.txt** failÄ…, kuriame bÅ«tÅ³ pirmas ketvertas eiluÄiÅ³ ir antras ketvertas eiluÄiÅ³ teksto?
:::


### head ir tail

Komandos `head` (galva) ir `tail` (uodega) naudojamos perÅ¾iÅ«rÄ—ti pirmÄ…sias arba paskutines failo eilutes. Ä®prastai jos atspausdina 10 eiluÄiÅ³ teksto.

::: {.callout-note}
Dabar tavo failas **song_text.txt** turÄ—tÅ³ turÄ—ti 8 eilutes teksto. TodÄ—l tokiu pat bÅ«du, kaip prieÅ¡ tai, pridÄ—k dar 4 eilutes teksto, kad turÄ—tum bent 12.
:::

PerÅ¾iÅ«rÄ—k pirmas 10 eiluÄiÅ³ **song_text.txt** su `head`:

```bash
head song_text.txt
```

PerÅ¾iÅ«rÄ—k paskutines 10 failo eiluÄiÅ³:

```bash
tail song_text.txt
```

Tiek `head`, tiek `tail` priima nustatymÄ… (**option**) `-n` su argumentu, nurodanÄiu, kiek eiluÄiÅ³ atspausdinti:

* Norint perÅ¾iÅ«rÄ—ti pirmas 3 eilutes, naudok komandÄ…: `head -n 3 song_text.txt`
* Norint perÅ¾iÅ«rÄ—ti paskutines 5 eilutes, naudok komandÄ…: `tail -n 5 song_text.txt`.

::: {.callout-tip title="Praktika"}
Kas nutiktÅ³, jei panaudotum `head` arba `tail` su failu, kuriame nÄ—ra 10 eiluÄiÅ³? Pabandyk su **favorite_song.txt**
:::

::: {.callout-tip title="Praktika"}

Dabar dirbsi su failu **data/temp_vilnius.txt**.

* Naudojant `cat`, atspausdink visÄ… failÄ… terminale
* Pirmosios dienos prognozÄ—s gali turÄ—ti maÅ¾iau nei 24 valandas (pvz., likusios 6 valandos). Naudojant `head`, atspausdink tik Å¡iandienos orÅ³ prognozes
* Kadangi Å¡iandienos oras jau aiÅ¡kus, tavo draugei Amelijai reikia rytojaus orÅ³ prognozÄ—s. Derinant `head` ir `tail`, iÅ¡filtruok eilutes taip ir sukurk tarpinius failus, kad bÅ«tÅ³ nusiÅ³stos tik rytojaus 24 valandÅ³ temperatÅ«ros prognozÄ—s. RezultatÄ… iÅ¡saugok Ä¯ failÄ… **amelija_temp_vilnius.txt** subdirektorijoje **data**. Naudojant `cat` Ä¯sitikink, jog turi tik rytojaus temperatÅ«ras.
:::


### less

PraÄ—jusiame skyriuje jau turÄ—jai atvejÄ¯, kai viso failo **temp_vilnius.txt** turinys netilpo Ä¯ terminalo langÄ…. TikÄ—tina, reikÄ—jo pakeisti terminalo lango dydÄ¯ arba slinkti su pele. Dabar tau galbÅ«t kyla klausimas, kaip bÅ«tÅ³ galima matyti failo turinÄ¯ gabaliukais?

Nors gali naudoti `cat` dideliems failams atspausdinti ir tada slinkti iÅ¡vestÄ¯, paprastai patogiau failÄ… rodyti puslapiais. Tam pirminÄ— komanda buvo `more`, bet jÄ… pakeitÄ— galingesnÄ— komanda `less`.

Naudojant `less <failas>`, vienu metu matysi tik vienÄ… failo puslapÄ¯. SpaudÅ¾iant â£ (space) klaviÅ¡Ä…, pereisi Ä¯ kitÄ… puslapÄ¯; gali taip pat naudoti â†“ ir â†‘ klaviÅ¡us, kad judÄ—tum po vienÄ… eilutÄ™ Å¾emyn arba aukÅ¡tyn. Norint iÅ¡eiti, spausk `q`.

::: {.callout-tip title="Praktika"}
Atsidaryk **data/temp_vilnius.txt** su less, iÅ¡bandyk judÄ—jimÄ… tekste Å¾emyn, aukÅ¡tyn ir uÅ¾daryk programÄ… su `q`.
:::

Jei `less` komandai nurodysi kelis failus, gali naudoti `:n` (**next**) pereiti prie kito failo, o `:p` (**previous**) sugrÄ¯Å¾ti prie ankstesnio failo. Norint iÅ¡eiti, spausk `q`.

::: {.callout-tip title="Praktika"}
Atsidaryk failus **favorite_song.txt**, **data/temp_vilnius.txt** ir **text/seneles_pasaka.txt** su less. IÅ¡bandyk judÄ—jimÄ… tekste Å¾emyn, aukÅ¡tyn, pereik tarp failÅ³ naudojant `:n` ir `:p` bei pabaigoje uÅ¾daryk `less` su `q`
:::


### wc

Komanda `wc` (angl. **word count**) naudojama atspausdinti naujÅ³ eiluÄiÅ³, Å¾odÅ¾iÅ³ ir baitÅ³ skaiÄiÅ³ faile.

| Nustatymas | ReikÅ¡mÄ—                                                                         |
|------------|----------------------------------------------------------------------------------|
| `-c`       | 	Atspausdina baitÅ³ skaiÄiÅ³ (angl. byte count), kiek vietos uÅ¾ima failas                                   |
| `-m`       | Atspausdina simboliÅ³ skaiÄiÅ³ (angl. character count)                               |
| `-w`       | 	Atspausdina Å¾odÅ¾iÅ³ skaiÄiÅ³ (angl. word count)                                 |
| `-l`       | Atspausdina eiluÄiÅ³ skaiÄiÅ³ (angl. line count)                                     |

Pastaba: `-c` ir `-m` gali atspausdinti skirtingus rezultatus priklausomai nuo failo koduotÄ—s, nes simbolis gali uÅ¾imti daugiau nei vienÄ… baitÄ… (pvz., specialÅ«s lietuviÅ¡ki simboliai).

::: {.callout-tip title="Praktika"}
* Kiek Å¾odÅ¾iÅ³ ir kiek eiluÄiÅ³ yra **text/seneles_pasaka.txt**?
* Kiek eiluÄiÅ³ yra **data/temp_vilnius.txt** ir kiek **data/temp_kaunas.txt**?
:::


### touch

Komanda `touch` naudojama kuriant tuÅ¡ÄiÄ… failÄ… arba keiÄiant esamo failo metaduomenis, pvz., modifikavimo ar prieigos laikÄ…. Ji yra universali ir ypaÄ naudinga tais atvejais, kai reikia greitai sukurti failÄ… arba atnaujinti failo laikus be jo turinio keitimo.

Jei failas neegzistuoja, `touch` jÄ¯ sukurs. Jei failas jau yra, komanda tiesiog pakeis failo "paskutinio keitimo laikÄ…" (**modification time**) Ä¯ dabartinÄ¯ laikÄ…, nesikeiÄiant turinio.

Sukurk tuÅ¡ÄiÄ… failÄ…:

```BASH
touch empty_1.txt
```

![](../img/shell_adv/touch_single.png)

Jei nurodysi kelis failÅ³ pavadinimus, touch sukurs visus iÅ¡ karto:

```BASH
touch empty_2.txt empty_3.txt empty_4.txt
```

![](../img/shell_adv/touch_multiple.png)


Jeigu failo pavadinimas yra nurodytas su absoliuÄiu ar reliatyviu keliu, failas bus sukurtas atitinkamoje direktorijoje, jei tokia direktorija egzistuoja. Jei direktorija neegzistuoja, bus praneÅ¡ta apie klaidÄ…, ir failas nebus sukurtas.

```bash
touch mix/empty_5.txt
touch tralala/empty_6.txt
```
![](../img/shell_adv/touch_error.png)


`touch` taip pat leidÅ¾ia atnaujinti failo prieigos arba modifikavimo laikÄ…. Å tai keli pavyzdÅ¾iai:

* Atnaujinti tiek prieigos, tiek modifikavimo laikus Ä¯ dabartinÄ¯ laikÄ…:

```BASH
touch empty_1.txt
```
* Atnaujinti tik prieigos laikÄ…:

```BASH
touch -a empty_1.txt
```
* Atnaujinti tik modifikavimo laikÄ…:

```BASH
touch -m empty_1.txt
```
* Nustatyti tiek prieigos, tiek modifikavimo laikus Ä¯ konkreÄiÄ… datÄ…, pvz., 2022 m. sausio 1 d., 12:00 val.: 

```BASH
touch -t 202201011200 empty_1.txt
```

* Naudoti `-d` parinktÄ¯, norint lankstesnio laiko nustatymo:

```BASH
touch -d "2023-07-04 15:45" empty_1.txt
```

Dabar gali kilti klausimas - kam tai naudinga? IÅ¡ tiesÅ³, failÅ³ laikÅ³ keitimas gali atrodyti niÅ¡inis, taÄiau tai naudinga tam tikrais atvejais:

* Jei nori iÅ¡bandyti skriptÄ…, kuris rÅ«Å¡iuoja ar archyvuoja failus pagal jÅ³ prieigos ar modifikavimo laikÄ…, gali generuoti tuÅ¡Äius failus su netikrais laikais ir patikrinti, ar skriptas veikia teisingai.
* Jei atstatai failus iÅ¡ atsarginÄ—s kopijos, gali norÄ—ti atkurti ir jÅ³ originalius prieigos bei modifikavimo laikus, kad iÅ¡saugotum failÅ³ istorijÄ… tiksliai tokia, kokia buvo prieÅ¡ atsargines kopijas.


### mkdir

Komanda `mkdir` (angl. **make directory**) naudojama naujÅ³ direktorijÅ³ kÅ«rimui.

NaujÄ… direktorijÄ… gali sukurti taip:

```BASH
mkdir projektas1
```

Kaip ir su komanda `touch`, gali sukurti kelias direktorijas vienu metu, nurodant pavadinimus arba kelius Ä¯ jas:

```BASH
mkdir projektas2 mix/projektas3
```

![](../img/shell_adv/mkdir.png)

Kartais reikia sukurti direktorijÅ³ medÄ¯ (hierarchijÄ…). Jei tarpinÄ—s direktorijos dar neegzistuoja, gali naudoti `-p` argumentÄ…, kuris automatiÅ¡kai sukurs ir tarpines direktorijas. PavyzdÅ¾iui:

```BASH
mkdir -p projektas0/duomenys
```

![](../img/shell_adv/mkdir_p.png)

::: {.callout-tip title="Praktika"}
Netrukus norÄ—sime sukurti tam tikrÅ³ failÅ³ atsargines kopijas. Kaip pasiruoÅ¡imÄ…, uÅ¾tikrink, kad shell_part_2 direktorijoje bÅ«tÅ³:

* backup/data
* backup/text

Sukurk jas naudojant `-p`, nurodant abi direktorijas kaip du argumentus vienoje komandoje (vienoje eilutÄ—je). 
:::

### cp

PripaÅ¾ink, kopijuoti failÄ… su `cat failas.txt > kopija.txt` nÄ—ra labai intuityvu. O kÄ… daryti, jei nori nukopijuoti ne tik failÄ…, bet ir visÄ… direktorijÄ…?

Komanda `cp` (angl. **copy**) naudojama failams ir direktorijoms kopijuoti.

PaprasÄiausiu atveju, kai nori sukurti failo kopijÄ…, komandai `cp` nurodai originalaus failo pavadinimÄ… ir kokiu pavadinimu turÄ—tÅ³ bÅ«ti sukurta kopija. 

```bash
cp song_text.txt song_text_copy.txt
```

Jei failas **song_text_copy.txt** jau egzistuotÅ³, jis bÅ«tÅ³ perraÅ¡ytas. Taigi `cp` veikia panaÅ¡iai kaip `>`.

Kaip ir su visomis BASH komandomis, gali naudoti tiek reliatyvius, tiek absoliuÄius kelius (angl. path). PavyzdÅ¾iui, kopijÄ… gali perkelti Ä¯ kitÄ… direktorijÄ…:

```bash
cp ./song_text.txt ./mix/song_text_copy.txt
```
![](../img/shell_adv/cp_dir.png)

Jeigu kaip antrÄ…jÄ¯ argumentÄ… nurodysi egzistuojanÄios direktorijos pavadinimÄ…, `cp` sukurs kopijÄ… tokiu paÄiu pavadinimu kaip originalas ir patalpins jÄ… Ä¯ nurodytÄ… direktorijÄ…. Å Ä¯kart praleidÅ¾iam 

```bash
cp song_text.txt mix
```

![](../img/shell_adv/cp_dir2.png)


`cp` gali kopijuoti ir direktorijas, taÄiau tam, kad visa direktorija bÅ«tÅ³ nukopijuota rekursyviai (su visu turiniu), reikia naudoti nustatymÄ… `-r` (**recursive**). Jeigu pamirÅ¡i `-r` direktorija nebus nukopijuota!

```bash
cp -r mix mix_copy
```

![](../img/shell_adv/cp_dir3.png)



Kada naudoti `cp -a`?

Nustatymas `-a` (arba **archive**) naudojamas, kai reikia nukopijuoti failus ir direktorijas kartu su jÅ³ metaduomenimis (pvz., failo leidimais, nuosavybe, laikais). Tai naudinga, kai nori iÅ¡saugoti visas originalaus failo ar katalogo savybes. `-a` iÅ¡ esmÄ—s yra kombinuotas `cp -r` (rekursija) ir kitÅ³ nustatymÅ³ rinkinys, kuris uÅ¾tikrina, kad iÅ¡saugomi visi atributai.

```bash
cp -a mix mix_copy_2
```

Dabar palyging metaduominis su `ls -l`. 

![](../img/shell_adv/cp_dir4.png)


::: {.callout-tip title="Praktika"}
* Padaryk **temp_vilnius.txt** kopijÄ… pavadinimu **temp_vilnius.txt**, bet kaip argumentÄ… nurodyk direktorijÄ… **ir** failo pavadinimÄ…. Patalpink kopijÄ… Ä¯ **backup/data**.
* Padaryk **temp_kaunas.txt** ir **temp_klaipeda.txt** kopijÄ… vienoje komandoje su originaliu pavadinimu, kaip **treÄiÄ…** argumentÄ… `cp` paduodant tik **backup/data** direktorijÄ….
* Padaryk **text** direktorijos kopijÄ… su visu jos turinu Ä¯ **backup** direktorijÄ…. IÅ¡saugok visus metaduomenis. 
* **Teorinis klausimas**: kas nutiktÅ³ jeigu panaudotum `cp -r text backup/text`?
* Ar darant **temp_** failÅ³ atsargines kopijas iÅ¡saugojai metaduomenis? jeigu ne, pakartok komandas tik su teisingu nustatymu ir Ä¯sitikink, ar iÅ¡ tiesÅ³ metaduomenys tokie pat!
:::


### mv

Komanda `mv` (angl. **move**) naudojama perkelti arba pervadinti failus ir direktorijas. Tai universali komanda, skirta tiek failÅ³ ir katalogÅ³ vietos keitimui, tiek jÅ³ pavadinimÅ³ modifikavimui.


Pvz., naudojant `mv`, gali pervadinti failÄ… **temp_vilnius.txt** Ä¯ **temp_alytus.txt**:


```BASH
mv data/temp_vilnius.txt data/temp_alytus.txt
```

![](../img/shell_adv/mv_single.png)


Taip pat su `mv` gali perkelti failus iÅ¡ vienos direktorijos Ä¯ kitÄ…. Å i komanda perkelia failÄ… **temp_kaunas.txt** Ä¯ **mix**:

```BASH
mv data/temp_kaunas.txt mix
```

![](../img/shell_adv/mv_file_dir.png)

`mv` komandai galima paduoti daugiau nei du argumentus. PavyzdÅ¾iui, Å¡i komanda perkelia failus **temp_alytus.txt** ir **seneles_pasaka.txt** Ä¯ direktorijÄ… **mix**. ÄŒia svarbu, kad paskutinis argumentas bÅ«tÅ³ egzistuojanti direktorija:

```BASH
mv data/temp_alytus.txt text/seneles_pasaka.txt mix
```
 
`mv` taip pat gali bÅ«ti naudojama perkelti direktorijÄ… ir visÄ… jos turinÄ¯. PavyzdÅ¾iui, Å¡i komanda perkelia direktorijÄ… **mix_copy** Ä¯ **mix**:

```BASH
mv mix_copy mix
```

**Pastaba**: dirbant su direktorijomis:

* jeigu `mv origin target` jeigu target neegzistuoja, tada mv **pervadins** direktorijÄ… origin Ä¯ target
* jeigu `mv origin target` jeigu target egzistuoja, tada mv **perkels** origin Ä¯ target direktorijÄ…

**Svarbu**: kaip ir naudojant `>` ar `cp`, jeigu tikslinis **failas** jau egzistuoja, jis bus perraÅ¡ytas, nebent pridÄ—si `-i` (interaktyvÅ³ reÅ¾imÄ…), kad bÅ«tÅ³ papraÅ¡yta patvirtinimo prieÅ¡ perraÅ¡ant.


::: {.callout-tip title="Praktika"}
* **Teorinis klausimas**: Kas nutiktÅ³, jei Ä¯vykdytum Å¡iÄ… komandÄ…?

```BASH
mv temp_vilnius.txt temp_kaunas.txt ~/Documents ~/Downloads
```

* Perkelk Alytaus ir Kauno temperatÅ«rÅ³ failus atgal iÅ¡ **mix** Ä¯ **data** naudojant `mv`. Pervadink Alytaus failÄ… atgal Ä¯ Vilniaus
* Atsidaryk Nemo ir rankiniu bÅ«du iÅ¡trink data direktorijÄ…. Dabar su terminal, padaryk backup/data kopijÄ… (su `cp` ir reikalaingais nustatymais), jog vÄ—l atsirastÅ³ **/shell_part_2/data**.
:::


### rm

Tavo **shell_part_2** direktorijoje dabar tikrai daug failÅ³ ir subdirektorijÅ³, kuriÅ³ nebereikia. Laikas Ä¯vesti Å¡iek tiek tvarkos!

Komanda `rm` (angl. **remove**) naudojama paÅ¡alinti failus ir direktorijas. Tai galinga komanda, todÄ—l ja reikia naudotis atsargiai, nes paÅ¡alinti failai ar direktorijos nÄ—ra perkeliami Ä¯ Å¡iukÅ¡liadÄ—Å¾Ä™ ir jÅ³ atkurti nebebus galima.

Norint paÅ¡alinti failÄ…, `rm` komandai paduodamas argumentas - failo pavadinimas arba absoliutus, arba reliatyvus kelias Ä¯ failÄ….

```BASH
rm day.txt
rm mix/empty_5.txt
```


Komandai `rm` galima paduoti ir kelis failus vienu metu:

```BASH
rm empty_1.txt empty_2.txt 
```


TuÅ¡ÄiÄ… direktorijÄ… (kai joje nÄ—ra jokiÅ³ kitÅ³ failÅ³ ar subdirektorijÅ³) galima paÅ¡alinti arba naudojant `rmdir` (kuri yra `mkdir` prieÅ¡ingybÄ—), arba su `rm`, nurodant nustatymÄ… `-d`.

```BASH
rm -d projektas1
rmdir projektas2
```

![](../img/shell_adv/rmdir.png)

Tiesiog paÅ¡alinti direktorijÄ…, kurioje yra kaÅ¾kas, su `rm` arba `rm -d` nepavyks, nes BASH bando apsaugoti vartotojÄ… nuo rizikos netyÄia iÅ¡trinti daugiau failÅ³ nei reikia.

![](../img/shell_adv/rmdir_error.png)

Jei reikia iÅ¡trinti visÄ… direktorijÄ… su visu jos turiniu, naudojamas parametras `-r` (**recursive**).

```BASH
rm -r projektas0
```

Kartais gali nutikti, jog `rm -r` negalÄ—s iÅ¡trinti direktorijos dÄ—l failÅ³ teisiÅ³ ar kitÅ³ kliÅ«ÄiÅ³. Tokiu atveju pridedamas nustatymas `-f` (**force**), kuris priverstinai iÅ¡trina failus.

```BASH
rm -rf mix_copy_2
```

**intarpas: Wildcard'Å³ naudojimas ***

Kartais BASH komandose norisi paÅ¾ymÄ—ti arba pasirinkti daugiau nei vienÄ… failÄ…. Kaip jau matei, tiek `cat`, tiek `cp`, `mv`, `rm`, `less` komandos kuo puikiausiai dirba su keliais failais. Tad kyla klausimas, kaip tai padaryti efektyviau naudojant wildcard simbolius.

Pvz., tu galÄ—tum raÅ¡yti:

```bash
rm empty_1.txt empty_2.txt
```
TaÄiau yra akivaizdu, jog Å¡iuose failÅ³ pavadinimuose yra tam tikras dÄ—sningumas - jie prasideda **empty_** ir baigiasi **.txt**.

BASH, kaip ir daugelyje kitÅ³ programavimo kalbÅ³, yra vadinamieji wildcard - simboliai, kurie leidÅ¾ia uÅ¾pildyti vienÄ… ar daugiau Å¾enklÅ³.

PavyzdÅ¾iui, `*` simbolis pakeiÄia bet kokÄ¯ skaiÄiÅ³ Å¾enklÅ³. Taigi, galima bÅ«tÅ³ paraÅ¡yti:

```bash
rm empty_*.txt
```

Wildcard'Å³ simboliai:

* `*` reiÅ¡kia jokio, vienÄ… arba daugiau simboliÅ³.
* `?` reiÅ¡kia tiksliai vienÄ… simbolÄ¯, pvz., 201?.txt galÄ—tÅ³ atitikti 2017.txt, 2018.txt, bet ne 2017-01.txt.
* `[...]` reiÅ¡kia vienÄ… iÅ¡ pateiktÅ³ simboliÅ³, pvz., 201[78].txt atitiks 2017.txt arba 2018.txt, bet ne 2016.txt.
* `{}` reiÅ¡kia vienÄ… iÅ¡ nurodytÅ³ reikÅ¡miÅ³, pvz., rm {*.txt,*.csv} atitiks visus failus, kuriÅ³ pavadinimas baigiasi .txt arba .csv, bet ne .pdf.

::: {.callout-tip title="Praktika"}
TeorinÄ— uÅ¾duotis - pasakyk, kas nutiktÅ³ visais Å¡iais atvejais:

* `rm song*.txt`
* `rm *song*.txt`
* `rm *.txt`
* `rm *.*`
* `rm ./*`
* `rm *`
* `rm data/*`
* `rm text/*.txt`
* Pasitikrink atsakymÄ… naudojant ChatGPT!


PraktinÄ— uÅ¾duotis - naudojantis wildcard iÅ¡trink iÅ¡ **shell_part_2** visus failus:

* kuriÅ³ pavadinime yra Å¾odis *song*, neproklausomai nuo pozicijos ir failo tipo
* kuriÅ³ failo tipas yra .txt
* visus failus esanÄius **mix** subdirektorijoje. Tam gali prireikti papildomo nustatymo `rm` komandai, nes **mix** gali bÅ«ti direktorijos!
* subdirektorijas **data** ir **text**. O tada naudodojant `cp` ir bÅ«tinai reikiamÄ… nustatymÄ… metaduomenÅ³ iÅ¡laikymui, atkurti iÅ¡ **backup**

:::

Atlikus visus valymus turÄ—tum turÄ—ti:

![](../img/shell_adv/cleaned_up.png)


### grep

Kartais tau gali prireikti nuskaityti tik tam tikras failo eilutes, kuriose yra konkretus tekstas. Komanda `grep` (angl. **global regular expression print**, liet. â€globalus reguliariÅ³jÅ³ iÅ¡raiÅ¡kÅ³ paieÅ¡kos spausdinimasâ€œ) naudojama teksto paieÅ¡kai pagal Å¡ablonÄ… failuose arba iÅ¡vestyje.

PavyzdÅ¾iui, Å¡i komanda surastÅ³ visas eilutes **data/seneles_pasaka**, kuriose yra Å¾odis â€Apieâ€œ:

```bash
grep Apie text/seneles_pasaka.text
```
![](../img/shell_adv/grep_apie.png)

Suprantama, gali pateikti kelis failus vienu metu. Å iuo atveju komanda `grep` suras visas eilutes, kuriose yra **14:00:00** abiejuose jai pateiktuose failuose ir atitinkamas eilutes atspausdins tau Ä¯ terminalÄ….

```bash
grep 14:00:00 data/temp_vilnius.txt data/temp_kaunas.txt 
```

![](../img/shell_adv/grep_multiple.png)


`grep` priima ir tam tikrus nustatymus, kurie padeda atlikti paieÅ¡kÄ… efektyviau:

* `-c`: atspausdina, kiek eiluÄiÅ³ atitinka tavo pateiktÄ… kriterijÅ³.
* `-h`: neatspausdina failÅ³ pavadinimÅ³, kuriuose rasti atitikimai, kai pateiki keli failai.
* `-i`: ignoruoja didÅ¾iÄ…sias ir maÅ¾Ä…sias raides (pvz., Ä¯raÅ¡ius -i apie, ras ir â€Apieâ€œ, â€apieâ€œ, â€APIEâ€œ ir t.t.).
* `-l`: atspausdina tik failÅ³ pavadinimus, kuriuose rasti atitikimai.
* `-n`: atspausdina eiluÄiÅ³ numerius Å¡alia paÄios eilutÄ—s.
* `-v`: ieÅ¡ko eiluÄiÅ³, kuriose nÄ—ra raktinio paieÅ¡kos kriterijaus.

::: {.callout-tip title="Praktika"}
Dirbk su **data/seneles_pasaka.txt**

* Kurios eilutÄ—s turi paminÄ—tÄ… Å¾odÄ¯ â€pasakaâ€œ (tik su maÅ¾Ä…ja raide)?
* Kurios eilutÄ—s turi paminÄ—tÄ… Å¾odÄ¯ â€pasakaâ€œ (nesvarbu, ar raÅ¡yta didÅ¾iosiomis, ar maÅ¾osiomis raidÄ—mis)?
* Kiek eiluÄiÅ³ (ieÅ¡kome skaiÄiaus) turi paminÄ—tÄ… Å¾odÄ¯ â€apieâ€œ, nepriklausomai nuo raÅ¡ybos?
* Kiek eiluÄiÅ³ (ieÅ¡kome skaiÄiaus) nepamini Å¾odÅ¾io â€apieâ€œ, nepriklausomai nuo raÅ¡ybos? 
:::


**Pastaba**: komanda `grep` ieÅ¡ko tekstinÄ—s atitikties failuose, todÄ—l ji nepriima loginiÅ³ operatoriÅ³ kaip >, =, ar <. Visgi, `grep` leidÅ¾ia naudoti reguliarias iÅ¡raiÅ¡kas (regular expressions), kurios leidÅ¾ia dar smulkiau atrinkti tekstÄ….

Å tai kaip bÅ«tÅ³ galima panaudoti `grep` su reguliariomis iÅ¡raiÅ¡komis, norint surasti visas eilutes, kuriose yra vienas skaitmuo prieÅ¡ taÅ¡kÄ…, visuose **temp_** failuose:

```bash
grep -P '\t[0-9]\.[0-9]' data/temp_*.txt
```

![](../img/shell_adv/grep_regex.png)


Ä® reguliarias iÅ¡raiÅ¡kas dabar neverta gilintis iÅ¡samiau, bet svarbu Å¾inoti, kad jos egzistuoja ir gali bÅ«ti labai naudingos dirbant su tekstiniais duomenimis. Jeigu kiltÅ³ noras pasibandyti, siÅ«lau naudti [https://regexr.com/](https://regexr.com/).

### cut

Kartais tau gali prireikti iÅ¡filtruoti ne eilutes, o stulpelius. Pvz., komanda `head` **data/temp_vilnius.txt** parodo tarsi 3 stulpelius: datÄ…, laikÄ… ir temperatÅ«rÄ…. Pastebima, kad tarp datos ir laiko yra maÅ¾as tarpas (greiÄiausiai â€spaceâ€œ), o tarp laiko ir temperatÅ«ros - didelis tarpas (tikÄ—tina, "tab"). Tai Å¡iek tiek apsunkina darbÄ…, kol nesusipaÅ¾inai su `sed` komanda, bet tai nereiÅ¡kia, jog negalime iÅ¡skaidyti failo Ä¯ stulpelius pagal skirtingus skirtukus, pvz., â€spaceâ€œ ir â€tabâ€œ.

![](../img/shell_adv/cut_head.png)


Komandai `cut` reikia tam tikrÅ³ nustatymÅ³. Pagrindiniai nustatymai:

* `-d` (**delimiter**) - skirtukas, kuris skiria stulpelius. Pagal nutylÄ—jimÄ… skirtukas yra tabuliacija (tab), tad Å¡io nustatymo keisti nereikia. Jeigu norÄ—tum naudoti kitÄ… skirtukÄ…, pvz., tarpo Å¾enklÄ…, turÄ—tum naudoti `-d " "`. Jeigu skirtukas bÅ«tÅ³ kablelis, naudotum `-d ","` ir t.t.
* `-f` (**fields**) - nurodo, kuriuos stulpelius (laukelius) nori pasirinkti. Pvz., `-f 2` pasirinktÅ³ antrÄ… stulpelÄ¯, `-f 2-5` pasirinktÅ³ nuo antro iki penkto stulpelio, o `-f 2-5,8` pasirinktÅ³ antrÄ…, treÄiÄ…, ketvirtÄ…, penktÄ… ir aÅ¡tuntÄ… stulpelius.


Å i komanda priima â€spaceâ€œ kaip skirtukÄ… ir atspausdina pirmÄ…jÄ¯ stulpelÄ¯:

```bash
cut -d " " -f 1 data/temp_vilnius.txt
```

![](../img/shell_adv/cut_column1.png)

Å i komanda priima â€tabâ€œ kaip skirtukÄ… ir atspausdina antrÄ…jÄ¯ stulpelÄ¯:

```bash
cut -f 2  data/temp_vilnius.txt
```

![](../img/shell_adv/cut_column_last.png)


Jeigu norÄ—tum gauti tik metus, galÄ—tum nurodyti skirtukÄ… â€-â€œ ir pasirinkti pirmÄ…jÄ¯ stulpelÄ¯:

```bash
cut -d "-" -f 1 data/temp_vilnius.txt 
```

![](../img/shell_adv/cut_year.png)


::: {.callout-tip title="Praktika"}

Programuojant ir dirbant su duomenimis, svarbu iÅ¡mokti iÅ¡naudoti AI galimybes. Å ioje praktikoje tu turi nueiti Ä¯ ChatGPT ir paraÅ¡yti kaÅ¾kÄ… panaÅ¡aus:

>Sugeneruok 25 eiluÄiÅ³ .csv failÄ…, kurio skirtukas bÅ«tÅ³ "," su Å¡iais stulpeliais:
>
>* user_id,
>* age (18-99)
>* country_code (LT, LV, EE)
>* orders (0-250)


ChatGPT sugeneruos .csv failÄ… ir leis jÄ¯ atsisiÅ³sti. Å iam sugeneravimui ChatGPT pasinaudos Python programavimo kalba. Tu galÄ—tum iÅ¡saugoti grÄ…Å¾intÄ… kodÄ… ir naudoti jÄ¯ ateityje, nes tavo kompiuteryje Å¡is kodas taip pat veiktÅ³. Bet prie Python mes dar grÄ¯Å¡ime vÄ—liau.

Perkelk failÄ… iÅ¡ **~/Downloads** Ä¯ **~/shell_part_2/data**. Tarkime, failas vadinasi sample_data.csv.

![](../img/shell_adv/gpt_generator.mp4)

Turint failÄ…:

1. Pervadink failÄ… Ä¯ **balt_customers.csv**.
2. Naudojant Å¾inomomis komandomis tyrinÄ—k failÄ… **data/balt_customers.csv**:
    * Kiek jame eiluÄiÅ³?
    * Koks skirtukas naudojamas?
    * Kokie duomenys yra pirmoje eilutÄ—je (antraÅ¡tÄ— ar duomenys)?
    * Kiek ir kurios eilutÄ—s yra duomenys?

**UÅ¾duotis**: Tu dirbi su klientais iÅ¡ Estijos (EE). Turi paraÅ¡yti visiems klientams iÅ¡ Estijos el. laiÅ¡kÄ… ir praneÅ¡ti apie jÅ³ uÅ¾sakymÅ³ skaiÄiÅ³. LaiÅ¡ko raÅ¡ymÄ… perims programa, taÄiau tu jai turi pateikti failÄ… **customers_ee.csv**, kuris turÄ—tÅ³ atrodyti taip (tavo duomenys gali skirtis dÄ—l atsitiktinio jÅ³ sugeneravimo):

![](../img/shell_adv/cut_project.png)

Kad Ä¯gyvendintum Å¡iÄ… uÅ¾duotÄ¯, tau prireiks komandÅ³: `head`, `cut`, `>` `>>`, `cat` ir `grep` bei sukurti kelis tarpinius failus, kuriuos vÄ—liau galÄ—si iÅ¡trinti. Taip pat patarÄiau bandyt skaidyti darbus :) 

SÄ—kmÄ—s!

:::



### Intarpas: StandartinÄ— Ä¯vestis, iÅ¡vestis ir klaidos

Iki Å¡iol mes naudojome sÄ…vokas, tokias kaip Ä¯vestis (**input**) ir iÅ¡vestis (**output**). Ä®vestis buvo tai, kÄ… tu Ä¯vedi klaviatÅ«ra Ä¯ terminalÄ…, o iÅ¡vestis - tai, kÄ… BASH atspausdina terminale arba kÄ… tu nukreipi Ä¯ failÄ… naudodant `>` arba `>>`. TaÄiau iki Å¡iol formaliai neaptarÄ—me BASH srautÅ³.

Linux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenÅ³ Ä¯vestÄ¯ ir iÅ¡vestÄ¯ programose bei komandose. Å ie srautai vadinami standartine Ä¯vestimi (**standard input**), standartine iÅ¡vestimi (**standard output**) ir standartine klaida (**standard error**). Kiekvienas srautas turi specifinÄ™ paskirtÄ¯ ir failo apraÅ¡ymo numerÄ¯.

Svarbu: Linux'e viskas yra failai, net srautai (input/output) traktuojami kaip failai.

#### StandartinÄ— Ä¯vestis (stdin)

StandartinÄ— Ä¯vestis, sutrumpinta kaip **stdin**, yra srautas, iÅ¡ kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, **stdin** yra prijungta prie klaviatÅ«ros, taÄiau gali bÅ«ti nukreipta iÅ¡ failo ar kito srauto.

Pabandyk Ä¯raÅ¡yti `cat`, paspausti Enter, ir tada Ä¯vesk kelis Å¾odÅ¾ius, vis paspausdÅ¾iant Enter. Terminale matysi tekstÄ…, kurÄ¯ Ä¯vedi, nes jis bus perduotas kaip Ä¯vestis `cat` komandai, kuri atspausdins Å¡Ä¯ tekstÄ…. TodÄ—l matysi dvigubai tai, kÄ… Ä¯vedei.

```bash
cat
```

Nutraukti `cat` Ä¯vestÄ¯ gali su `Ctrl-D` arba `Ctrl-C`.

![](../img/shell_adv/std_input_cat.mp4)



Ä®vestis taip pat gali bÅ«ti perduodama iÅ¡ failo Ä¯ komandÄ…. PavyzdÅ¾iui, komandai `cat` galime nurodyti failÄ… taip:

```bash
cat < data/customers_ee.csv
```

KodÄ—l veikia <?

Simbolis `<` nurodo komandai, kad vietoje Ä¯prastos Ä¯vesties iÅ¡ klaviatÅ«ros naudotÅ³ failÄ… kaip Ä¯vesties Å¡altinÄ¯. Pvz., `cat < data/customers_ee.csv` reiÅ¡kia, kad `cat` komanda skaitys duomenis iÅ¡ failo data/customers_ee.csv, o ne iÅ¡ klaviatÅ«ros.

![](../img/shell_adv/std_input_file.png)


StandartinÄ—s Ä¯vesties apraÅ¡ymo numeris: 0. VÄ—liau pamatysi, kam tie skaiÄiai naudingi.

#### StandartinÄ— iÅ¡vestis (stdout)

StandartinÄ— iÅ¡vestis, sutrumpinta kaip **stdout**, yra srautas, Ä¯ kurÄ¯ komanda ar programa raÅ¡o iÅ¡vestÄ¯. Dirbant terminale, **stdout** prijungta prie terminalo ekrano. PavyzdÅ¾iui, Ä¯raÅ¡ius Å¡iÄ… komandÄ…, terminale atspausdinamas â€Hello Worldâ€œ:

```bash
echo "Hello World"
```

Galima nukreipti standartinÄ™ iÅ¡vestÄ¯ ne Ä¯ terminalo langÄ…, bet Ä¯ failÄ…, kaip jau esame darÄ™ anksÄiau:

```bash
echo "Hello World!" > hello_world.txt
```
StandartinÄ— iÅ¡vestis turi numerÄ¯ 1. Tai reiÅ¡kia

```bash
echo "Hello World!" 1> hello_world.txt
```

jog **stdout** srautas (`1`), kurÄ¯ generuoja `echo` komanda, siunÄiamas Ä¯ failÄ… hello_world.txt. Mes panaudojom srauto numerÄ¯, kad pasakyti kurÄ¯ srautÄ… siÅ³sti Ä¯ failÄ….

#### StandartinÄ— klaida (stderr)

Kai komanda negali atlikti tam tikro veiksmo, ji sugeneruoja klaidos praneÅ¡imÄ…, kuris siunÄiamas Ä¯ standartinÄ¯ klaidos srautÄ… (**stderr**). StandartinÄ—s klaidos srautas turi numerÄ¯ 2, ir jÄ¯ taip pat galima nukreipti Ä¯ failÄ….

Pabandyk komandÄ… `ls` su neegzistuojanÄia direktorija, pvz.,:

```bash
ls abc
```

![](../img/shell_adv/stderr_ls.png)

Klaidos praneÅ¡imas bus iÅ¡spausdintas terminale. TaÄiau galime nukreipti tik klaidos srautÄ… Ä¯ failÄ…:

```bash
ls abc 2> error.log
```

Terminale klaidos nebus matyti, bet gali naudoti komandas `head` arba `cat`, kad paÅ¾iÅ«rÄ—tum, kas yra **error.log** faile.

![](../img/shell_adv/stderr_ls_log.png)




### Kaip visÄ… tai taikyti praktikoje?

Ä®sivaizduok, kad turi komandÄ… `ls`, kuri kartais sugeneruoja iÅ¡vestÄ¯, kuriÄ… nori nukreipti Ä¯ list.txt, o klaidas - Ä¯ error.log. Tam galÄ—tum naudoti:

```bash
ls <direktorija1> <direktorija2> <direktorija3> 1>>list.txt 2>>error.log
```

IÅ¡bandyk Å¡iÄ… komandÄ… su egzistuojanÄia ir neegzistuojanÄia direktorija (prieÅ¡ tai su `rm` iÅ¡trink error.log jeigu toks egzistuoja)


```bash
ls -l data abc text 1> list.txt 2> error.log
```

![](../img/shell_adv/stdout_stderr.png)


Kartais gali prireikti, kad abu srautai bÅ«tÅ³ nukreipti Ä¯ tÄ… patÄ¯ failÄ…. Pvz., jeigu kas 10 minuÄiÅ³ matuoji kompiuterio temperatÅ«rÄ…, gali nukreipti tiek stdout, tiek stderr Ä¯ failÄ…:

```bash
komanda 1>temp.log 2>&1
```

Arba gali klaidos srautÄ… nukreipti Ä¯ temp.log, o standartinÄ™ iÅ¡vestÄ¯ - Ä¯ klaidÅ³ srautÄ…:

```bash
komanda 2>temp.log 1>&2
```
Simbolis `&` nurodo, kad mes kalbame apie srautÄ…, o ne apie failo vardÄ…. Kai raÅ¡ai, pvz., `1>&2`, tai reiÅ¡kia, kad standartinÄ™ iÅ¡vestÄ¯ (stdout, 1) nukreipi ne Ä¯ failÄ…, o Ä¯ standartinÄ¯ klaidÅ³ srautÄ… (stderr, 2). Tai leidÅ¾ia abu srautus sujungti ir siÅ³sti Ä¯ tÄ… patÄ¯ tikslÄ…. Jei `&` nebÅ«tÅ³, sistema galvotÅ³, kad â€2â€œ yra failo pavadinimas, o ne kitas srautas. AnalogiÅ¡kai, `2>&1` reiÅ¡kia, kad klaidÅ³ srautas (stderr, 2) nukreipiamas Ä¯ iÅ¡vesties srautÄ… (stdout, 1).


### pipe |

Iki Å¡iol, kai reikÄ—davo vienos komandos iÅ¡vestÄ¯ panaudoti kitoje komandoje, pavyzdÅ¾iui, iÅ¡filtravus Estijos vartotojus su `grep EE data/balt_customers.csv`, turÄ—jai juos iÅ¡saugoti Ä¯ tarpinÄ¯ failÄ… (pvz., **temporal.csv**), o tik tada paduoti rezultatÄ… Ä¯ `cut -d "," -f 1,4 temporal.csv`, kad gautum norimÄ… rezultatÄ…. Tai yra neefektyvus metodas, nes:

* Lieka daug tarpiniÅ³ failÅ³.
* Komandos bÅ«na suskaidytos per kelias eilutes, todÄ—l jas sunku perÅ¾iÅ«rÄ—ti su `history`.

BASH siÅ«lo kelis bÅ«dus, kaip efektyviau panaudoti vienos komandos rezultatus kitose, pavyzdÅ¾iui, su `xargs` arba kitais Ä¯rankiais. TaÄiau daÅ¾niausiai naudojamas metodas yra **pipe** (angl. "vamzdis").

`|` (**pipe**) - tai vertikalus brÅ«kÅ¡nys, kuris sujungia komandas Ä¯ vienÄ… srautÄ…, kur vienos komandos iÅ¡vestis tampa kitos komandos Ä¯vestimi.

![](../img/shell_adv/pipe_input_ouput.png)

Pabandyk sujungti Å¡ias komandas:

* `grep EE data/balt_customers.csv` - iÅ¡filtruoti tik EE vartotojus.
* Panaudoti `|`, kuris pavers pirmosios komandos iÅ¡vestÄ¯ antrosios komandos Ä¯vestimi.
* `cut -d "," -f 1,4` - iÅ¡kirpti pirmÄ… ir ketvirtÄ… stulpelius.
* GalutinÄ¯ rezultatÄ… su `>` nukreipk Ä¯ failÄ… `data/customers_ee_2.csv`.

![](../img/shell_adv/pipe_input_ouput_ee.png)

```bash
grep EE data/balt_customers.csv | cut -d "," -f 1,4 > data/customers_ee_2.csv
```

Pirma pabandyk paleisti komandÄ… be `>`, kad pamatytum rezultatÄ… terminale:

![](../img/shell_adv/pipe_ee.png)

Dabar paleisk pilnÄ… komandÄ…, nukreipianÄiÄ… iÅ¡vestÄ¯ Ä¯ failÄ…:

![](../img/shell_adv/pipe_ee_2.png)


::: {.callout-tip title="Praktika"}
* Terminale atspausdink pirmas 3 eilutes, kuriose yra Å¾odis â€Apieâ€œ iÅ¡ failo **data/seneles_pasaka.txt**.
* Terminale atspausdingk paskutines 3 eilutes kuriose yra 00:00:00 faile **data/temp_vilnius.txt**
:::



### sort 

Tu darai nuostabiÄ… paÅ¾angÄ… ir jau moki naudoti `grep`, `cut`, `head`, `tail`, su kuriomis gali iÅ¡filtruoti eilutes, stulpelius ir t.t. Naudojant `|`, jau moki sujungti kelias komandas Ä¯ vienÄ…. TaÄiau ko tu dar nemoki - kaip iÅ¡rikiuoti reikÅ¡mes. ÄŒia pravers komanda `sort`.

`sort` labai gerai sÄ…veikauja su pipe `|`.

Pagrindiniai nustatymai:

* `-r` - nuo didÅ¾iausios iki maÅ¾iausios reikÅ¡mÄ—s.
* `-n` - rikiuoti skaiÄius.
* `-h` - rikiuoti pagal dydÄ¯, jei dydis pateiktas *human readable* skaiÄiais (pvz., KB, MB, GB).
* `-t` - nurodo, koks yra skirtukas tarp stulpeliÅ³ (**delimiter**).
* `-k` - pagal kurÄ¯ stulpelÄ¯ rikiuoti.


Sukurk Å¡Ä¯ failÄ…:

```bash
echo -e "A,101\nB,3\nC,2\nD,40" > tosort
```

Ar pastebÄ—jai, **tosort** neturi indikacijos, koks tai failas, nei .csv, nei .txt. Nieko tokio Linux operacinÄ—je sistemoje, komandos veikia kuo puikiausiai ir be failo tipo indikatoriaus.

![](../img/shell_adv/sort_ex_base.png)

Pagal nutylÄ—jimÄ… sort priims failÄ… kaip argumentÄ… ir rikiuos pagal pirmÄ… stulpelÄ¯. sort -r apsuks rikiavimo eigÄ….

```bash
sort tosort
sort -r tosort
```

![](../img/shell_adv/sort_text_r.png)

Jei nori, kad BASH suprastÅ³ failÄ… kaip turintÄ¯ skirtingus stulpelius, turi nurodyti, koks yra skirtukas (**delimiter**) su `-t ","`. Tuomet galima rikiuoti pagal konkretÅ³ stulpelÄ¯ su `-k 2`. Jei nepridÄ—si `-n`, sort rikiuos taip, lyg skaiÄiai bÅ«tÅ³ tekstas, t.y., vertins pagal pirmÄ… skaitmenÄ¯, tada pagal antrÄ… ir t.t. PridÄ—jus `-n`, skaiÄiai vertinami kaip skaiÄiai.

Galima apsieiti ir be kabuÄiÅ³ aplink skirtukÄ…, o `-n` pridÄ—ti prie `-k 2`, kad bÅ«tÅ³ rikiuojama pagal skaiÄius. GalÅ³ gale, tai tavo pasirinkimas.


```bash
sort -t "," -k 2 tosort
sort -t "," -k 2 -n tosort
sort -t, -k2n tosort
```

![](../img/shell_adv/sort_tabuler_numeric.png)


::: {.callout-tip title="Praktika"}

**UÅ¾duotis**: Ä®sivaizduok, kad esi IT administratorÄ— arba administratorius, atsakingas uÅ¾ sistemÅ³ stebÄ—jimÄ…. Tau reikia periodiÅ¡kai siÅ³sti sÄ…raÅ¡Ä… su 5 didÅ¾iausiais failais ar direktorijomis pagal dydÄ¯ namÅ³ direktorijoje (`~`). Å is sÄ…raÅ¡as turÄ—tÅ³ apimti visus paslÄ—ptus failus (kurie prasideda su "." savo pavadinime), o dydis turÄ—tÅ³ bÅ«ti *human readable* formatu, o ne baitais. Taip pat norisi, kad maksimalus gylis bÅ«tÅ³ 1, t.y., jog bÅ«tÅ³ Å¾iÅ«rima Ä¯ `~` ir vienÄ… lygÄ¯ giliau, t.y. `~/direktorija/`.

Kadangi Å¡iÄ… uÅ¾duotÄ¯ reikia atlikti kasdien, nusprendei sukurti ilgÄ… BASH komandÄ….

**Pagalba**: PrieÅ¡ pradedant nueik Ä¯ ChatGPT ir papraÅ¡yk:

>PaaiÅ¡kink man "du" komanda Linux ir jos nustatymus. Man reiktÅ³ matyti failus human readable formatu. Pateik kelis pvz.

Perskaityk kÄ… tau graÅ¾ins ChatGPT, jeigu reikia pasitisklink uÅ¾duodant papildomus klausimus.

![](../img/shell_adv/du_example.png)

Pabandyk sukurti komandÅ³ sekÄ… (**pipeline**) su `du`, `sort`, `head`. Eksperimentuok su nustatymais.

Kai terminalo lange matysi reikiamÄ… iÅ¡vestÄ¯, naudok `echo`, apskliausk visÄ… komandÄ… kabutÄ—mis ir nukreipk Ä¯ failÄ… pavadinimu **list_du_homedir.sh**. Taigi, tai turÄ—tÅ³ atrodyti daugmaÅ¾ taip:

```bash
echo "komanda komanda komanda" > list_du_homedir.sh
```

O dabar pabandyk  

```bash
bash list_du_homedir.sh
```

arba su pipe

```bash
cat list_du_homedir.sh | bash
```

Sveikinu, kÄ… tik sukÅ«rei savo pirmÄ… skriptÄ…! Tai komandÅ³ rinkinys, kurÄ¯ gali perduoti BASH, ir jis jÄ¯ Ä¯vykdys.

:::


### sed

`sed` komanda Linux sistemoje yra srauto redaktorius (**stream editor**), naudojamas tekstui apdoroti ir manipuliuoti. Ji leidÅ¾ia atlikti Ä¯vairius teksto pakeitimus, pvz., ieÅ¡koti ir pakeisti Å¾odÅ¾ius, iÅ¡trinti eilutes arba modifikuoti tekstÄ… pagal tam tikras taisykles, nespausdinant teksto Ä¯ terminalÄ….

Vienas paprasÄiausiÅ³ bÅ«dÅ³ naudoti `sed` - tai pakeisti tam tikrÄ… tekstÄ… kitu tekstu: tam naudojama tokia sintaksÄ— `sed 's/kÄ… keisti/kuo pakeisti/'`.

Taigi, Å¡i komanda pakeiÄia â€rytasâ€œ Ä¯ â€vakarasâ€œ:

```bash
echo "Labas rytas" | sed 's/rytas/vakaras/'
```

`sed` nÄ—ra agresyvi komanda, todÄ—l ankstesnÄ— komanda pakeiÄia tik pirmÄ… rastÄ… atitikmenÄ¯:

```bash
echo "Labas rytas, pasakÄ— senelÄ— kai atÄ—jo rytas" | sed 's/rytas/vakaras/'
```

Matyti, kad tik pirmas â€rytasâ€œ pakeistas Ä¯ â€vakarasâ€œ, o antrasis ne. Jei nori, kad visi atitikmenys bÅ«tÅ³ pakeisti, reikia pridÄ—ti nustatymÄ… `g`:

```bash
echo "Labas rytas, pasakÄ— senelÄ— kai atÄ—jo rytas" | sed 's/rytas/vakaras/g' 
```

Su sed taip pat galima iÅ¡trinti eilutes. PavyzdÅ¾iui, jei `ls -l` komanda atspausdina â€total ...â€œ, galima tai iÅ¡trinti naudojant `sed '1d'`:

```bash
ls -l
ls -l |sed '1d'
```
Vietoje `1`, kuris nurodo, kuriÄ… eilutÄ™ trinti, galima nurodyti ir diapazonÄ…, pvz., nuo 1 iki 3 su sed `'1,3d'`:

```bash
ls -l | sed '1,3d'
```

Taip pat galima Ä¯terpti naujas eilutes:

```bash
ls -l | sed '3a/nauja eilutÄ—'
```

Pora Ä¯domybiÅ³:

Su `sed` gali naudoti *regular expressions*. Å tai keletas reikÅ¡miÅ³:

* `^` reiÅ¡kia eilutÄ—s pradÅ¾iÄ….
* `$` reiÅ¡kia eilutÄ—s pabaigÄ….
* `\t` reiÅ¡kia tabuliacijÄ… (naudoti su `sed -E`).
* `\s` reiÅ¡kia tarpÄ… (naudoti su `sed -E`).

Pvz., pridÄ—ti veidukÄ… prieÅ¡ kiekvienÄ… eilutÄ™:

```
sed 's/^/ğŸ˜€/g' text/seneles_pasaka.txt
```

Jei nori, kad `sed` ignoruotÅ³ raidÅ¾iÅ³ dydÅ¾ius, pridÄ—k nustatymÄ… `I`. Tai panaÅ¡u Ä¯ `grep -i`.

```bash
echo Labas Rytas | sed 's/rytas/Vakaras/'
echo Labas Rytas | sed 's/rytas/Vakaras/I'
```

::: {.callout-tip title="Praktika"}

1. Dirbk su **data/seneles_pasaka.txt**. Tavo tikslas - padaryti pasakÄ… labiau patraukliÄ… vaikams, pakeiÄiant Å¾odÅ¾ius simboliais. Naudok `sed` komandÄ… ir pakeisk Å¡iuos Å¾odÅ¾ius Ä¯ atitinkamus simbolius. Sujunk visas `sed` komandas Ä¯ viena *pipeline* naudojant `|`.

* Å½Ä…sinÄ… moliÅ«gÄ… - ğŸ¦¢ğŸƒ
* VilkÄ… - ğŸº
* BaltÄ… meÅ¡kÄ… - ğŸ»â€â„ï¸
* JonÄ… - ğŸ‘¦ğŸ»
* EglÄ™ - ğŸŒ²
* Å½alÄio - ğŸ
* Ragana - ğŸ§™â€â™€ï¸
* PamotÄ— pikta - ğŸ˜¡


IÅ¡saugok pasakÄ… kaip **text/seneles_pasaka_emojies.txt** 

![](../img/shell_adv/sed_pasaka.png)

2. **data/temp_vilnius.txt** ir kitÅ³ miestÅ³ failai turi kelias problemas, kurias turÄ—tum iÅ¡taisyti:
    * Vilniaus faile kiekvienos eilutÄ—s pradÅ¾ioje Ä¯raÅ¡yk â€Vilnius â€œ (su tarpeliu po miesto pavadinimo). Kituose miestuose atitinkmai "Kaunas " ir "KlaipÄ—da "
    * Dabar pirmieji du skirtukai yra tarpai, o antrasis - tabuliacija. Paleisk `sed` komandÄ… du kartus: vienÄ… kartÄ… pakeisk tarpus (space) Ä¯ kablelius, o antrÄ… kartÄ… - tabuliacijas Ä¯ kablelius.
    * IÅ¡saugok Vilniaus, Kauno, ir KlaipÄ—dos failus kaip **temp_vilnius.csv**, **temp_kaunas.csv**, **temp_klaipeda.csv** (vietoje .txt naudok **.csv** plÄ—tinÄ¯).
    * Kiekvienas miestas turÄ—tÅ³ turÄ—ti visÄ… komandÄ… vienoje eilutÄ—je naudojant `|`.
* Sujunk visus Vilniaus, Kauno ir KlaipÄ—dos failus Ä¯ vienÄ… ir pavadink rezultatÄ… temp_lietuva.csv.
* Pabandyk atidaryti Å¡Ä¯ failÄ… su LibreOffice Calc:
 
 ```bash
 libreoffice --calc temp_lietuva.csv
 ```
* Pavaizduok sekanÄiÅ³ dienÅ³ temperatÅ«ras.

 ![](../img/shell_adv/sed_temp.png)
* Pabandyk atsidaryti visus tris pavienius failus su Excel Power Query ir apdorojus duomenis sukurti dashboard to slicer filtrais ir grafikais.
:::