[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Linux ir programavimas",
    "section": "",
    "text": "Įvadas",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#operacinė-sistema",
    "href": "index.html#operacinė-sistema",
    "title": "Linux ir programavimas",
    "section": "Operacinė sistema",
    "text": "Operacinė sistema\nKai tu įjungi savo telefoną, kompiuterį ar mikrokompiuterį, jame pasileidžia programa - instrukcijų rinkinys, kuris nurodo, kaip tavo prietaisas turi veikti. Ši programa nurodo, pavyzdžiui, įjungus prietaisą pradėti šviesti ekranui, paspaudus klavišus abc suprasti, kad tu rašai, arba įjungus elektros kabelį pradėti krauti bateriją.\n\n\n\nKompiuteris. Autorius: Alessandro Oliverio\n\n\nŠis instrukcijų rinkinys dar nėra visavertė operacinė sistema. Tai yra vadinamasis branduolys (angl. - kernel), kuris nurodo, kaip turi veikti kompiuterinė įranga tarpusavyje.\nŠalia branduolio yra ir kita programinė įranga, kuri leidžia tau naudotis prietaisu - tai įvairiausios programos, pvz., skambinimo programėlė, kalkuliatorius, interneto naršyklė. Visa ši programinė įranga kartu su branduoliu sudaro operacinę sistemą (angl - operating system, arba - OS).\nTaigi operacinė sistema (OS) yra programinė įranga, kuri valdo kompiuterinės įrangos ir programų išteklius. Ji veikia kaip tarpininkė tarp vartotojo ir kompiuterio aparatūros. Pagrindinės populiarios operacinės sistemos yra Windows, UNIX šeimos OS - macOS, ir Linux.\n\nWindows: Microsoft korporacijos sukurta populiariausia operacinė sistema, naudojama tiek namų, tiek verslo kompiuteriuose. Ji žinoma dėl savo patogumo ir plataus programų pasirinkimo.\nmacOS: Apple korporacijos operacinė sistema, naudojama Mac kompiuteriuose. Ji žinoma dėl savo dizaino, stabilumo ir integracijos su Apple ekosistema.\nLinux: Atviro kodo operacinė sistema, kurią gali keisti ir dalintis visi norintys. Ją naudoja dauguma serverių ir technologijų entuziastų.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#ubuntu-skoniai",
    "href": "index.html#ubuntu-skoniai",
    "title": "Linux ir programavimas",
    "section": "Ubuntu skoniai",
    "text": "Ubuntu skoniai\nLinux yra atviro kodo operacinė sistema, todėl ją gali keisti ir dalintis visi norintys. Dėl to yra nemažai programuotojų, kurie nusprendžia pasidalinti savo pagamintais Linux variantais, vadinamais distribucijomis.\n\n\n\nLinux distribucijų medis\n\n\nKai tu įjungi telefoną arba kompiuterį, branduolys užtikrina, kad visi kompiuterio komponentai galėtų tarpusavyje bendrauti. Vis dar trūksta programų, kurios rodytų vaizdus ekrane, leistų įvesti tekstą ir pan. Tam yra reikalingos papildomos programos, dauguma jų buvo sukurtos GNU projekto metu. Tačiau tik branduolys ir GNU programos dar neleistų visavertiškai naudotis kompiuteriu, todėl papildomai diegiamos įvairios reikalingos programos, kurios padaro operacinę sistemą praktiška ir gražiai atrodančia.\nTaigi, pilną operacinę sistemą, dar kartais vadinamą Linux distribucija (distribution), sudaro:\n\nLinux branduolys (kernel)\nGNU programos\nPapildomos programos ir grafinis dizainas",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#kodėl-linux",
    "href": "index.html#kodėl-linux",
    "title": "Linux ir programavimas",
    "section": "Kodėl Linux",
    "text": "Kodėl Linux\nGrįžkime prie klausimo - “Kodėl Linux”?\n\nSaugumas: Linux dažnai laikoma saugesne operacine sistema dėl savo architektūros ir mažesnio virusų kiekio.\nServeriai: Linux arba jai giminingos UNIX sistemos veikia beveik visuose pasaulio serveriuose. Greičiausiai net tavo namuose yra ne vienas įrenginys, kuriame veikia Linux.\nUniversalumas: tiek iOS, tiek Android taip pat veikia UNIX pagrindu.\nLankstumas ir pritaikomumas: Linux leidžia tau būti labiau savarankiškam ir geriau suprasti, kaip veikia kompiuteriai. Tuo pačiu metu išmoksti dalykų, kurių nemoka kiti.\nProgramavimas: Linux yra gera pradžia kelionei į Python ir kitas programavimo kalbas, kurios naudojamos programuojant robotus, kuriant interneto svetaines ar atliekant skaičiavimus su dideliais duomenų kiekiais.\n\nŠiais laikais vis daugiau ir daugiau profesijų kasdienėje veikloje reikia programavimo. Buhelteriai naudojasi Python,kad greičiau apdorotų duomenis. Architektai ir inžinieriai, kad teisingai apskaičiuotų pastato konstrukcijas. Transporto srauto specialistai, kad planuotų ir valdytų automobilių srautus, o NASA darbuotojai, kad valdytų į kosmoosą kylančias raketas.\nTaigi Linux ir tam tikra prasme - programavimas, paruošia tave 21-ajam amžiui.\nNegana to, Linux veikia ant tokių paprastų mikrokompiuterių kaip Raspberry Pi Zero ir gali atgaivinti net 10-20 metų senumo nešiojamą kompiuterį. Taigi, tai padeda tausoti gamtą, nes savo technika gali naudotis ilgiau.\nBet yra ir kita medalio pusė. Ne visos tavo įprastos programos veikia Linux. Pavyzdžiui, Adobe produktai tiesiog neveikia Linux aplinkoje. Microsoft Excel ir Word taip pat nėra pritaikyti Linux. Jei tavo mokslui ar darbui yra būtinos tam tikros programos, Linux gali neatitikti tavo lūkesčių. Tačiau reikia žinoti, kad daugelis šių programų turi analogus Linux aplinkoje. Dažniausiai jie yra atviro kodo ir nemokami.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#linux-mint",
    "href": "index.html#linux-mint",
    "title": "Linux ir programavimas",
    "section": "Linux Mint",
    "text": "Linux Mint\nKaip jau minėjau, yra daug Linux distribucijų. Šiame vadovėlyje naudosime vieną iš paprasčiausių - Linux Mint distribuciją, kuri sukurta Ubuntu pagrindu.\nJą galima parsisiųsti iš linuxmint.com. Kaip ją instaliuoti, gali šiek tiek skirtis priklausomai nuo kompiuterio, tad geriausia šioje vietoje tiesiog paieškoti vaizdo įrašo Youtube svetainėje.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html",
    "href": "a_linux_pagrindai/1_linux_configure.html",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "",
    "text": "1.1 Intro",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#themes",
    "href": "a_linux_pagrindai/1_linux_configure.html#themes",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.2 Themes",
    "text": "1.2 Themes",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#backgrounds",
    "href": "a_linux_pagrindai/1_linux_configure.html#backgrounds",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.3 Backgrounds",
    "text": "1.3 Backgrounds",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#menu",
    "href": "a_linux_pagrindai/1_linux_configure.html#menu",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.4 Menu",
    "text": "1.4 Menu",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#panel",
    "href": "a_linux_pagrindai/1_linux_configure.html#panel",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.5 Panel",
    "text": "1.5 Panel",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#firewall",
    "href": "a_linux_pagrindai/1_linux_configure.html#firewall",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.6 Firewall",
    "text": "1.6 Firewall",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#languages",
    "href": "a_linux_pagrindai/1_linux_configure.html#languages",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.7 Languages",
    "text": "1.7 Languages",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#keyboard",
    "href": "a_linux_pagrindai/1_linux_configure.html#keyboard",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.8 Keyboard",
    "text": "1.8 Keyboard",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#time",
    "href": "a_linux_pagrindai/1_linux_configure.html#time",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.9 Time",
    "text": "1.9 Time",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#tips-tricks",
    "href": "a_linux_pagrindai/1_linux_configure.html#tips-tricks",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.10 Tips & Tricks",
    "text": "1.10 Tips & Tricks",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html",
    "href": "a_linux_pagrindai/2_linux_update.html",
    "title": "2  Linux atnaujinimas",
    "section": "",
    "text": "2.1 Pradžia\nVisuose kompiuteriuose yra daugybė įvairių programų. Pavyzdžiui, jau susipažinome su Terminal ir Files programomis. Taip pat išmokome naudoti kai kurias įdiegtas komandas: echo, cat, ir base64. Šių programų kūrėjai dažnai atnaujina savo programas, tad norėdami pasinaudoti naujausiomis funkcijomis ir pataisymais, turime įdiegti šiuos atnaujinimus (angl. - update).\nŠioje pamokoje sužinosime:\nBe to, išmoksime:\nŠis skyrius padės išmokti, kaip efektyviai tvarkytis su programomis ir jų atnaujinimais, kad kompiuteris visada būtų naujausias ir veiktų be trikdžių.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html#pradžia",
    "href": "a_linux_pagrindai/2_linux_update.html#pradžia",
    "title": "2  Linux atnaujinimas",
    "section": "",
    "text": "Kas yra veidrodiniai serveriai (angl. - mirrors).\nKaip atnaujinti programas naudojant Update Manager programą.\nKaip atlikti programų atnaujinimus naudojant terminalą.\n\n\n\nKaip įdiegti (angl. - install) programas naudojant Software Manager ir terminalą.\nKuo skiriasi System Package nuo Flatpak programų.\nKaip pašalinti (angl. - uninstall) nebereikalingas programas, kad kompiuteris būtų švaresnis ir veiktų sklandžiau.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html#update-manager",
    "href": "a_linux_pagrindai/2_linux_update.html#update-manager",
    "title": "2  Linux atnaujinimas",
    "section": "2.2 Update Manager",
    "text": "2.2 Update Manager\nUpdate Manager yra programa, kuri padeda atnaujinti kitas programas tavo kompiuteryje. Ji pati praneša, kai laikas atnaujinti programas. Kai internete yra prieinami atnaujinimai, dešiniame kampe atsiranda skydelio su raudonu tašku piktograma (raudonas taškas reiškia, kad yra naujų atnaujinimų).\n\n\nBet jei nematai šios piktogramos, gali paleisti “Update Manager” programą per Menu:\n.\nPirmą kartą paleidus šią programą, gali pamatyti tokį langą, kuris paaiškina, ką ji daro. Drąsiai spausk ant OK.\n\nJei pamatysi, kad pačiai programai reikia atnaujinimo, spausk ant “Apply the Update” (lt. - įdiegti atnaujinimą). Taip pat gali matyti užrašą switch to a local mirror, kol kas spausk No. Kas yra veidrodžiai (angl. - mirrors), pakalbėsime netrukus.\n\nJei paspaudus “Apply the Update” kompiuteris paprašys tavo slaptažodžio, įvesk jį. Taip kompiuteris įsitikina, kad tik tu ar kitas vartotojas, kuriam priklauso šis kompiuteris, gali atlikti pakeitimus. Drąsiai įvesk savo slaptažodį ir spausk Authenticate (lt. - patvirtinti tapatybę).\n\nNetrukus pamatysi vaizdą, kuris gali atrodyti panašiai - vienas ar keli, o gal net daugybė skirtingų programų atnaujinimų, kuriuos gali įdiegti savo kompiuteriui. Tačiau kol kas dar nieko nespauskime. Susipažinkime su tuo, ką čia matome:\n\n\n\nType - kokio tipo yra atnaujinimas? Jie gali būti:\n\nSecurity update - saugumo atnaujinimas. Jo simbolis yra skydelis. Tai svarbiausias atnaujinimas, kurį reikia kuo skubiau įdiegti, kad kompiuteris būtų saugus.\nKernel update - pagrindinės Linux sistemos atnaujinimas. Jo simbolis yra žaibas. Šie atnaujinimai pagerina, kaip veikia pats kompiuteris. Ar ekranas rodo gerai? Ar veikia pelė? Ir t.t.\nSoftware update - programų atnaujinimai. Tai atnaujinimai, kuriuos programų kūrėjai sukuria, kad jų programos veiktų geriau, turėtų daugiau funkcijų ir pan.\n\n\nŠiame lange taip pat gali paspausti ant:\n\n\nClear - išvalyti visus pasirinktus atnaujinimus\nSelect All - pasirinkti visus atnaujinimus\nRefresh - atnaujinti sąrašą atnaujinimų, kurie yra prieinami\nInstall Updates - įdiegti pasirinktus atnaujinimus\n\nBet kaip kompiuteris žino, kokias programas atnaujinti? Ir iš kur jis jas atsisiunčia?\n\n2.2.1 Mirrors ir Updates\nVeidrodėli, veidrodėli, kas pasaulyje gražiausia?\n\nPradėkime nuo pradžių…\nĮsivaizduok, kad programuotoja, kuri kuria programas, dirba iš namų, kaip ir tu. Po ilgos darbo savaitės, ji nusprendžia: “Viskas, programos atnaujinimas paruoštas. Ištaisyta klaida, įdiegti nauji patobulinimai”.\n\n(Nuotraukoje Jaime Gunther, kuri 38 metų nusprendė, kad mokysis savarankiškai programuoti ir tapo programuotoja)\nBet dabar įsivaizduok, kad keli milijonai žmonių bandytų parsisiųsti iš jos kompiuterio šiuos atnaujinimus. Jos kompiuteris negalėtų to atlaikyti, ir viskas strigtų bei vyktų labai lėtai.\nTodėl programuotoja naudoja serverius veidrodžius (angl. - mirrors).\n\nKas yra serveris? Serveris yra didelis kompiuteris, kuris pastatytas specialiose vietose ir gali aptarnauti milijonus žmonių vienu metu. (daugiau nuotraukų gali rasti čia)\n\n\n\nKodėl jie vadinami veidrodžiais (angl. - mirrors)? Nes jie atspindi tuos programinius pakeitimus, kuriuos programuotoja padarė savo namuose. Kai ji kažką atnaujina, šie serveriai iškart tai atspindi, ir tu gali parsisiųsti atnaujinimus neapkraudamas programuotojos namų kompiuterio!\n\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuris turi sąrašą, kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs, priklauso programų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitikrinti ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasties kartais tavo kompiuteris paklausia, ar nori prisijungti prie vietinių veidrodinių serverių - “Do you want to switch to a local mirror?”\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuriame yra sarašas kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs nutolęs, priklauso prgramų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitiktrinti, ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasies, kartais tavo kompiuteris paklausia, ar nori prisijngti prie lokalių veidrodžių.\nKaip tai padaryti?\n\nSpausk ant “Edit” (pakeitimai) ir tada ant “Software Sources” (programų šaltiniai).\nKompiuteris vėl paprašys tavo slaptažodžio, įvesk jį.\nAtsidariusiame naujame lange pamatysi Main ir Base veidrodžius. Jie gali būti nustatyti ne visai ten, kur gyveni tu.\nSpustelk pele prie Main. Atsidarys langas, kuriame bus serveriai, surūšiuoti pagal tai, kaip arti tavęs jie yra (pagal atsisiuntimo greitį). Tu pamatysi, kad po kelių sekundžių sąrašo viršus nebekinta. Tau nereikia laukti, kol kompiuteris parsisiųs visų serverių informaciją. Pasirink patį pirmą serverį\nPakartok tai su Base serveriu.\nSpustelk ant “Update the mirrors” (atnaujinti veidrodinius serverius). Tai gali truputį užtrukti.\nAtnaujinus, pamatysi, kad buvusius serverius pakeitė kiti, tavo pasirinkti serveriai.\nDabar gali uždaryti šį langą.\n\nVisas procesas šiame video:\nVideo\nDabar gali atnaujinti programas, paspaudus ant Install Updates. Gali atsirasti papildomi langai, kur paklaus, ar tikrai nori įdiegti atnaujinimus, gali paprašyti ir įvesti tavo slaptažodį dar kartą. Visur drąsiai sakyk “taip” ir įrašyk savo slaptažodį.\nTačiau yra ir kitas būdas! Naudojant Terminal.\nVeidrodinių serverių atnaujinimas yra būtinas net kai įdiegi atnaujinimus per Terminalą. Tad retkarčiais pasitikrink, ar pasirinkti vis dar sparčiausi veidroriniai serveriai.\n\n\n2.2.2 Atnaujinimų instalivimas per Terminal\nKodėl kartais geriau įdiegti atnaujinimus per Terminal programą? Visų pirma - tu praktikuojiesi BASH kalbos žinias! Visų antra, vėliau išmoksi, kaip vos kelių klavišų paspaudimu tai padaryti daug greičiau nei spaudant su pele ir naudojant Update Manager programą.\nŠtai taip atrodo kodas, kurį reikės įrašyti:\nsudo apt update && \nsudo apt full-upgrade -y && \nsudo apt autoremove -y && \nflatpak update\nDabar tavo galvoje gal atrodo taip:\n\nPradėkime nuo pradžių ir eikime per visas komandas, kad jas suprastume. Kai suprasi - pamatysi, kad viskas gana paprasta.\nMes galime visas komandas surašyti į vieną eilutę, bet paprastumo dėlei, terminale įrašyk komandą po komandos, kaip pateiktia žemiau.\n\nsudo apt update.\n\n\nčia iššaukiama komanda apt. Tai yra programa, kuri rūpinasi programų atnaujinimu.\nupdate yra argumentas, ką programa turi daryti. Priešingai nei atrodo, ji neatnaujina programų. Ką ji padaro, tai palygina tavo kompiuterio programas su tuo, kas yra veidrodiniuose serveriuose (mirror). Jeigu ji aptinka skirtumą, nes, pvz., serveryje programa yra naujesnė, apt tave informuos apie galimus atnaujinimus.\nO kas yra sudo? Atsimeni, kai Update Manager tavęs prašė įrašyti tavo slaptažodį? Kai tu jį įrašydavai, kompiuteris suprasdavo, jog tu turi kompiuterio administratoriaus teises. sudo padaro tą patį. Ši komanda pasako, kad po jo sekantis kodas būtų įvykdytas su kompiuterio administratoriaus teisėmis ir apsaugo, kad svetimi žmonės nieko negalėtų padaryti tavo kompiuteriui.\n\nSpausk Enter. Paleidus šią komandą, Terminal tavęs paprašys įrašyti savo slaptažodį. Jį rašant tu nieko nematysi (juk nenori, kad sėdint kavinėje, kas nors pamatytų tavo slaptažodį?). Įvesk ir spausk Enter dar kartą. Jeigu savo slaptažodį įvesi neteisingai - terminalas tau tai pasakys, tad galėsi bandyti dar kartą.\nJeigu tavo kompiuteriui yra pasiekiami atnaujinimai - tu pamatysi, kiek jų.\n\n\nsudo apt full-upgrade -y.\n\n\nŠi dalis pasako, kad sudo - elkis kaip administratorius\napt naudok programų atnaujinimų programą.\nfull-upgrade - atnaujink visas programas.\n-y yra nustatymas, panašus į ką jau matėme su base64 -d, tik šį kartą jis reiškia yes (lt - taip). Jeigu jo nepanaudotum, Terminal programa tavęs paklaustų, kokius atnaujinimus siūlo padaryti ir dar kartą klaustų, ar tikrai nori viską įdiegti. Tam kad išvengti šio papildomo klausimo, iš karto pasakome - yes.\n\nJeigu tu rašai šią komandą iškart po to, kai jau naudojai sudo apt update, Terminal programa tavęs gali ir nebeprašyti dar kartą įrašyti savo slaptažodį.\nPriklausomai nuo to, kiek yra atnaujinimų, šis procesas gali užtrukti kelioliką sekundžių, bet gali ir kelioliką minučių.\nVideo\n\nsudo apt autoremove -y.\n\n\nsudo ir apt jau žinome.\nauto-remove - šis nustatymas pasako apt komandai, kad jeigu yra kažkokių programų, kurios po atnaujinimo nebereikalingos, jas ištrintų. Nebijok, apt programa yra labai protinga ir atsargiai atsirenka, ką trinti ir ko ne.\n-y nustatymas pasako yes (taip), kad nereiktų patvirtinimo.\n\n\n\nflatpak update - kiek kita komanda. Čia mes iššaukiame programą flatpak, kuri, kaip ir programa apt, moka instaliuoti programas. Tačiau ją atnaujinti užtenka vos šių dviejų žodžių.\n\n\n\nO ką gi reiškia && toje ilgoje komandoje? Kai mes rašome komandas po vieną, kaip padarėme dabar, mes patys matome, ar nutiko kas nors netikėto, ar įvyko kokia nors klaida ir t.t. Tam, kad kompiuteris žinotų, jog tik padarius sudo apt update ir negavus jokių klaidų, jis eitų prie sekančios komandos sudo apt full-upgrade -y ir taip toliau, reikia šias komandas sujungti su &&. Jeigu prieš tai buvusi komanda nepavyktų, kompiuteris nutrauktų visas likusias komandas.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html#žodynėlis",
    "href": "a_linux_pagrindai/2_linux_update.html#žodynėlis",
    "title": "2  Linux atnaujinimas",
    "section": "2.3 Žodynėlis",
    "text": "2.3 Žodynėlis\n\n\n\n\n\n\n\n\nKomanda\nApibrėžimas\nPavyzdys\n\n\n\n\nsudo apt update\nKomanda, kuri atnaujina paketų sąrašą iš visų saugyklų, kad būtų galima gauti informaciją apie naujausias programinės įrangos versijas.\nPaleidus sudo apt update, sistema patikrina, ar yra naujų programinės įrangos paketų atnaujinimų.\n\n\nsudo apt full-upgrade\nKomanda, kuri atnaujina visus įdiegtus paketus į naujausias galimas versijas, automatiškai pašalindama arba įdiegdama paketus, kai reikia.\nNaudojant sudo apt full-upgrade, jūsų sistema bus atnaujinta į naujausias programinės įrangos versijas.\n\n\nsudo autoremove\nKomanda, kuri pašalina nereikalingus paketus, kurie buvo įdiegti kaip priklausomybės, bet dabar nebėra reikalingi.\nPaleidus sudo autoremove, bus pašalinti nereikalingi bibliotekų paketai, siekiant atlaisvinti vietos diske.\n\n\nflatpak update\nKomanda, kuri atnaujina visus įdiegtus Flatpak programas į naujausias versijas.\nNaudojant flatpak update, jūsų Flatpak programos bus atnaujintos į naujausias versijas.\n\n\nsudo apt install &lt;name&gt;\nKomanda, kuri įdiegia nurodytą programinės įrangos paketą iš saugyklos.\nPaleidus sudo apt install vim, bus įdiegta vim redaktoriaus programa.\n\n\nsudo apt remove &lt;name&gt;\nKomanda, kuri pašalina nurodytą programinės įrangos paketą iš sistemos.\nNaudojant sudo apt remove vim, bus pašalinta vim redaktoriaus programa.\n\n\nflatpak install &lt;name&gt;\nKomanda, kuri įdiegia nurodytą Flatpak programą iš Flatpak saugyklos.\nPaleidus flatpak install flathub org.gimp.GIMP, bus įdiegta GIMP programa.\n\n\nflatpak remove &lt;name&gt;\nKomanda, kuri pašalina nurodytą Flatpak programą iš sistemos.\nNaudojant flatpak remove org.gimp.GIMP, bus pašalinta GIMP programa.\n\n\n-y\nParametras, kuris automatiškai atsako “taip” į visus klausimus, kuriuos komanda gali užduoti, taip palengvinant automatizuotą diegimą ar pašalinimą.\nKomandoje sudo apt install -y vim, parametras -y užtikrina, kad diegimo procesas vyks be vartotojo įsikišimo.\n\n\n&&\nLoginis operatorius, naudojamas sujungti kelias komandas taip, kad antroji komanda būtų vykdoma tik tuo atveju, jei pirmoji komanda baigiasi sėkmingai.\nKomandoje sudo apt update && sudo apt upgrade, sudo apt upgrade bus vykdoma tik tada, jei sudo apt update sėkmingai baigiasi.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html",
    "href": "a_linux_pagrindai/3_linux_software.html",
    "title": "3  Linux programos",
    "section": "",
    "text": "4 Programų instaliavimas\nProgramų instaliavimas Linux yra gana paprastas. Užtenka susirasti ir atsidaryti Software Manager.\nJam atsidarius, iškart matome daug programų pasiūlymų. Drąsiai panaršyk šiame lange. Ar matai ką nors tave dominančio?",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-instaliavimas",
    "href": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-instaliavimas",
    "title": "3  Linux programos",
    "section": "4.1 Sisteminių paketų instaliavimas",
    "text": "4.1 Sisteminių paketų instaliavimas\nSisteminis paketas (angl. System Package) - tai programa, kurią Linux kūrėjai patikrino ir pritaikė tavo kompiuterio veikimui. Šios programos valdomos per apt programą.\nKita programų instaliavimo sistema yra Flatpak, su ja susipažinsime vėliau.\nĮdiekime “Bloboats” žaidimą.\nPaieškos viršuje įrašyk Bloboats ir paspausk ant programos piktogramos.\n\nKaip matai, sekantis langas parodo, jog tai System Package ir leidžia tau šią programą įdiegti. Spausk ant Install.\n\nSoftware Manager programa informuos tave, jei reikia įdiegti papildomas programas.\n\nJei taip nutiktų, spausk ant Continue, o tada įrašyk savo slaptažodį ir spausk ant Authenticate. Prisimeni, kai tu įrašai savo slaptažodį, kompiuteris komandas vykdo kaip sudo :)\n\nDabar gali spausti ant Launch (lt - paleisti), arba rasi šią programą tarp visų programų.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "href": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "title": "3  Linux programos",
    "section": "4.2 Sisteminių paketų įdiegimas Terminal lange",
    "text": "4.2 Sisteminių paketų įdiegimas Terminal lange\nSusiraskime kitą programą - 3dchess. Kaip matai, jos pavadinimas kompiuteriui yra parašytas šio lango apačioje:\n\nAtsidaryk terminalą ir įrašyk šią komandą, daug kas jau tau bus matyta:\nsudo apt install 3dchess\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia įdiegti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\ninstall - komanda, pasakanti apt, ką turi daryti, šįkart įdiegti naują programą.\n3dchess - argumentas, pasakantis, kokią programą įdiegti.\n\nMes taip pat galėjome pridėti -y, bet šįkart to nepadarysime. Pažiūrėkime, kas nutinka. Ar pastebėjai kompiuterio reikalavimą patvirtinti, jog tikrai nori instaliuoti šią programą? Do you want to Continue [Y/n]\nVideo\nKaip matai, kompiuteris manęs klausė, ar tikrai noriu, ir teko įrašyti Y raidę ir spustelėti Enter. Tiesa, kai matai [Y/n] tai reiškia, kad jeigu tiesiog paspausi Enter - kompiuteris galvos, kad tu renkiesi Y (Yes trumpinys), tad rašyti Yes tau net nereikia. Kartais tu gali pamatyti [N/y]. Taigi tas pasirinkimas, kuris parašytas didžiąja raide - bus automatiškai pasirinktas jeigu nieko neįrašysi, bet pasupausi Enter klavišą.\nJeigu būčiau įrašęs komandą\nsudo apt install 3dchess -y\nTerminal programa manęs neprašytų patvirtinti mano pasirinkimo. Nes priejus šiam klausimui Do you want to Continue [Y/n], nustatymas -y pasakytų iškart Yes.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#flatpak",
    "href": "a_linux_pagrindai/3_linux_software.html#flatpak",
    "title": "3  Linux programos",
    "section": "4.3 Flatpak",
    "text": "4.3 Flatpak\nFlatpak yra kitoks būdas instaliuoti programas. Kai tu instaliuoji Flatpak programą, tu atsisiunti ne tik pačią programą, bet ir visas kitas programas, kurios reikalingos, kad pagrindinė programa veiktų. Pabandykime tai paaiškinti kitaip.\nĮsivaizduok, kad tavo kompiuteris yra kaip namas. Namai turi kambarius, virtuvę, vonią ir t.t. Dabar įsivaizduok, kad nori naujos spintos. Kai tu parsisiunti spintą kaip System Package (sisteminį paketą), tai tarsi parsiveži ją iš IKEA parduotuvės ir pastatai savo kambaryje.\nFlatpak programos veikia kitaip. Kai tu atsisiunti Flatpak programą, tai tarsi parsineštum visą didelę palapinę, kurioje yra ne tik tavo spinta, bet ir visa kita - virtuvė, vonia ir dar keli kambariai. Kodėl taip daroma?\nKartais programoms reikia kitų programų, kad jos veiktų gerai. Tavo kompiuteryje ne visada yra visos šios reikalingos programos. Todėl kai parsisiunti Flatpak programą, ji atsisiunčia viską, ko jai reikia, kad veiktų be problemų. Tai reiškia, kad gauni naujesnę ir geriau veikiančią programą. Tačiau ši didelė palapinė užima daugiau vietos tavo kompiuteryje, nes joje yra viskas, ko reikia programai.\nPavyzdžiui, susiraskime programą “hedgewars”. Pasirink bet kurią piktogramą.\n\nKaip matai, šalia “System Package” arba “Flatpak” yra nedidelis trikampiukas. Paspaudus ant jo, pamatysi, jog gali įdiegti šią programą ir kitu formatu.\nTaip atrodo System Package:\n\nO štai taip Flatpak. Atkreipk dėmesį į programos versijos skirtumus ir kiek vietos reikia kompiuteryje.\n\nKaip System Package ši programa užima 194 MB vietos tavo kompiuteryje, o kaip Flatpak - 3.7 GB. 3.7 GB atitinka 3700 MB. Taigi beveik 20 kartų daugiau vietos. Tai reiškia, kad Flatpak programai reikia daugiau vietos, nes ji atsisiunčia viską, ko jai reikia.\nGera žinia yra ta, kad kai instaliuosi kitą programą su Flatpak, labai tikėtina, kad kita programa jau galės naudotis kai kuriais dalykais iš pirmosios palapinės. Tada naujai programai reikės mažiau vietos.\nFlatpak programas taip pat galima instaliuoti per Terminal programą.\nTačiau tai šiek tiek skiriasi:\n\nnereikia naudoti sudo\nvietoj apt reikia naudoti flatpak\nnaudojame install\nprogramos pavadinimą galima pasiimti iš Software Manager, bet daugiau Flatpak programų galima rasti ir flathub.org tinklapyje.\n\nVideo",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#software-manager",
    "href": "a_linux_pagrindai/3_linux_software.html#software-manager",
    "title": "3  Linux programos",
    "section": "5.1 Software Manager",
    "text": "5.1 Software Manager\nPirmiausia pažiūrėkime, kaip ištrinti programas naudojant Software Manager.\n\nAtidaryk Software Manager.\nPaspaudus ant trijų brūkšnelių spausk ant “Show Installed Application” (lt. parodyk įdiegtas programas).\n\n\n\nSurask programą, kurią nori ištrinti, ir spausk ant jos pavadinimo ar piktogramos.\n\n\n\nAtsidariusiame lange spausk ant Remove (lt. pašalinti).\n\n\n\nSoftware Manager programa paprašys patvirtinimo. Spausk Continue, įvesk savo slaptažodį ir spausk Authenticate.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#menu",
    "href": "a_linux_pagrindai/3_linux_software.html#menu",
    "title": "3  Linux programos",
    "section": "5.2 Menu",
    "text": "5.2 Menu\nKitas būdas ištrinti programas yra per Menu.\n\nAtidaryk meniu, kur randi visas savo programas.\nDešiniu pelės klavišu spustelk ant programos, kurią nori ištrinti. Prasiskleis papildomas meniu.\nPasirink Uninstall (lt. pašalinti).\nPasirodys patvirtinimo langas. Pasirink OK, įvesk savo slaptažodį ir spausk Authenticate.\n\nVideo",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#terminalas",
    "href": "a_linux_pagrindai/3_linux_software.html#terminalas",
    "title": "3  Linux programos",
    "section": "5.3 Terminalas",
    "text": "5.3 Terminalas\nProgramas taip pat galima ištrinti per terminalą.\n\n5.3.1 Sisteminis paketas\nNorėdami ištrinti sisteminį paketą, naudokime apt programą. Pavyzdžiui, jei nori ištrinti programą “3dchess”:\n\nAtidaryk terminalą.\nĮrašyk šią komandą: sudo apt remove 3dchess\n\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia ištrinti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\nremove - komanda, pasakanti apt, kad reikia ištrinti programą.\n3dchess - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#flatpak-1",
    "href": "a_linux_pagrindai/3_linux_software.html#flatpak-1",
    "title": "3  Linux programos",
    "section": "5.4 Flatpak",
    "text": "5.4 Flatpak\nPer Terminal irgi galime ištrinti Flatpak programą. Pavyzdžiui, jei nori ištrinti programą org.hedgewars.Hedgewars:\nflatpak uninstall org.hedgewars.Hedgewars\nPaaiškinkime, kas čia yra kas:\n\nflatpak - programa, kuri įdiegia, atnaujina ir pašalina Flatpak programas.\nuninstall - komanda, pasakanti flatpak, kad reikia ištrinti programą.\norg.hedgewars.Hedgewars - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#kodėl-per-terminal",
    "href": "a_linux_pagrindai/3_linux_software.html#kodėl-per-terminal",
    "title": "3  Linux programos",
    "section": "5.5 Kodėl per Terminal?",
    "text": "5.5 Kodėl per Terminal?\nKo gero tau dabar kyla klausimas, kodėl verta mokėti atnaujinti, įdiegti ir ištrinti programas naudojant Terminal?\nNaudoti Terminal gali atrodyti sudėtingiau nei spustelėti pelę, tačiau jis turi daug privalumų.\n\nTerminal leidžia tau atlikti daugybę užduočių labai greitai. Užuot naršant per meniu ir ieškant reikiamų funkcijų, tu gali tiesiog įvesti kelias komandas ir tavo darbas bus atliktas.\nTerminal suteikia daugiau galimybių ir lankstumo. Kai kuriuos dalykus gali padaryti tik per Terminal. Be to, Terminal naudoti gali būti smagu! Tai tarsi magija – tu rašai komandas, o kompiuteris jas vykdo.\nTerminal naudojimas gali padėti tau geriau suprasti, kaip veikia tavo kompiuteris. Kai tu įrašai komandas ir matai, kaip jos veikia, tu pradedi suvokti, kas vyksta tavo kompiuterio viduje.\nTerminal naudojimas gali padėti tau tapti tikru kompiuterių ekspertu. Ir kas žino, galbūt ateityje tave sudomins programavimo, duomenų analitikos ar tiesiog inžinerijos mokslai? Labai daug profesijų pradeda nautodi programavimą kasdieniuose savo darbuose. Aplinkosaugininkai gali tyrinėti kaip keičiasi klimatas ir kaip kinta gamta, buhalteriai gali paspasrtinti ataskaitų ruošimą, architektai apskaičiuoti kaip statyti namą, jog jis nesugriųtų vykstant žemės drebėjimui, robotikos specialistai - kaip sukonstruoti robotoą, kuris važinėja ir tyrinėja Marso planeta…\n\nSkamba truputį sudėtingai, tiesa? Pateiksiu tau pavyzdį. Įsivaizduok, kad tu turi draugę vardu Pelenė. Pelenė irgi turi kompiuterį, bet nežino, kaip įdiegti programas. Tačiau jūs norite kartu žaisti tą patį žaidimą - lenktyniauti žaidžiant Super Tux Cart. Ką daryti?\nTu gali jai parašyti žinutę ir pasakyti, kad nukopijuotų ir paleistų štai tokį kodą:\nsudo apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update && flatpak install net.supertuxkart.SuperTuxKart -y\nNa štai, jeigu jūs turite paskyras Super Tux Cart, dabar galite nuotoliniu būdu lenktyniauti kartu.\nDar neturi paskyros ir elektroninio pašto adreso? Sekančioje pamokoje tai ir susikursime.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html",
    "href": "a_linux_pagrindai/4_passwords_programms.html",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "",
    "text": "4.1 Intro\nAr žinai, kas kelia didžiausią riziką internete, tiek vaikams, tiek suaugusiems? Nesaugūs slaptažodžiai.\nTokie slaptažodžiai kaip:\nyra begalo pavojingi. Blogi pogramuotjai, dar vadinami “hakeriais”, nuolat bando nulaužti internetinas paskyras. Tam jie naudojasi teksto generatoriais, sukuria šimtus tūkstančių kombinacijų, pvz pelenė123 ir bando nulaužti internetinius slaptažodžius.\nkas gali nutikti blogiausia, jeigu tavo slaptažodį nulauš?\nScerijus:\nRetai, bet taip nutinka.\nŠioje pamokoje išmoksi kas yra saugus slaptažodis, kaip juos sukurti ir kaip juos saugoti. Taip tai ne visada yra patogu, bet deja, kaip visad gyvenime, reikia ieškoti kompromiso tarp saugumo ir patogumo.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html#intro",
    "href": "a_linux_pagrindai/4_passwords_programms.html#intro",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "",
    "text": "12345\nslaptažodis\nvardaspavardė\nmamos vardas\naugintinio vardas\n\n\n\n\n\nHackeris “nulaužia” t.y. atspėja tavo slaptažodį pvz Google paskyros\nNueina į tavo banko paskyrą, ir pranša, kad pamiršo savo slaptažodį. Bankas atsiunčia nuorodą į elektronį paštą, kuriame prideda nuorodą, leidžiančia sukurti naują slaptažodį bankui.\nPrisijungęs prie tavo banko paskyros - hackeris ištuština tavo visas santaupas. Dabar tu turi eiti skolintis, vien tam, kad turėti pinigų maistui.\nBet hackeris buvo ypač blogas, apart visko, jis dar ištrynė ir visas kitas tavo paskyras, nuotraukų kopijas esančias internete ir prikėtė visokių kitų šunybių.\nNa prie to pačio, dar ir užrakino tavo telefoną, ištrynė kontaktus, tad net nebežinai, kaip paskambinti draugams ir paprašyti pagalbos.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html#kas-yra-saugus-slaptažodis",
    "href": "a_linux_pagrindai/4_passwords_programms.html#kas-yra-saugus-slaptažodis",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "4.2 Kas yra saugus slaptažodis",
    "text": "4.2 Kas yra saugus slaptažodis\nPirmiausia, saugus slaptažodis yra toks, kurio tu nežinai! Jeigu tu nežinai savo slaptažodžio, tu negali jo užrašyti ant jokio popieriaus lapelio, tad niekas jo ir nepamatys.\nTai kaip prisijungti prie paskyrų internete, pvz, banke? prie elektroninio pašto?\nTam padeda slaptažodžių programos. Jų yra įvairių\n\ninternetinės programos tokios kaip Bitwarden, kurios sinchronizuoja, t.y. suvienodina informaciją per visus tavo įrenginius: kompiuterį, telefoną ir t.t.\nkompiuteryje instaliuotos programos, pvz keepassx, kuriose išsaugai slaptažodius ir kai reikia prisijungti, atsidarai jas ir iš jų nusikopijuoji slaptažodį, kurio reikia.\n\nKiti aspektai saugaus slaptažodžio:\n\nbent 16 simbolių (geriau naudoti daugiau, bet ne visur leidžiama)\nnaudoti tiek DIDŽIĄSIAS RAIDES, tiek mažąsas, tiek skaičius bet būtinai ir simpbolius tokius kaip !@#$%^&*()_\n\ntačiau pati svarbiausia taisyklė:\n\nnaudoti skirtingus slaptažodžius visur\n\nJeigu kam nors pavyktų nulaužti tavo vieną paskyrą, pvz kokios nors internetinės parduotuvės, tas hackeris negalėtų panaudoti išgauto slaptažožio norint prisijungti prie tavo elektroninio pašto.\nNaudojant tokias programėlės kaip Bitwarden, KeepassX ir kitas, su laiku tu pamatysi, kiek daug paskyrų turi ir kaip nelengva būtų visur turėti skirtingus slaptažodžius.\n\n4.2.1 KeepassX\nInstlaiuok keepassx savo kompiuteryje. Prisimink iš praėjusio skurio, kaip instaliuoti programas naudojantis Terminal Programos pavadinimas kurio reikės keepassx\nPagalba:\n\nsudo suteikia administratoriaus teises\napt programa kuri valdo programas\ninstall komanda kuri įdiegia programas\n&lt;argumentas&gt; programos pavadinimas, kurią norima įdiegti\n\n             Video Video\nTai dar kartą:\n\n16-20 simbolių slaptažodis\nsusidedantis iš įvairių raidžių, skaičių ir simbolių\nkiekvienam paskyrai skirtingas slaptažodis\nišsaugotas programėleje",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html#elektroninis-pašto-adresas",
    "href": "a_linux_pagrindai/4_passwords_programms.html#elektroninis-pašto-adresas",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "4.3 Elektroninis pašto adresas",
    "text": "4.3 Elektroninis pašto adresas\nDauguma žmonių turi elektroninį paštro adresą sukuart Google svetainėje. Tai labai paprarsta ir patogu, juo labiau, nemokama.\nBet vėlgi, patogumas netolygu saugumui. Visų pirma Google naudojasi visais turimais duomenis, failais, laiškais ir t.t. tam, kad pagerintų reklamos rodymą. Ne Google yra produktas, kurį naudoji, o TU tampi produktu Google.\nTačiau yra ir saugumo problema, jeigu kas nors pamato tavo ekrano slaptžodį ir pavogia telefoną, o ten yra Gmail programėle, tai jau beveik ir nebereikia spėlioti tavo slaptažodžių. Tu gali nespėti užblokuoti savo telefono, o banko sąskaita jau gali būti tuščia. Kaip? Velgi, vagišius pasinaudos “pamiršau savo slaptažodį” funkcija. Jam atsius laišką į gmail su nuoroda kaip susikurti naują slaptažodį, o patvirtinimui, akd ten “tikrai tu”, bankas atsiųs SMS žinutę. Viskas viename įrenginyje…\nO jeigu tavo Gmail laiškuose dar ir tavo žinutės tavo slaptai meilei?\nKą daryti?\nGeriausia turėti elektroninį pašto adresą kuris nėra google. Gera alternatyva - Prononmail.\nTad dabar pažiūrėsime kaip susikurti Protonmail ir kaip galėsi atsidaryti emailus Thunderbird laiškų probramėlėje kompiuteryje.\nLaišku programėlės į telefoną - net nediegsime, juk vėl padidintume riziką.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "",
    "text": "5.1 Shell ir Terminalas\nŠiek tiek istorijos… Senais laikais kompiuteriai buvo milžiniški. Kad būtų patogiau (santykinai) su jais dirbti, žmonės prisėsdavo prie ekrano su klaviatūra, kuris buvo sujungtas su kompiuteriu. Ši instaliacija – ekranas su klaviatūra – buvo vadinama terminalu. Darbuotojai rašydavo komandas, o kompiuteris jas vykdydavo ir grąžindavo rezultatus. Tais laikais buvo rašomos komandos, nes kompiuteriai dar nebuvo tokie galingi ir neturėjo GUI (graphical user interface, lt - grafinės vartotojo sąsajos). Taigi, terminalas buvo CLI (command line interface, lt- komandų eilutės sąsaja), nes priimdavo komandas. Tai yra vartotojo sąsaja, kurioje komandos įvedamos (input) tekstu, o rezultatai rodomi kaip teksto išvestis (output). Skirtingai nuo GUI, kur naudojami vizualiniai elementai, tokie kaip langai ir mygtukai, CLI leidžia tiesiogiai rašyti instrukcijas, kurias vykdo sistema.\nKiek vėliau, atsiradus ekranams…\nŠiais laikais, kai norime, kad kompiuteris vykdytų komandas, taip pat naudojamės terminalu, tik jau ne fiziniu, o program, kuri emuliuoja fizinį terminalą.\nPrograma, kuri priima ir vykdo komandas, bendrai vadinama Shell. Ji priima komandas, išverčia jas į kompiuterio suprantamą kalbą ir liepia kompiuteriui jas įvykdyti. Po to, gavusi rezultatus, ji juos parodo terminale. Yra keletas skirtingų Shell “kalbų” arba tipų. Populiariausi Shell tipai, tokie kaip Bash (Bourne Again Shell), yra standartinė kiekvienos Linux sistemos dalis. Zsh (Z Shell) yra standartinis Shell MacOS sistemose, tačiau jis vis labiau populiarėja ir tarp Linux vartotojų.\nShell programos leidžia automatizuoti įvairias užduotis ir vykdyti sudėtingas komandas. Be to, Shell turi programavimo kalbos savybių, leidžiančių rašyti skriptus – failus su komandomis, kurios vykdomos viena po kitos.\nTaigi terminalas yra CLI programa, kuri leidžia pasiekti Shell sąsają. Jį galima įsivaizduoti kaip langą kompiuteryje, per kurį įvedi komandas ir matai jų rezultatus. Terminalo programos naudojamos įvairiose operacinėse sistemose, nes jos leidžia efektyviau valdyti sistemą nei daugelis grafinių vartotojo sąsajų. Naudodajantis terminalu, gali atlikti įvairias užduotis greičiau ir tiksliau.\nAtidaryk terminalo programą ir įrašyk šią komandą. Ji parodys, kur yra Shell ir koks būtent Shell tipas naudojamas.\nAtsakymas (output) parodo vykdomojo Shell failo vietą – Shell programą, kuri šiuo metu naudojama tavo terminale. Iš output taip pat gali matyti, koks tai Shell tipas. Šiuo atveju, tai Bash.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#shell-ir-terminalas",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#shell-ir-terminalas",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "",
    "text": "The IBM 2741 Terminal IBM\n\n\n\n\n\n\n22.0 IBM Modell 360 / 370 IBM\n\n\n\n\n\n\n\nwhich $SHELL",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#iš-ko-susideda-cli-komanda",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#iš-ko-susideda-cli-komanda",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.2 Iš ko susideda CLI komanda?",
    "text": "5.2 Iš ko susideda CLI komanda?\nAtsidaryk terminalo programą. Štai ką turėtum pamatyti:\n\n\n\nTerminal su matomu prompt\n\n\n\nPrompt\n\nTerminale iškart matai prompt – tai teksto eilutė, kuri nurodo, kad sistema yra pasirengusi priimti komandą. Ši eilutė dažniausiai rodo informaciją apie dabartinę direktoriją, vartotojo vardą ar kitus naudingus duomenis. Pavyzdžiui:\njustas@linux-pc:~$\nČia rodoma: vartotojo vardas @ kompiuterio pavadinimas. Simbolis ~ nurodo aktyvią darbinę direktoriją (namų direktoriją), o $ reiškia, kad sistema laukia įvesties (todėl ir vadinama prompt – iššaukimas). Kas yra darbinė direktorija, sužinosime vėliau.\nŠtai pavyzdys, kai Shell yra užsiėmęs ir nėra pasirengęs priimti tavo komandos:\n\n\n\nTerminal vykdo užduotį\n\n\n\nŽymeklis (Cursor)\n\nMirksintis žymeklis (cursor) rodo, kad terminalas pasirengęs priimti kitą įvestį ir nurodo, kurioje vietoje eilutėje bus įrašas.\n\nKomanda (command)\n\nKomanda (angl. command) yra specifinis nurodymas, kurį vartotojas įveda, kad būtų atliktas tam tikras veiksmas sistemoje. Komandos gali būti naudojamos įvairiems veiksmams atlikti, pvz., failų kopijavimui, direktorijų kūrimui ar informacijos rodymui. Pavyzdžiui, komanda ls rodo dabartinės direktorijos failus ir subdirektorijas:\nls\nKai kurios komandos turi subkomandas. Pavyzdžiui, apt yra komanda, atsakinga už programinės įrangos (angl. software) valdymą, tačiau ji naudojama su subkomandomis:\n\napt update:: Atnaujina prieinamų programų sąrašą.\napt install: Instaliuoja nurodytą paketą.\napt remove: Pašalina nurodytą paketą.\napt upgrade: Atnaujina visus diegtus paketus į naujausias versijas\n\nKad bet kas negalėtų instaliuoti programų, ši komanda turi būti vykdoma su administratoriaus teisėmis, pasitelkiant komandą sudo. Todėl kartais naudojamos kelios komandos iš eilės:\nsudo apt update\nsudo apt install cowsay\n\nPasirinkimai ir argumentai (Option, Argument)\n\nPasirinkimas (angl. option) ir argumentas (angl. argument) yra papildomi parametrai, kurie gali būti pridėti prie komandos, siekiant tiksliau nurodyti, kaip komanda turėtų būti vykdoma.\nPasirinkimas (option): Pasirinkimas modifikuoja komandos elgesį. Jis dažnai pridedamas prie komandos su brūkšneliu (-) arba dvigubu brūkšneliu (--). Pavyzdžiui, naudojant ls -l, -l yra pasirinkimas, kuris rodo failų sąrašą ilgąja forma. Naudojant sutrumpintus pasirinkimus, naudojamas vienas brūkšnys -, o išrašant pilną pavadinimą – dvigubas brūkšnys --.\nArgumentas (argument): Argumentas yra papildoma informacija, kurią komanda naudoja veikimui. Pvz., ls Documents nurodo, kad komanda ls turėtų parodyti direktorijos Documents turinį. Šiuo atveju Documents yra argumentas.\n\n\n5.2.1 Praktika\n\nIdentifikuok užklausą (prompt), komandą (command), pasirinkimą (option) ir argumentą (argumentą). Nepanikuok, jei nepažįsti pačių komandų.\n\nmain-user@linux-mint:~$ sudo apt install -y cowsay\nmain-user@linux-mint:~$ cd Downloads\nmain-user@linux-mint:~$ rm -rf test/\nmain-user@linux-mint:~$ ls -alh /home/user/Downloads\nmain-user@linux-mint:~$ mkdir -p /project/data\n\nSurask būdą, kaip sukurti skirtukus (tabs) terminalo lange. Kartais yra labai patogu turėti kelis skirtingus terminalo skirtukus. Pavyzdžiui, viename galite stebėti kompiuterio temperatūrą, kitame valdyti ir paleisti programas, o trečiame - stebėti, ar sistema nefiksuoja kokių nors klaidų. Bet kaip atidaryti skirtukus? Koks yra klaviatūros trumpinys? Jei norėtumėte paleisti ne skirtuką, o atskirą langą, koks trumpinys tai padarytų?\n\n\n\nSusirask terminalo grafinius nustatymus ir pakeisk foną, teksto spalvą ir kitus stiliaus elementus. Rask tau patinkantį stilių. Nebijok eksperimentuoti!\n\n\n\nNors dažniausiai žymeklis yra blyksintis kvadratėlis, surask, kaip jį pakeisti į |?",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#linux-failų-sistema",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#linux-failų-sistema",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.3 Linux failų sistema",
    "text": "5.3 Linux failų sistema\nTerminai “direktorija”, “katalogas” ir “aplankas” dažnai vartojami kaip sinonimai ir paprastai reiškia tą patį – vietą failų sistemoje, kur gali būti saugomi failai ir kiti subkatalogai. Tačiau yra keletas kultūrinių ir kontekstinių niuansų:\n\nDirektorija (angl. directory): Techninis terminas, dažniausiai vartojamas Unix/Linux bendruomenėje ir kitose techninėse aplinkose. Jis pabrėžia hierarchinę failų sistemos struktūrą.\nKatalogas: Tai dar vienas techninis terminas, dažnai vartojamas kaip sinonimas direktorijai. Šis terminas paplitęs tiek techninėje, tiek kasdieninėje kalboje.\nAplankas (angl. folder): Terminas, dažniausiai naudojamas grafinėse vartotojo sąsajose (GUI), pavyzdžiui, Windows ir Mac OS. Nors jis iš esmės reiškia tą patį kaip direktorija ar katalogas, jis dažniau vartojamas GUI kontekste.\n\nČia aš naudosiu terminą „direktorija“, nes jis yra artimiausias angliškam „directory“. Tačiau kartais galiu panaudoti ir „aplanką“ ar „katalogą“, tad nenustebk.\n\n5.3.1 sudo\nPraeitame skyriuje aptarėme, kad tam tikroms komandoms vykdyti reikia naudoti sudo, t.y., eskaluoti (pakelti) savo vartotojo privilegijas iki administratoriaus (root) lygio. Tam reikia įvesti slaptažodį. Taip užtikrinamas saugumas, kad bet kas negalėtų vykdyti pavojingų veiksmų sistemoje.\nPaprastas vartotojas (user) ir administratorius (root) Linux sistemoje turi skirtingas teises ir privilegijas:\nuser:\n\nTeisės: Turi ribotas teises, gali atlikti veiksmus tik savo namų direkorijoje (home directory) ir kitose direktorijose, kuriose turi suteiktas teises.\nPriėjimas: Negali atlikti sisteminės administracijos užduočių, pvz., negali įdiegti ar pašalinti programinės įrangos, keisti sisteminių failų ar atlikti daugumos konfigūracijos pakeitimų.\n\nroot\n\nTeisės: Turi pilną administracinę prieigą prie visos sistemos. Gali atlikti bet kokias užduotis, įskaitant sisteminių failų modifikavimą, vartotojų administravimą, programinės įrangos diegimą ir pašalinimą.\nPriėjimas: Gali atlikti bet kokias operacijas be apribojimų.\n\nPaprastas vartotojas, vykdydamas sudo, gali laikinai gauti root teises, pvz.:\nsudo apt install &lt;programa&gt;\nPerėjimas iš paprasto vartotojo į root yra galimas tik tiems vartotojams, kurie yra įtraukti į sudo grupę. Instaliuojant Linux, pirmasis vartotojas automatiškai pridedamas prie šios grupės, tačiau vėliau sukurti vartotojai gali būti pridėti į sudo grupę pagal poreikį.\n\n\n5.3.2 root direktorija\nWindows operacinėje sistemoje turbūt matei diskus, pažymėtus raidėmis, pavyzdžiui, C:, D:, E:. Tai nereiškia, kad kompiuteryje yra keli fiziniai kietieji diskai. Dažniausiai tai yra vienas kietasis diskas, padalytas į logines dalis.\n\n\n\nŠaltinis OnlineComputerTips\n\n\nPavyzdžiui, C: diske paprastai saugomi Windows failai, o vartotojai dažnai naudoja kitą diską failams saugoti. Šie „diskai“ yra visiškai atskirti vienas nuo kito.\nLinux sistemoje viskas veikia šiek tiek kitaip. Net jei kompiuteryje būtų keli fiziniai diskai, jie gali būti sujungti į vieną loginę talpą (angl. logical volume) ir „pakišti“ po root direktorija, kuri žymima /.\nRoot direktorija yra failų sistemos viršūnė, žymima /. Visi kiti failai ir direktorijos yra šios šakninės direktorijos pavaldiniai. Tai atitinka Windows C: diską.\n\n\n\nŠaltinis\n\n\nČia rasi daug subdirektorijų. Svarbiausios iš jų:\n\n/root: Root vartotojo (administratoriaus) namų direktorija.\n/etc: Konfigūracijos failai, kurie kontroliuoja įvairių programų paleidimą ir veikimą.\n/home: Paprastų vartotojų namų direktorijos, pvz., /home/justas/, /home/ruprecht/.\n/mnt: Laikina vieta prijungtoms laikmenoms, tokioms kaip kietieji diskai ar tinklo diskai.\n/media: Katalogas, kuriame pritvirtinami USB, CD ar DVD įrenginiai.\n/bin: Sisteminiai vykdomieji failai, pvz., ls, cp, mv.\n/lib: Bibliotekos, būtinos sisteminėms programoms ir komandų vykdymui.\n\nKai atidarai failų naršyklę (Linux Mint tai programa Nemo), tavo namų direktorija bus po /home/vartotojas/. Štai kaip atrodytų naršy\n/\n└── home\n    ├── user name\n\nVisada gali pasitikrinti savo buvimo vietą, paspaudžiant ant „Toggle Location Entry“:\n\n\n\n5.3.3 Praktika\n\nAtsidaryk excalidraw naršyklėje ir nupiešk /, /home/, /media/ struktūros diagramą. Įsivaizduok, kad kompiuteryje yra trys vartotojai: justas, ruprechtas ir slibinas. Nupiešk jų namų direktorijas.\nĮkišk USB laikmeną į kompiuterį, atidaryk failų naršyklę (Nemo). Turėtum pamatyti kažką panašaus. Paspausk ant USB laikmenos, tada spustelėk „Toggle Location Entry“ ir identifikuok, kurioje failų sistemos vietoje yra USB laikmena. Pridėk tai prie diagramos, kurią piešei.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#keliavimas-failų-sistema",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#keliavimas-failų-sistema",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.4 Keliavimas failų sistema",
    "text": "5.4 Keliavimas failų sistema\nJau šiek tiek susipažinai su Linux failų sistemos struktūra. Kai atsidarai failų naršyklę (Nemo), matai šias direktorijas:\n\nDirektorijų medyje tai atrodytų taip:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\nŠiame skyriuje išmoksi, kaip sužinoti, kur esi, su komanda pwd, kaip pakeisti direktoriją su cd ir kaip atspausdinti failų bei direktorijų sąrašą su ls.\nTačiau prieš einant prie pačių komandų, tau dar reikis susipažinti su vienu svarbiu konceptu - absoliučiu ir relatyviu adresu (arba keliu, nes angliškai - path).\n\n5.4.1 Absoliutus kelias\nAbsoliutus kelias (angl. absolute path) yra pilnas kelias nuo šaknies direktorijos (/) iki konkretaus failo ar katalogo. Jis visada nurodo tą pačią vietą, nepriklausomai nuo to, kur esi šiuo metu.\nPavyzdžiui, šis kelias nurodo visą maršrutą nuo / per /home/, vartotojo namų direktoriją /justas/iki subdirektorijos Documents, kurioje yra failas data.csv:\n/home/justas/Documents/data.csv\n\n\n5.4.2 Relatyvus kelias\nRelatyvus kelias (angl. relative path) yra nurodomas atsižvelgiant į dabartinę darbinę direktoriją. Jis neturi pradinio /, todėl priklauso nuo to, kur esi.\nJeigu šiuo metu esi direktorijoje/home/justas, relatyvus kelias į failą data.csv subdirektorijoje Documents būtų:\nDocuments/data.csv\nKartais gali pamatyti relatyvų kelią su . (tašku), kuris reiškia “esama direktorija”. Taigi šis relatyvus kelias irgi tinka:\n./Documents/data.csv\n\n\n5.4.3 ~\nVartotojų vardai Linux sistemoje gali skirtis, pvz., justas, ruprechtas ir t.t. Tarkime, rašai skriptą, kuris turi veikti vartotojo Downloads direktorijoje. Tu negali žinoti vartotojo vardo, todėl naudoti absoliutų kelią /home/justas/Downloads būtų nepatogu.\nBet ir relatyvus kelias ./Downloads gali sukelti problemų, nes skriptas gali būti paleistas ne iš vartotojo namų direktorijos, o tiesiai iš Downloads direktorijos, kas sukurtų absurdišką Downloads/Downloads.\n/\n└── home\n    ├── justas\n    │   ├── Downloads\n    │     ├── ./Downloads\nŠtai čia gelbsti ~. Shell atpažįsta ~ kaip nuorodą į dabartinio vartotojo namų direktoriją.\nTaigi relatyvus kelias~/Downloads yra automatiškai keičiamas į /home/justas/Downloads, jeigu vartotojas yra justas, arba į /home/ruprecht/Downloads, jeigu vartotojo vardas yra ruprecht.\nKada naudoti ką?\n\nAbsoliutūs keliai dažniausiai naudojami skriptuose, konfigūracijų failuose, dokumentacijoje ir sisteminiuose veiksmuose.\nRelatyvūs keliai labiau tinka kasdieniam darbui su failais, naršymui ir interaktyviam scenarijų vykdymui.\n\n\n\n5.4.4 pwd\nJau kelis kartus minėjome darbinę direktoriją. Kas tai? Darbinė direktorija yra ta direktorija, kurioje šiuo metu “gyvena” shell. Įsijunk terminalą, įrašyk komandą pwd ir paspausk Enter, kad ją įvykdytum. Komanda pwd (angl. “print working directory”) parodo dabartinės darbinės direktorijos pilną kelią (path).\npwd\n\nŠiuo atveju darbinė direktorija yra /home/justas.\nTaigi, iš mano darbinės direktorijos, Downloads subdirektorijoje esantis failas data.csv man būtų pasiekiamas Downloads/data.csv keliu. Tačiau aš galiu pakeisti savo darbinę direktoriją pereidamas į kitas direktorijas su komanda cd.\n\n\n5.4.5 cd\nKomanda cd (angl. change directory) naudojama pereiti iš vienos direktorijos į kitą. Kai pereini į kitą direktoriją, pasikeičia ir darbinė direktorija, kartais dar vadinama aktyvia direktorija (angl. current directory).\nĮvedęs komandą:\ncd Downloads\nAš pereinu į Downloads subdirektoriją. Kadangi Downloads yra mano namų direktorijoje, galėjau pasinaudoti relatyviu keliu. Atkreipk dėmesį, kaip pasikeičia terminalo prompt: vietoj ~ (jau žinai, ką jis reiškia), dabar matosi ~/Downloads.\n\nDabar failas Downloads/data.csv tampa pasiekiamas tiesiog kaip data.csv.\nKomandai cd gali duoti absoliutų kelią, ir tada cd pakeis darbinę direktoriją, nesvarbu, kur tuo metu esi:\ncd /home/justas/Documents\nŠi komanda perkelia mane iš Downloads tiesiai į Documents.\n\nTačiau cd komandai gali nurodyti ir relatyvų kelią, svarbu, kad jis egzistuotų. Pavyzdžiui, aš galiu pereiti iš savo namų direktorijos į Downloads su cd Downloads/, tačiau negaliu pereiti į Documents, jei esu Downloads direktorijoje, nes Documents ten nėra. Tada gaunu klaidos pranešimą: bash: cd: Documents/: No such file or directory.\n\nPriminimui:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\nKaip jau minėjau, taškas . reiškia “čia”. Pvz., iš namų direktorijos galėčiau pereiti į Downloads su cd ./Downloads.\nYra ir .., du taškai, kurie reiškia direktoriją esančią aukščiau už dabartinę (.) direktoriją. Ji dažnai vadinama parent directory. Taigi, su komanda cd ./Downloads nuėjęs į Downloads, galiu vėl pakilti į viršų su cd ...\n\n.. taip pat gali būti naudojama pereiti relatyviai, pvz., iš Downloads į Documents. Būdamas Downloads direktorijoje, galiu naudoti komandą cd ../Documents, kad pakilčiau vienu lygiu aukščiau ir tada pereičiau į Documents.\n\n.. gali būti naudojama ir kelis kartus iš eilės, pvz., iš Downloads galima pakilti į home, naudojant cd ../...\n\nPriminimui\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\nKomandą cd gali naudoti ir be jokių argumentų, kad grįžtum į namų direktoriją, pvz., cd arba su cd ~.\n\nPereiti į ankstesnę direktoriją gali su komanda cd -. Tarkime, buvau home/justas/Downloads, perėjau į home/justas/Documents, bet supratau, kad padariau klaidą - norėčiau likti Downloads. Galiu grįžti atgal su cd -.\n\nSveikinu! Dabar jau moki naršyti po direktorijas naudojant terminalą. Nors tai gali atrodyti sudėtinga iš pradžių, laikui bėgant pastebėsi, kad paleisti terminalą su klaviatūros trumpiniu Ctrl-Alt-T ir, naudojant TAB greitesniam komandų ir argumentų užpildymui, greitai nueiti į norimą direktoriją bei redaguoti failus bus daug greičiau nei tai daryti su grafinės sąsajos (GUI) įrankiais.\nPvz., iš savo namų direktorijos pereinu į Documents, tada į project, tada į documentation, atspausdinu failų sąrašą su ls ir redaguoju failą su nano programa.\nVideo\nBet kas ta ls komanda?\n\n\n5.4.6 ls\nKomanda ls (angl. list storage) naudojama norint peržiūrėti failų ir katalogų sąrašą dabartinėje arba nurodytoje direktorijoje. Tai viena dažniausiai naudojamų komandų, naviguojant failų sistemoje.\nJei atidarytum failų naršyklę, pavyzdžiui, Nemo, matytum kažką panašaus:\n\nLygiai taip pat failų sąrašą gali parodyti ir terminale, įvedant komandą ls:\n\nKomanda ls gali priimti argumentą – direktorijos kelią, kurio turinį norima parodyti. Šis kelias gali būti tiek absoliutus, tiek relatyvus. Pavyzdžiui, ls /home/justas/Downloads parodys Downloads katalogo turinį. Atkreipk dėmesį į spalvas: failai yra balti, o katalogai – mėlyni.\n\nKartais pamatyti tik failų pavadinimus gali būti nepakankama. Galbūt norisi matyti daugiau informacijos, pvz., kada failai sukurti, kas turi teises juos valdyti ar matyti, ar kam jie priklauso.\n\nKaip ir failų naršyklėje, kur gali perjungti į “List View”, terminale gali naudoti komandos ls nustatymą -l, kuris išveda išsamų (ilgą) failų sąrašą su papildoma informacija: teisėmis, savininku, dydžiu ir paskutinio modifikavimo data.\n\nPavyzdžiui ką tokią eilutė reikšia, paaikšinsiu netrukus.\ndrwxr-xr-x 2 justas justas 4096 Sep 15 10:19 Desktop\nNorint pamatyti visus failus, įskaitant paslėptus (failai, kurių pavadinimai prasideda tašku), gali naudoti -a arba --all:\n\nNemo failų naršyklėje taip pat gali pamatyti paslėptus failus, jei aktyvuosi šią funkciją.\nVideo\nKai paleidi ls -l, failų dydžiai nurodomi baitais. Kartais naudingiau matyti dydžius, išreikštus žmonėms suprantamesniais vienetais, kaip kilobaitai (1000 baitų), megabaitai (1000 kilobaitų) ir t.t. Tam gali naudoti nustatymą --human-readable arba trumpinį -h - ls -lh\nŠios abi komandos ls -all -l --human-readable ir ls -alh yra teisingos, tačiau dažniau naudojamas trumpesnis variantas. Panaudojant ls -alh, galėsi matyti paslėptus failus, o failų dydžiai bus išreikšti žmonėms labiau suprantama forma.\n\nKartais gali prireikti rekursyvaus katalogo turinio peržiūros. Komanda ls -R arba ls --recursive parodys ne tik pasirinktos direktorijos, bet ir visų jos subdirektorijų turinį.\n\n\n\n5.4.7 Teisės ir tipai\nŠi eilutė rodo failų arba direktorijų sąrašą su jų detalėmis:\n\nPirmas stulpelis parodo, kokio tipo failas ar direktorija tai yra, ir kokias teises turi skirtingi vartotojai.\nPirmoji raidė gali būti:\n\nd – Direktorija (directory)\nl – Simbolinė nuoroda (link)\n- – Įprastas failas (regular file)\n\nLinux sistemoje yra trys vartotojų tipai:\n\nSavininkas – vartotojas, kuris sukūrė failą arba direktoriją. Šiuo atveju vartotojas yra justas.\nGrupė – Grupė, kuriai priklauso failo savininkas. Dažnai grupės vardas yra tas pats kaip ir savininko vartotojo vardas, pvz., justas. Vartotojai gali priklausyti kelioms grupėms, tačiau kiekvienas failas ir direktorija turi pagrindinę grupę, kuri turi tam tikras teises į tą failą arba direktoriją. Pameni minėjom, kad ne visi vartotojai priklauso sudo grupei? Čia panašiai, tik kita grupė.\nKiti (other) – Visi kiti vartotojai, kurie nėra nei savininkas, nei grupės nariai. Tai apima visus kitus sistemos vartotojus, kurie neturi specialių teisių šiam failui ar direktorijai.\n\nTeisės nurodomos pirmame stulpelyje trimis tripletais: xxx-xxx-xxx (be brūkšnių).\n\nr – Skaitymo teisė (read), leidžia matyti ir skaityti turinį.\nw – Rašymo teisė (write), leidžia perrašyti turinį.\nx – Vykdymo teisė (execute), leidžia vykdyti failą.\n\nPvz., teisės drwxr-xr-x:\n\nd – Direktorija (directory)\nrwx – Savininko teisės: skaitymas (read), rašymas (write), vykdymas (execute)\nr-x – Grupės teisės: skaitymas (read), vykdymas (execute)\nr-x – Kitų vartotojų teisės: skaitymas (read), vykdymas (execute)\n2 – Nuorodų skaičius į šią direktoriją. Tai apima nuorodą į pačią direktoriją ir bet kurias subdirektorijas. Pavyzdžiui, jei skaičius būtų 4, tai reikštų, kad direktorijoje yra trys subdirektorijos (ir arba failai) ir viena pati direktorija.\njustas – Direktorijos savininko vartotojo vardas.\njustas – Direktorijos grupės vardas.\n4096 – Direktorijos dydis baitais.\nSep 15 10:19 – Paskutinio direktorijos modifikavimo data ir laikas.\nDesktop – Direktorijos pavadinimas.\n\n\n\n5.4.8 Pagalbinės funkcijos terminale\n\n\n5.4.9 history\nKomanda history (liet. „istorija“) naudojama norint parodyti visų anksčiau įvestų komandų sąrašą dabartinėje terminalo sesijoje. Tai suteikia patogų būdą sekti ir kartoti anksčiau vykdytas komandas.\n\nJei nori parodyti tik paskutines n komandų, gali naudoti history n. Pvz., parodyti paskutines 10 komandų history 10:\n\nKartoti konkrečią komandą pagal numerį galima įrašius ! ir komandos numerį. Pavyzdžiui, jei nori pakartoti komandą, kurios numeris yra 99:\nhistory\n!99\n\nIštrinti komandų istoriją galima su history -c.\nhistory -c\nhisotry\n\n\n\n5.4.10 clear\nKomanda clear (liet. „valyti“) naudojama norint išvalyti terminalo ekraną, pašalinant visus anksčiau įvestus ir parodytus tekstinius duomenis. Tai palieka terminalą švarų ir patogesnį tolimesniam naudojimui. Svarbu: ši komanda neištrina terminalo istorijos (history); ji tik paslenka visą tekstą į viršų, už dabartinio vaizdo ribų.\nclear\n\n\n5.4.11 Ctrl-L\nAlternatyva komandos clear naudojimui yra klaviatūros trumpinys Ctrl-L. Šis trumpinys atlieka tą pačią funkciją kaip ir komanda clear, tačiau jis yra greitesnis ir patogesnis, ypač kai dirbi terminale ir nori greitai išvalyti ekraną. Naudojant Ctrl-L, terminalo ekranas bus išvalytas, tačiau terminalo istorija liks nepakitusi.\n\n\n5.4.12 Navigacija terminale\nRašant ilgas komandas, klaidos neišvengiamos. Pavyzdžiui, rašai „Hello World“ ir paspaudi Enter ⏎, tik tada supranti, kad reikėjo parašyti echo prieš „Hello World“.\nŠtai kaip tai gali ištaisyti:\n\nPakilk į ankstesnę eilutę naudodamas rodyklę į viršų ⬆️.\nPerkelk kursorių į eilutės pradžią naudodamas rodyklę į kairę ⬅️.\nPrirašyk echo ir pakartok komandą paspaudus Enter ⏎.\n\nVideo\nKartais eilutės būna gana ilgos:\nsud apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update\nJei praleidai raidę, pavyzdžiui, pirmame sudo truksta o, nereikia viską iš naujo rašyti\n\nPakilk į ankstesnę eilutę naudodamas rodyklę į viršų ⬆️.\nNaudokCtrl-A, kad perkeltum kursorių į eilutės pradžią.\n➡️ ➡️ ➡️ ir pridėti o raidę.\npabaigus taisymą tiesiog paspausti Enter ⏎ (nebūtina nueiti į eilutės pabaigą)\n\nVideo\nTavo žiniai:\n\nCtrl-A: perkelia kursorių į eilutės pradžią\nCtrl-E: perkelia kursorių į eilutės pabaigą\nCtrl-U: ištrina viską į dešinę nuo kursoriaus\n\nUžduotis:\nPastebėsi, kad Ctrl-C ir Ctrl-V neveikia taip, kaip esame įpratę. Terminalo nustatymuose (settings) rask derinį, kuris atitinka įprastines Ctrl-C ir Ctrl-V kombinacijas.Kokie jie?\n\n\n5.4.13 Ctrl-C ir Escape\nNaudojant komandinę eilutę, kartais terminalas gali „pakibti“. Pvz., jei pradėsi rašyti echo su kabutėmis, bet pamirši uždaryti kabutes, terminalas lauks, kol užbaigsi komandą.\nTokiais atvejais terminalas gali atrodyti „pakibęs“. Pabandyk paleisti šias komandas po vieną:\n$ echo \"hello\n$ grep foobar\n$ yes\n$ tail\n$ cat\nNorėdamas nutraukti „pakibusią“ komandą, naudok Ctrl-C. Šis derinys siunčia kontrolės signalą terminalui ir nutraukia vykdomą procesą. Pastaba: Ctrl-C čia reiškia „Cancel“ (nutraukti).\nKartais terminale gali pamatyti ^C, rodančią, kad buvo paspaustas Ctrl-C. Jei Ctrl-C neveikia, pabandyk ESC klavišą.\nVerta žinoti: kad kartais vietoj Ctrl- notacijos, gali sutikti ^ notaciją, pvz., ^C, ^O, ^X.\n\n\n5.4.14 Praktika\n\nKai paleidi terminalą, kurioje direktorijoje esi? Pakeisk direktoriją į Downloads. Uždaryk terminalą ir paleisk jį iš naujo. Kur dabar esi?\nIš/home/user/ direktorijos pereik į Downloads ir atspausdink direktorijos turinį naudojant ls. Užduotis:\n\nFailų dydis būtų suprantamas žmonėms.\nSąrašas būtų pateikiamas viename stulpelyje.\n\nIš /home/user/ direktorijos pereik į Documents. Iš ten atspausdink failų sąrašą Downloads (!!!) direktorijoje\n\nnaudojant absoliutų kelią\nnaudojant relatyvų kelią\n\n\nPagalbai:\nHome Directory/\n├── Desktop/\n├── Documents/\n├── Downloads/\n├── Music/\n├── Pictures/\n├── Public/\n├── Templates/\n└── Videos/\n\nNaudok clear, kad išvalytum terminalą, tada su history surask tau patinkančią komandą ir pakartok ją naudojant !n.\nVizualizuok vartotojų ir grupių santykius pagal šią lentelę. Naudok Excalidraw:\n\n\n\n\nVartotojas\nSudo grupė\nGrupė “namai”\n\n\n\n\nroot\nTaip\nTaip\n\n\njustas\nTaip\nTaip\n\n\nruprechtas\nNe\nTaip\n\n\n\n\nĮsivaizduok, kad failas /home/ruprechtas/info.txt turi tokias savybes:\n\n-rwx----- 2 ruprechtas namai 4096 Sep 15 10:19 info.txt\nAr vartotojas justas, priklausantis grupei namai, galės atidaryti ir perrašyti šį failą? Kodėl?\n\nKą reikėtų pakeisti, kad vartotojas justas galėtų matyti ir perrašyti šį failą? Atsakyk teoriškai (nes dar nežinai komandų, kuriomis tai apdaryti).\nNukopijuok ir paleisk šią komandą terminale.\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/e61bb3ab5cf28686f74a50e436b06fe6/raw | bash\nŠi komanda parsisiųs ir įvykdys skriptą, kuris sukurs test direktoriją tavo/home/username/ direktorijoje.\nPasinaudok ls, atspausdink visus failus, esančius (sub-)direktorijose ir atsakyk į šiuos klausimus:\n\nKiek yra subdirektorijų test direktorijoje?\nKiek iš viso suskaičiuoji failų? Suskaičiuok visus failus, esančius visose subdirektorijose.\nKokio tipo failų (pvz., .txt, .csv) yra daugiausia? Kurioje direktorijoje?",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#funkcijos",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#funkcijos",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.5 Funkcijos",
    "text": "5.5 Funkcijos\nVisos skyriuje panaudotos funkcijos\n\n\n\n\n\n\n\nFunkcija\nAprašymas\n\n\n\n\nwhich\nParodo vykdomojo failo vietą\n\n\npwd\nParodo dabartinės darbinės direktorijos pilną kelią\n\n\ncd\nPakeičia dabartinę direktoriją (esamą vietą) terminale\n\n\nls\nRodo failų ir katalogų sąrašą direktorijoje\n\n\nsudo\nLeidžia vykdyti komandas su kitokio vartotojo teisėmis (dažniausiai root)\n\n\nhistory\nRodo ankstesnių komandų istoriją\n\n\nclear\nIšvalo terminalo ekraną\n\n\nCtrl-A\nPerkelia kursorių į eilutės pradžią\n\n\nCtrl-E\nPerkelia kursorių į eilutės pabaigą\n\n\nCtrl-U\nIštrina viską į kairę nuo kursoriaus\n\n\nCtrl-C\nNutraukia vykdomą komandą terminale\n\n\nCtrl-L\nIšvalo terminalo ekraną (panašu į clear)\n\n\nShift-Ctrl-C\nKopijuoja tekstą iš terminalo\n\n\nShift-Ctrl-V\nĮkelia tekstą į terminalą\n\n\nShift-Ctrl-T\nSukuria naują terminalo skirtuką\n\n\nShift-Ctrl-N\nSukuria naują terminalo langą",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/6_bash_comands_basic.html",
    "href": "b_bash_pagrindai/6_bash_comands_basic.html",
    "title": "6  BASH komandos",
    "section": "",
    "text": "6.1 Failų ir direktorijų valdymas\nPraėjusiame skyriuje išmokai naviguoti terminale naudojant komandas pwd ir cd. Sužinojai apie Linux failų sistemą: kaip matyti visų failų ir katalogų sąrašą naudojant ls komandą, bei tai, kad Linux sistemoje vartotojai turi skirtingas teises, priklauso grupėms, ir kiekvienas failas turi savininko, grupės, bei kitų vartotojų teises naudotis tuo failu ar katalogu. Taip pat išmokai svarbių klaviatūros trumpinių, kaip peršokti į komandinės eilutės pradžią (Ctrl-A), pabaigą (Ctrl-E), nutrinti dalį (Ctrl-U), kaip kopijuoti ir įklijuoti į terminalą naudojant Ctrl-Shift-C ir Ctrl-Shift-V. Išmokai dirbti su terminalo istorija naudojant history ir kartoti komandas su !n.\nŠiame skyriuje skirsi dėmesį darbui su failais ir direktorijomis. Tu išmoksi kurti failus ir direktorijas, juos kopijuoti, perkelti, ištrinti. Taip pat išmoksi sujungti kelias komandas. Ir šio skyriaus pabaigoje pamatysi, kad tavo BASH įgūdžiai tampa dar stipresni!\nPrieš pradedant, įsitikink, kad turi keletą svarbių programų: jq ir curl. Kaip ir praėjusiame skyriuje, kai ieškojaiwhich $SHELL, komanda tau parodė, kur yra binary failas (programa). Dabar padaryk tą patį:\nJei tavo kompiuteris aptinka šias programas, terminalas atspausdins vietą, kur jos yra įdiegtos. Jei terminalas jų neranda, įdiek curl ir jq kaip sisteminius paketus naudojant apt. Jei pamiršai, kaip tai daryti, pakartok ankstesnę medžiagą.\nKai tai atliksi, nukopijuok ir paleisk šią komandą savo terminale - ji sukurs direktoriją shell_2_dalis tavo namų direktorijoje kartu su visais šiam skyriui reikalingais failais:\nJeigu viskas gerai, turėtum pamatyti:\nSu ls komanda atspausdink long formatu savo home directory turinį. Paaiškink visas šios eilutės reikšmes.\nPakeisk savo darbinę direktoriją į ~/shell_2_dalis. Kaip pasikeitė tavo prompt? Paaiškink, kas čia yra kas.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/6_bash_comands_basic.html#failų-ir-direktorijų-valdymas",
    "href": "b_bash_pagrindai/6_bash_comands_basic.html#failų-ir-direktorijų-valdymas",
    "title": "6  BASH komandos",
    "section": "",
    "text": "By J. Howard Miller - U.S. National Archives and Records Administration\n\n\n\n\nPatikrink, ar turi curl, su which curl.\nPatikrink, ar turi jq, su which jq.\n\n\n\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/b4bfc0d672a859afc0fe28f1e721e167/raw | bash\n\n\n\n\n\n\n\n\nTip\n\n\n\nPasikartok komandas cd, prisimink absoliutų ir reliatyvų kelią, bei ką reiškia ~, . ir ... Šiame skyriuje taip pat dažnai reikės naudoti ls, tad pasikartok šią komandą ir jos nustatymus dabar.\n\n\n\n\n\n\n\n6.1.1 echo\nKomanda echo naudojama norint atspausdinti vartotojo įvestį (input) terminale (dar vadinamą standartine išvestimi, angl. standard output). Tai paprasta, bet galinga komanda, dažnai naudojama skriptuose pranešimams rodyti arba kintamųjų reikšmėms tikrinti.\nNors nėra būtina tekstą apskliausti kabutėmis, dėl geresnio aiškumo ir įskaitomumo patartina tai daryti.\necho Hello World!\necho 'Hello World!'\necho \"Hello World!\"\nReikėtų atkreipti dėmesį, jog dvigubos kabutės (\" \") ir viengubos kabutės (' '’) šiek tiek skiriasi. Tekstas, esantis viengubose kabutėse (' '), atspausdinamas paraidžiui, nepaisant ten esančių kintamųjų. Tuo tarpu tekstas, esantis dvigubose kabutėse (\" \"), yra interpretuojamas, ir Shell leidžia naudoti kintamųjų vertes.\nPabandyk šias komandas, kurios naudoja kintamąjį $USER, atspausdinantį shell sesijos vartotojo vardą:\necho My username is $USER\necho 'My username is $USER'\necho \"My username is $USER\"\nAr pastebi, kuo skiriasi išvestis?\n\n\n\n6.1.2 &gt; ir &gt;&gt; operatoriai\n&gt; ir &gt;&gt; operatoriai naudojami išvesties nukreipimui (angl. output redirection). Jie nukreipia komandos išvestį (angl. output) į failą, o ne į terminalą. Šie operatoriai yra esminiai dirbant su failais ir automatizuojant užduotis skriptuose.\n&gt; operatorius nukreipia komandos išvestį į failą, perrašydamas jo turinį, jei failas jau egzistuoja. Jei failas neegzistuoja, jis bus sukurtas.\nŠi komanda sukuria (arba perrašo) failą hello_world.txt su tekstu “Hello World!”.\necho \"Hello World!\" &gt; hello_world.txt\nKaip echo komanda ir jos argumentas “Hello World!” buvo nukreipti į tekstinį failą, taip galime nukreipti ir kitų komandų išvestis į failus. Operatoriaus &gt; argumentas nebūtinai turi būti tik failo pavadinimas, tai gali būti ir failo pavadinimas su absoliučiu ar reliatyviu adresu.\nls &gt; mix/direktorijos_turinys.txt\nŠi komanda nukreipia ls komandos išvestį į failą direktorijos_turinys.txt, kuris yra mix subdirektorijoje. Atsidaryk šį failą ir patikrink, ar jis susikūrė teisingai. Turėtum matyti kažką panašaus į šį vaizdą:\n\n\n\n\n\n\n\nPraktika\n\n\n\nLiekant shell_part_2 direktorijoje, atspausdink namų direktorijos (angl. home directory) turinį su visais paslėptais failais, ilguoju formatu ir žmonėms geriau suprantamais failų ir direktorijų dydžiais, ir nukreipk išvestį į mix subdirektorijoje esantį failą direktorijos_turinys.txt, jį perrašant.\n\n\n\nIntarpas\nHey, ką tik gavai užduotį. Ateityje gausi panašias ir dar sudėtingesnes užduotis. Todėl šioje vietoje padarykime intarpą. Pakalbėkime apie vieną svarbiausių darbo būdų programavime (ir ne tik!) - darbų skaidymą (angl. break down).\nKartais gali gauti labai sudėtingą užduotį, kuri iš pradžių atrodys neįveikiama ar nesuprantama. Tai visiškai normalu. Nestresuok - giliai įkvėpk, iškvėpk, jei reikia, pasiimk popierių ir pieštuką ir pradėk skaidyti darbus į logines sekas. Pvz., prieš tai buvusią užduotį galima suskaidyti į tris dalis:\n\nreikia failų ir direktorijų sąrašo\natspausdinti perrašant\nfailo pavdinimas\n\n\nDabar galima skaidyti ar toliau detalizuoti kiekvieną iš šių dalių.\n\nls -alh pagamina sąrašą ilguoju, žmonėms suprantamų dydžių formatu\n&gt; perrašo\ndirektorijos_turinys.txt bus pavadinimas\n\n\nTačiau dabartinė darbinė direktorija yra ~/shell_part_2, todėl reikia\n\nls -alh kaip argumentą paduoti ~ arba atitinmai /home/username\ndirektorijos_turinys.txt turi būti mix subdirektorijoje\n\n\nSkaidant užduotį į mažesnes dalis, vis labiau suprasi, ką reikia padaryti. Turint daugiau patirties, geriau žinosi, kiek laiko gali prireikti kiekvienam žingsniui.\nPvz., duomenų analitikas gali gauti užduotį: suprognozuoti sekančių metų ledų pardavimus. Analitikas, žinodamas, kad ledų pardavimai priklauso nuo lauko temperatūros, gali suskaidyti darbus taip:\n\nImportuoti istorinius tam tikros vietos temperatūros duomenis\nPrognozuoti sekančių metų kiekvienos dienos temperatūras\nApskaičiuoti kiekvienos dienos pardavimus\nAprašyti duomenis ir pateikti juos užsakovui suprantamu formatu\n\n\n\n\nPhoto by Kamaji Ogino\n\n\nKiekvieną iš šių žingsnių analitikas gali suskaidyti į dar daugiau mažesnių užduočių.\nKodėl tai svarbu? Visų pirma, tai padeda geriau suprasti, ką reikia padaryti, ir kiek tai gali užtrukti. Kiekvienas žingsnis tampa atskiru procesu, ir jei nepavyksta vienas metodas, gali bandyti kitą.\nDarbų skaidymas yra intuityvus procesas kasdieniame darbe ir tu jau šį metodą ir taip taikai pasąmoningai, bet kai gauname naujas ir labai sudėtingas užduotis, vis tiek verta prisiminti šią strategiją, nes kartais mes pamirštame, kaip ji padeda išvengti pasimetimo.\n\n&gt;&gt; operatorius nukreipia komandos išvestį į failą, pridedant (angl. append) prie failo turinio. Jei failas neegzistuoja, jis bus sukurtas.\necho \"What a beatiful morning\" &gt;&gt; day.txt\necho \"What a beatiful day\" &gt;&gt; day.txt\necho \"What a beatiful evening\" &gt;&gt; day.txt\nŠios komandos prideda tekstą “What a beautiful morning”, “What a beautiful day” ir “What a beautiful evening” prie failo day.txt galo, neperrašydamos esamo turinio. Jei tokio failo nėra, jis bus sukurtas.\n\n\n\n\n\n\nPraktika\n\n\n\n\nSusirask tau patinkančios dainos tekstą internete.\nNaudojant komandą echo ir operatorių &gt;, sukurk failą favorite_song.txt. Failo turinys turėtų būti panašus į “My favorite song is ”.\nPirmas keturias dainos eilutes atspausdink į failą song_text.txt naudojant echo ir &gt;&gt;. Nepamiršk, kokie klaviatūros trumpiniai naudojami kopijuojant ir įkeliant tekstą į terminalą!\n\n\n\n\n\n6.1.3 cat\nKomanda cat (angl. concatenate, liet. „sujungti“) naudojama peržiūrėti, sujungti ir atspausdinti failus. Tai viena iš pagrindinių Linux komandų, nes leidžia greitai peržiūrėti failų turinį, įvesti turinį į kitus failus arba sujungti kelis failus į vieną.\nPraeitame skyriuje sukūrei du failus favorite_song.txt ir song_text.txt. Dabar juos ir naudosime.\nAtspausdink failo favorite_song.txt turinį į terminalą:\ncat favorite_song.txt\nPas mane tai atrodo taip:\n\ncat leidžia sujungti kelių failų turinį ir atspausdinti rezultatą terminale:\ncat favorite_song.txt song_text.txt\n\nKaip praeitame skyriuje išmokai, komandos išvestį (nesvarbu, ar tai būtų echo, ar ls) galima nukreipti į failą. Lygiai taip pat gali nukopijuoti failą naudojant cat ir &gt; arba &gt;&gt;:\ncat favorite_song.txt &gt; favorite_song_2.txt\nŠi komanda nukopijuoja failo favorite_song.txt turinį į naują failą favorite_song_2.txt, perrašydama jo turinį, jei toks failas jau egzistuoja.\n\n\n\n\n\n\nPraktika\n\n\n\n\nNaudojant echo ir &gt;&gt;, įrašyk dar 4 eilutes mėgstamiausios dainos teksto į failą song_text_2.txt.\nSujunk failus song_text.txt ir song_text_2.txt, nukreipiant rezultatą į song_text_full.txt:\nPagalvok, kaip naudojant visas iki šiol žinomas komandas, būtų galima gauti song_text.txt failą, kuriame būtų pirmas ketvertas eilučių ir antras ketvertas eilučių teksto?\n\n\n\n\n\n6.1.4 head ir tail\nKomandos head (galva) ir tail (uodega) naudojamos peržiūrėti pirmąsias arba paskutines failo eilutes. Įprastai jos atspausdina 10 eilučių teksto.\n\n\n\n\n\n\nNote\n\n\n\nDabar tavo failas song_text.txt turėtų turėti 8 eilutes teksto. Todėl tokiu pat būdu, kaip prieš tai, pridėk dar 4 eilutes teksto, kad turėtum bent 12.\n\n\nPeržiūrėk pirmas 10 eilučių song_text.txt su head:\nhead song_text.txt\nPeržiūrėk paskutines 10 failo eilučių:\ntail song_text.txt\nTiek head, tiek tail priima nustatymą (option) -n su argumentu, nurodančiu, kiek eilučių atspausdinti:\n\nNorint peržiūrėti pirmas 3 eilutes, naudok komandą: head -n 3 song_text.txt\nNorint peržiūrėti paskutines 5 eilutes, naudok komandą: tail -n 5 song_text.txt.\n\n\n\n\n\n\n\nPraktika\n\n\n\nKas nutiktų, jei panaudotum head arba tail su failu, kuriame nėra 10 eilučių? Pabandyk su favorite_song.txt\n\n\n\n\n\n\n\n\nPraktika\n\n\n\nDabar dirbsi su failu data/temp_vilnius.txt.\n\nNaudojant cat, atspausdink visą failą terminale\nPirmosios dienos prognozės gali turėti mažiau nei 24 valandas (pvz., likusios 6 valandos). Naudojant head, atspausdink tik šiandienos orų prognozes\nKadangi šiandienos oras jau aiškus, tavo draugei Amelijai reikia rytojaus orų prognozės. Derinant head ir tail, išfiltruok eilutes taip ir sukurk tarpinius failus, kad būtų nusiųstos tik rytojaus 24 valandų temperatūros prognozės. Rezultatą išsaugok į failą amelija_temp_vilnius.txt subdirektorijoje data. Naudojant cat įsitikink, jog turi tik rytojaus temperatūras.\n\n\n\n\n\n6.1.5 less\nPraėjusiame skyriuje jau turėjai atvejį, kai viso failo temp_vilnius.txt turinys netilpo į terminalo langą. Tikėtina, reikėjo pakeisti terminalo lango dydį arba slinkti su pele. Dabar tau galbūt kyla klausimas, kaip būtų galima matyti failo turinį gabaliukais?\nNors gali naudoti cat dideliems failams atspausdinti ir tada slinkti išvestį, paprastai patogiau failą rodyti puslapiais. Tam pirminė komanda buvo more, bet ją pakeitė galingesnė komanda less.\nNaudojant less &lt;failas&gt;, vienu metu matysi tik vieną failo puslapį. Spaudžiant ␣ (space) klavišą, pereisi į kitą puslapį; gali taip pat naudoti ↓ ir ↑ klavišus, kad judėtum po vieną eilutę žemyn arba aukštyn. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk data/temp_vilnius.txt su less, išbandyk judėjimą tekste žemyn, aukštyn ir uždaryk programą su q.\n\n\nJei less komandai nurodysi kelis failus, gali naudoti :n (next) pereiti prie kito failo, o :p (previous) sugrįžti prie ankstesnio failo. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk failus favorite_song.txt, data/temp_vilnius.txt ir text/seneles_pasaka.txt su less. Išbandyk judėjimą tekste žemyn, aukštyn, pereik tarp failų naudojant :n ir :p bei pabaigoje uždaryk less su q\n\n\n\n\n6.1.6 wc\nKomanda wc (angl. word count) naudojama atspausdinti naujų eilučių, žodžių ir baitų skaičių faile.\n\n\n\n\n\n\n\nNustatymas\nReikšmė\n\n\n\n\n-c\nAtspausdina baitų skaičių (angl. byte count), kiek vietos užima failas\n\n\n-m\nAtspausdina simbolių skaičių (angl. character count)\n\n\n-w\nAtspausdina žodžių skaičių (angl. word count)\n\n\n-l\nAtspausdina eilučių skaičių (angl. line count)\n\n\n\nPastaba: -c ir -m gali atspausdinti skirtingus rezultatus priklausomai nuo failo koduotės, nes simbolis gali užimti daugiau nei vieną baitą (pvz., specialūs lietuviški simboliai).\n\n\n\n\n\n\nPraktika\n\n\n\n\nKiek žodžių ir kiek eilučių yra text/seneles_pasaka.txt?\nKiek eilučių yra data/temp_vilnius.txt ir kiek data/temp_kaunas.txt?\n\n\n\n\n\n6.1.7 touch\nKomanda touch naudojama kuriant tuščią failą arba keičiant esamo failo metaduomenis, pvz., modifikavimo ar prieigos laiką. Ji yra universali ir ypač naudinga tais atvejais, kai reikia greitai sukurti failą arba atnaujinti failo laikus be jo turinio keitimo.\nJei failas neegzistuoja, touch jį sukurs. Jei failas jau yra, komanda tiesiog pakeis failo “paskutinio keitimo laiką” (modification time) į dabartinį laiką, nesikeičiant turinio.\nSukurk tuščią failą:\ntouch empty_1.txt\n\nJei nurodysi kelis failų pavadinimus, touch sukurs visus iš karto:\ntouch empty_2.txt empty_3.txt empty_4.txt\n\nJeigu failo pavadinimas yra nurodytas su absoliučiu ar reliatyviu keliu, failas bus sukurtas atitinkamoje direktorijoje, jei tokia direktorija egzistuoja. Jei direktorija neegzistuoja, bus pranešta apie klaidą, ir failas nebus sukurtas.\ntouch mix/empty_5.txt\ntouch tralala/empty_6.txt\n\ntouch taip pat leidžia atnaujinti failo prieigos arba modifikavimo laiką. Štai keli pavyzdžiai:\n\nAtnaujinti tiek prieigos, tiek modifikavimo laikus į dabartinį laiką:\n\ntouch empty_1.txt\n\nAtnaujinti tik prieigos laiką:\n\ntouch -a empty_1.txt\n\nAtnaujinti tik modifikavimo laiką:\n\ntouch -m empty_1.txt\n\nNustatyti tiek prieigos, tiek modifikavimo laikus į konkrečią datą, pvz., 2022 m. sausio 1 d., 12:00 val.:\n\ntouch -t 202201011200 empty_1.txt\n\nNaudoti -d parinktį, norint lankstesnio laiko nustatymo:\n\ntouch -d \"2023-07-04 15:45\" empty_1.txt\nDabar gali kilti klausimas - kam tai naudinga? Iš tiesų, failų laikų keitimas gali atrodyti nišinis, tačiau tai naudinga tam tikrais atvejais:\n\nJei nori išbandyti skriptą, kuris rūšiuoja ar archyvuoja failus pagal jų prieigos ar modifikavimo laiką, gali generuoti tuščius failus su netikrais laikais ir patikrinti, ar skriptas veikia teisingai.\nJei atstatai failus iš atsarginės kopijos, gali norėti atkurti ir jų originalius prieigos bei modifikavimo laikus, kad išsaugotum failų istoriją tiksliai tokia, kokia buvo prieš atsargines kopijas.\n\n\n\n6.1.8 mkdir\nKomanda mkdir (angl. make directory) naudojama naujų direktorijų kūrimui.\nNaują direktoriją gali sukurti taip:\nmkdir projektas1\nKaip ir su komanda touch, gali sukurti kelias direktorijas vienu metu, nurodant pavadinimus arba kelius į jas:\nmkdir projektas2 mix/projektas3\n\nKartais reikia sukurti direktorijų medį (hierarchiją). Jei tarpinės direktorijos dar neegzistuoja, gali naudoti -p argumentą, kuris automatiškai sukurs ir tarpines direktorijas. Pavyzdžiui:\nmkdir -p projektas0/duomenys\n\n\n\n\n\n\n\nPraktika\n\n\n\nNetrukus norėsime sukurti tam tikrų failų atsargines kopijas. Kaip pasiruošimą, užtikrink, kad shell_part_2 direktorijoje būtų:\n\nbackup/data\nbackup/text\n\nSukurk jas naudojant -p, nurodant abi direktorijas kaip du argumentus vienoje komandoje (vienoje eilutėje).\n\n\n\n\n6.1.9 cp\nPripažink, kopijuoti failą su cat failas.txt &gt; kopija.txt nėra labai intuityvu. O ką daryti, jei nori nukopijuoti ne tik failą, bet ir visą direktoriją?\nKomanda cp (angl. copy) naudojama failams ir direktorijoms kopijuoti.\nPaprasčiausiu atveju, kai nori sukurti failo kopiją, komandai cp nurodai originalaus failo pavadinimą ir kokiu pavadinimu turėtų būti sukurta kopija.\ncp song_text.txt song_text_copy.txt\nJei failas song_text_copy.txt jau egzistuotų, jis būtų perrašytas. Taigi cp veikia panašiai kaip &gt;.\nKaip ir su visomis BASH komandomis, gali naudoti tiek reliatyvius, tiek absoliučius kelius (angl. path). Pavyzdžiui, kopiją gali perkelti į kitą direktoriją:\ncp ./song_text.txt ./mix/song_text_copy.txt\n\nJeigu kaip antrąjį argumentą nurodysi egzistuojančios direktorijos pavadinimą, cp sukurs kopiją tokiu pačiu pavadinimu kaip originalas ir patalpins ją į nurodytą direktoriją. Šįkart praleidžiam\ncp song_text.txt mix\n\ncp gali kopijuoti ir direktorijas, tačiau tam, kad visa direktorija būtų nukopijuota rekursyviai (su visu turiniu), reikia naudoti nustatymą -r (recursive). Jeigu pamirši -r direktorija nebus nukopijuota!\ncp -r mix mix_copy\n\nKada naudoti cp -a?\nNustatymas -a (arba archive) naudojamas, kai reikia nukopijuoti failus ir direktorijas kartu su jų metaduomenimis (pvz., failo leidimais, nuosavybe, laikais). Tai naudinga, kai nori išsaugoti visas originalaus failo ar katalogo savybes. -a iš esmės yra kombinuotas cp -r (rekursija) ir kitų nustatymų rinkinys, kuris užtikrina, kad išsaugomi visi atributai.\ncp -a mix mix_copy_2\nDabar palyging metaduominis su ls -l.\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nPadaryk temp_vilnius.txt kopiją pavadinimu temp_vilnius.txt, bet kaip argumentą nurodyk direktoriją ir failo pavadinimą. Patalpink kopiją į backup/data.\nPadaryk temp_kaunas.txt ir temp_klaipeda.txt kopiją vienoje komandoje su originaliu pavadinimu, kaip trečią argumentą cp paduodant tik backup/data direktoriją.\nPadaryk text direktorijos kopiją su visu jos turinu į backup direktoriją. Išsaugok visus metaduomenis.\nTeorinis klausimas: kas nutiktų jeigu panaudotum cp -r text backup/text?\nAr darant temp_ failų atsargines kopijas išsaugojai metaduomenis? jeigu ne, pakartok komandas tik su teisingu nustatymu ir įsitikink, ar iš tiesų metaduomenys tokie pat!\n\n\n\n\n\n6.1.10 mv\nKomanda mv (angl. move) naudojama perkelti arba pervadinti failus ir direktorijas. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\nPvz., naudojant mv, gali pervadinti failą temp_vilnius.txt į temp_alytus.txt:\nmv data/temp_vilnius.txt data/temp_alytus.txt\n\nTaip pat su mv gali perkelti failus iš vienos direktorijos į kitą. Ši komanda perkelia failą temp_kaunas.txt į mix:\nmv data/temp_kaunas.txt mix\n\nmv komandai galima paduoti daugiau nei du argumentus. Pavyzdžiui, ši komanda perkelia failus temp_alytus.txt ir seneles_pasaka.txt į direktoriją mix. Čia svarbu, kad paskutinis argumentas būtų egzistuojanti direktorija:\nmv data/temp_alytus.txt text/seneles_pasaka.txt mix\nmv taip pat gali būti naudojama perkelti direktoriją ir visą jos turinį. Pavyzdžiui, ši komanda perkelia direktoriją mix_copy į mix:\nmv mix_copy mix\nPastaba: dirbant su direktorijomis:\n\njeigu mv origin target jeigu target neegzistuoja, tada mv pervadins direktoriją origin į target\njeigu mv origin target jeigu target egzistuoja, tada mv perkels origin į target direktoriją\n\nSvarbu: kaip ir naudojant &gt; ar cp, jeigu tikslinis failas jau egzistuoja, jis bus perrašytas, nebent pridėsi -i (interaktyvų režimą), kad būtų paprašyta patvirtinimo prieš perrašant.\n\n\n\n\n\n\nPraktika\n\n\n\n\nTeorinis klausimas: Kas nutiktų, jei įvykdytum šią komandą?\n\nmv temp_vilnius.txt temp_kaunas.txt ~/Documents ~/Downloads\n\nPerkelk Alytaus ir Kauno temperatūrų failus atgal iš mix į data naudojant mv. Pervadink Alytaus failą atgal į Vilniaus\nAtsidaryk Nemo ir rankiniu būdu ištrink data direktoriją. Dabar su terminal, padaryk backup/data kopiją (su cp ir reikalaingais nustatymais), jog vėl atsirastų /shell_part_2/data.\n\n\n\n\n\n6.1.11 rm\nTavo shell_part_2 direktorijoje dabar tikrai daug failų ir subdirektorijų, kurių nebereikia. Laikas įvesti šiek tiek tvarkos!\nKomanda rm (angl. remove) naudojama pašalinti failus ir direktorijas. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar direktorijos nėra perkeliami į šiukšliadėžę ir jų atkurti nebebus galima.\nNorint pašalinti failą, rm komandai paduodamas argumentas - failo pavadinimas arba absoliutus, arba reliatyvus kelias į failą.\nrm day.txt\nrm mix/empty_5.txt\nKomandai rm galima paduoti ir kelis failus vienu metu:\nrm empty_1.txt empty_2.txt \nTuščią direktoriją (kai joje nėra jokių kitų failų ar subdirektorijų) galima pašalinti arba naudojant rmdir (kuri yra mkdir priešingybė), arba su rm, nurodant nustatymą -d.\nrm -d projektas1\nrmdir projektas2\n\nTiesiog pašalinti direktoriją, kurioje yra kažkas, su rm arba rm -d nepavyks, nes BASH bando apsaugoti vartotoją nuo rizikos netyčia ištrinti daugiau failų nei reikia.\n\nJei reikia ištrinti visą direktoriją su visu jos turiniu, naudojamas parametras -r (recursive).\nrm -r projektas0\nKartais gali nutikti, jog rm -r negalės ištrinti direktorijos dėl failų teisių ar kitų kliūčių. Tokiu atveju pridedamas nustatymas -f (force), kuris priverstinai ištrina failus.\nrm -rf mix_copy_2\nintarpas: Wildcard’ų naudojimas *\nKartais BASH komandose norisi pažymėti arba pasirinkti daugiau nei vieną failą. Kaip jau matei, tiek cat, tiek cp, mv, rm, less komandos kuo puikiausiai dirba su keliais failais. Tad kyla klausimas, kaip tai padaryti efektyviau naudojant wildcard simbolius.\nPvz., tu galėtum rašyti:\nrm empty_1.txt empty_2.txt\nTačiau yra akivaizdu, jog šiuose failų pavadinimuose yra tam tikras dėsningumas - jie prasideda empty_ ir baigiasi .txt.\nBASH, kaip ir daugelyje kitų programavimo kalbų, yra vadinamieji wildcard - simboliai, kurie leidžia užpildyti vieną ar daugiau ženklų.\nPavyzdžiui, * simbolis pakeičia bet kokį skaičių ženklų. Taigi, galima būtų parašyti:\nrm empty_*.txt\nWildcard’ų simboliai:\n\n* reiškia jokio, vieną arba daugiau simbolių.\n? reiškia tiksliai vieną simbolį, pvz., 201?.txt galėtų atitikti 2017.txt, 2018.txt, bet ne 2017-01.txt.\n[...] reiškia vieną iš pateiktų simbolių, pvz., 201[78].txt atitiks 2017.txt arba 2018.txt, bet ne 2016.txt.\n{} reiškia vieną iš nurodytų reikšmių, pvz., rm {.txt,.csv} atitiks visus failus, kurių pavadinimas baigiasi .txt arba .csv, bet ne .pdf.\n\n\n\n\n\n\n\nPraktika\n\n\n\nTeorinė užduotis - pasakyk, kas nutiktų visais šiais atvejais:\n\nrm song*.txt\nrm *song*.txt\nrm *.txt\nrm *.*\nrm ./*\nrm *\nrm data/*\nrm text/*.txt\nPasitikrink atsakymą naudojant ChatGPT!\n\nPraktinė užduotis - naudojantis wildcard ištrink iš shell_part_2 visus failus:\n\nkurių pavadinime yra žodis song, neproklausomai nuo pozicijos ir failo tipo\nkurių failo tipas yra .txt\nvisus failus esančius mix subdirektorijoje. Tam gali prireikti papildomo nustatymo rm komandai, nes mix gali būti direktorijos!\nsubdirektorijas data ir text. O tada naudodojant cp ir būtinai reikiamą nustatymą metaduomenų išlaikymui, atkurti iš backup\n\n\n\nAtlikus visus valymus turėtum turėti:\n\n\n\n6.1.12 grep\nKartais tau gali prireikti nuskaityti tik tam tikras failo eilutes, kuriose yra konkretus tekstas. Komanda grep (angl. global regular expression print, liet. „globalus reguliariųjų išraiškų paieškos spausdinimas“) naudojama teksto paieškai pagal šabloną failuose arba išvestyje.\nPavyzdžiui, ši komanda surastų visas eilutes data/seneles_pasaka, kuriose yra žodis „Apie“:\ngrep Apie text/seneles_pasaka.text\n\nSuprantama, gali pateikti kelis failus vienu metu. Šiuo atveju komanda grep suras visas eilutes, kuriose yra 14:00:00 abiejuose jai pateiktuose failuose ir atitinkamas eilutes atspausdins tau į terminalą.\ngrep 14:00:00 data/temp_vilnius.txt data/temp_kaunas.txt \n\ngrep priima ir tam tikrus nustatymus, kurie padeda atlikti paiešką efektyviau:\n\n-c: atspausdina, kiek eilučių atitinka tavo pateiktą kriterijų.\n-h: neatspausdina failų pavadinimų, kuriuose rasti atitikimai, kai pateiki keli failai.\n-i: ignoruoja didžiąsias ir mažąsias raides (pvz., įrašius -i apie, ras ir „Apie“, „apie“, „APIE“ ir t.t.).\n-l: atspausdina tik failų pavadinimus, kuriuose rasti atitikimai.\n-n: atspausdina eilučių numerius šalia pačios eilutės.\n-v: ieško eilučių, kuriose nėra raktinio paieškos kriterijaus.\n\n\n\n\n\n\n\nPraktika\n\n\n\nDirbk su data/seneles_pasaka.txt\n\nKurios eilutės turi paminėtą žodį „pasaka“ (tik su mažąja raide)?\nKurios eilutės turi paminėtą žodį „pasaka“ (nesvarbu, ar rašyta didžiosiomis, ar mažosiomis raidėmis)?\nKiek eilučių (ieškome skaičiaus) turi paminėtą žodį „apie“, nepriklausomai nuo rašybos?\nKiek eilučių (ieškome skaičiaus) nepamini žodžio „apie“, nepriklausomai nuo rašybos?\n\n\n\nPastaba: komanda grep ieško tekstinės atitikties failuose, todėl ji nepriima loginių operatorių kaip &gt;, =, ar &lt;. Visgi, grep leidžia naudoti reguliarias išraiškas (regular expressions), kurios leidžia dar smulkiau atrinkti tekstą.\nŠtai kaip būtų galima panaudoti grep su reguliariomis išraiškomis, norint surasti visas eilutes, kuriose yra vienas skaitmuo prieš tašką, visuose temp_ failuose:\ngrep -P '\\t[0-9]\\.[0-9]' data/temp_*.txt\n\nĮ reguliarias išraiškas dabar neverta gilintis išsamiau, bet svarbu žinoti, kad jos egzistuoja ir gali būti labai naudingos dirbant su tekstiniais duomenimis. Jeigu kiltų noras pasibandyti, siūlau naudti https://regexr.com/.\n\n\n6.1.13 cut\nKartais tau gali prireikti išfiltruoti ne eilutes, o stulpelius. Pvz., komanda head data/temp_vilnius.txt parodo tarsi 3 stulpelius: datą, laiką ir temperatūrą. Pastebima, kad tarp datos ir laiko yra mažas tarpas (greičiausiai „space“), o tarp laiko ir temperatūros - didelis tarpas (tikėtina, “tab”). Tai šiek tiek apsunkina darbą, kol nesusipažinai su sed komanda, bet tai nereiškia, jog negalime išskaidyti failo į stulpelius pagal skirtingus skirtukus, pvz., „space“ ir „tab“.\n\nKomandai cut reikia tam tikrų nustatymų. Pagrindiniai nustatymai:\n\n-d (delimiter) - skirtukas, kuris skiria stulpelius. Pagal nutylėjimą skirtukas yra tabuliacija (tab), tad šio nustatymo keisti nereikia. Jeigu norėtum naudoti kitą skirtuką, pvz., tarpo ženklą, turėtum naudoti -d \" \". Jeigu skirtukas būtų kablelis, naudotum -d \",\" ir t.t.\n-f (fields) - nurodo, kuriuos stulpelius (laukelius) nori pasirinkti. Pvz., -f 2 pasirinktų antrą stulpelį, -f 2-5 pasirinktų nuo antro iki penkto stulpelio, o -f 2-5,8 pasirinktų antrą, trečią, ketvirtą, penktą ir aštuntą stulpelius.\n\nŠi komanda priima „space“ kaip skirtuką ir atspausdina pirmąjį stulpelį:\ncut -d \" \" -f 1 data/temp_vilnius.txt\n\nŠi komanda priima „tab“ kaip skirtuką ir atspausdina antrąjį stulpelį:\ncut -f 2  data/temp_vilnius.txt\n\nJeigu norėtum gauti tik metus, galėtum nurodyti skirtuką „-“ ir pasirinkti pirmąjį stulpelį:\ncut -d \"-\" -f 1 data/temp_vilnius.txt \n\n\n\n\n\n\n\nPraktika\n\n\n\nProgramuojant ir dirbant su duomenimis, svarbu išmokti išnaudoti AI galimybes. Šioje praktikoje tu turi nueiti į ChatGPT ir parašyti kažką panašaus:\n\nSugeneruok 25 eilučių .csv failą, kurio skirtukas būtų “,” su šiais stulpeliais:\n\nuser_id,\nage (18-99)\ncountry_code (LT, LV, EE)\norders (0-250)\n\n\nChatGPT sugeneruos .csv failą ir leis jį atsisiųsti. Šiam sugeneravimui ChatGPT pasinaudos Python programavimo kalba. Tu galėtum išsaugoti grąžintą kodą ir naudoti jį ateityje, nes tavo kompiuteryje šis kodas taip pat veiktų. Bet prie Python mes dar grįšime vėliau.\nPerkelk failą iš ~/Downloads į ~/shell_part_2/data. Tarkime, failas vadinasi sample_data.csv.\nVideo\nTurint failą:\n\nPervadink failą į balt_customers.csv.\nNaudojant žinomomis komandomis tyrinėk failą data/balt_customers.csv:\n\nKiek jame eilučių?\nKoks skirtukas naudojamas?\nKokie duomenys yra pirmoje eilutėje (antraštė ar duomenys)?\nKiek ir kurios eilutės yra duomenys?\n\n\nUžduotis: Tu dirbi su klientais iš Estijos (EE). Turi parašyti visiems klientams iš Estijos el. laišką ir pranešti apie jų užsakymų skaičių. Laiško rašymą perims programa, tačiau tu jai turi pateikti failą customers_ee.csv, kuris turėtų atrodyti taip (tavo duomenys gali skirtis dėl atsitiktinio jų sugeneravimo):\n\nKad įgyvendintum šią užduotį, tau prireiks komandų: head, cut, &gt; &gt;&gt;, cat ir grep bei sukurti kelis tarpinius failus, kuriuos vėliau galėsi ištrinti. Taip pat patarčiau bandyt skaidyti darbus :)\nSėkmės!\n\n\n\n\n6.1.14 Intarpas: Standartinė įvestis, išvestis ir klaidos\nIki šiol mes naudojome sąvokas, tokias kaip įvestis (input) ir išvestis (output). Įvestis buvo tai, ką tu įvedi klaviatūra į terminalą, o išvestis - tai, ką BASH atspausdina terminale arba ką tu nukreipi į failą naudodant &gt; arba &gt;&gt;. Tačiau iki šiol formaliai neaptarėme BASH srautų.\nLinux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenų įvestį ir išvestį programose bei komandose. Šie srautai vadinami standartine įvestimi (standard input), standartine išvestimi (standard output) ir standartine klaida (standard error). Kiekvienas srautas turi specifinę paskirtį ir failo aprašymo numerį.\nSvarbu: Linux’e viskas yra failai, net srautai (input/output) traktuojami kaip failai.\n\n6.1.14.1 Standartinė įvestis (stdin)\nStandartinė įvestis, sutrumpinta kaip stdin, yra srautas, iš kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, stdin yra prijungta prie klaviatūros, tačiau gali būti nukreipta iš failo ar kito srauto.\nPabandyk įrašyti cat, paspausti Enter, ir tada įvesk kelis žodžius, vis paspausdžiant Enter. Terminale matysi tekstą, kurį įvedi, nes jis bus perduotas kaip įvestis cat komandai, kuri atspausdins šį tekstą. Todėl matysi dvigubai tai, ką įvedei.\ncat\nNutraukti cat įvestį gali su Ctrl-D arba Ctrl-C.\nVideo\nĮvestis taip pat gali būti perduodama iš failo į komandą. Pavyzdžiui, komandai cat galime nurodyti failą taip:\ncat &lt; data/customers_ee.csv\nKodėl veikia &lt;?\nSimbolis &lt; nurodo komandai, kad vietoje įprastos įvesties iš klaviatūros naudotų failą kaip įvesties šaltinį. Pvz., cat &lt; data/customers_ee.csv reiškia, kad cat komanda skaitys duomenis iš failo data/customers_ee.csv, o ne iš klaviatūros.\n\nStandartinės įvesties aprašymo numeris: 0. Vėliau pamatysi, kam tie skaičiai naudingi.\n\n\n6.1.14.2 Standartinė išvestis (stdout)\nStandartinė išvestis, sutrumpinta kaip stdout, yra srautas, į kurį komanda ar programa rašo išvestį. Dirbant terminale, stdout prijungta prie terminalo ekrano. Pavyzdžiui, įrašius šią komandą, terminale atspausdinamas „Hello World“:\necho \"Hello World\"\nGalima nukreipti standartinę išvestį ne į terminalo langą, bet į failą, kaip jau esame darę anksčiau:\necho \"Hello World!\" &gt; hello_world.txt\nStandartinė išvestis turi numerį 1. Tai reiškia\necho \"Hello World!\" 1&gt; hello_world.txt\njog stdout srautas (1), kurį generuoja echo komanda, siunčiamas į failą hello_world.txt. Mes panaudojom srauto numerį, kad pasakyti kurį srautą siųsti į failą.\n\n\n6.1.14.3 Standartinė klaida (stderr)\nKai komanda negali atlikti tam tikro veiksmo, ji sugeneruoja klaidos pranešimą, kuris siunčiamas į standartinį klaidos srautą (stderr). Standartinės klaidos srautas turi numerį 2, ir jį taip pat galima nukreipti į failą.\nPabandyk komandą ls su neegzistuojančia direktorija, pvz.,:\nls abc\n\nKlaidos pranešimas bus išspausdintas terminale. Tačiau galime nukreipti tik klaidos srautą į failą:\nls abc 2&gt; error.log\nTerminale klaidos nebus matyti, bet gali naudoti komandas head arba cat, kad pažiūrėtum, kas yra error.log faile.\n\n\n\n\n6.1.15 Kaip visą tai taikyti praktikoje?\nĮsivaizduok, kad turi komandą ls, kuri kartais sugeneruoja išvestį, kurią nori nukreipti į list.txt, o klaidas - į error.log. Tam galėtum naudoti:\nls &lt;direktorija1&gt; &lt;direktorija2&gt; &lt;direktorija3&gt; 1&gt;&gt;list.txt 2&gt;&gt;error.log\nIšbandyk šią komandą su egzistuojančia ir neegzistuojančia direktorija (prieš tai su rm ištrink error.log jeigu toks egzistuoja)\nls -l data abc text 1&gt; list.txt 2&gt; error.log\n\nKartais gali prireikti, kad abu srautai būtų nukreipti į tą patį failą. Pvz., jeigu kas 10 minučių matuoji kompiuterio temperatūrą, gali nukreipti tiek stdout, tiek stderr į failą:\nkomanda 1&gt;temp.log 2&gt;&1\nArba gali klaidos srautą nukreipti į temp.log, o standartinę išvestį - į klaidų srautą:\nkomanda 2&gt;temp.log 1&gt;&2\nSimbolis & nurodo, kad mes kalbame apie srautą, o ne apie failo vardą. Kai rašai, pvz., 1&gt;&2, tai reiškia, kad standartinę išvestį (stdout, 1) nukreipi ne į failą, o į standartinį klaidų srautą (stderr, 2). Tai leidžia abu srautus sujungti ir siųsti į tą patį tikslą. Jei & nebūtų, sistema galvotų, kad „2“ yra failo pavadinimas, o ne kitas srautas. Analogiškai, 2&gt;&1 reiškia, kad klaidų srautas (stderr, 2) nukreipiamas į išvesties srautą (stdout, 1).\n\n\n6.1.16 pipe |\nIki šiol, kai reikėdavo vienos komandos išvestį panaudoti kitoje komandoje, pavyzdžiui, išfiltravus Estijos vartotojus su grep EE data/balt_customers.csv, turėjai juos išsaugoti į tarpinį failą (pvz., temporal.csv), o tik tada paduoti rezultatą į cut -d \",\" -f 1,4 temporal.csv, kad gautum norimą rezultatą. Tai yra neefektyvus metodas, nes:\n\nLieka daug tarpinių failų.\nKomandos būna suskaidytos per kelias eilutes, todėl jas sunku peržiūrėti su history.\n\nBASH siūlo kelis būdus, kaip efektyviau panaudoti vienos komandos rezultatus kitose, pavyzdžiui, su xargs arba kitais įrankiais. Tačiau dažniausiai naudojamas metodas yra pipe (angl. “vamzdis”).\n| (pipe) - tai vertikalus brūkšnys, kuris sujungia komandas į vieną srautą, kur vienos komandos išvestis tampa kitos komandos įvestimi.\n\nPabandyk sujungti šias komandas:\n\ngrep EE data/balt_customers.csv - išfiltruoti tik EE vartotojus.\nPanaudoti |, kuris pavers pirmosios komandos išvestį antrosios komandos įvestimi.\ncut -d \",\" -f 1,4 - iškirpti pirmą ir ketvirtą stulpelius.\nGalutinį rezultatą su &gt; nukreipk į failą data/customers_ee_2.csv.\n\n\ngrep EE data/balt_customers.csv | cut -d \",\" -f 1,4 &gt; data/customers_ee_2.csv\nPirma pabandyk paleisti komandą be &gt;, kad pamatytum rezultatą terminale:\n\nDabar paleisk pilną komandą, nukreipiančią išvestį į failą:\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nTerminale atspausdink pirmas 3 eilutes, kuriose yra žodis „Apie“ iš failo data/seneles_pasaka.txt.\nTerminale atspausdingk paskutines 3 eilutes kuriose yra 00:00:00 faile data/temp_vilnius.txt\n\n\n\n\n\n6.1.17 sort\nTu darai nuostabią pažangą ir jau moki naudoti grep, cut, head, tail, su kuriomis gali išfiltruoti eilutes, stulpelius ir t.t. Naudojant |, jau moki sujungti kelias komandas į vieną. Tačiau ko tu dar nemoki - kaip išrikiuoti reikšmes. Čia pravers komanda sort.\nsort labai gerai sąveikauja su pipe |.\nPagrindiniai nustatymai:\n\n-r - nuo didžiausios iki mažiausios reikšmės.\n-n - rikiuoti skaičius.\n-h - rikiuoti pagal dydį, jei dydis pateiktas human readable skaičiais (pvz., KB, MB, GB).\n-t - nurodo, koks yra skirtukas tarp stulpelių (delimiter).\n-k - pagal kurį stulpelį rikiuoti.\n\nSukurk šį failą:\necho -e \"A,101\\nB,3\\nC,2\\nD,40\" &gt; tosort\nAr pastebėjai, tosort neturi indikacijos, koks tai failas, nei .csv, nei .txt. Nieko tokio Linux operacinėje sistemoje, komandos veikia kuo puikiausiai ir be failo tipo indikatoriaus.\n\nPagal nutylėjimą sort priims failą kaip argumentą ir rikiuos pagal pirmą stulpelį. sort -r apsuks rikiavimo eigą.\nsort tosort\nsort -r tosort\n\nJei nori, kad BASH suprastų failą kaip turintį skirtingus stulpelius, turi nurodyti, koks yra skirtukas (delimiter) su -t \",\". Tuomet galima rikiuoti pagal konkretų stulpelį su -k 2. Jei nepridėsi -n, sort rikiuos taip, lyg skaičiai būtų tekstas, t.y., vertins pagal pirmą skaitmenį, tada pagal antrą ir t.t. Pridėjus -n, skaičiai vertinami kaip skaičiai.\nGalima apsieiti ir be kabučių aplink skirtuką, o -n pridėti prie -k 2, kad būtų rikiuojama pagal skaičius. Galų gale, tai tavo pasirinkimas.\nsort -t \",\" -k 2 tosort\nsort -t \",\" -k 2 -n tosort\nsort -t, -k2n tosort\n\n\n\n\n\n\n\nPraktika\n\n\n\nUžduotis: Įsivaizduok, kad esi IT administratorė arba administratorius, atsakingas už sistemų stebėjimą. Tau reikia periodiškai siųsti sąrašą su 5 didžiausiais failais ar direktorijomis pagal dydį namų direktorijoje (~). Šis sąrašas turėtų apimti visus paslėptus failus (kurie prasideda su “.” savo pavadinime), o dydis turėtų būti human readable formatu, o ne baitais. Taip pat norisi, kad maksimalus gylis būtų 1, t.y., jog būtų žiūrima į ~ ir vieną lygį giliau, t.y. ~/direktorija/.\nKadangi šią užduotį reikia atlikti kasdien, nusprendei sukurti ilgą BASH komandą.\nPagalba: Prieš pradedant nueik į ChatGPT ir paprašyk:\n\nPaaiškink man “du” komanda Linux ir jos nustatymus. Man reiktų matyti failus human readable formatu. Pateik kelis pvz.\n\nPerskaityk ką tau gražins ChatGPT, jeigu reikia pasitisklink užduodant papildomus klausimus.\n\nPabandyk sukurti komandų seką (pipeline) su du, sort, head. Eksperimentuok su nustatymais.\nKai terminalo lange matysi reikiamą išvestį, naudok echo, apskliausk visą komandą kabutėmis ir nukreipk į failą pavadinimu list_du_homedir.sh. Taigi, tai turėtų atrodyti daugmaž taip:\necho \"komanda komanda komanda\" &gt; list_du_homedir.sh\nO dabar pabandyk\nbash list_du_homedir.sh\narba su pipe\ncat list_du_homedir.sh | bash\nSveikinu, ką tik sukūrei savo pirmą skriptą! Tai komandų rinkinys, kurį gali perduoti BASH, ir jis jį įvykdys.\n\n\n\n\n6.1.18 sed\nsed komanda Linux sistemoje yra srauto redaktorius (stream editor), naudojamas tekstui apdoroti ir manipuliuoti. Ji leidžia atlikti įvairius teksto pakeitimus, pvz., ieškoti ir pakeisti žodžius, ištrinti eilutes arba modifikuoti tekstą pagal tam tikras taisykles, nespausdinant teksto į terminalą.\nVienas paprasčiausių būdų naudoti sed - tai pakeisti tam tikrą tekstą kitu tekstu: tam naudojama tokia sintaksė sed 's/ką keisti/kuo pakeisti/'.\nTaigi, ši komanda pakeičia „rytas“ į „vakaras“:\necho \"Labas rytas\" | sed 's/rytas/vakaras/'\nsed nėra agresyvi komanda, todėl ankstesnė komanda pakeičia tik pirmą rastą atitikmenį:\necho \"Labas rytas, pasakė senelė kai atėjo rytas\" | sed 's/rytas/vakaras/'\nMatyti, kad tik pirmas „rytas“ pakeistas į „vakaras“, o antrasis ne. Jei nori, kad visi atitikmenys būtų pakeisti, reikia pridėti nustatymą g:\necho \"Labas rytas, pasakė senelė kai atėjo rytas\" | sed 's/rytas/vakaras/g' \nSu sed taip pat galima ištrinti eilutes. Pavyzdžiui, jei ls -l komanda atspausdina „total …“, galima tai ištrinti naudojant sed '1d':\nls -l\nls -l |sed '1d'\nVietoje 1, kuris nurodo, kurią eilutę trinti, galima nurodyti ir diapazoną, pvz., nuo 1 iki 3 su sed '1,3d':\nls -l | sed '1,3d'\nTaip pat galima įterpti naujas eilutes:\nls -l | sed '3a/nauja eilutė'\nPora įdomybių:\nSu sed gali naudoti regular expressions. Štai keletas reikšmių:\n\n^ reiškia eilutės pradžią.\n$ reiškia eilutės pabaigą.\n\\t reiškia tabuliaciją (naudoti su sed -E).\n\\s reiškia tarpą (naudoti su sed -E).\n\nPvz., pridėti veiduką prieš kiekvieną eilutę:\nsed 's/^/😀/g' text/seneles_pasaka.txt\nJei nori, kad sed ignoruotų raidžių dydžius, pridėk nustatymą I. Tai panašu į grep -i.\necho Labas Rytas | sed 's/rytas/Vakaras/'\necho Labas Rytas | sed 's/rytas/Vakaras/I'\n\n\n\n\n\n\nPraktika\n\n\n\n\nDirbk su data/seneles_pasaka.txt. Tavo tikslas - padaryti pasaką labiau patrauklią vaikams, pakeičiant žodžius simboliais. Naudok sed komandą ir pakeisk šiuos žodžius į atitinkamus simbolius. Sujunk visas sed komandas į viena pipeline naudojant |.\n\n\nŽąsiną moliūgą - 🦢🎃\nVilką - 🐺\nBaltą mešką - 🐻‍❄️\nJoną - 👦🏻\nEglę - 🌲\nŽalčio - 🐍\nRagana - 🧙‍♀️\nPamotė pikta - 😡\n\nIšsaugok pasaką kaip text/seneles_pasaka_emojies.txt\n\n\ndata/temp_vilnius.txt ir kitų miestų failai turi kelias problemas, kurias turėtum ištaisyti:\n\nVilniaus faile kiekvienos eilutės pradžioje įrašyk „Vilnius “ (su tarpeliu po miesto pavadinimo). Kituose miestuose atitinkmai “Kaunas” ir “Klaipėda”\nDabar pirmieji du skirtukai yra tarpai, o antrasis - tabuliacija. Paleisk sed komandą du kartus: vieną kartą pakeisk tarpus (space) į kablelius, o antrą kartą - tabuliacijas į kablelius.\nIšsaugok Vilniaus, Kauno, ir Klaipėdos failus kaip temp_vilnius.csv, temp_kaunas.csv, temp_klaipeda.csv (vietoje .txt naudok .csv plėtinį).\nKiekvienas miestas turėtų turėti visą komandą vienoje eilutėje naudojant |.\n\n\n\nSujunk visus Vilniaus, Kauno ir Klaipėdos failus į vieną ir pavadink rezultatą temp_lietuva.csv.\nPabandyk atidaryti šį failą su LibreOffice Calc:\n\nlibreoffice --calc temp_lietuva.csv\n\nPavaizduok sekančių dienų temperatūras.\n\n * Pabandyk atsidaryti visus tris pavienius failus su Excel Power Query ir apdorojus duomenis sukurti dashboard to slicer filtrais ir grafikais.\n\n\n\n\n\n\n\n\nProjektas\n\n\n\nUžduotis: Top 10 populiariausių markių analizė naudojant Bash\nŠiame mini projekte tu dirbsi su transporto priemonių valstybiniais numeriais pagal markę ir modelį. Duomenys yra prieinami čia ( https://data.gov.lt/datasets/2749/#info ). Paspausk „Duomenys“, o tada „Atsisiųsti“. Gausi failą, kuris vadinsis ValstybinisNumeris.csv. Jis yra gana didelis (~380mb, tad užtruks kol atsisiųs), todėl prireiks ir komandų efektyviam jo apdorojimui (į excelį netelpa, nes čia virš 1 mln eilučių: Pagrindiniai stulpeliai (galimi papildomi metaduomenys): _id vda_id valst_nr_zym marke modelis 59e046e3 000008398921ea6 XXX000 CHEVROLET CRUZE 3c1e15b0 000009b2cf32ad9 XXX000 TOYOTA MEM LEXUS RX400H 9fba96c4 00000c08564017c XXX000 MITSUBISHI MITSUBISHI ASX 3a8fda00 000014d2a79c79d XXX000 VW PASSAT 03344c63 0000209af983016 XXX000 MERCEDES BENZ B 180 CDI Tavo užduotis:\nSusikurk naują direktoriją „pop_markes“.\n\nAtsisiųsk failą ir perkelk jį iš „Downloads“ į „pop_markes“ direktoriją. Alternatyva gali pasinaudoti ir bash komanda curl \"https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris\" (su curl susipažinsi netrukus, bet ji šiuoatveju atsiunčia failą)\n\nNaudodama cut, sort, head arba tail bei uniq komandas, suskaičiuok, kurios 15 markių yra labiausiai populiarios Lietuvoje.\nPagalba:\nAtidaryk ChatGPT ir paklausk:\n„Kaip naudoti komandą uniq kartu su sort norint suskaičiuoti ir išrikiuoti eilutes pagal pasikartojimų skaičių?“\nPerskaityk atsakymą, suprask ir užsirašyk tai į savo užrašus.\nRezultatas:\nRezultatas kurį turėtum gauti, parašius visas komandas vienoje eilutėje ir sujungiant jas su pipe | simboliu:\nPeržiūrėk sąrašą. Ar matai problemas? Jų ne viena, o netgi slypi pora,nors ir su tuo pačiu gamintoju…. Panašu, kad duomenys, ne tik ne visai tvarkingi, bet dar ir su atkskirties tašku gali būti problema. Painvestiguok duomenis savarankiškai… Pagalvok ir pasakyk man, kaip spręstum šią problemą ir su kokia komanda?",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html",
    "title": "7  BASH pažengusiems",
    "section": "",
    "text": "7.1 Įvadas\nPraėjusiame skyriuje susipažinai su įvairiomis CLI (command line interface) komandomis, suteikiančiomis pagrindinius įrankius darbui su shell aplinka. Išmokai naudoti echo, cat, head, tail, less, wc, touch, mkdir, cp, mv, rm, grep, cut, sort, sed, taip pat operatorius &gt;, &gt;&gt;, bei |. Šios komandos leidžia dirbti su failais, kurti direktorijas, atlikti filtravimą pagal eilutes ir stulpelius bei automatizuoti užduotis.\nŠiame skyriuje dar gilinsimės į failų valdymą ir apdorojimą. Sužinosi:\nŠis skyrius suteiks tvirtesnį pagrindą darbui su Linux aplinka, padės efektyviau valdyti failus ir suprasti esminius failų teisių, procesų bei tinklo valdymo aspektus.\nTaip pat tu vis dažniau gausi nuorodas naudotis ChatGPT. Esminis dalykas - išmokti naudotis šiuo įrankiu ne tam, kad jis už tave spręstų problemas, bet kad įgalintų tave greičiau rasti geriausią sprendimą. Todėl niekad nesiek atiduoti sprendimo paieškos ChatGPT, o veikiau naudok jį kaip korektorių: pasitikrink, ar gerai darai, ar gali pagerinti savo darbą, taip pat įgyti naujų žinių ar pasitikrinti save.\nTaip pat mano rekomendacija perskaičius kiekvieną skyriaus dalį - skirk laiko reflektuoti, atsakant į klausimus:",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#įvadas",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#įvadas",
    "title": "7  BASH pažengusiems",
    "section": "",
    "text": "Pagalbos komandas - mokysiesi naudotis help, man ir tldr, kad greitai rastum informaciją apie komandas.\nTinklo komandas - išmoksi naudoti ping, curl ir wget, kad galėtum patikrinti ryšį bei atsisiųsti duomenis.\nKaip ieškoti failų - naudosi find, locate ir whereis, kad efektyviai surastum failus ir suprastum jų vietą.\nTeksto apdorojimą - įgysi žinių apie awk, paste ir sed, kad galėtum analizuoti ir jungti duomenis.\nFailų teises ir savininkystę - sužinosi apie chmod, chown ir chgrp, kurie padės valdyti failų teises ir naudotojus.\nProcesų valdymą - sužinosi, kaip stebėti ir valdyti procesus naudojant ps ir top ir htop.\nKomandų istoriją ir alias - naudosi history ir alias, kad galėtum peržiūrėti praeityje naudotas komandas bei kurti trumpinius.\n\n\n\n\n\nKą aš ką tik išmokau?\nKaip aš tai galėčiau panaudoti? Sukurk mintyse bent kelis scenarijus.\nPradėk konspektuotis kompiuteryje naudojant Joplin arba Obsidian - programos padės vėliau lengviau rasti tai, ką išmokai.\n\n\n\n\n\n\n\nPraktika\n\n\n\nNamų direktorijoje susikurk subdirektoriją šiam skyriui, pavadink ją pvz bash_advanced. Pereik į ją, nes šįkart visus duomenis susikursi besimokydama.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#pagalbos-komandos-help-man-ir-tldr",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#pagalbos-komandos-help-man-ir-tldr",
    "title": "7  BASH pažengusiems",
    "section": "7.2 Pagalbos Komandos: help, man ir tldr",
    "text": "7.2 Pagalbos Komandos: help, man ir tldr\nNaudojant Linux, komandos turi daugybę nustatymų ir opcijų, kurias gali būti sudėtinga prisiminti. Pavyzdžiui, gali iškilti klausimas, ar sort komandai reikia naudoti -d ar -t flagą, arba norisi prisiminti, kuo sed skiriasi nuo grep. Šiame skyriuje išmoksi efektyviai naudotis pagalbos įrankiais, kurie padės greitai rasti informaciją apie komandas ir jų naudojimo būdus, kai iškyla klausimų.\nAptariamos pagalbos komandos:\n\nhelp komanda - kaip naudoti --help, kad greitai gautum pagrindinę informaciją apie komandą ir jos dažniausius nustatymus.\nman komanda - detalus vadovas apie man komandos naudojimą ir struktūrą (sekcijos NAME, SYNOPSIS, DESCRIPTION).\ntldr komanda - kaip greitai gauti pagrindinius patarimus ir scenarijus, naudojant tldr, kuris pateikia paprastus pavyzdžius ir labiausiai reikalingus flagus.\nChatGPT - kaip gali pasitelkti įrankius, tokius kaip ChatGPT, klausimų paaiškinimui ir pagalbai, kai prireikia papildomo paaiškinimo.\n\nScenarijus\n\nSusikurk projekto direktoriją su mkdir ir pakeisk savo darbinę direktoriją į projekto direktoriją. Pavadink ją pvz., “energetikos_analizė”.\nParsisiųsk fizinių asmenų elektros suavrotjimo duomenis .csv formatu su curl komanda. Tai padarysi taip:\ncurl https://get.data.gov.lt/datasets/gov/eso/fizin_asm_elektros_suvartojimas/FizinAsmElektraSuvartojimas/:format/csv -o raw_data_hh_customers.csv\nSiuntimas truks ilgai, nes failo dydis yra apie 2 GB. Tai daugmaž atitinka 130 000 puslapių Word dokumentų.\nNusprendei susipažinti su duomenimis, analizuojant pirmas 15 eilučių terminale. Pamiršai, kokie flagai naudojami su wc, head ir cut komandomis.\n\n\n7.2.1 --help\nDauguma komandų turi flagą (opciją) --help, kuris pateikia santrauką apie komandos veikimą ir galimus flagus. Kai kurios komandos taip pat turi trumpesnį -h flagą. Jei --help neveikia, pabandyk -h. Atmink, kad --help veikia tik pagrindinei komandai (pvz., apt –help), tačiau subkomandoms (apt update) ji gali neveikti.\n\n\n\n\n\n\nPraktika\n\n\n\n\nKiek eilučių yra raw_data_hh_customers.csv faile? Naudok wc --help, kad sužinotum flagą, skirtą eilučių skaičiavimui.\nKonspektavimas: Tekstiniame dokumente užsirašyk, ką bandei padaryti, kokie naudingi flagai, ir pateik pavyzdines komandas.\n\n\n\n\n\n7.2.2 man: manual pages\nKaip ir su namų technika - prie jos būna trumpos ir ilgos instrukcijos. Trumpos parodo kaip kaip veikia, tia atitinka --help arba tldr (su kuria susipažinsi netrukus). Tačiau kartais reikia dar daugiau informacijos, tam kad suprastum kaip kas veikia - arba skaityti pilnas vartotojų instrikcuijas (angl - manual). Būtent šią funkcija atlieka man komanda, kuriai kaip argumentą gali pateikti kitą komandą, arba net ją pačia!\nKadangi man - vartojojo instrukcijos yra kur kas iglesnės nei --help, man savo išvesties nespausdina terminale, o iššaukia less su kuria jau susipažinai praeitame skyriuje. Keisti psulapius gali su space klavišu, o nutraukti su :q\nMan puslapis įprastai turi tokią struktūra\nname synopsos description author reproting bugs copywrigh\n[…] reiškia…. , o altenrtyvos atksirtos |. kas gali kartotis nurodoma su …\n\n\n\n\n\n\nPraktika\n\n\n\n\nPrisimeni, jog su head ir tail galėjai nurodyti kiek eilučių spausdinti? pvz head -n 15 atspausdino pirmas 15 eilučių. Atsiversk man head ir susirask -n. Ten aprašytas naudojimas - skaičiaus. Dabar pažiūrėk man tail ir ten rask -n bet su + naudodjimu.\nsusikonspektuok head ir tail tame pačiame dokumente, kaip ir wc\ndabar tavo failas raw_data_hh_customers.csv turi antraštes (header) ir duomenis. pasinaudojus head arba tail bei išmoktais flagais, sukurk naują failą pure_data.csv kuriame būtų visos originalaus failo eilutės bet ne antraštė.\npalyging su wc eilučių skaičių viename ir kitame faile ir įsitinkjog skirtumas tik 1 eilutė.\nsu ls -lh arba ls -l palygik, kiek sutaupei vietos, atsisakius vienos eilutės “duomenų”.\n\n\n\n\n\n7.2.3 tldr\nman puslapiai yra begalo išsamūs, tačiau jie ir ganėtinai ilgi. &lt;command&gt; --help arba &lt;command&gt; -h kartais būna gani trumpi ir aiškūs pagalbos puslpiai, tačiau jeigu komanda turi daug nustatymų ir argumentų, net --help puslapiai gali būti perdaug sudėtingi, ypač pačioje pradžioje naudojantis shell. Čia į paggalba gali ateiti kita programa, kurios greičiausiai tavo kompiuretyje nėra - tldr. (akronimias reiškiantis “too long;didn’t read it” = santrauka). Ši programa pateikia dažniausius komandos naudjimo scenarijus ir labai trumpą paaiškinimą apie komandą. Tad tai dar vienas instrumentas tavo arsenale, primiršus prismint kaip veikia komanda, ką ji daro ir kokie nustatymai ir argumentai yra galimi.\n\n\n\n\n\n\nPraktika\n\n\n\n\npasitikrink ar turi tldr su which\nPrisimink kokius žingsnius turi padaryti, norint instlaituoti programą?\nInsaltiuok tldr\n\n\n\ntldr komanda priima kaip argumentą kitą komandą. Daugumai standarintinių komandų, tldr terminale tau atspausdins standarintinius ir dažniausiai vartojamus flagus (nustatymus) bei kelis jų taikomo pvz.\n\nPabandyk\n\ntldr head\ntldr wc\n\nPabandyk tldr tldr\n\nkaip matai, tldr priima ir  ir \n\n\n\n\n\n\nPraktika\n\n\n\n\nTu norėtum po truputi inspektuoti raw_data_hh_customers.csv failą, tačiau pamirškai, kaip pasirinkti tam tikrą stulpelį. pasinaudkok tldr cut.\nJeigu paleisti cut … raw_data_hh_customers.csv , jis tau atspausdins laai duag eilučių. tia būtų neefektyvu. Prisimink, kaip sujungti skritingas komandas ir pagalvok, kaip galėtum inspreksuoti kievieną stulpelį atksirai, bet matyti tik pirmas 15 eilučių? inspektuok temrinale pirmus 10 stulepių, pabandyk surpasti ar jie būtų vertingi analizei ar ne.\n\n\n\n\n\n7.2.4 ChatGPT\nChatGPT yra nuostabus įrankis. Jis nėra labai protingas, bet jo algoritmai yra gana stiprūs, jog padėtų tau dirbant. Keli labai svarbus dalykai.\nTik prisiregistravus tu gali naudotis gerensiu modeliu. Taip pat išsisaugo tavo užklausų istorija, o tai padeda turėti ilgenses sesijas. Ilgensės sesijos turi naudą, jog tda ChatGPT reaguoja į visą sesijos kontekstą, apie ką kalbėjote, kokią informaciją iš tavęs gavo.\nLabai svarbu, jog po truputi pratintumeisi KAIP rašyti užklausas CHATGPT. Štai keli patarimai\n\nangliškai chatgpt surptna ir atršo geriau, nei lietuviškai, nes angliškos kalbos modelis turėjo daugiau trenirvaimosi duomenų (wikipedia anglų kalba yra daug išsamesnė nei lietuvių)\npradėk užklausą suteikiant kotektsą, o ne tik rašant klausimą.\nkartais tu gali norėti, jog chatgpt elgtsi kaip tam tikras asmuo. tai gali suformuluoti savo užklausoje\n\n\n\n\n\n\n\nPraktika\n\n\n\npraeitame praktikume tu panaudojai head 15 raw_data_hh_customers.csv | cut -d \",\" -f 1 bet galėjai panaudoti ir cut -d \",\" -f 1 raw_data_hh_customers.csv | head 15. tačiau kuris variantas yra gerensis?\nišbanyk šias užklausas ir palygink jų atskaymus. Rašyk užklausas pradėdama vis naują chat’ą.\n\n“Ar galima naudoti cut -d \",\" -f 1 raw_data_hh_customers.csv | head 1”.\nKuri komanda yra efektyvesnė head 15 raw_data_hh_customers.csv | cut -d \",\" -f 1 ar cut -d \",\" -f 1 raw_data_hh_customers.csv | head 15.\nO dabar suteik daugiau konteksto ir įvertinkg GPT atsakymą į klausimą: “Aš dirbu su 4 mln eilučių failų raw_data_hh_customers.csv. Mano tiklsas yra perpūrėiti pirma 15 eilučių kiekvieno stulpelio. koks komendų head ir cut eiliškumas šioje situacijoje būtų geriausas. paaiškink savo atsakymą. elkis taip, tarsi būtum labai patyes shell (bash) programuotojas”\n\n\n\nAr pastebėjai skirtumą? Pateikus kontekstą bei paprašius argumentuoti savo pasirinkimą, GPT tau pateikia kur kas tiklsinesįė taskymą. Prierašas jog elgųtsi kaip patyręs bash programuotojas, GPT ne tik atsako į klausimą, galbūt pateikia net ir papildomų sprendimų kaip įveikti šią užduoti.\ntaigi įismink:\n\nkontekstas (ką tu darai)\ntikslas (ką nori padaryti, kokį rezultatą norėtum gauti)\nproblemos (ką gauni vietoj to, ko negauni, arba kur matai problemą)\nprašymas paaikšinti savo pasirinkimą\n“agento” sukūrimas paakant kaip kas turėtų GP elgti\n\nyra žingniai, kurie padės tau efektyviau dirbti\n\n\n7.2.5 konspektavimas\nKo gero jau pradedi pastabeti, kad prisiminti visas komandas nėra lengva. Kai kurias iš jų naudosi taip dažnai, jog jos taps pastovios atminties dalimi. Kai kurias, naudosi rečiau. Dirbant analitikoje, programavime, tu niekada nepsiriminsi visko. Tiesiog reikia įprasti ir naudtis savo “antrinėmis smegenimis” - konspektuotis viską taip, kad vėliau prireikus galėtum greičiau rasti reikiamą informaciją.\nPvz analitikai, dažnai išsisaugo ilgus duomenų užklausų kodų gabalus (code chunks), ypač jeigu jų prireikia reguliariai, bet nėra kitos geros galimybės jų išsisaugoti. prograuotojai irgi dažnai naudoja obsidian https://youtu.be/kUZ3RP08-HY.\nAš dažnai naudoju Obsidian arba Joplin tam, kad kosnpektuočiausi kokia poblema kilo, kaip aš ją sprendžiau, kas veikė kas ne. konspektuotis rpadedu dar tebesitęsiant problemai. pvz, ne per seniausiai mano kompiuteris negalėjo sukurti VPN tunelio, tada kartu su chatgpt bandžiau kartu spręsti kilusias probelmas. Kartu mes išmabdėme daug dalykų, kad patikinti kas veikia kas ne, tam kad identifikuoti problemos priežastį ir susiaurinti įtaramiųjų sąrašą. vsią šį procesą aš apsirašiau tam, kad vėl kilus tai probelamai, neturėčiau kartoti šio proceso, o jau žinočiau ką pradėti daryti ir taip sutaupyčiau laiko, nes pats atlikes tam tikrus veiksmus jau galėčiau chatgpt užduoti tiklesniį klausimą, apteikiant aiškesnensį situaijos įvertinimą.\nKitas scenarijus, kur nuolat naudoju užrašus, tai kaip aš instlaiuoju savo Linux sistemą. Kadangi mano kompiuteris naudoajmas ir darbo ir asmeniniais tikslais, man svarbu, akd perinstaliavus Linux, aš turėčiau gerai aprašytą procesą, ką turiu instaliuoti, po ko, kodėl. Po instaliavimo proceso, vis instlaiuojant naujas programas, aš kaskart papildau šį dokumentą, tam kad visad turėčiau aktualiasia jo versiją. To nedarant atsiranda taip vadinas “tech debt” - techninė skolą. Tai temrinas kuris naudojamas IT pasaulyje, kai programuotjai kažką padaro čia ir dabar, palikdami problemas ateičiai. :)\n\n\nperžirūėk https://youtu.be/kUZ3RP08-HY ir galbūt https://youtu.be/hSTy_BInQs8\ninstaliuok obsidian. Susikurk “vault” (direktoriją kurioje bus visi obsidian užrašai idelaisiu atveju į savo namų serverio Nextcloud)\nPerkelk savo konspektus. pagalvok, kaokia būtų geriausia aplankų ir failų struktūra\n\n\nObsidian naudoja Markdown formatą. Peržiūrėk čia, kaip jis naudojamas.\nPlugins\n\ncanvas\ntags\ntagsfolder\ncodeblocks dataview",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#tinklo-komandos",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#tinklo-komandos",
    "title": "7  BASH pažengusiems",
    "section": "7.3 Tinklo komandos",
    "text": "7.3 Tinklo komandos\nŠioje dalyje to išmoksi naudoti ping, curlir wget, kad galėtum patikrinti ryšį bei atsisiųsti duomenis.\nFilmuose apie povandeninius laivus dažnai sonarai paleidžia “ping” garsą, tam kad paleistas garsas reflektuotų objektus esančius vandenyje ir sonarai galėtų identifikuoti, kur slepiasi kitas povandeninis laivas.\n\n\nVideo\nPanašiai ir tu, gali naudoti ping komandą, kuri pingina kompiuterius, serverius ir gali patikrinti tiek, ar tu turi prieigą prie interneto (ping komanda išeina), tiek ar tavo norimas pasiekti kompiuteris yra pasiekimas.\nLinux operacinėje sistemoje komanda ping &lt;host&gt; leidžiua tau nurodyti vietoj  tiek tau žinomą URL adresą, pvz lrt.lt, tiek tiek kompiuterio / serverio IP adresą. Kartu priešingai nei Windows operacinėje sistemeoje, Linux ping nesustoja, tad labai patarčiau naudoti -c (count) ir nurodyti skaičių po kiek ping signalų komanda turėtų sustoti, pvz 5 .\nPabandyk\nping -c 5 infraplanas.lt\nDabar turėtum matyt kažką panašaus:\n\n\nping parašo kokį adresą pingins infraplanas.lt bet kartu ir nurodo šio adreso IP adresą (65.108.247.94)\ntu turėtum gauti 5 eilutės pingų atgal, su nurodytais meta duomenimis, tarp ju time, kaip ilgai užtruko signalui iš tavo kompiuterio nueitiki iki 65.108.247.94 ir grįžti atgal.\nping komanda sustojo po 5 kartų\n\nDabar tau gali kilti klausimas, ar tu gali pasinaudoti šiuo adresu, kad tiesiai atsiaryti interneto tinklapį?\npabandyk įrašyti komanda firefox 65.108.247.94\nVideo\nKaip matai, pavyksta. Bet taip nebus ne visada. Labai trumpai paaikšinsiu kodėl iškart po tavo praktikos.\n\n\npasinaoduok tldr ir identifikuok pagrinius flagus ping komandai. kada ir kokius naudotum? susikonspektuok\npabandyk pinginti 3 kartus vinted.lt\npabandyk atsidaryti pingintą IP su firefox &lt;IP&gt;\n\n\nTrumpai apie tai, kodėl tau pavyko pingtini vinted.lt, bet nepavyko atsidaryti 172.64.150.26.\n\nKai į interneto naršyklę įrašai vinted.lt tavo kompiuteris dar nežino, kur keliauti, t.y. konketaus IP adreso. Tad jis išeina į internatą irt šaukią AUUUU kas žinot, koks vinted.lt IP adresas? Yra specialūs serveriai, kurie reaguoja į tokis užklausas ir jie pasako, eik į IP 1xx.xxx.xxx.xxx tada tavo kompiuteris keliauja ten. Pimru atveju infraplanas.lt buvo pasiekiamas tiesiai adresu 65.108.247.94. Nes tai kažzkokiame paprastame serveryje patalpintas statinis tinklapis. Tačiau dauguma serverių šiais laikais naudojasi Cloudflare apsauga. Tai tari ugniasienė (firewall) kuri apsaugo serverius nuo atakų. Panašu, jog rašant vinted.lt tu kuo puikiaisi nueisi į vinted.lt tinklapį, bet įrašius IP adresą, Cloudflare sako:\n\nPabandyk dabar atjungti savo wifi ryši kompiuteryje ir pinginti pvz lrt.lt.\n\nKaip matai, gauni kur kas kitokią išvestį. Beje, pagalvok, čia stdout ar stderr?",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#curl-ir-wget",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#curl-ir-wget",
    "title": "7  BASH pažengusiems",
    "section": "7.4 curl ir wget",
    "text": "7.4 curl ir wget\ncurl ir wget yra įrankiai darbui su tinklo užklausomis, tačiau jų paskirtis skiriasi. wget orientuotas į failų atsisiuntimą, palaiko rekursyvų atsisiuntimą (pvz., svetainių veidrodžiams), automatiškai atnaujina nutrauktus parsisiuntimus ir paprastai išsaugo failus tiesiai į diską. Tuo tarpu curl yra universalesnis – jis tinka ne tik failų atsisiuntimui, bet ir duomenų siuntimui (pvz., API užklausoms), dirba su daugiau tinklo protokolų ir pagal nutylėjimą išveda duomenis į terminalą, o ne į failą.\n\n7.4.0.1 wget\nInterneto naršyklėje atsidaryk https://data.gov.lt/datasets/2749/, čia rasi “Transporto priemonių valstybiniai numeriai pagal markę ir modelį” duomenis. Papaudus ant “Duomenys” ir “Atsiųsti”, tu suprantama gali atsisiųsti manualiai duomenis. Bet argi taip elgiasi tikri programuotojai?\n\nNueik į API skiltį. Ten rasi HTTP, HTTTPie ir curl. Nusikopijuok url adresą esantį skiltyje Užklausa.\n\nTerminale irašyk wget https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris\n\nPeržvelk kas parašyta. Pirma wget resolvin’a url adresą ir supranta, kad tai 193.219.12.192, tada jungiasi prie jo. Gauną atsakymą kad ok, tau apvyko prisijungti (200 OK). tada pradeda duomenų parsiuntimą ir išsaugo kaip ValstybinisNumeris. Pabaigus siuntimą turėtum matyti tokį pranešimą, kuris pasako koks buvo vidutinis greitis ir koks failo pavadinimas.\n\nYra vienas bet… failą tau atsiuntė. tačiau jeigu pabandysi head ValstybinisNumeris nustebsi, nes pamatysi, jog terminalas nenustoja spausdinti. Tiesa gali jį nutraukti su ctrl+c. Taip nutiko dėl to, jog wget prigriebė reikiamą failą, tačiau netinkamu formatu. Tau atsiuntė failą taip vadinamu JSON formatu. Kur visi duomenys yra pirmoje eilutėje. Apie JSON formatus, pagalbėsime kitą kartą.\nTavęs neišgelbės ir flagas --output-document ValstybinisNumeris.csv kur galėtum nurodyti kaip užvadinti failą, nes po .csv failu vis tiek slypės JSON formato duomenys. Štai parsisiuntus ir bandant atsidaryti su LibreOffice Calc tu jau amtai, kad kažkas čia negerai\n.\nTaigi esmė ta, jog šie duomenys serveryje guli ne visai tuo formatu, kuris mums tinkamas. Taip yra dėl to, jog https://data.gov.lt/ yra gražus fasadas, bet po apačia veikia kiek mažiau graži programa, kuri pvadainta duomenų spinta.\nNueik į tą mažiau gražią “spintą”\n.\nVirįšuje pamatysi, visus formatus, kuriais galėtum parsisiųsti duomenis. Jeigu kairės pelės mygtuku paspausi and CSV interneto naršyklė pradės iškart šiųsti ValstybinsNumeris.csv. Bet tu atėjai ne to. Dešiniu pelės mygtuku paspasuks ant CSV ir meniu pasirinki nukopijuoti nuorodą (copy link)\n.\nnuordą kurią turėjai gauti atrodo taip https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris/:format/csv\nKaip matai, ji nealabai skirasi nuo https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris, kurią matei API skiltyje. Tiesiog URL adrese yra /:format/csv dalelė, kuri pasako, kokiu formatu parsisti.\n\n\n\n\n\n\nPraktika\n\n\n\n\nnaudojant rm komandą išsivalyk darbinę dirketoriją nuo nereikalingų failų\nnaudojantis wget ir nukopijuotą Link adresą parsiisųsk duomenis. Parsiunčiant naudok flag’ą --output-document ValstybinisNumeris.csv\nkol siunčiasi duomenys - pasidaryk kavos ☕\nAtspausdink primas 5 ValstybinisNumeris.csv failo eilutes ir įsitkink, jog duomenys dabar tokie, kokių tikėtumeisi.\n\n\n\n\n\n\n7.4.1 curl\ncurl yra panaši, tik kur kas daugiau nustatymų turinti programa. Svarbu pamainėti, kad curl nepateikus nustatymų, gražiną išvestė tiesiog terminale. Tai nėra optimalu, norin parsisiųsti duomenis. Jeigu paleistum curl https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris/:format/csv pamatytum skrieti rpadedantį .csv failą\n\n\n\n\n\n\n\nPraktika\n\n\n\n\npasinaudok tldr curl, curl --help ir pabandyk identifikuoti pagrindinius flagus. Taip pat pasiklausk ChatGPT apie tai, kokius flagus galėtum naudoti.\nnaudojant curl parsisiųsk failą\n\n\n\nPagrindiniai curl flagai -o &lt;failo pavadnimas&gt; išsaugo failą norimu pavadinimu. -s (silent) curl negrąžina jokio stdout, t.y. veikia tyliai.\n\n\n\n\n\n\nPraktika\n\n\n\n\nTinklapyje https://data.gov.lt susirask duomenis Valstybės apdovanojimai.\nParsisisųk juos .csv formatu išsaugant failą pavadinimu apdovanojimai.csv naudok wget\nprisimink, jog URL adresą gali pasiimt iš API skiltyje esančios užklausos adreso, tik turėtum pridėti /:format/csv\nsu curl parsisiųsk “Pacientų registracijos paslaugoms Žalgirio klinikoje” ir išsaugant kaip reg_zalgiris.csv\n\nDabar turėtum turėti 4 duomenų failus:",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failų-redagavimas-ir-apdorojimas",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failų-redagavimas-ir-apdorojimas",
    "title": "7  BASH pažengusiems",
    "section": "7.5 Failų Redagavimas ir Apdorojimas",
    "text": "7.5 Failų Redagavimas ir Apdorojimas\nPraeitame skyriuje tu jau išmokai naudotis komanda sed, kuri yra labai galinga apdorojant raw duomenis. Dabar dar praplėsi supratimą kaip gali išnaudoti uniq, kad geriau susipažintum su failo struktūra ar netgi atlik mini analizes.\n\n7.5.1 uniq\nTu jau moki sortiruoti failo eilutes su komanda sort, tiek didėjančia (A-Z), tiek žemėjančia (Z-A) tvarka, taip pat sortiruoti pagal skaičius. uniq comanda įgalina tave parodyti unikalias eilutes ir jeigu reikia jas suskaičiuoti.\nŠis komandų junginys head reg_zalgiris.csv | cut -d \",\" -f 13 | sort paima pirmas 10 eilučių, supjausto reg_zalgiris.csv failą identifiikuojant , kaip skirtumą tarp stulpelių, pasirenką 13ą stulpelį, o sort surikiuoja duomanis didėjančia tvarką (A-Z).\n\nKomanda uniq leidžia pamatyti unikalias reikšmes, tik uniq parašyta taip, kad aptiktų duplikatus tik tada, kai jie vienas šalia kito. Todėl uniq beveik visada naudojama kartu su sort head reg_zalgiris.csv | cut -d \",\" -f 13 |sort | uniq\n\nLabai retais atvejais tau gali būti įdomu sužinoti tik eilutes, kurios neturi duplikatu, tada naudutum flag’ą -u. Šiuo atveju gydytojo_specialybe kartojasi tik vieną kartą (natrūlau, tai duomenų antraštė), todėl uniq -u grąžina tik šią eilutę.\n\nKur kas prakšitkėnis flag’as - uniq -c, kuri suskaičiuoja kiek yra vienodų eilučių.\n\nTik kaip matai, dabar mes turime problemą -stuleplio antraštė (header) figuruoja kaip duomenys. Jeigu tau reikia tik grubiai įsivertinti ar duomenys teisingi, ir juos geriau surpasti, tai gali netrukdyti. Bet būtų galima iš išsivalyti.\n\n\n\n\n\n\nPraktika\n\n\n\n\nkokias 2 strategijas (komandas) reg_zalgiris.csv turi savo arsenale, neįtraukti eilutės su gydytojo_specialybe į tolimensius veiksmus? Prisimink ką išmokai --help dalyje, prisimink komandą, kuri filtuoja eilutes.\nPasinaudok viena iš šių strategijų ir suskaičiuok pas kokių speliacibių daktarus buvo daugiausiai ir mažiausiai registracijų.\n\nTurėtum gauti šį rezultatą:\n\nKaip matai, rezultatas nėra tobulas, nes dabar turi 6622 “Ortodontė” ir 6727 Ortodontas. Nors specialybė tokia pati. Jeigu tave domintų, kiek buvo registracijų pagal specialybes, ko gero suskirutm taisykles su sed komanda, kur suvienodintum profesijų pavadinimus ir apdaryutm juos neutralius lyčiai.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failų-paieška",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failų-paieška",
    "title": "7  BASH pažengusiems",
    "section": "7.6 Failų Paieška",
    "text": "7.6 Failų Paieška\nDabar susipažinsi su keliomis labai svarbiomis komandomis, kurios padės tau rasti failus. find skirtas paieškai su detaliaiss paieškos kriterijais (pagal pavadinimą, tipą, datą ir kt.). locate išnaudoja linux operacinėje sistemoja kuriamą failų indeksą greitai failų paieškai. whereis skirtas direktorijos vietos ir vykdomojo failo kelio (path) radimui, apimant bin ir dokumentaciją.\n\n7.6.1 find\nKomanda find naudojama ieškoti failų ir direktorijų pagal pavadinimą, dydį, datą, teises ir kitus kriterijus.\nBazinė find komanda atrodo taip find /path/to/search -options criteria\nTikėinta tavo darbinė direktorija dabar yra bash_advanced ir joje turi 4 failus. Pažiūrėk kokie jie dydžio.\n\nTurint omenyje, kad čia tik 4 failai, tai nėra bėgalo įdomu. Pažiūrėk ar dar turi shell_part_2 savo namų direktorijoje, jeigu ne, paleisk skriptą, jog ji vėl būtų sukurta (žr praėjusio skyrio pradžią).\nIeškoti failų darbinėje direktorijoje, t.y. “čia” galima išnaudoajt taško notaciją .. Tačiau tu darbuosies labiau su ~, t.y. nuoroda į visą savo namų direktoriją. Tavo ir mano terminalo išvestys skirsis, tad nenustebk, jeigu matysi daugiau ar mažiau failų.\npakeisk savo darbinę direktroiją į namų su cd ~.\nKomandai find pirmas argumentas yra kur yra ieškoma, dažniausiai tai tai gali būti:\n\nfind . ieškoti aktyvioje direktorijoje\nfind ~ ieškoti namų direktorijoje\nfind / ieškoti root direktorijoje (t.y. vismae kompiuteryje)\nfind ~/Downloads ieškoti vartootjo Downloads direktorijoje, arba kitoje konkrečiai nurodytoje direktorijoje\n\nfind priima daug skirtinų nustatmų ir vienas pagrindinių jų -name.\nSuraskime kur yra failas su regigtsracijomis į Žalgirio kliniką. įsivaizuokk, jog prisimini tik, kad ten buvo zalgiris pavadinime… Kaip matai, pirmoji komanda negfražina jokio failo, nes jo nerado. find kaip ri dauguma bash komandų gali veikti su wildcards.\nfind ~ -name zalgiris find ~ -name *zalgiris*\n\nDabar tu nori susirasti faila su valstybiniais numeriais, tačiau find ~ -name *valstyb* nieko negrąžina, nes find yra case sensitive, kaip ir viskas BASH’e. Panašiai kaipir su kitomis komandimis, čia gali pasinaudoti -iname kad padaryti paiekšą ne case-sensitive.\nfind ~ -name *valstyb* find ~ -iname *valstyb*\n\nBeje, jeigu nenurodysi -name &lt;pavadinimas&gt; tada find komanda ieškos visų failų ar direktorijų, atitinkančių kitus nurodytus kriterijus, jeigu nebus jokio kriterijo, tada ji suras tiesiog visus failus.\nfind bash_advanced/\n\nKartais tu gali norėti, kad find gražinntų ne tik rastų failų adresus bet ir daugiau informacijos, tada gali panaudoti -ls flagą\n\nTu gali apriboti paiešką pagal tai, kokio tipo failo (f) ieškai, ar tai yra direktoriją (d) , ar tai failas ar nuoroda (l).\nŠi komanda ieško tipo - direktorijos, kurios pavadinaime nepriklausomai nuo vietos ir raidžių dydžio yra “do”.\nfind -type d -iname *do*\nKaip matai find gražiną ir direktorijas kurios yra paslėptos\n\nTikėtina, kad tua gali būti įdomu rasti failus kurie užima daug, arba labai mažai vietos. šioje vietoje tau talkininkauja -size flagas. jis priima skaičius human readable formatu, pvz 10M = 10 megabaitų, 1G = 1 gigabaitas ir t.t. tam kad indikuoti failų dydį glai naudoti - arba + prieš skaičių, pasakant, kad ieškoti mažesnių nei x arba didesnių nei x failų.\nJeigu nurodysi skaičių be pliuso ar minuso, find ieškoys failų kurių dydis lygus pasirinktam argumentui.\nfind -type f -size 300M find -type f -size +300M\nJeigu kompiuteriu naudosies ilgai, tu gali norėti ieškoti failų pagal jų\n\nsūkūrimo data c\nmodifikavimo data m\nprieigos data a\n\ntokiu atveju tu turėtum naudoti flagus -[acm]time (pasirink reikiamą raidę) ir nurodyti dienas. -n reikš per paskutines n dienų, +n reikš daugiau nei prieš n dienų. Turėk omenyje, jog dienas find vertina kaip kalendorines. taip pat, jeigu nori, gali sukabinti kelis reikalavimus į vieną. pavz ieškoti failų kurie buvo sukurti prieš daugiau nei 2 diens -ctime +2 bet (ir) mažiau nei prieš 7 dienas -ctime -7\nfind ~ -type f -ctime +2 -ctime -7\nPaleidus šią komanda pamatysi, kad tikėinta, esi sukūrus gana daug failų, ir galbūt norėtum apsiriboti, kaip giliai find turėtų ieškoti. pabandyk išnaudoti -maxdepth arba -mindepth. šis argumentas yra globalus todėl jį turėtum rašyti iškart po find ~\nfind ~ -maxdepth 1 -type f -ctime +2 -ctime -7\nkomanda find priima ir loginius operatorius -and -or ir !( šauktukas atitinke - ne). nenustebk, neretai gali pamatyti trumpinius -a ir -o\nŠtai komandos ieško fialų, kurie yra sukurti prieš daugiau nei 2, bet mažiau nei prieš 7 dienas ARBA ir IR kai jų dydis daugiau nei 300MB.\nfind ~ -maxdepth 2 -type d -ctime +2 -ctime -7 -or -size +300M find ~ -maxdepth 2 -type d -ctime +2 -ctime -7 -and -size +300M\nKaip matai, -or leidžia rasti daugiau, nes or pakanki kad bent viena sąlyga būtų patenktina, tuo tarpu -and reikialauja, kad salygos visos sąlygos būtų ptanektintos.\n_\nKą daryti, jeigu nori sujungti daugiau sąlygų arba sukurti kiek sudėtingesnį loginį algoritmą? Tam gali išnaudoti skliaustleius. tačiau juos turėti escpainti su \\( ir \\) tam kad find neieškotų skliaustelių pavadinime.\nštai tai būtų galima ieškoti failų, kurie didesni nei 2M ir mažesni nei 100M IR yra arba .csv arba .txt\nfind ~ -size +2M -size -100M \\( -iname *.txt -or -iname *.csv \\)\nŠioje vietoje svarbu paminėti, akd būtina turėt tarpepius aplink skliaustleius! jeigu sukeli kelis raikalavimus, kaip atnai -size +2M, -size -100M, jie sujungiami su and todėl nebūtina jo nurodyti explicitškai\nFind komanda suteikia ir tam tikrų papildomų funkcijų. pvz -delete nustatymas ištrins (povisam) visus rastus failus!\nThe -exec option allows you to execute any command on the files or directories that find locates. The command is terminated with ;, and the {} placeholder is used within the command to represent the current file being processed.\nKitas svarus aspektas, kad tu gali perduoti rastus failus apdirbti kitoms komandoms. tada sintakse atrodo taip find -name ... exec grep -i apie {} \\;\nO dabar prieikime prie pavojingesnių komandų!\nfind turi nustatymą -delete, kad visus surastus failus, kuriuos ras pagal nurodyus parametrus, ištrintų. Naudok -delete tik, kai prieš tai būsi tikra, kad viskas, kas randama, gali būti trinama\nfind ~ -name \"*.txt\" -delete\n\nfind komanda jau yra labai stipri, tačiau tu dar nežinai jos stipriausios galios! su find tu gali perleisti rastus failus, tolesniam apdirbimui. tiesa, tai neveikia taip, kaip su pipe |. Syntakse yra tokia\nfind ... -exec &lt;komanda&gt; {} \\;\n\n-exec pasako, kad su tuo ką radai, dabar vykyk kitą komanda\n&lt;komanda&gt; gali būti bet kas, tik turi būti tinkama pasirinktiems failams\n{} panaudojamas vietoj failų pabadinimo\nkad baigei komandą, nurodai su \\;\n\nįsivaizduok, tu nori nori atspausdinti visas eilutes, kuriose yra žodis “apie”. Bet nepameni, kuriame būtent faile, tik žinai, kad tas failas buvo .txt formato\nfind ~ -type f -iname \"*.txt\" -exec grep -iH \"apie\" {} \\;\n\n\ntaigi find suranda visus tekstinius failus, tiklsiau tuos failus, kurių pavadinimas baigiasi .txt\n-exec perleidžia juos grep komandai\ngrep ieško case insensitive -i bet kartu ir atspasdina failo, kuriam priklauso rasti eilutė adresą -H\n\ntaip kaip perleidome failus rastus grep, juos alima perleisti ir ktoms komandoms, pvz rm, cp mv\nVisgi kaip matai, perelsiti failus į -exec gali būti pavojinga. alternatyva, kur tavęs prašys patvritinti kiekvienam failui taikomą komanda, yra -ok. Štai komanda, kuris suras visus failus, kuriųpavadinime yra .csv ir padarys jų kopiją į aplanka ~/copy.\nmdkir copy find ~ -iname “*.csv” -ok cp {} ~/copy/ ;\nKaip matai, prieš kiekvieną operą, temrinalas reikalauja patvirtinmo, kuri turi įrašyti y arba yes arba n no. jeigu spausi enter, tada tai aititks no.\nVideo\nKaip matai vykdant šia operaciją, find rado dar kartą tuos pačius failus ten, kur jie jau buvo nukopijuoti, t.y. pačioje copy direktorijoje. kad išvengti to, galima find nurodyti kur ne ieškoti su -not -path \"/home/justas/copy/*\" arba ! -path \"/home/justas/copy/*\" atkreip dėmesį į tai, nurodant -path, reikia absoliutaus adreso ir * kad tenai rasti failai (jų adresai) nebūtų įtraukti.\n\n\n\n\n\n\nPraktika\n\n\n\n\nparašyk komandą, kuri ieško visų failų tavo namų direktrijoje, kurių pavadinimas baigiasi arba .csv arba .txt.\nta pati komanda tik perleisk rezultatus į grep, atspausdink tas eilutes, kuriose yra “2024”\nsurask visus failus kurių sukūrimo data yra daugiau nei prieš 14 dienų, kurių pavadinimas baigiasi .mp4 ir failai yra dwhelper arba Downlaods direktorijose bei kurių dydis yra didesnis nei 100M.\nta pati komanda, tik panaudok -ok ir rm {}. dabar komanda perklaus ar trinti keivieną failą. Ši komanda turėtų padėti tau apsivalyti įvairius senokus video.\n\n\n\n\n\n7.6.2 locate\nLinux operacine sistema nuolad indeksuoja visus failus. Tad komanda locate &lt;pavadinimas&gt; padeda labai greitei rasti failą, kurio pavadinimą tu jau žinai. Suprantama, gali naudoti wildcard *.\n\nTrūkumas: Nerodo naujausiai sukurtų ar pervardytų failų, kol nėra atnaujinta duomenų bazė. Iššaunkti atnaujinimą alima su updatedb\nVideo\nLocate taip pat neturipaiekšos parametrų kaip dydis, amžius ir t.t. kuriuos turi find.\n\n\n7.6.3 whereis\nKomandos whereis paskirtis rasti vykdomuosius failus (binary files), jų dokumentaciją (man puslapius) ir šaltinio failus. Naudojama norint sužinoti, kur yra įdiegta programa ar vykdomasis failas.\n\n\n\n7.6.4 which\nKomandos which paskirtis rodyti, kurioje PATH aplinkoje esantis vykdomasis failas bus paleistas, kai įvesi jo pavadinimą terminale. which patikrina vartotojo aplinkos kintamąjį PATH ir pateikia pirmą rastą vykdomąjį failą.\n\nSvarbu: which rodo tik pirmą PATH rastą vykdomąjį failą. Taigi jeigu nori žinoti AR turi programa pvz python instlaiuotą, which tau į tai atsakys. tačiau enatsakys, ar turi tam tirkas python versijas. Tam geriau naudti whereis.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failo-teisių-valdymas",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failo-teisių-valdymas",
    "title": "7  BASH pažengusiems",
    "section": "7.7 Failo teisių valdymas",
    "text": "7.7 Failo teisių valdymas\nUžpaeitame skyriuje susipažinai su tuo, jog failai ir direktorijoms priirktas valdytojas. ir kartu nurodomos to vartojo, jo grupės ir visų kitų vartotojų teisės.\ndrwxrwxr-x 4 justas justas 4096 Sep 27 18:28 backup drwxrwxr-x 2 justas justas 4096 Sep 28 18:45 data -rw-rw-r– 1 justas justas 45 Sep 28 16:28 list_du_home.sh -rw-rw-r– 1 justas justas 635 Sep 28 13:33 list.txt drwxrwxr-x 2 justas justas 4096 Sep 27 21:42 mix drwxrwxr-x 2 justas justas 4096 Sep 28 18:34 text\nTaigi, ką tu gali keisti?\n\nsu chmod tu gali keisti priegos teises\nsu chown tu gali keisti vartotojo vardą\nsu chgrp tu gali keisti savininko grupę\n\nSu chown ir chgrp tu susidursi retai, nes relaybeje beveik nebus scenarijų kada tau gali reikėti keisti failo savininko vardą ar jo grupę. Jeigu visgi prireiktų turėk omenyje kas su\n\nchown &lt;user&gt; &lt;file&gt; pasirinktam failui tu gali nurodyti, aks yra vartotojas\nchown &lt;user&gt;:&lt;group&gt; &lt;file&gt; po : gali nurodyti iškart ir grupę\nchown -R &lt;user&gt;:&lt;group&gt; &lt;direcotry&gt; jeigu reikia pakeisti visų failų esnų direktorijoe teises gali naudoti flag’ą -R\ntik grupę gali pakeisti su chown :&lt;group&gt; &lt;file&gt;\narba su chgrp &lt;group&gt; &lt;file&gt;\n\nTurėk omenyje, kad jeigu keisti sisteminių failų savininkų teises, tau gali reikėi administratoriaus teisių, todėl gali reikėti panaudoti sudo prie chown komandą.\nKol savininko vardo ir grupės keitimas yra mažai tikėtinas scenarijus, su kuriuo susidursi, teisių keitimas yra labai aktualus.\nYra du scenarijai, kada tau reikės keisti failo teises.\n\nskriptų paleidimas\nappimages paleidimas\n\nĖsivaizduok tu sukuri skriptą, ką tavo Linux’as turi padaryti atlitki, na pvz surasti 30 dienų nenatidarytus failus esčnaius dwhelper ir downloads direktorijose ir tuos failus ištrinti. tarkime skritpas yra senu_video_valymas.sh. jeigu tu atpsausdinsi ls -l pamatyti, jog faials turi įprastines reises, savininkos ir jo grupė turi teisę read ir write, o kiti vartotojai tik read.\nTačiau su chmod &lt;kodas&gt; &lt;failas&gt; tu gali pakeisti šias teises.\nKodo reikšmės:\n\n4 - read\n2 - write\n1 - execute\n\nJeigu nori savininkui suteikti read 4 + write 2 + execetu 1 = 7. jeigu nori suteikti tokias pat teises grupei - 7. O kitiems vartotojams, jeigu nori palikti tik read - 4, gauni trijų skaitmenų koda 774. Kurio nustatai, kad turi ir kokias teises.\nchmod 774 senu_video_valymas.sh\n\nAtkreipk dėmsi į tai, kad skiprtas, kai jis tapo executible, pakeitė spalvą ir tapo žalias!\nTu bet kada gali atkeisti teises pvz atgal tik į read +write , t.y 4+2=6 vartojui ir jo grupei ir tik read =4 kitiems vartotojams\nchmod 664 senu_video_valymas.sh.\nKitas varianta kada gali reikėti pakeisti teises, tai parsisiuntus AppImage. AppImage yra tam tikras programos failo formatas, kur visa programa yra konteinerizuota pačiame faile. Nors tu tiktėtina jau turi Freetube, nueik į https://freetubeapp.io/#download ir paspausk ant AppImage, kad jį atsisiųsti.\n\nkaip matai, failas neturi executbale teisių.\n.\nNorint paleisti failą, reiktų arba atsidarius su Nemo, aspausti dešiniu pelės mygtuku, ir pasirinkti Properites, tada eiti į Permissions ir ten udždėti varnelę ant “Allow executing file as program”.\nVideo\narba su chmod 774 freetube_0.22.0_amd64.AppImage suteikti tas pačias teises.\ndabar dukart paspaudus ant Freetube ikonėlės porgama pasileidžia, bet paleisti ją galima ir iš temrinalo su ./freetube_0.22.0_amd64.AppImage.\nTaigi iš esmės skriptas ir parsisiųstas AppImage failas iš esmės veikia gana panašiai.\nverta žinoti, kad internete gali suteikti ir chmod a+x &lt;failas&gt; komandos notaciją, kuri reiškia: visiems (a) vartotojams pridėk execution (+x) teises. Tačiau mano patarimas, geriau elgtis kiek saugiau ir suteikinėti teises tik savininkui ir jo grupei, bet ne kitiems vartotojams.\nŠiame symbolic mode tu gali sudėti komandas naudojant:\n\na: all users (user, group, and others)\nu: user (owner of the file)\ng: group (group associated with the file)\no: others (everyone else)\nr: read permission (value 4)\nw: write permission (value 2)\nx: execute permission (value 1)\n+: add permission\n-: remove permission\n=: set exact permissions (replace existing ones)\n\nCommand Numeric Value User Group Others Explanation chmod a+x — Adds x to all users (rwxr-xr-x) - - Adds execute permission for all users chmod 777 777 rwx rwx rwx Full permissions for all users chmod 755 755 rwx r-x r-x Owner can read, write, execute; others can read and execute chmod 664 664 rw- rw- r– Owner and group can read and write, others can only read chmod 644 644 rw- r– r– Owner can read and write, others can only read chmod 700 700 rwx — — Only the owner has full access",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#procesų-valdymas",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#procesų-valdymas",
    "title": "7  BASH pažengusiems",
    "section": "7.8 Procesų Valdymas",
    "text": "7.8 Procesų Valdymas\nSistemų administravime ir duomenų analitikoje svarbu suprasti, kas vyksta kompiuteryje. Komandos ps aux ir htop leidžia stebėti veikiančius procesus ir identifikuoti problemas, susijusias su resursų naudojimu.\n\n7.8.1 ps aux – Procesų sąrašas\nps aux leidžia pamatyti visų veikiančių procesų sąrašą. Ši komanda naudinga, kai norite gauti statinį procesų vaizdą.\nKą rodo išvestis?\n\nUSER: Kas paleido procesą. Pvz., justas, root.\nPID: Procesų identifikatorius (unikalus skaičius).\n%CPU: Kiek procesorius užimtas procesu.\n%MEM: Kiek RAM naudoja procesas.\nCOMMAND: Proceso paleidimo komanda, pvz., python analysis.py.\n\nTipiniai scenarijai:\nIeškoti konkretaus proceso\nTarkime, dirbate su dideliu Python skriptu, bet jis užstringa ir turite jį sustabdyti. Naudokite:\nps aux | grep python\nTai parodys visus procesus, susijusius su python. Rasite PID ir galėsite sustabdyti procesą su kill komanda:\nkill \nRūšiuoti pagal procesoriaus naudojimą Jei kompiuteris veikia lėtai, išsiaiškinkite, kuris procesas apkrauna CPU:\nps aux –sort=-%cpu | head\nAtminties naudojimo analizė Tarkime, jūsų mašinos RAM greitai užsipildo analizuojant didelius duomenis:\nps aux –sort=-%mem | head\n\n\n7.8.2 htop – Patogus procesų stebėjimas realiu laiku\nhtop – tai interaktyvus įrankis, skirtas stebėti procesus realiu laiku. Jis yra vizualiai aiškesnis nei ps aux, pateikia spalvotą sąsają, leidžia filtruoti, rūšiuoti ir valdyti procesus.\nKaip paleisti htop:\nhtop\nPagrindinės funkcijos:\nRodo procesus, rūšiuotus pagal resursų naudojimą.\nLeidžia sustabdyti procesus neišeinant iš sąsajos.\nDinamiškai atnaujina informaciją.\nValdymas htop viduje:\nRodyklių klavišai: Naršyti procesus.\nF3: Ieškoti proceso pagal pavadinimą (pvz., įveskite python).\nF9: Užbaigti pasirinktą procesą (kill).\nF10: Išeiti iš htop.\nTipiniai scenarijai:\nSurasti procesą, kuris apkrauna CPU\nDirbant su dideliais duomenų failais, htop leidžia pamatyti, ar jūsų skriptas naudoja per daug CPU. Ieškokite proceso, rūšiuokite paspausdami P.\n\nValdyti strigusį procesą\nJei jūsų R arba Python procesas užstringa, raskite jį naudodami htop, pasirinkite rodyklėmis ir paspauskite F9.\n\nAtminties stebėjimas realiu laiku\nDarant sudėtingus skaičiavimus (pvz., mokant mašininio mokymosi modelį), stebėkite atminties naudojimą. Jei procesas per daug apkrauna sistemą, galite jį sustabdyti.\n\n\n7.8.3 whoami\n5.2 whoami and $PATH: Identifying User and Executable Paths\nwhoami: Check current user.\n$PATH: Understand the executable search path and use which to locate commands.\nExercise: Check your $PATH, then find the path of ls with which.\nKomanda whoami parodo dabartinio vartotojo (user) vardą, su kuriuo esate prisijungę prie sistemos. Tai paprastas ir naudingas būdas patikrinti, kokį vartotojo prisijungimą naudojate, ypač kai dirbate su keliais vartotojais toje pačioje sistemoje.\nwhoami\n\n\n\n7.8.4 $PATH\nPersp4jimas ši tema kiek sudėtingesnė, bet ją pravartu žinoti.\nKaip Shell žino, kokią programą startuoti, kai pvz tu įrašai ls? Juk negali Shell eiti per visus tavo failus ir ieškoti, ar yra tokia programa ls? Tai užtruktų labai ilgai ir būtų neefektyvu. Tavo Bash programa yra išsaugojusi visų direktorijų sąrašą, kurias ji tikrina. Tod4l pavyzdžiui įrašius\nmain-user@linux-mint:~$ $PATH\nbash: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin: No such file or directory\nKą visa tai reiškia? Kai vartotojas įrašo komanda ls Bah pirma tikrina /usr/local/sbin/ jeigu ten neranda, eina į sekandią direktoriją /usr/local/bin ir t.t. Jeigu visame sąraše šios programos nebūtų, įrašius ls nieko neįvyktų, o terminale išvystum pranešimą, su siūlymų galbūt šią programą instaliuoti (jeigu apt programa apie šią komandą kažką žino).\nsu komanda which galime pamayti, o tai kur būtent ls randasi\nmain-user@linux-mint:~$ which ls\n/usr/bin/ls\nTaigi įrašius ls bash keliavo\n\n/usr/local/sbin &lt;- nerado ls\n/usr/local/bin &lt;- nerado ls\n/usr/sbin &lt;- nerado ls\n/usr/bin &lt;- čia rado ls\n\nRetais atvejais, tau gali reikėti pridėti direktorijas prie $PATH, bet labai tikėtina, jog tik pradedant naudotis Linux CLI, tau to dar nereikės. Tačiau jeigu kada prireiks, tu žinosi, apie ką čia kalbama.\n\n\n7.8.5 which\nKomanda which naudojama norint sužinoti, kurioje vietoje (path) yra esanti tam tikra vykdomoji programa. Ji parodo visą vykdomojo failo kelią, nurodydama, kurioje direktorijoje sistema pirmiausiai ieškos šios programos pagal PATH aplinkos kintamąjį.\nKartu ši komanda naudojama norint sužinoti, ar norima komanda yra įdiegta.\nparodo kurioje vietoje yra ls programa\nwhich ls\nTaip pat galima pamatyti, ar pvz neovim programa yra instaliuota\nwhich neovim\nKadangi Terminal negrąžino jokio kelio (path), tai pasako, jog šios programos nėra.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#nano",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#nano",
    "title": "7  BASH pažengusiems",
    "section": "7.9 nano",
    "text": "7.9 nano\nwhich nano\nnano\nNew Buffer - rei6kia n4ra jokio failo galima bet ką ašyti\nsu rodyklėmis galima judėti\n^Raidė = tas ptas kas spausti ctrl ir raidę\ncitrl O write Out tada duoti pavadinimą\ndaug dažniau naudojama\nnano failas. jeigu failas yra, jis bus atidarytas jeigu failo nėra, jis bis sukurtas, KAI jis bus išsaugottas jeigu reikia teisių rayši sistmeinius failus sudo nano failas\nctrl w - leidžia ieškoti ctrl - X kad išeiti cut visą eilutę cltr k paste cltr u ctrl s\nnano + linenumber nano -v fialas (view only file)\nsudo apt install spell\nctr t iškart parodo kuris neteisingas tada galima apačioje ršašyti ctrl t vl palitki spell check mode\n\n7.9.1 Pagrindiniai “nano” klaviatūros trumpiniai:\n\nCtrl + O: Išsaugoti failą (Write Out).\nCtrl + X: Išeiti iš nano.\nCtrl + W: Ieškoti teksto (Where Is).\nCtrl + K: Iškirpti pažymėtą tekstą.\nCtrl + U: Įklijuoti iškirptą tekstą.\nCtrl + J: Teisingai suformatuoti dabartinį pastraipą (išlyginti tekstą).\nCtrl + C: Rodyti dabartinę žymeklio padėtį (eilutė ir stulpelis).\nCtrl + A: Pereiti į eilutės pradžią.\nCtrl + E: Pereiti į eilutės pabaigą.\nCtrl + Y: Slinkti aukštyn viena puslapiu.\nCtrl + V: Slinkti žemyn viena puslapiu.\nCtrl + T: Tikrinti rašybą (jei pasiekiama).\nCtrl + _ (pamynimas): Pereiti į konkrečią eilutę.\n\n\n\n7.9.2 “nano” paleidimas iš komandų eilutės:\n\nnano &lt;failas&gt;: Atidaryti nurodytą failą (sukurti, jei jis neegzistuoja).\nnano -c &lt;failas&gt;: Rodyti žymeklio padėtį (eilutė ir stulpelis) būsenos juostoje.\nnano -B &lt;failas&gt;: Įjungti atsarginio failo kūrimą prieš išsaugant.\nnano -m &lt;failas&gt;: Įjungti pelės palaikymą (slinkimui ir teksto žymėjimui).\nnano -l &lt;failas&gt;: Rodyti eilutes kairėje maržoje.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#alias",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#alias",
    "title": "7  BASH pažengusiems",
    "section": "7.10 Alias",
    "text": "7.10 Alias\nIr užbaikime šį skyrių nedideliu “programavimu”. Tai dar ne visai skriptų rašymas, bet jau gana “šilta”.\n\nTu išmokai surasti didelius video failus ir tavo komanda atrodė ko gero taip\nfind ~/Downloads/ ~/dwhelper/ -type f -iname \"*.mp4\" -size +100M -atime +14\njeigu kaskart reiktų ją surašyti, nors tu be abejonės galėtum tai padaryti, tai atime daug laiko. Vienas variantas, kurį ioksi vėliau, tai automatizuoti tam tikrų skriptų paleidimą, pvz kai įsijungia kompiuteris. Tačiau kiek paprastenis būdas, yra šiai komandai sukurti trumpinį, kurį tavo temrinalas žinos ir kurį įrašius, jis vietoj tavėęs padaryšs visą ilgą komanda.\nkad sukurti trumpinį, tu turi edituoti taov namų direktorijjoje esantį .bashrc failą. pačioje failo pabaigoje turėtum priratyši tokią sintakse\nalias alias_name='command' pvz alias lnuf='find...'\njeigu dabar terminale įrašysi lnuf jis nieko nesupras ir sakys, akd tokios komandos neturi. Taip nutiko dėl to, kad paeisus .bashrc failą, tavo terminalas dar nežino, akd šis failas atsinaujino. Vienas sprendimas būtų tiesiog išjungti ir vėl paleisti Terminal programą. Tačiau gerensis sprendimas yra komanda source .bashrc, kuris iš naujo užrkauna terminale bash shell nustaytyms su nauju sukurtu alias.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html",
    "title": "8  BASH darbas su OS",
    "section": "",
    "text": "8.1 tail -f\ntail -f Komanda Linux sistemoje\ntail -f yra komanda, naudojama stebėti failų turinį realiu laiku. Paprastai ji naudojama stebint log failus arba bet kokius kitus failus, kuriuose įrašai nuolat pridedami. Tai labai naudinga stebint programas ar sistemos procesus, kurie generuoja žurnalus arba nuolat atnaujina savo išvestį. Sintaksė:\ntail -f [failo_pavadinimas]\nPagrindiniai pavyzdžiai, kaip naudoti tail -f:\ntail -f /var/log/syslog\nStebėti žurnalo failą, kuris nuolat atnaujinamas: Jei turite programą, kuri generuoja žurnalą ir nuolat prideda naujus įrašus į failą, galite naudoti tail -f:\ntail -f /path/to/logfile.log\nStebėti kelis failus vienu metu: Galite stebėti daugiau nei vieną failą, nurodydami kelis failus komandoje:\ntail -f /var/log/syslog /var/log/auth.log\nPakeisti atvaizduojamų eilučių skaičių: Norėdami rodyti ne tik paskutines 10 eilučių, galite naudoti -n parinktį ir nustatyti norimą eilučių skaičių:\nNaudojimo atvejai ir scenarijai:\nPapildomos parinktys:\nApibendrinimas:\ntail -f yra komanda, leidžianti stebėti failo turinį realiu laiku. Tai ypač naudinga stebint log failus, kad galėtumėte matyti naujausius įrašus, kurie pridedami prie failo, pavyzdžiui, klaidas, įvykdytas operacijas arba įvykusius įvykius. Tai būtina komanda sistemų administratoriams ir kūrėjams, kurie dirba su realiu laiku atnaujinamais duomenimis.\nServices\nsystemctl Komanda Linux sistemoje\nsystemctl yra pagrindinė komanda, naudojama valdyti sisteminius paslaugų (services), procesus ir įrangą, kai naudojama systemd (dažniausiai pasitaikanti init sistema Linux distrose, pvz., Ubuntu, CentOS ir kt.). Su šia komanda galima valdyti, stebėti ir konfigūruoti paslaugas, užtikrinant, kad sistema veiktų sklandžiai. Pagrindiniai systemctl naudojimo atvejai:\nsudo systemctl start [service_name]\nSustabdyti paslaugą:\nsudo systemctl stop [service_name]\nIš naujo paleisti paslaugą:\nsudo systemctl restart [service_name]\nĮjungti paslaugą, kad ji būtų paleista po sistemos paleidimo:\nsudo systemctl enable [service_name]\nIšjungti paslaugą, kad ji nebeveiktų po sistemos paleidimo:\nPatikrinti paslaugos statusą:\nPeržiūrėti visas veikiančias paslaugas:\nŽiūrėti logus:\nPakeisti sistemą:\nsudo systemctl reboot\nIšjungti sistemą:\nDažnai naudojamos systemctl parinktys:\nPavyzdžiai, kaip naudoti systemctl:\nsudo systemctl status nginx\nĮjungti nginx serverį, kad jis automatiškai startuotų po sistemos paleidimo:\nsudo systemctl enable nginx\nSustabdyti nginx paslaugą:\nsudo systemctl stop nginx\nPerkrauti paslaugą, pvz., po konfigūracijos pakeitimų:\nsudo systemctl restart nginx\nPeržiūrėti žurnalą, susijusį su paslauga:\nNaudojimo atvejai:\nApibendrinimas:\nsystemctl komanda yra galingas įrankis, skirtas valdyti sistemines paslaugas ir procesus, kai naudojama systemd. Tai leidžia startuoti, sustabdyti, atnaujinti, peržiūrėti ir konfigūruoti paslaugas bei sisteminius procesus. Tai būtina komanda tiek sistemos administratoriui, tiek kūrėjui, kuris dirba su serveriais ar kitomis Linux pagrindu veikiančiomis sistemomis.\nsudo systemctl status apache2\nsudo systemctl start apache2\nsudo systemctl stop apache2\nsudo systemctl restart apache2\nsudo systemctl enable apache2\nSecurity - Users and Groups\nPermissions are assigned based on “everyone”, users and groups.\nAll resources are objects in Linux. So to give permission to the webcam you would add your user to the group that owns the video object.\nCertain resources reset their permissions at reboot such as video. You have to add your user to the group that owns it instead of simply making yourself owner.\nadduser, groupadd, usermod Komandos Linux sistemoje\nŠios komandos naudojamos valdyti vartotojus ir grupes Linux sistemoje. Jos leidžia kurti, redaguoti ir pašalinti vartotojus bei grupes, taip pat nustatyti leidimus ir konfigūruoti paskyras. Šios komandos yra naudingos sistemų administravimui, kai reikia valdyti prieigą prie sistemos. 1. adduser – Naujo vartotojo sukūrimas\nKomanda adduser naudojama sukurti naują vartotoją Linux sistemoje. Tai paprastai apima ir vartotojo namų katalogo sukūrimą, taip pat vartotojo paskyros konfigūravimą.\nSintaksė:\nsudo adduser [vartotojo_vardas]\nPavyzdys:\nsudo adduser jonas\nPaaiškinimas: Tai sukurs naują vartotoją „jonas“, sukurs jo namų katalogą /home/jonas, taip pat nustatys vartotojo slaptažodį ir kitus parametrus (pvz., pilną vardą, telefono numerį ir kt.). 2. groupadd – Naujos grupės sukūrimas\nKomanda groupadd naudojama kuriant naują grupę Linux sistemoje. Grupės leidžia grupuoti vartotojus ir priskirti jiems bendrus leidimus.\nSintaksė:\nsudo groupadd [grupės_vardas]\nPavyzdys:\nsudo groupadd admins\nPaaiškinimas: Tai sukurs grupę „admins“, kurią vėliau galima naudoti priskiriant vartotojus, kad jie turėtų bendrus leidimus (pvz., administravimo teises). 3. usermod – Vartotojo paskyros modifikavimas\nKomanda usermod leidžia modifikuoti esamą vartotojo paskyrą. Su šia komanda galima keisti vartotojo grupes, nustatyti ar pakeisti vartotojo namų katalogą, slaptažodį ir kitus parametrus.\nSintaksė:\nsudo usermod [parinktys] [vartotojo_vardas]\nDažniausiai naudojamos parinktys:\nPavyzdžiai:\nsudo usermod -aG admins jonas\nPakeisti vartotojo vardą:\nsudo usermod -l petras jonas\nPakeisti vartotojo namų katalogą:\nNaudojimo atvejai ir scenarijai:\nApibendrinimas:\nŠios komandos yra būtinos sistemos administratoriui, kad galėtų valdyti vartotojus ir grupes, reguliuoti prieigą ir užtikrinti saugumą.\nWhat is a Service?\nA service is typically a background process (daemon) that starts when the system boots and provides ongoing functionality (e.g., web servers, databases, logging systems). Services are managed by init systems like systemd, which starts, stops, and supervises them. How Processes Relate to Services\nUsing systemd to Inspect Processes\nsystemctl status\nThis shows the service’s status, logs, and the active processes.\nExample for nginx:\n● nginx.service - A high performance web server Loaded: loaded (/lib/systemd/system/nginx.service; enabled) Active: active (running) since Mon 2024-11-25 10:00:00 Main PID: 1234 (nginx) Tasks: 3 (limit: 4915) Memory: 4.5M CGroup: /system.slice/nginx.service ├─1234 nginx: master process └─1235 nginx: worker process\nFind All Processes in a Service’s cgroup:\nsystemd-cgls\nThis command shows the hierarchy of processes, grouped by services.\nList All Processes Started by systemd:\nExamples of How Processes and Services Work Together\nWhen a Process Isn’t Connected to a Service\nWhy Use systemd for Processes?\nBy using tools like systemctl and understanding how services spawn and manage processes, you can efficiently control and troubleshoot system processes in Linux.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH darbas su OS</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#tail--f",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#tail--f",
    "title": "8  BASH darbas su OS",
    "section": "",
    "text": "Stebėti log failą realiu laiku: Jei norite stebėti sistemos logus, pavyzdžiui, /var/log/syslog arba /var/log/auth.log, galite naudoti šią komandą:\n\nPaaiškinimas: Tai leis matyti naujausius įrašus, kurie pridedami prie syslog failo.\n\n\n\n\nPaaiškinimas: Tai leis stebėti abu failus realiu laiku.\n\ntail -n 20 -f /var/log/syslog\n\n    Paaiškinimas: Tai parodys paskutines 20 eilučių iš syslog failo ir toliau stebės naujus įrašus.\n\nSistemos administravimas:\n    Žurnalo stebėjimas: Stebėti sistemos logus, kad pastebėtumėte klaidas ar problemas. Pavyzdžiui, galite stebėti, kas vyksta su jūsų serveriu, stebėdami /var/log/syslog failą.\nProgramų stebėjimas:\n    Programos žurnalo stebėjimas: Kai programa generuoja log failus (pvz., web serverio žurnalai), galite naudoti tail -f, kad matytumėte, kas vyksta realiu laiku.\nTinklo klaidų ir užklausų stebėjimas:\n    Tinklo žurnalai: Jei dirbate su tinklo diagnostika, galite stebėti tinklo logus, kad matytumėte užklausas ir klaidas realiu laiku.\n\n-f (follow): Tai pagrindinė parinktis, kuri leidžia stebėti failo turinį realiu laiku.\n-n: Nustato, kiek eilučių turėtų būti rodomos iš karto, kai komanda pradeda.\n-s: Nustato atnaujinimo intervalą (sekundėmis). Pvz.:\n\ntail -f -s 2 /var/log/syslog\n\nTai stebės syslog failą, atnaujindama išvestį kas 2 sekundes.\n\n\n\n\n\nPaslaugų valdymas (start, stop, restart, enable, disable):\n    Startuoti paslaugą:\n\nPaaiškinimas: Ši komanda užtikrina, kad nurodyta paslauga pradėtų veikti (pvz., httpd, ssh).\n\n\nPaaiškinimas: Sustabdo veikiančią paslaugą.\n\n\nPaaiškinimas: Atkūrimas po klaidos ar konfigūracijos pakeitimų. Tuo pačiu metu paslauga sustabdyta ir vėl paleidžiama.\n\n\nPaaiškinimas: Tai įgalina paslaugą automatiškai startuoti po sistemos paleidimo.\n\nsudo systemctl disable [service_name]\n\n    Paaiškinimas: Tai sustabdo paslaugos automatinį paleidimą per kitą sistemos paleidimą.\n\nPaslaugos būsenos peržiūra:\n\nsystemctl status [service_name]\n\n    Paaiškinimas: Ši komanda parodo paslaugos būseną, įskaitant, ar ji veikia, klaidas, paskutines žinutes ir kt.\n\nVisų paslaugų peržiūra:\n\nsystemctl list-units --type=service\n\n    Paaiškinimas: Tai rodo visų aktyvių paslaugų sąrašą sistemoje.\n\nŽiūrėti sisteminius logus:\n\njournalctl\n\n    Paaiškinimas: Tai leidžia peržiūrėti sisteminius žurnalus, kurie apima įvykius ir klaidas, susijusias su paslaugomis, sistemomis ir įrenginiais. Galima naudoti įvairias parinktis, kad filtruotumėte informaciją.\n\nPerkrauti sistemą:\n\nPaaiškinimas: Tai perrašo sistemą (dažnai naudojama po atnaujinimų).\n\n    sudo systemctl poweroff\n\n        Paaiškinimas: Tai išjungia sistemą.\n\n--type=service: Tai leidžia tiksliai nurodyti, kad norite dirbti su paslaugomis (service).\n-a: Tai rodo visų paslaugų būseną (net ir paslaugų, kurios nėra aktyvios).\n--failed: Tai parodys tik tas paslaugas, kurios nepavyko paleisti.\n\nPatikrinti paslaugos būseną:\n\nTai parodys, ar nginx web serveris veikia, ar jis sustabdytas, ir paskutines klaidas.\n\n\n\n\n\n\n\njournalctl -u nginx\n\n    Tai parodys visus įrašus, susijusius su nginx paslaugos žurnalu.\n\nSistemos administravimas: systemctl yra būtina komanda sistemos administratoriui, kad jis galėtų valdyti paslaugas, keisti jų būsenas ir peržiūrėti logus.\nWeb serverių administravimas: Tai naudinga prižiūrint web serverius, tokius kaip nginx ar apache, ir užtikrinant, kad paslaugos būtų teisingai paleistos ir veiktų be trikdžių.\nSistemos diagnostika: Naudojant systemctl status ir journalctl, galima greitai diagnozuoti problemas, susijusias su paslaugomis ir sistema.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-aG: Pridėti vartotoją prie grupės.\n-d: Nustatyti vartotojo namų katalogą.\n-l: Pakeisti vartotojo vardą.\n\nPridėti vartotoją prie grupės:\n\nPaaiškinimas: Tai pridės vartotoją „jonas“ prie grupės „admins“.\n\n\nPaaiškinimas: Tai pakeis vartotojo vardą iš „jonas“ į „petras“.\n\nsudo usermod -d /home/petras jonas\n\n    Paaiškinimas: Tai pakeis vartotojo „jonas“ namų katalogą į /home/petras.\n\nSistemos administravimas:\n    Vartotojų kūrimas ir redagavimas: Naudojant adduser ir usermod, galima kurti naujus vartotojus ir pritaikyti jiems teises, kad jie galėtų prisijungti prie sistemos ir atlikti tam tikras užduotis.\n\nGrupių valdymas:\n    Grupių kūrimas ir priskyrimas: groupadd leidžia kurti grupes, kurias galima naudoti, norint grupuoti vartotojus pagal jų roles (pvz., administratorių grupės, vartotojų grupės) ir valdyti prieigą prie failų ir sistemų išteklių.\n\nTeisių suteikimas:\n    Pridėti vartotoją prie grupės: Su usermod -aG galima suteikti vartotojui papildomas teises pagal grupę. Tai ypač naudinga valdyti vartotojų prieigą prie tam tikrų paslaugų (pvz., administratorių teises ar prieigą prie specifinių resursų).\n\nadduser yra naudinga, kai reikia sukurti naują vartotoją sistemoje.\ngroupadd leidžia sukurti naujas grupes, kad vartotojai galėtų būti grupuojami pagal roles ir paskirtas teises.\nusermod suteikia galimybę redaguoti esamų vartotojų paskyras, pritaikant vartotojo vardą, grupes, namų katalogus ir kitas savybes.\n\n\n\nServices Start Processes:\n    When you start a service with systemctl start &lt;service-name&gt;, systemd launches the associated process.\n    For example, starting the nginx service launches the nginx process.\n\nProcesses Managed by systemd:\n    systemd supervises the lifecycle of service processes. If a process crashes, systemd can restart it automatically.\n    systemd tracks processes via cgroups (control groups), which help isolate resources and ensure the process hierarchy remains tied to the service.\n\nParent-Child Relationship:\n    Processes started by a service often create child processes (e.g., worker processes for web servers). These child processes are also managed as part of the service by systemd.\n\nCheck Active Processes for a Service:\n\n\n\n\n\n\n\n\nps -e --forest\n\nThis shows a tree of all processes. Processes started by systemd will appear under its PID.\n\nWeb Server:\n    Starting apache2 as a service with systemctl start apache2 launches the apache2 process (and its worker threads).\n    If the main process crashes, systemd can automatically restart it.\n\nDatabase Server:\n    Starting mysql with systemctl start mysql launches the mysqld process.\n    Multiple helper processes may also spawn, all tied to the mysql.service.\n\nScheduled Tasks:\n    A cron job managed by the cron service spawns processes (e.g., a Python script).\n    The cron service itself is managed by systemd.\n\nIf you run a program manually (e.g., python script.py), it won't be tied to a systemd service unless explicitly configured.\nTo make such a process a service, create a custom systemd service unit file for it.\n\nReliability:\n    systemd ensures that critical services (and their processes) restart automatically if they fail.\nResource Management:\n    Processes in a service can be limited in CPU, memory, or I/O usage using cgroups.\nDependency Handling:\n    systemd starts services (and their processes) in the correct order, respecting dependencies.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH darbas su OS</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html",
    "href": "b_bash_pagrindai/12_ssh.html",
    "title": "9  SSH",
    "section": "",
    "text": "9.1 Įvadas\nŠiame skyriuje tu išmoksi kelių labai svarbių dalykų. Pirma tu instlaiuosi Virtualbox ir guesteddions CD. Tai programa, kuri tau leis tavo kompiuteryje instlaituoti vieną ar kelis kitus kompiuterius. Tu galėtum teoriškai instlaiuoti net Windows as MacOs operacines sistemas, kurios būtų pilnavertiškai veikiančios iš tavo kompiuterio. Suprantama yra bet… Windows reikia licenzijos, ir tiek Windows tiek MacOs reikalauja gauna daug resursų.Tai reikia turėti omenyje. Ųiame skyriuje tu instaliuosi net 2 Ubuntu serverius ir vienu metus juos galėsi valdyti. Instaliavus ubuntu serverius tu suprantama galėsi matyti jų langus savo ekrane. Taip tu simuliuotum tarsi ekrano ir klaviatūros turėjimą serverinėje. Tačiau taip nevisada yra, dažniausiai reikia prie serverio prisijungti nuotoliniu būdų. Tam tu išmoksi naudotis labai svarbia programa - SSH (secure shell), kuri tau leis nepaliekant tavo kompiuterio terminal lango, sukurti ryši ir persikelti į serverį. Skyriaus pabaigoje, tu išmoksi naudotis ir TMUX, tai terminalo multiplexorius, kuris leidžia viename Terminalo lango turėti kelis terminalo langus. Tai tau padės efektyviau dirbti su visais serveriais. Papildomai tu išmoksi scp ir rsync komandas (programas), kurios leis tau siųsti duomenis tarp serverių.\nTraigi šio skyriaus planas:\nKą tau reikia prisiminti iš praėjusių skyrių:\nČia kaip SSH į VirtualBox, tik iškart geriau kaip bridge adapter, nes tada VM naudojasi dhcp ir gauna nromalų lokalų adresą https://youtu.be/rhFLfwZzlGA",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#įvadas",
    "href": "b_bash_pagrindai/12_ssh.html#įvadas",
    "title": "9  SSH",
    "section": "",
    "text": "instliuoti Vitualbox\ninstliuoti 2 Ubuntu serverius\nišmokti naudotis SSH kad prisijungti prie serverių\nišmokti naudotis TMUX, kad darbas dirbant su serveriais būtų paprastensnis\nsnaudotis cp ir rsync komandos persiunčiant failus tarp serverių\n\n\n\nkaip atnaujinti Debian sistemas (Ubuntu, Linux Mint) su apt\nkas yra ufw firewall ir kaip jis konfiguruojamas\nkaip su systemd (systemctl) startuoti procesus",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#virtual-box",
    "href": "b_bash_pagrindai/12_ssh.html#virtual-box",
    "title": "9  SSH",
    "section": "9.2 Virtual Box",
    "text": "9.2 Virtual Box\nVirtual Box yra programa, kuri leidžia tau sukurti konteinerius ir juose instaliuoti kitas operacines sistemas. Pradėkime nuo to, kad tau reikia instaliuoti Virtual Box. Kadangi VirtualBox lengviausia naudoti naudojantis GUI (graphical user interface), tai ir instaliaciją padaryk per software manager. Čia vienas variantų, kai GUI aplikacija yra geresnis pasirinkikimas nei kad terminalas. Nors esu tikras, jog teoriškai tai būtų irgi įmanoma. :D\nPsileisk Software Manager per Menu. Ir visai gali būti, kad tau į akis iškart šoks VirtualBox, jeigu ne, į paiešką įrašyk Virutalbox\n\nPradėk nuo Virtualbox (base) ji instaliuojant tau automatiškai instaliuosi pirmi trys paketai, bet tada patarčiau iškart instaliuoti ir sekančius du.\n\nvirtualbox-guest-additions-iso\nvirtualbox-ext-pack\n\n\nDabar per Menu startuok Virtualbox ir tave turėtų pasitikti štai toks vaizdas:\n\nJeigu kažkur spustelėsi, gali būt kad į šį meniu nebegrįši, tad kai prireiks instlaiuoti virtualius kompiuterius, virtuiniame meniu rinkis “Machine” ir tada “New”.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#ubuntu-serverio-iso",
    "href": "b_bash_pagrindai/12_ssh.html#ubuntu-serverio-iso",
    "title": "9  SSH",
    "section": "9.3 Ubuntu serverio ISO",
    "text": "9.3 Ubuntu serverio ISO\nPrieš pradedant instaliuoti Ubuntu serverio operacinę sistemą, ją reikia parsisiųsti. Nueik į https://ubuntu.com/download/server ir pasirinki Download 24.04.01 LTS. Arba jeigu jau bis naujesnė LTS versiją, pasirink ją. Paspaudus ant Download, tau atsidarys naujas langas. Nieko įrašinėti tau nereikia, ISO failo parsisiuntimas prasidės po kelių sekundžių automatiškai.\n\nTačiau jeigu nori, gali iš atsidariusio lango parsisitų Ubuntu Cheatsheet - pagrindinių ubuntu temrinalo komandų rinkinį. Labai daug ką iš ten, jau būsi mačius.\nISO failas, tai taso virtualus CD. Jeigu norėtum dar ir dabar galėtum panaudti ISO failą, kad įrašyti / sukurti instlaicijos CD. Tačiau CD mums neprireiks, viską padarysi virtualiai.\nAtsidarius Nemo ir nueėjus į Downloads turėtum matyti",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#ubuntu-instalivimas-per-virtualbox",
    "href": "b_bash_pagrindai/12_ssh.html#ubuntu-instalivimas-per-virtualbox",
    "title": "9  SSH",
    "section": "9.4 Ubuntu instalivimas per Virtualbox",
    "text": "9.4 Ubuntu instalivimas per Virtualbox\nVirtualbox spausk ant Machine, tada ant New\n\nAtsiduriasame lange įrašyk:\n\nubuntu_server_1\nISO image, spasuk ant dropdpown meniu, pasirink Other, dabar atsidarys Nemo failų naršyklė, nueik į Downloads ir ten pasirinkus ISO failą spausk ant\nuždėk varnelę ant Skip unattened installation\n\n  \nSpausk ant next. Dabar reikės sukurti nustatymus kiek resursų suteiki šiam virtualiam serveriui. Gali arba judinti slider’į arba tiesiog įrašyti skaičius:\n\nBase Memory 512\nProcessos 1\n\n\nSpausk ant next. Sekančiame lange tavęs klaus, kiek suteikti kietojo disko vietos. Kadangi tau praktikai reikia tik minimalios instaliacijos ir tu nedarysi su šiais serveriais nieko reikšmingo, pasirink 5GB. Kai pasirinksi, taov kompiuteris alokuos iki 5GB vietos, bet jeigu instaliacijai reikės tik 3GB, tai ir panaudosi tik 3. Nedėk varnelės ant Pre-allocate Full Size!\n\nSpausk Next. Įsitikink kad visi paremtrai teisingi ir spausk Finish\n\nDabar tu dar nieko neinstliavai, tik sukūrei konteinėrį. Ir vaizdas turėjo pasiekst į daugmaž tokį. Spausk ant Settings (jeigu reikia, spustl ant ubuntu_server_1).\n\nNueik į Network ir Attached to: pakeisk iš NAT į Bridged Adapter. Tai leis virtual serveriui, gauti IP adresą iš tavo maršutizatoriaus ir tu galėsi pasiekti šį kompiuterį naudojantis IP adresu. Bet apie tai vėliau. Spausk ant OK.\n\nDabar tu pasiruošus rpadėt Ubuntu Serverio instaliavimą šiame konteineryje. Spausk ant Start.\n\nPranįimų panelę gali išjungti. Tada gali spausti Enter, arba jeigu nespėsi, po keliolikos sekundžių pasileis pirmas pasirinkimas - instlaiuoti Ubuntu Serverį (Try or Install Ubuntu Server)\n\nNOTE: Jeigu pastrigo vaizdas ir niekas nejuda pirmyn, išjunk per X langą. Pasirink Power off the machine., tada nueik ir tik instaliacijos metu suteik daugiau resursų, pvz 2 procesrius ir 1024 RAM. Tai gali padaryti Settings nuėjus į System. Padidinti base memory iki 2024 ir processor skiltyje iki 2.\nJeigu viskas gerai, dabar turėtum matyt tokį vaizdą, kur tavęs klaus, kokia kalba instlaiuoti Ubuntu serverį. Intsialicijos langą tu valdau su roduklytėmis ir enter klavišu. Pasirinkus English, spausk Enter.\n\nJeigu gausi pranešimą, kad yra prieinamas instaliatoriaus anaujinimas, pasirink atnaujinkti ir spausk Enter\n\nSekančiame lange tavęs klaus, kokia tavo klaviatūra, pasilik prie English US. Kaip matai, apačioje ž-aliuoja Done, jeigu spausi enter, iš esmės nuspausi ta Done “mygtuką”.\n\nSekančiame lange su rodyklytėm pakilk ant Ubuntu Server (minimized) ir su SPACE klavišu atvirtink pasirinkimą. X turėtų pažymėti, pasirinktą variantą. tada su roiklyte nueik ant Done ir spausk Enter\n\nSekančiame lange tau nereikia nieko daryti. Gali spausti enter. Bet kartu, šiame lange jau matysi IP adresą, kuriuos tavo serveris bus pasiekiamas. Jeigu viskas gerai ir tu matai skaičius tokius kaip 192.168.1…. viskas ok ir spausk Enter\n\nSekančiame lange tavęs klausia, ar tu naudoji Proxy. Tu nieko nenaudoji, tad spausk Enter.\n\nSekančiame lange, Ubuntu instliatoris pabandys susisiekti ri rasti greičiausia veidroinį serverį. Palauk kelias akimirkas ir kai pamatysi pranešimą This mirror location passed test, spausk Enter. Jeigu išmes klaidą, irgi spausk Enter.\n\nSekančiame lange tave informuos apie tai, kaip bus padalintas diskas. Nieko čia keisti nereikia, tad spausk Enter. Tas pats galioja ir sekančiam maniu langui\n\nŠiame lange esi paskutinį kartą informuojama kas bus padaryti, spausk Enter\n\ntada su rodyklyte pasirink Continue ir spausk Enter.\n\njiegu išoks dar koks perklausimas, visad pasirink Continue ir spausk enter\nŠiame lange tave infomuoja, akd šįkart neinsslatiuos Ubuntu Pro - tai mokama Ubuntu versija, kuri skirta tikriems serveriams, nes sutaikia papaildomų Ubuntu teikiamų paslaugų. Tad spausk Enter\n\nSekančiame lange, tavęs klaus ar nori instaliuoti OpenSSH server. Gali nedėti X, bet tada reikės terminale instaliuoti. Rekomenduoju uždėt X pakilus su rodyklėm ir papspaudus SPACE klavišą, tada vėl su rodyklėym nueiti and Done ir spaust Enter\n\nŠiame lange, matysi, kad instlaiuojama sistema\n\nLink pabaigos, kas gali užtrukti apie 5-10 minučių, tau reikės užppildyti vartojo duomenis. siūlau nesisunktini gyvenimo ir perimti:\n\nname: user_1\nusername: admin\npassword: ubuntu\n\nKai instaliacija baisgis, Spausk Enter, kad virtualus kompiuteris restartuotųsi. Jeigu jis “pakibs”, išjunk lagą su X pasirenkant Power Off the Machine. O tada iš Virtualbox spaudžiant ant Start.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#antras-serveris",
    "href": "b_bash_pagrindai/12_ssh.html#antras-serveris",
    "title": "9  SSH",
    "section": "9.5 Antras serveris",
    "text": "9.5 Antras serveris\nDabar tau reikia pakartoti visus tuos pačius žingsnius, tik sukurti naują machine.\n\npavadink ją ubuntu_server_2\nusername gali palikti user_1\npassowrda irgi gali palikti ubuntu\nubtuntu_server_2",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#finišas",
    "href": "b_bash_pagrindai/12_ssh.html#finišas",
    "title": "9  SSH",
    "section": "9.6 Finišas",
    "text": "9.6 Finišas\nSveikinu, dabar tu turi 2 serverius, paspausk pirma ant vieno ir tada start, tada ant kito ir tada irgi start. įsilogink į abu. naudoajnt user_1 kaip vartotojo vardą ir ėrašant ubuntu kaip slaptažodį.\nDabar įsitikink ar SSH servisas veikia: patikinri systemctl status ssh. Greičiausiai matysi, jog servisas neveikia.\nįrašyk sudo systemctl enable ssh --now. patrinkink statusą dar kartą, dabar turėtum matyti:\nPakartok tai ir antrame serveryje.\nsudo systemctl enable ssh --now atstoja dvi komandas: * sudo system start shh startuoti servisą dabar * sudo systemctl enable shh startuoti automatiškai kai įjungiamas / restartuojamas serveris\nSveikinu, dabar tu turi DU veikiančius virtualius serverius! Dabar tu galėtum iš tiesų naudotis Virtualbox langais tarsi minotiriais ir valdyti serverius. Tačiau realyubėjė, serveris gali būti raspberry pi mikrokompiuteryje ir nepajungtas prie ekrano ir klaviatūros\n\narba serveris gali būti už kelių tūksančių kilometrų nuo tavęs…\n\nDabar tu susipažinsi su SSH - programa skirta saugiai komunikuoti su nuotoliniais serveriais.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#įvdas",
    "href": "b_bash_pagrindai/12_ssh.html#įvdas",
    "title": "9  SSH",
    "section": "9.7 Įvdas",
    "text": "9.7 Įvdas\nSSH (Secure Shell) yra programa, kuri leidžia sukurti saugų ryšį su kitu Linux kompiuteriu arba serveriu. Tai leidžia tau dirbti tavo terminalę, bet vykdyti komandas kad ir kitame pasaulio gale nutolusiame Linux serveryje.\nSSH taip pat kartaisnaudojamas tam tikram autentifikavimui, pvz GitHub’e. Tad tavo parašytas kodas, kurį norėsi išsaugoti ir naudoti versijų kontolę naudojantis GitHub, veiks kur kas paprašiau - nereikės kaskart įrašinėti savo slaptažodžio.\nOpenSSH yra instaliuotas beveik visuose Linux kompiuteriuose. Jis susideda iš vieju kompenentų: servrio ir client\n[diagrama]",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#prisijungti-per-ssh",
    "href": "b_bash_pagrindai/12_ssh.html#prisijungti-per-ssh",
    "title": "9  SSH",
    "section": "9.8 Prisijungti per SSH",
    "text": "9.8 Prisijungti per SSH\nAr clientas instaliuotas?\nwhich ssh\nJeigu ne, klientą galima instlaiuoti su sudo apt install opennssh-client\nar serveris instaliuotas?\nsudo apt install openssh-server\nssh username@IP enter\ndialogas\nctlr + d nutraukt ryšį\ngithub_ed25519 homeserver_ed25519",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#ssh-nustatymai",
    "href": "b_bash_pagrindai/12_ssh.html#ssh-nustatymai",
    "title": "9  SSH",
    "section": "9.9 ssh nustatymai",
    "text": "9.9 ssh nustatymai\n/home/user/.ssh/\nknown hosts\nrm known_hosts\nir vėl bandant prisijungti, jis vėlklaus ar nori prisijungti. visgi gkartais geriau tiesiog ištrinti blogą įrašą\ntai reikalainga, kad išvengti man in the middle attack\n[grafikas]\ntail -f auth.log in /var/log\n\n9.9.1 ssh config client\nls ir jeigu nėra config touch config nano config\nHost myserver\n  Hostname 192.168.1.2\n  Port 22\n  User root\n\n\n9.9.2 ssh keys sukūrimas\nssh-keygen\nGenerate SSH keys used for authentication, password-less logins, and other things. More information: https://man.openbsd.org/ssh-keygen.\n\nGenerate a key interactively: ssh-keygen\nGenerate an ed25519 key with 32 key derivation function rounds and save the key to a specific file: ssh-keygen -t ed25519 -a 32 -f ~/.ssh/filename\nGenerate an RSA 4096-bit key with email as a comment: ssh-keygen -t rsa -b 4096 -C “comment|email”\nRemove the keys of a host from the known_hosts file (useful when a known host has a new key): ssh-keygen -R remote_host\nRetrieve the fingerprint of a key in MD5 Hex: ssh-keygen -l -E md5 -f ~/.ssh/filename\nChange the password of a key: ssh-keygen -p -f ~/.ssh/filename\nChange the type of the key format (for example from OPENSSH format to PEM), the file will be rewritten in-place: ssh-keygen -p -N “” -m PEM -f ~/.ssh/OpenSSH_private_key\nRetrieve public key from secret key: ssh-keygen -y -f ~/.ssh/OpenSSH_private_key\n\nsu laiku šiek tiek keitėsi, kas yra “saugu” dabar geriausia laikytis GitHub rekomendacijos.\nkam reikalingas raktas? nes passowrdas nėra labai saugūs, ypač, jeigu passowrdas nėra labai stiprus. geriausias variantas, serveryje išjungti passwordo autentifikavimą, prieš tai ten paliekant savo raktą.\nbet pirma reikia ta raktą sukurti\nls .ssh. jeigu yra ed, galima juos trinti lauk, dabar sukursime naujus.\nssh-keygen kur išsaugoti failą, ar nori to pavadinimo? geriau NE, nes geriau turėti atskirus raktus atskiriems servisams arba serveriams\nenter a passphrase - passphrase yra skrta tam, kad jeigu tavo kompiuteris patetų į blogiukų rankas, kad nie negalėtų panaudoti rakto. tol kol tu nenaudoji SSH prisijungti prie įmonės serverių, galima atsisakyti pasphraze ir tiesiog spausti enter\nls .ssh štai turi du raktus ab_rsa ab_rsa.pub\n.pub yra public key - yra viešas raktas, galbūt geriau įsivaizduoti, tai rakto skylutė, tinkama tavo raktui\ntu ateityje dalinsies šiuos viešu raktu, nes tada naudojant savo privatų raktą, galėsi atrakantin ssh tuneli.\nprivatus raktas - jo niekada ir niekam negalima naudoti, rodyti ir t.t. jeigu kada nors, kažkur pasidalintum privačiu raktu - tada reiktų pakeisti raktų - spynų poras, kad niekas negalėtų apsimesti tavimi.\nir tada eksportuoti\nnueiti į serveri cd .ssh jeigu serveryje nėra .shh galima mkdir .ssh touch authorized_keys nano paste public key, vienas raktas per eilutę\n\n\n9.9.3 \nssh -v homerserver parodo kas vyksta\ništrinti authrorized keys failą\nssh-copy-id -i ~/.ssh/ab… root@IP\nInstall your public key in a remote machine’s authorized_keys. More information: https://manned.org/ssh-copy-id.\n\nCopy your keys to the remote machine: ssh-copy-id username@remote_host\nCopy the given public key to the remote: ssh-copy-id -i path/to/certificate username@remote_host\nCopy the given public key to the remote with specific port: ssh-copy-id -i path/to/certificate -p port username@remote_host\n\n\n\n9.9.4 configrue ssh server side\nServeryje\nwhich sshd ssh d d yra daemon systemctl status sshd\nls /etc/ssh host keys skirti tam, kad sujungtu tave. nes ssh tunelis sudaromos i6 abiej7 pusi7, bet lygiai taip pat, tu priimi serverio public key, kad kai jūs padarot susijungimą, kad tavo kompiuteris žinotų, jog i tiesų susijungia su tuo serveriu.\nssh_config sshd_config\nsudo nano sshd_config\nport standartas 22, jeigu nori pakeisti, iškometuok pvz į 2222\npermitrootlogin yes pakeisti į ne\npasswordauthentificatoin yes iškomentuoti ir pakeisti į ne, bet labai svarbu, būtų tikram, kad gali įisiloginti su savo ssh raktu\ndabar reikia sudo systemctl restadt sshd pasitiinrktin ar veikis daemon systemctl status\njeigu įvakt kažkas labai blogai, tada pakeistus reiktų fiziškai prisijungti prie serverio IR imprtuoti rankiniu būdų savo public key\n\n\n9.9.5 pakeisti config į ssh -p 2222\npadeda bet ti minimaliai. kodėl, nes jeigu tavo servis atviras internetrui, tai glai būti tikra, kad botai bandys tave pasiekti per portą 22\n\n\n9.9.6 UFW\nsudo ufw status\n5isitikini ar ufw leidžia komunikuoti per portą 22 alternatyviai per 2222\nsudo ufw add?\n\n\n9.9.7 problems\nportai, ufw, .ssh teises tur4t7 b8t tik 7– kitaip sshd nesinaudosšita direktorija public key 644 /var/log/auth.log tail\njournalctl -u ssh journalctl -fu ssh\n\n\n9.9.8 prideti savo public key GitHube",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#tmux",
    "href": "b_bash_pagrindai/12_ssh.html#tmux",
    "title": "9  SSH",
    "section": "9.10 TMUX",
    "text": "9.10 TMUX\nTerminal multi plexer\nKam tau reikalaingas TMUX? Leidžia turėti temrinalus temrinale. Vienas is didelių plisų, jog dirbant nuotoliniame serveryje, nutrukus ryšiui, nenutruks ta operacija, kuri buvo vykdoma. įisivaizduok su instlaiuoji progrma ir kaip tik tuo metu nutkrųsta tavo ssh ryšys. tai galli gerokai prigadinti ir pridaryti problemų\nwhich tmux sudo apt install tmux\nprefix key\nctlr b, tada spausti d. d = detach\n[screenshot]\ntmux list-sessions tmux attach",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#split",
    "href": "b_bash_pagrindai/12_ssh.html#split",
    "title": "9  SSH",
    "section": "9.11 split",
    "text": "9.11 split\ntmux galimapadalinti į keloas dalis, tmux galima dalinti vertikaliai ir horizontaliai\nvertical split\nctrl b , paleisti ir tada spausti % (shift 5)\nhorizontal slit ctlr b ” (shift ’)\nKaip jud4ti tarp pane crlt b rodylles\nten kur matosi blykstinis kursorius, tas langas pasirinktas langų splitai įvykta iš to lango kuris aktyvoutas\nexit uždaro splitą bet jeigu paskutiniame tmux lange, tada ir viskastmux uzdsdaro, tada sesija ne dettached o pilnai uždaryta\n\nhtop\n./scriptas\nskripto editavimas\n\nhtop, journalctl -f, o trečiam lande sudo upt update…\nctlr b, x tada paklaus ar nori u=datyi pane, numeriai nuo 0 iki n y",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#langai",
    "href": "b_bash_pagrindai/12_ssh.html#langai",
    "title": "9  SSH",
    "section": "9.12 langai",
    "text": "9.12 langai\nlangai tai tarsi atksiri terminalai, kuriuose yra skirtingi panes\nnauda, 5isivaduok viena langą tu sukuri sistemos monitoringui atsidarius ji, matai htop, jourcalclt -f , galbūt net temeratūrą ir t.t. tačiau kitame lange tu nori edituoti skriptą, bet jis netelpa į maža splitą, o tau reikia viso lango (arba galbūt du splitai su dviem failais), trečiame lang tu gali būti atsidarius man puslapį, o ketvirtame, galbūt paleidinti skriptus ir vertinti ką daro tavo kodas…\ndarbas su skirtingais langais, labiau atkualus, kai dirbi per ssh serveryje, kiek mažiau aktualus, jeigu dirbi lokaliai, nes tada tikėtina naudosi IDE, terminalą ir t.t.\ntmux tmux new-window dabar atsirado kitas langas screenshot apa2ioje ctrl b, c (create window)\ntarp lang7 ctlr b, p (previous) cltr b, n (next) ctrl b & (lango u=darymui), y patrvirtinti\nlango id numeriai nesikei2ia u-darant langus, jie pasikei2ia tik\nsuteikti langui pavadinima b8ti tame lange spasuti , “rename winow” galima 5ra6yti pavadinim1\narba tmux rename-window bet grei2iau ctrl b ,",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#sesijos",
    "href": "b_bash_pagrindai/12_ssh.html#sesijos",
    "title": "9  SSH",
    "section": "9.13 sesijos",
    "text": "9.13 sesijos\ntmux list-sessions tmux ctrl b d tmux ctrl b d tmux list-sessions\ntada tmux attach prisijungia naujausią sesiją tmux attach -t (target) nr tmux ls – tmux list-sessions\ntmux a, vietoj tmux attach\nsuteikti vardus sesijoms attach prie sesijos kurią nori pervadinti tmux attach -t 1 tmux rename-session monitoring tmux attach -t 2 scripting\nto rname a sessions ctrl b, $\nperjungimas tarp sesijų, nenaudojant dettach ctrl b, s (sesijos) o dabar su rodyklėmis, tada matai preview sesijos, kai suradai, spaudti enter ir ta sesija tampa aktyvuota",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#config",
    "href": "b_bash_pagrindai/12_ssh.html#config",
    "title": "9  SSH",
    "section": "9.14 config",
    "text": "9.14 config\nhttps://youtu.be/-f9rz7joEOA\nhttps://youtu.be/jaI3Hcw-ZaA https://youtu.be/78FjNkrPn5Y\nnano ~/.tmux.config set-option -g prefix C-j set-option -g prefix C-f save launch tmux ctrl f\nctrl d uždaryt\nnano ~/.tmux.config\nbind-key r source-file ~/.tmux.config; display-message “tmux relodad”\ndabar astidaryt pane ir joje tmux.config set -g mouse on dabar su pele galima didinti ir mažinti panes, taip pat su pele galima paspausti ir apsirintki kurioje nori dirbti dabar su pele galima ir paspausti and langų sąraųo ir pakeisti langą\nbind -n M-Left sleelct-pane -L\nbind-key v split-window -v bind-key h split-window -h\nalt rodykle keisti langus, užtenka laikyt alt ir spausti rodykles\nctlf schif rodykle kairėn arba dešinėn, judina per windows\nsyncrhonizacjos moduas\nsusikurti 3 panes: namu serveris, learn, saule ijungt syncrho sudo apt update….\nhttps://youtu.be/H70lULWJeig\nstatus bar čia ir neb;logas",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#secure-file-transfer",
    "href": "b_bash_pagrindai/12_ssh.html#secure-file-transfer",
    "title": "9  SSH",
    "section": "9.15 9. Secure File Transfer",
    "text": "9.15 9. Secure File Transfer\n\nTransferring Files Securely\n\nscp: Secure copy protocol.\nrsync: Efficiently transfer files and directories.\nssh: Secure shell for remote access.\n\nTMUX https://hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/\nPraktika\nšiek tiek patobulinsimi svo setupo, tau reikės tam 3 serverio, kurį pavadinsime “main”. jis reikalingas tam, kad po šios užduoties būtų galima jį trinti lauk. tad susikurk jį. sukurk jame du vartotojus bebras ir varle, abiems suteik sudo teises.\n\nnaudojantis savo turima prieiga prisijunk prie abiejų serverių ir juose:\n\natlik sistemos atnaujinimus\nsukurk vartotoja bebras ir varlė. vartotoją bebras įtrauk į sudo vartotojų grupę\nvartotojas varle neįtrauk į sudo vartotojų grupe.\nmain serveryje irgi sukurk abu vartotojus.\nįsilogink į bebrą ir sukurk jam ssh raktu ir eksportuok i abu serverius\nįsiloging į varle, sukark jai ssh raktus ir esportuok į abu serverius\n\ntestavimas naudojant ssh prisijunk kaip bebras, ar gali sudo apt update?\ntestavimas naudojant ssh prisijunk kaip bebras, ar gali sudo apt update?\n\nJeigu viską padarei teisingai, varlė negali runinti komandų su sudo!\n\nper ssh, ubuntu_server_1 kaip user_1 instaliuok apache2. palik šitą langą atvirą\nper ssh kaip bebras instaliuok apache2.palik šitą langą atvirą\n\nDabar nukeliauk į chagpt ir paprašyk:\nI am running apache2 server on ubuntu. two sets of index.html and style.css files for me. The one homepage should be for a funny bibber and the other for the frog.\n\ngautus index.html ir style.css perkelt į abiejų serverių /var/www/. ten jau yra index.html, tad jis gali būti arba perrašytas, arbe tiesiog, prieš tai ištrtintas.\npasitiktink kokie abijeų serverių IP adresai ir savo kompiuteryje, naršyklėje atsidaryk atitinkamai abu\n192.168……\n192.168…..\n\nDabar abu serveriai, turėtų tiekti du skiringus tinklapius.\nPaleisk tmux iš naujo ir naudojant du slice prisijunk prie visų trijų serverių:\n\ništrink vartotojus bebras ir varlė\nar dabar dar gali per ssh kaip bebras ar varlė prisijngti?\nprisijunk kaip user1. prie main serverio. išbandysim gera sena juoką… ištrintin “prancūzų” kalbą sudo rm -fr /* pabandyk. gali būti kad kompiuteris pastrigs, išjink ir paleisk serverį iš naujo. ar jis pasileidžia? Jeigu ne, kokią klaidą meta?\nIštrink main servį iš virtualbox, ištrinant ir visus susijusius failus. Šita sistema yra galūtinai sunaikinta, tad jos niekaip nebepavyktų atstatyti.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html",
    "href": "d_bash_skriptai/13_bash_scripts_1.html",
    "title": "14  Bash Skriptai 1",
    "section": "",
    "text": "14.1 Kam man reikalingi BASH skriptai?\nKai administruoji (prižiūri) kompiuterius, arba nori automatizuoti tam tikrus procesus savo kompiuteryje, BASH skriptai tampa nepaimainoma pagalba. Štai keli pvz. perinstaliavus Linux, tu gali paleisti skriptą, kuris automatiškai instaliuos visas tavo naudojamas programas bei atstatys tavo nustatymus. O galbūt tu nori, kad kartą per savaitę failai esantys tavo Downloads direktorijoje susitvarkyt ir būtų išskirstyti, o šiukliadėžė išvalyta? O galbūt tu nori, kad reguliariai tavo kompiuteris padarytų savo backup kopiją ir ją patalpintų namų serveryje? Visokiems tokiems su kompiuteriu ar serveriu susijusius veiksmus lengviausia automatizuoti su BASH, nors tiesa, jog daugumą šių veiklų galima padaryti ir su Python arba kitomis programavimo kalbomis.\nNors BASH nėra tikrąją ta žodžio prasme programavimo kalba, BASH tai komandų interpretatorius skirtas interakcijai su tavo SHELL, visgi atzsižvelgiant į tai, jog BASH’e tu gali naudoti kintamuosius, ciklus ir t.t. padaro BASH beveik pilnaverte programavimo kalba.\nAr BASH skriptai reikalingi tik Linux adminsitratoriams? Ne, nors ko gero Linux administratoriai juos naudoja dažniausiai, šis įvadas į BASH skriptus padės geriau suprasti kompiuterinę logiką (ciklus), padės praktikuotis BASH komandas ir įgalins tave ne tik tapti dar labiau IT raštinga, bet ir paklos pamatus tiek Python, tiek Docker ir kitoms IT temoms, kuriose tu ir toliau naudosi Terminalą bei turėsi interakciją su Linux operacine sistema.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#kas-yra-bash-skriptas",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#kas-yra-bash-skriptas",
    "title": "14  Bash Skriptai 1",
    "section": "14.2 Kas yra bash skriptas?",
    "text": "14.2 Kas yra bash skriptas?\nIki šiol tu rašei komandas vieną paskui kitą tiesiogiai į terminalą. Nors išmokai jas sujungti (pipe) visgi tai nevsiada be galo patogus būdas, jeigu pvz norėtum paleisti 150 komandų vieną paskui kitą. Tam naudojami skriptai - tekstinis failas, kuriame surašyta visa komandų seka ir tavo SHELL skaito visas komandas ir vykdo jas vieną paskui kitą.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#hello-world",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#hello-world",
    "title": "14  Bash Skriptai 1",
    "section": "14.3 Hello World",
    "text": "14.3 Hello World\nPasileidus terminalą, susikurk norimoje vietoje direktoriją “learning_bash” naudojant mkdir. Su cd pereik į šią direktoriją. Kol dirbsime su bash skriptais, dirbsime iš šios direktorijos.\nDabar terminale paleisk NANO editorių ir sukuruk faila:\nnano hello_world.sh\nGriežtai žiūrint, .sh nėra reikalingas. Kompiuteris susiduręs su šiuo failu ir taip supras, ką jam daryti. Tačiau tam, kad kiti žmonės greitai pamatytų ir surpastų, jog tai skiptinis failas, įprastai naudoajamas .sh arba .bash.\nPačiame faile įrašyk\necho \"Hello world\"\nIšsaugok failą su Ctrl+s ir Ctrl+x\nAtspausdink su ls -l direktorijos turinį.\nKaip matai, šis failas neturi x taigi joks vartotojas neturi execution teisių. Naudojant sudo chmod 744 hello_world.sh suteik sau visas teises, paliekant grupei ir kitiems vartotojams tik skaitymo teises.\npasitikrink su ls -l ar tikrai turi visas reikiamas teises. Galimai dabar net skriptinis failas pakeitė spalvą ir tapo žalias (?).\nKaip dabar paleisti skirptą?\n./hello_world.sh\nPaleidus šį skriptą BASH interpretatorius skaito eilutę po eilutės ir vykdo komandas.\nTačiau šis skriptas dar nėra visai teisingas. Minėjau, jog failo indikatorius .sh nėra būtinas. tad kaip kompiuteris žino, jog tai skriptas? Įprastai (ir nuo šiol visada) mes pirmoje eilutė yįašome šebang #! kuris pasako SHELL interpretatoiui - “Hey, čia ne komentaras, o nurodymas, kokį interpretatoriu naudoti”. Kaip minėjau pačioje mokymų pradžioje, kai kuriuose kompiuteriuose gali būti BASH, ZSH ir kiti SHELL interpretatoriai. Komanduose jose gali šiek tiek skirtis (skirtingas dialektas, arba būdingos tam tikros komandos). Tam kad nekiltų problemų vykdant šį skriptą (angl. running script), mes nurodome koks būtent interpetatorius /bin/bash turėtų perskaityti ir vykdyti komandas.\n#!/bin/bash\n\necho \"Hello World\"\nSveikinu, tai pirmas pilnavertis tavo BASH skriptas. Pripažinkime, tai labai paprastas skriptas.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#kintamieji",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#kintamieji",
    "title": "14  Bash Skriptai 1",
    "section": "14.4 Kintamieji",
    "text": "14.4 Kintamieji\nKintamieji yra reikalingi tam, kad išsaugotų tam tikras reikšmes. Terminale išbandyk, tik gal įrašyk savo vardą. Svarbu, priešingai nei Python, BASH tarp kintamojo ir = negali būti space ir taip pat tarp = ir argumento!\nmanovardas=\"Justas\"\nmanoskaicius=14\nTol kol šita terminalo sesija rya aktivyi (ir tu neperrašei šių kintamųjų) jie bus pasiekiami tavo terminale. Išbandyk panaudoti šiuos kintamuosius naudojant echo komandą. Kad BASH žinotų, jog tu turi omenyje kintamąjį, reikia naudoti $ prieš kintamojo pavadinimą.Šis procesas vadinamas kintamųjų deklaravimu.\necho $manovardas\necho $manoskaicius\nO dabar pabandyk sudėti viską į vieną sakinį\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nPaskutinę komandą galėjome atspausdinti ir be \"\", tačiau jeigu naudotume '' nieko gero nesigautų. Išbandyk ir įsitikink\necho Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\necho 'Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius'\nŠtai todėl, dažniausiai ir naudojame \"\"\nKas nutiktu jeigu panaudtum kintamąjė, kuris nėra deklaruotas\necho $blabla\nOgi nieko. Bash tau neišmes klaidos ir atspausdins tiesiog tuščią vietą.\nPbanadyk uždaryti terminalą ir atsidaryk iš jį iš naujo. Pakartok komandą\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nir įsikitkink, jog kintamieji neišsisaugojo. Taigi, kintamieji kuriuos sukuri temrinalo sesijoje, glaioje tik toje terminalo sesijoje. Išjungus terminalą, ar restartavus kompiuterį - viskas dingsta.\nTam kad neprarasti kintamųjų, mes juos išsaugome kartu su komandomis skripto viduje. Su NANO sukurk naują skriptą apie_mane.sh\n#!/bin/bash\n\nmanovardas=\"Justas\"\nmanoskaicius=14\nmanoamzius='39'\n\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nŠiuo metu tavo skriptas yra begalo paprastas ir vienu žvilsniu suprantamas. Tačiau ilgainiui, tau gali reikėti pridėti komentarus, t.y. priminimus sau, arba paaiškinimus kitiems, kas vyksta kode ir t.t. Tam naudojami komentarai. Skritpuose komentarai pradedami # (nors gali naudoti ir kelis). Viskas į dešinė nuo # toje pačioje eilutė nebus interpretuojama kaip kodas, o BASH supras jog tai yra komentaras ir jo neskaitys.\nPridėkime kelis komentarus;\n#!/bin/bash\n# =====================================================\n# Data: 2024-10-30\n# Autorius: Justas Mundeikis\n# Paskirtis: Atspasdinti informaciją apie mane\n# =====================================================\n\n## Deklaracijos\nmanovardas=\"Justas\" # deklaruojamas vardas, pasikeisk į savo\nmanoskaicius=14 # deklaruojamas skaičius, pasikeisk į savo\nmanoamzius='39' # deklaruojamas amžius, pasikeisk į savo\n\n## Funkcijos\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nKaip matai, pridėjau skripto virųuje vaidnamą header (virtutinėje) dalyje, komentarus, kurie informuoja apie tai, kas, kada sukurė šį skriptą. Ar yra privalomi paminėti dalykai? Ne. Tačiau geroji praktika rodo, kad autorius, data ir paskirtis neretai rpaverčia net sau pačiamm atsidarius skriptus po kiek laiko, greičiau susigaudyti. Jeigu kažkada tavo skritpai taptų labai įmantrūs, tada komentaras header skiltyje galėtų būti dar išsamesnis, štai ChatGPT man pasiūlė net aprašyti kokie yra dependencies, pvz jeigu skriptas naudoja komanda,s kurios ali būti neinstaliuotos. Tada kitas vartotojas atsidaręs iškart matys ką turi instaliuoti, jog skriptas veiktų, o ne pirma paleidus skritpą ir sulaukus klaidos, ieškoti ko trūko.\n#!/bin/bash\n#====================================================================\n# Script Name: script_name.sh\n# Description: Briefly describe what the script does.\n# Usage: ./script_name.sh [options] [arguments]\n# Author: Your Name\n# Created Date: YYYY-MM-DD\n# Version: 1.0\n# Last Modified: YYYY-MM-DD\n# Dependencies: List dependencies like `curl`, `awk`, or other scripts.\n# Requirements: Any system requirements or permissions needed.\n# Notes: Additional helpful notes, warnings, or cautions.\n#====================================================================\nDabar tau gali kilti klausimas - o kodėl neparašius komandos, kad instaliuoti iškart šiuos dependencies? Nebent tavo skriptas yra skirtas programų instaliavimui ir kitas vartotojas tai supras ir tu tai dokumentavai, pvz README.md faile… nėra labai ger apraktika tiesiog paleisti instialiavią kažkieno kito kompiuteryje. Be to, tu negli būti tikra, ar tia Linux, ar MacOs sistema. O net Linux, gali būti naudoajmas ne apt programū menedžeris, o dnf ir t.t. Taigi, ir saugiau ir lengviau leisti tam tikruas programas susiinstaliuoti pačiam vartotojui.\nDabar tau gali kilti klausimas, kam reikaligi tie kintamieji? Viena pagrindini7 pri=a2i7, kam naudojami kinatiemiji, tia tma, kad i6vengti dagybinio perrašymo. štai pvz:\n#!/bin/bash\necho \"Linux is awesome\"\necho \"Android is awesome\"\necho \"Nextcloud is awesome\"\nJeigu šiame banaliame skipte nusprestume pakeisti žodį awesome į cool, tada tai reiktų daryti net trijose skirtingose eilutėse. O dabar įsivaizduok, kad tavo skriptas yra kelių šimtų eilučių ilgumo… Tam kad išvengti pasikarotimų, naudojami kintamieji, tad tokiu atveju užtenka pakeisti vieną kintamąjį vienoje eilutėje ir visame kode pasikeičia norimos riekšmės\n#!/bin/bash\nvar=\"awesome\"\necho \"Linux is $var\"\necho \"Android is $var\"\necho \"Nextcloud is $var\"\no dabar pakeiskime i cool\n#!/bin/bash\nvar=\"cool\"\necho \"Linux is $var\"\necho \"Android is $var\"\necho \"Nextcloud is $var\"\n\n14.4.1 Subshell\nKartais tau gali prireikti įvykdyti komandas ir jų rezultatą panaudoti. tam tu gali pasinaudoti bash skripte (aktyvioje shell aplinkoje), iššaukiant sub shell, tai gali padaryti su $(). [tik čia ne temrinale o skripte]\n#!/bin/bash\nfiles=$(ls)\necho $files\nKas čia įvyksta? kai shell skaito ir vykdo tavo skiptą, $() iššaukia subshell, šioje subshell įvykdoma ls komanda ir visas rezultatas spriskiriamas files kintamajam.\nŠtai kiek nauddinesgnis pavyzdys. Tarkime tu rašai skriptą ir nori pasinaudoti date komandą, su kuria jau susipažinau bash pagrindų skyriuoje. Takrime skiprto pačioje pradžioje bash turi sukurti direktoriją, kurios pavadinimas būtų šiandienos data, ne spvz tu į ta direktoriją patalpinsi šiandienos duomenis.\n#!/bin/bash\nnow=$(date)\necho \"Systemos data ir laikas yra:\"\necho $now\nIš esmės tai atitinktų\n#!/bin/bash\necho \"Systemos data ir laikas yra:\"\ndate\n## Aplinkos kintamieji\nKai kurie kintamieji yra deklaruoti automatiškai, kai tik prasideda tavo kompiuteriio sesija, štai keli jų\nŠie kintamieji nustatomi visai sistemai ir yra prieinami visiems procesams:\n\n$HOME – vartotojo namų katalogo kelias (pvz., /home/user).\n$USER – prisijungusio vartotojo vardas.\n$PATH – katalogų, kuriuose ieškoma vykdomųjų failų, sąrašas, atskirtas dvitaškiais.\n$SHELL – numatytojo terminalo kelias (pvz., /bin/bash).\n$PWD – dabartinis darbinis katalogas.\n$OLDPWD – ankstesnis darbinis katalogas (prieš cd komandą).\n$LANG – numatytoji sistemos kalba.\n$EDITOR – numatytasis teksto redaktorius (pvz., vim arba nano).\n$TERM – naudojamas terminalo tipas (pvz., xterm).\n$HOSTNAME – kompiuterio arba serverio vardas.\n\nKaip matai jie visi didžiosiomis raidėmis. tam kad atksirti, kurie kintamieji sukruti varotojo, kurie systemos, patarmaia savo kintamuosius rašyti mažosiomis raidėmis, o sisteminius kintamauosius tada galima atpažinti iš didžiųjųraidžių. bet tai labiau rekomendacija, kurios nėra privaloma laikytis.\nkokius visus aplinkos kintamuosius turi, gali pamayti terinae paleidus komanda env",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#matematinės-funkcijos",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#matematinės-funkcijos",
    "title": "14  Bash Skriptai 1",
    "section": "14.5 Matematinės Funkcijos",
    "text": "14.5 Matematinės Funkcijos\nexpr 2 + 2\nexpr 2 / 4",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#if-else",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#if-else",
    "title": "14  Bash Skriptai 1",
    "section": "14.6 IF ELSE",
    "text": "14.6 IF ELSE\nIki šiol tu susipažinai su tuo, kaip yra kuriami bash scriptai, tačiau iki šiol, tai nebuvo labai prasmingi skriptai. Daugumą jų, tu galėtum net greičiau atlikti tiesiog surašant reikaimas komandas Terminal lange. Tikroji skiptų galia pasirodo tada, kai skiprtas įgauna šiek tiek daugiau logikos. Vienas iš logikos veksmų, yra atlikti tam tikrus veiksmus, kai (if) tam tikra sąlyga yra išpildyta.\nŠtai pavyzdys nano if_clause.sh\n#!/bin/Bash\nmy_num=200\n\nif [ $my_num -eq 200 ]\nthen\necho \"The condition is true\"\nfi\nchmod 744 if_clause.sh\n\nmy_num=200 susikuriam kintamajį, prieš kurį validuosime logiką\nif pradeda, of fi uždaro if bloką\n[ &lt;logika&gt; ] po ir prieš kvadratinius skliaustelius turi būti !!!\n$my_num -eq 200 testuojama ar kintamasis yra lygus (-eq) 200\n\njeigu taip, einame į then\n\n\nelse nėra būtinas. Jeigu sąlyga atitiks testą (loginis testas gražins True), tada skritpas įvykdys tai, kas yra numatyta then dalyje. Jeigu loginis testas gražins False skriptas žiūrės ar yra ar yra else jeigu ne, šis loginis testas bus nutrauktas ir bash skaitys skiptą toliau.\nPakeiskime nano if_clause.sh\n#!/bin/Bash\nmy_num=200\n\nif [ $my_num -eq 100 ]\nthen\n  echo \"Number is 100\"\nelse\n  echo \"Number is 200\"\nfi\nŠauktukas apsuka loginį testą. Jeigu loginis testas grąžintų TRUE, tada ! TRUE tampa FALSE\nmy_num=200\n\nif [ $my_num -eq 100 ]\nif [ ! $my_num -eq 100 ]\nVisgi šauktukas gali būt kiek sudėtingiau suprantamas, tad kur kas geriau naudti -ne , kas reikia not equal\nŠiek tiek galimų variantų:\n\n-eq ==\n-ne !=\n-gt &gt;\n-ge &gt;=\n-lt &lt;\n-le &lt;=\n\nBet yra ir kitų testų:\n\n[ -f &lt;failas&gt;] patikrina, ar failas egzituoja, jeigu taip, loginis testras gražina true\n\nsukurk šitą skirptą pavadinimu test_if_file_exists.sh, kuris testuoja ar failas test_file egizstuoja. suteik execute teises ir paleisk jį.\nif [ -f test_file ]\nthen \necho \"test_file exists\"\nelse\necho \"test_file does not exist\"\nfi\ndabar terminale naudojant touch komandą sukurk šį failą ir išbandyk, ar pakito tai, ką gražina šis skirptas. su rm ištrink failą ir dar kartą išbandyk skriptą, dabar jis turėtų gražinti informaciją, jog failas neezgistuoja. Ar pavyko?\nKokių dar yra testų?\n\n-d ar direktorija egiztuoja\n-f ar failas egistuoja\n\nwhich komandą tu jau pažinai pirmuose skyriuose, ji parodo, kur randasi proogramos binarinis kodas.\nwhich bash\nBet jeigu tu įrašai pvz which htop ji nieko negražins, nes tikėtina, tu dar nesi instaliavusi šios programos! išbandyk which htop. htop yra sistemos monitoringo progframa, kuri parodo kiek procesocoairuas, darbinėįs atminties dabar tavo kompiuteris naudoja, kurie procesai tai daro ir.t.t. tam tikr aprasme tai task manager, kurį galbūt pameni iš Windows.\nKo gero jau nujauti, kas bus dabar? Tu moki valdyti logiką, tu moki patikinrti ar programa aptinkama kompiuteryje… tad dabar pažiūrėkime, kaip galima išnaudoti bash skriptus ir instlaiuoti trūkstamas programas.\nnano install_requirements.sh\n#!/bin/bash\n\nbinary=/usr/bin/htop\n\nif [ -f $binary ]\nthen \necho \"htop is present\"\nelse\necho \"htop is not present. Installing it now\"\nsudo apt update && sudo apt install htop -y\nfi\nSuprantama, šiuo metu tai vis dar nėra labai prasmingas, nes tu turi žinoti, kurioje vietoje turėtų būti instaliuotas htop.\nBet tu jau moki iššaukti subshell ir jos rezultatus priskirti kintamajam. Ką reiktų viršuje esančiame skripte pakeisti? Būtent, panaudokime which kuri sukurs binary kintamąjį, kurio vertė arba bus tuščia, jeigu htop binary nėra sistemoje, arba su adresu binary failo.\n#!/bin/bash\n\nbinary=$(which htop)\n\nif [ -f $binary ]\nthen \necho \"htop is present\"\nelse\necho \"htop is not present. Installing it now\"\nsudo apt update && sudo apt install htop -y\nfi\nBet kas dabar negarai su šiuo kodu? mes 3 kartus parašome tą patį htop\n[]\nPabandykime pakeisti ir optimizuoti kodą. kaiskime htop kintamuoju, kuriam priskirsime pavadinimą htop.\n#!/bin/bash\n\nprogramm=htop\nbinary=$(which $programm)\n\nif [ -f $binary ]\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nNuostabu, dabar jeigu nuspręstum pakeisti programos pavadinimą į kokią nors kitą, tau tereiktų skripte atnaujinti tai vienoje vinetinleėje vietoje!\nGalima ir šiokia tokia variacija. Jeigu atsisakysime testo, ar failas egzistuoja, galima supraprastinti loginį testą iki to, ar komanda egzistuoja su command -v.\nPrieš taisant skriptą išbandyk temrinale command -v htop ir command -v abc. Jeigu argumentas (komanda) egzistuoja, temrinal gražins binary, jeigu ne, tada ne.\n#!/bin/bash\n\nprogramm=htop\n\nif command -v $programm\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nar galėtume command pakeisti which? TAIP!\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nbet abiems atvejais… mes gaunam kelią į binary, jeigu jis egzistuoja. Galbūt mes to nenorime. Ar pameni, stdin, stdout ir stderror ir jų nukreipimus? padarikime taip, which $programm atsakymą nukreipkime į /dev/null, tam, kad skirptas negrąžintu nieko mums.\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm &gt;/dev/null 2&gt;&1\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nSVEIKINU! tu parašei pirmą, ganėtinai prasmingą skriptą. Gerai pagalvok ir sudėliok kelis scenarijus, kaip galėtum tai panaudoti ateityje? Kaip galbūt reiktų papildomai pakeisti šį ar panašų skriptą? Aptark!",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#išeities-kodai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#išeities-kodai",
    "title": "14  Bash Skriptai 1",
    "section": "14.7 Išeities kodai",
    "text": "14.7 Išeities kodai\nKiekvieną kartą, kai tu paleidi kažkurią komandą, ji arba suveikia, arba ne. Jeigu ji suveikia, tu pamatai aiškų tikimasi rezultatą. Jeigu ne, dažniausiai bash tave informuoja apie problemą. Tačiau tau nematant, kiekvienos komandos įvykdymas sugeneruoja ir tam tikrus išeities kodus (exit codes), ty skaičius, kuris turi tam tikrą reiškmę. Ši elgsena nėra reta IT pasaulyje, pvz įvedus netinkama URL adresą, neretai gali išvyst 404\n[404]\nPanašiai ir BASH. Po kiekvienos komandos įvykdymo, bash sukuria kintamajį, su išeities kodu. Paskutinis išeities kodas galima pamatyti su echo $?\nls\necho $?\nls tralala\necho $?\n\nišeities kodas 0 reiškia, jog nebuvo jokių klaidų\nvisi kiti kodai, reiškia, jog buvo kažkokia klaida\n\nDabar gali pagalvboti, kaip galėtum derinti išeities kodus su if [ exit_code -eq 0] arba if [ exit_code -ne 0]\nšiame skripte:\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm &gt;/dev/null 2&gt;&1\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nŠioje vietoje, ko gero prasmingiausia būtų atspausdinti, ar $prgramm instaliavimas buvo sėkmginas ar ne.\n::: Praktikumas\nsukurt antra if clause skripte, kuris atspausintų pranešimą, ar programa buvo ar nebuvo sėkmingai instaliuota. Tačiau gerai pagalvok apie logiką. Jeigu tu idėsi antrą if clause po pirmojo, tada antrassis if vertins tiek išeities kodą kai programa egistuoja, tiek kai programa neegistuoja ir einama instaliavimo keliu\npapildomas reikalavimas, pagalvok, kaip apdaryti, jog temrinale nebūtų spausdinami apt update ir apt install pranešimai, kurie užildo visą terminalo langą. apt update tu gali drąsiai pasiųsti į /dev/null, tačiau install pranešimus, tu norėtum nusiųsti į script.log failą, jog bet kada galėtum pamatyti,kas vyko. Suprantama, tu nenori, kad failas būtų kaskart perrašomas, o kauptų istoriją.\nTaigi tavo logiką turėtų atrodyti daug maž taip.\n[caldidraw]\nišinstaliuok htop ir su skruptų vėl sintaliuok, tada pakeisk scriptą, kad paketas btūtų “notexist”. peržiūrėk log failus su cat. :::\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm &gt;/dev/null 2&gt;&1\nthen \n        echo \"$programm is present\"\nelse\n        echo \"$programm is not present. Installing it now\"\n        sudo apt update &gt;/dev/null 2&gt;&1 && sudo apt install $programm -y &gt;&gt; \n        if [ $? -eq 0 ]\n        then \n                echo \"Installation of $programm was successfull\"\n        else\n                echo \"Installation of $programm was not successfull\"\n        fi\nfi\njeigu nori pašalinti htop ir pažiūrėti kaip veikia skriptas gali naudoti sudo apt remove htop -y",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#while-ciklai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#while-ciklai",
    "title": "14  Bash Skriptai 1",
    "section": "14.8 WHILE ciklai",
    "text": "14.8 WHILE ciklai\nIki šiol tu išmokai IF ciklą, IF TRUE THEN DO ELSE DO THAT. Tai labai galingas ciklas, nes jis įgalina taov skriptą veikti logiškai. Jeigu programos X nėra, skiprtas ją instaliuota, jeigu ji yra, tai jos instaliuoti nereikia. Tačiau tai nevienintinlis ciklas. Kitas ciklas yra WHILE. WHILE (angl kol), veikia tol, kol tam tirka salyga yra teisinga.\npvz. kol lyja neiti iš namų. Toks ciklas reišktų, kad tu neinit tol iš namų, kol lyja. bet tik nustos lyti, tu galėsi eiti iš namų. Bet čia tu matai ir jau vieną problemą, WHILE ciklai gali būti pavojingi, tu juk nenori eiši iš namų 3 nakties?.\n[lunatic]\nŠtai pavyzdys, kurį aptarsime išsamiau run_while.sh:\n\npirma sukuriame kintamąjėį var ir priksieame jam reikšmę 1\ntad apaleidžiame WHILE ciklą, kuris testuoja ar var &lt;=15 ir kol taip yra WHILE paleidia savo cikla\nWHILE ciklas pradedas do ir užbaigiamas done\ncikle atspausdinamas var\nbet tam kad var neliktų 1, reikia jį inkrepemtuoti (padidinti vienetu), tam man iš sukuriame naują įvertį, prie $var prideda 1 Ėvar +1, bet liepiema tai apdaryti subshell $(), tačiau tu matai, jog šįkart mes panaudojaom dvigubus skliaustelius $((…)), taip rya todėl, nes\nsleep 0.5 priverčia kompiuterėį pauzuoti pusę sekndunės tarp kiekvieno ciklo, tam kad tu geriau matytum jog tai pavieniai ciklai\nkai var pasieks 16, tada while taps FALSE ir ciklas nepasileis\n\n#!/bin/bash\n\nvar=1\n\nwhile [ $var -le 15 ]\ndo\n        echo \"$var\"\n        var=$(($var +1))\n        sleep 0.5\ndone\necho \"While ciklas baigtas\"\naltrernatyva naudoti gryną aritmetika ((var++)) čia pvar++ reiškia, jog paimamas var kintamais ir padidinaimas vientu ir tada rezultatatas priskiriamas tam pačiam var kintamajam.\n#!/bin/bash\n\nvar=1\n\nwhile [ $var -le 15 ]\ndo\n        echo \"$var\"\n        ((var++))\n        sleep 0.5\ndone\necho \"While ciklas baigtas\"\nKitas pvz.\n#!/bin/bash\n\ntouch ~/testfile\n\nwhile [ -f ~/testfile ]\ndo\n        echo \"$(date) Failas egzistuoja\"\n        sleep 1\ndone\necho \"$(date) Failas nebeegizstuoja\"\nO dabar kitame terminale, su rm testfile panaiking failą\nSualvbok bent 3 scenarijus, kada tu pasirinktum naudoti WHILE ciklus?\nŠtai mano keli scenarijai. Tiesa, kai kuriuos iš jų, būtų lengviau suprogramuoti su Python nei su bash\n\nKol naktis, tol išjungiamas internetas namuose (while + date)\nKas 24 valandas parsiųsti vilniaus temperatūrų prognozes (while + sleep )\nKai namuose atsiranda vaiko telefonas (pasijungia prie wifi, išsiųsti žinutę tėvams). Tai daryti kas 15min, kol tėvų išmaniųjų telefonų nėra namuose. (while + ping + sleep)\nKai namų serverio procesoriaus temperatūra pakylą virš XX C, išsiųsti pranešimą apie kaistantį procvesorių per Telegram.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas",
    "title": "14  Bash Skriptai 1",
    "section": "14.9 Praktikumas",
    "text": "14.9 Praktikumas\nParašyk universal_update.sh skriptą.\n\nif [ -d /etc/pacman.d ]\nthen\n  sudo pacman -Syu\nfi\n\nif [ -d /etc/apt ]\nthen \n  sudo apt update\n  sudo apt full-upgrade -y\nfi\n\nosr=/etc/os-release\nif grep -qi “ubuntu” /etc/os-release\nUžduotis, surask kokios dar versijos egzituoja ir kokios komandos atnaujintų sistemą. Paisnoaudok tam chat gpt\n||\nif grep -qi “ubuntu” $osr || grep -qi “debian” $osr\n\n|| OR\n&& AND",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#for-ciklai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#for-ciklai",
    "title": "14  Bash Skriptai 1",
    "section": "14.10 FOR ciklai",
    "text": "14.10 FOR ciklai\nJau moki IF clause, kuris įvyką vieną ciklą jeigu salyga teisinga, bei WHILE ciklą, kuris nuolat sukasi tol, kol sąlygos testvimas gražina TRUE. Tačiau kartais tau nereikia kad skritpas suktūsi be galo, o tik tam tikra ciklų skaičių. Tuo tiklsu naudojami FOR ciklai.\nskaiciai_1_10.sh\n#!/bin/Bash\n\nfor nr in 1 2 3 4 5 6 7 8 9 10\ndo \n  echo $nr\n  sleep 0.5\ndone\necho \"Finished\"\nKas čia vyksta?\n\nfor pradeda for ciklą, o do ir done, kaip ri while cikle apibrėžia ciklo ribas\nnr sukuria kintamąjį kuris yra in sekoje. pirmą karta nr priims vertę 1, antra karta 2, ir t.t. kol apsieks paskutinę vertę - 10\n\nTiesa, toks skaičių išrašymas yra labai neefektyvus. Skaičių seką tu gali sukurti {1..10}. Pabandyk\nBet skaičiai nėra vienintelis kintamojo reikšmė, kuri gali būti naudojami it tekstinai kintamieji.\n#!/bin/Bash\n\nfor nr in 'uobolys' 'citrina' 'mangas'\ndo \n  echo $nr\n  sleep 0.5\ndone\necho \"Finished\"\n#!/bin/bash \n\nfor file in zip_files/*.zip\n\ndo \n  zip $file.zip\ndone\n#!/bin/bash \n\nfor file in zip_files/*.zip\n\ndo \n  unzip file\ndone\n#!/bin/bash\n\n# File containing the URLs\nfile=\"urls.txt\"\n\n# Loop through each line in the file\nfor url in $(cat \"$file\"); do\n    echo \"Fetching $url\"\n    curl -O \"$url\"  # Use -O to save the file with the same name as the remote file\ndone\n\necho \"All URLs have been processed.\"",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#kur-saugoti-skriptus",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#kur-saugoti-skriptus",
    "title": "14  Bash Skriptai 1",
    "section": "14.11 Kur saugoti skriptus?",
    "text": "14.11 Kur saugoti skriptus?\nFHS flilesysteh hierachy standard\n/usr/local/bin\nsudo mv &lt;scriptane.sh&gt; /usr/local/bin  sudo move update.sh /usr/lcoal/bin/update taigi be sh\nptiktinkime teises, matome, kad teisės yra vartotojo, tad pakeiskime į root\nsudo chown root:root /usr/local/bin/update\n.sh failo pratęsimas (file extension) yra skirtas labiau vartotojui, nei kad kompiuteriui. Tai šiek tiek skiriasi nuo Microsoft Windows,, kur failo tipoas yra pivalomas.\nKas įvyksta: /usr/local/bin guli tavo PATH kelyje, kur linux tirkina ar yra tam tikri failai… tad kai tu terminale įrašai tiesiog update bash eidamas per visas direktrijas numatytas PATH, randa update ir jį įvyko. jeigu paliktum update.sh, tai nesuveiktu.\nštai pvz. perkelk šituos du skriptus į /usr/local/bin viena pavading call_1 kitą call_2.sh, suteik root privilegijas ir dabar temrinale įrašyk call_1, call_1sh, call_2, call_2.sh\n[rezultatas]\nir dabar šį skritpą gali nukopijuoti į bet kokį kitą linux kompiuterį. sugalvok 2-3 skirptus, kurie būtų rpamsingi tavo ir kitų kompiuteriuose?\nenv sąraše pamatysi path bet gali path iššaukti ir taip. which komanda pereina per šias direktrijas, kai iešįko programos binary failo. pvz which htop.\nkas, jeigu /usr/local/bin nera path? tokiu atveju tu galėtum pridėti:\nexport PATH=/usr/local/bin:$PATH\nbet dabar tau to tikėinta daryti nereikia. Tačiau turėk omenyje, kad taip pridedamos vietos prie path, ir ateityje nauddoajnt tam tikras programas, tavo path gali prailgėti.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#data-streams-stdin-stdout-stderror",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#data-streams-stdin-stdout-stderror",
    "title": "14  Bash Skriptai 1",
    "section": "14.12 Data Streams (stdin, stdout, stderror)",
    "text": "14.12 Data Streams (stdin, stdout, stderror)\nTrumpas priminimas apie data streams stdin stdout ir stder\nJau žinai, kaip galima atpažinti klaidas, taip pat žinai, jog su echo $? gali atspasdinti paskutinės komandos išeities kodą. Tačiau būna atveju, kai tavo komanda gražina tiek stdout tiek stderr vienu metu.\nštai geras pvz, jeigu ieškai failo\nfind /etc -type f\nir išbandyk echo $?\nPaskrollinus terminale, tu rasi daug įrašu, kuriuos gali matayti, bet lygiai taip pat pamatysi įrašy, kur Permission denied, nes kamndą įvykei ne su sudo ir neturi pakankamai priveligejų. Taigi šiuo atveju gravai ir stdout ir stderr viename lange!\nTu jau žinai, jog komandos išvestis galima nukreipti, tad šiuo atveju, nukreipk klaidas į /dev/null\nfind /etc -type f 2&gt;/dev/null\nir išbandyk echo $? Kaip matai, paskutinė komanda nebuvo įkydyta be klaidų, tačiau klaidų tu nematei, nes jas nusiuntei į /dev/null.\nO dabar išbandyk nusiust sdtdout į /dev/null, tam kad pamatytum, kuriems failams tu neturi prieigos teisių\npritayk šias žinias\n#!/bin/bash\nrelease_file=/etc/os-release\nlog_file=/var/log/updter.log\nerror_log=/var/log/updater_error.log\n\nif grep -qi 'arch' $release_file\nthen\n  sudo pacman -Syu 1&gt;&gt;$log_file 2&gt;&gt;$error_log\n  if [ $? -ne 0 ]\n  then echo \"Error occured\"\n  fi\nfi\n\nif grep -qi 'debian' $release_file || grep -qi 'ubuntu' $release_file\nthen \n  sudo apt update 1&gt;&gt;$log_file 2&gt;&gt;$error_log\n   if [ $? -ne 0 ]\n  then echo \"Error occured\"\n  fi\n  sudo apt full-upgrade -y 1&gt;&gt;$log_file 2&gt;&gt;$error_log\n  if [ $? -ne 0 ]\n  then echo \"Error occured\"\n  fi\nfi\nO kaip apie stdin?\n#!/bin/bash\n\necho \"Echo please enter your name\"\nread myname\necho \"Hello $myname, how is your day?\"\nŠiuo atveju read iššaukia stdin, t.y. kad varotojas įrašytų kažką klaviatūra. Tai kas įrašyta, mes galime prisikrti kintamajam ir toliau jį naudoti.\nPabandyk. Šiame pvz neveikia logika {$x..$y} nes {} priima tik skaičius, ne kintamuosius, todėl pasitelksime kitą funckiją seq\n#!/bin/bash\n\necho \"Nuo kokio skaičiaus skaičiuosime? \"\nread x\necho \"Iki kokio skaičiaus skaičiuosime? \"\nread y\n\nfor i in $(seq $x $y)\ndo\n    echo $i\n    sleep 0.5\ndone",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#funkcijos",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#funkcijos",
    "title": "14  Bash Skriptai 1",
    "section": "14.13 Funkcijos",
    "text": "14.13 Funkcijos\nhttps://www.cloudbooklet.com/developer/how-to-create-and-use-bash-functions-in-linux\nJeigu tu kažką parašei jau du kartus - geras ženklas, jog tai turėtų būti funkcija, o ne tieiosg kodas.\nŠi filosofija labai gerai apibūdina prorgramavimą bendrai, tiek bash, python, R ir t.t.\nPeržiūrėk ką tu pakartojai update skripte? sudo nano /usr/local/bin/update\n[]\nTu gali refaktorizuoti dalį kodo, kuri kartojasi panaudojant funkciją\ncheck_exit_status() {\n  if [ $? - ne 0 ]\n  then ....\n  fi\n}\ndabar kodas atrodo taip\ncode",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#case",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#case",
    "title": "14  Bash Skriptai 1",
    "section": "14.14 CASE",
    "text": "14.14 CASE\n#!/bin/bash\n\necho \"Kaip tavo diena?\"\necho \"1 - nelabai gera\"\necho \"2 - nei gera, nei bloga\"\necho \"3 - labai gera\"\necho \"įrašyk skaičių\"\n\nread value\n\ncase $value in\n  1) echo \"Gal pakalbam?\";;\n  2) echo \"Papasakok\";;\n  3) echo \"Kaip faina, pasidalink!\";;\n  *) echo \"Gal pabandyk dar kartą, tarp 1 ir 3?\"\nesac\nKaip matai, pabandius vieną kartą skritpas pasibaigia. Bet įrašius 999 ir gavus pasiūlymą bandyt dar kartą. Šioje vietoje, tau labai rpaverstų while ciklas. Pagalvok, ką būtų galima čia pakeisti? O tada žiūrėk į atsakymą žemiau\n#!/bin/bash\n\npabaiga=0\n\nwhile [ $pabaiga -eq 0 ]\ndo \n\necho \"Kaip tavo diena?\"\necho \"1 - nelabai gera\"\necho \"2 - nei gera, nei bloga\"\necho \"3 - labai gera\"\necho \"įrašyk skaičių\"\necho \"kai norėsi pabaigti, parašyk 'stop' \"\n\nread value\n\ncase $value in\n  1) echo \"Gal pakalbam?\";;\n  2) echo \"Papasakok\";;\n  3) echo \"Kaip faina, pasidalink!\";;\n  stop) pabaiga=1\n  *) \"Gal pabandyk tarp 1 ir 3 arba stop\"\nesac\ndone\n\nTu - katinas Leopoldas, kuriam priklauso kačių kavinė. Kavinėje dirba 4 katės: Luci, Nora ir Bumas ir Floras. Jie priima užsakymus. Tiesa, kačių kavinės meniu nera didelis, svečiai gali pasirinkti “Ledai”, “Pyragas”, “Kava”. Ledai kainuoja 2.5, Pyragas 4.5, p kava tik 2 eurus. Kačių kavinės savininko - Leopoldo noras, dienos pabaigoje pamatyti, kur iš kačių aptarnavo daugiausiai ir kiek ko buvo parduota. Leopoldo lūkestis matyti tokius duomenis, pvz:\ndata,laikas,katė,produktas,kaina 2024-10-01,10:00,Luci,Kava,2.0 2024-10-01,10:00,Luci,Pyragas,4.5 2024-10-01,10:30,Floras,Ledai,2.5\nLeopoldas - nusprendė jog planšetėje paleis skriptą, į kuri kačių kavinės personalas galės suvesti ir tai bus labai didelis palengvinimas vedant apskaitą. Bet kad nepakrauti kačių, jis nusprendė jos jos suves tik: vardą ir kas buvo parduota. Kaina ir laikas - turi būti sugeneruoti automatiškai.\nŠiame projekte naudok case, while, if, echo, &gt;&gt; po visos dienos, Leopoldas tikisi rasti failą “pardavimai.csv”\nKai pabaigsi projektą, suvesk atlik bent 10 įvedimus už kates, o tada naudojant Excel arba LibreOffice Calc, importuok duomenis ir atvaizduok juos.\n\n\nSugalvok bent 2-3 kitas idėjas panašiames skriptams. Tada trumpai ant popieriau lapo nupaišyk logiką, kaip veiktų skriptas, kokios dalys būtų, kur būtųš if, while, for, case….\n\n#!/bin/bash\n\nwhile true; do\n  value=$(whiptail --title \"Dienos nuotaika\" --menu \"Kaip tavo diena?\" 15 60 4 \\\n    \"1\" \"nelabai gera\" \\\n    \"2\" \"nei gera, nei bloga\" \\\n    \"3\" \"labai gera\" 3&gt;&1 1&gt;&2 2&gt;&3)\n\n  exitstatus=$?\n  if [ $exitstatus = 0 ]; then\n    case $value in\n      1) whiptail --msgbox \"Gal pakalbam?\" 8 45;;\n      2) whiptail --msgbox \"Papasakok\" 8 45;;\n      3) whiptail --msgbox \"Kaip faina, pasidalink!\" 8 45;;\n    esac\n  else\n    break\n  fi\ndone",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#cron",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#cron",
    "title": "14  Bash Skriptai 1",
    "section": "14.15 CRON",
    "text": "14.15 CRON\nAutomatinis paleidimas (sheduling) yra labai svarbus konceptas. Prieš atsirandant tokiems instrumentams kaip Airflow, duomenų inžinieriai anksčiau automatizuodavo darbus manualiai su CRON. Nemažai įmonių ir dabar, CRON vis dar naudojamas automatizuoti tam tikrus darbų paleidimus. Bet ir asmeniniame kompiuteryje ar namų serveryje CRON yra labai naudingas instrumentas. CRON yra automatiškai įdiegtas visuose Linux sistemose. Tačiau rekomenduoju apsitikrinti, ar tu jį turi su which cron. taip pat išbandyk, ar turi at su which at. Jeigu neturi, instaliuok!.\nat komanda yra labai paprasta. Ką ji padaro, tai tiesiog suteikia galimybę paleisti tam tikrą komandą tam tikru metu Susikurk šitą skriptą example_for_at.sh\n  GNU nano 7.2                                                            example_for_at.sh                                                                     \n#!/bin/bash\nlogfile=at_logfile.log\n\nfor i in {1..10}\ndo \necho \"This is $i run at $(date)\" &gt;&gt;$logfile\nsleep 1\ndone\nsuteik execute teises su chmod 744 example_for_at.sh\nišabndyk prirmą skriptą manualiai ir su cat įsitikink, jgo skriptas iš tiesų veikia ir nėra jokių klaidų.\no dabar su at pasirink kada paleisti skriptą. Pasirink laiką, tarkime už kelių miniučių nuo dabar, kad nereiktų ilgai laukti ir pamatyti, jog iš tiesų at suveikė. Nepamiršk su rm ištrinti senajo log failo. Ir nurodyk atitinkmą kelią, arba absoliutų arba relatyvų.\nat 10:00 -f ~/example_for_at.sh\nJeigu nori pamatyti, kokie darbai yra suplantuoti:\natq\nČia pamatysi job id, kurė galėsi ištrinti su atrm &lt;id&gt;\nTarkime nori suplanuoti tiklsiesnę datą\nat 10:00 2024-12-31 -f ~/example_for_at.sh\nat yra patogi komanda, bet ji paleidžia komandą ar skriptą tik vieną kartą. Ir tai ali būti nepakankama, nes pvz,, galbūt tu nori, jog duomenys parsisiųstų kasnakt? O galbūt, kad kiekvieną sekmadienį tavo Downloads direktorijije esantys failai būtų perkeltį į namų serverį / Nextcloud, tam kad turėti jų atsarginę kopiją?\ncron\nfully qualified path for commands ir kodėl jas reikia naudoti cron paruoštiems skriptams, bet galbūt geriau ir bendrai visada.\n\ncron gali veikti ne shell\nkas nros gali sukurti komanda vz kaip ems update ir tik ją pavadint, pvz echo ir tada pekitus path, cron galėtų paimti tą komandą…\n\nTačiau prieš pradedant automatizuoti\ncrontab -e iššaukia crontab editorių pasirink teksto editorių su kuriuo norėsi dirbti. rekomenduoju - NANO. Atsidarius crontab -e nemžą dalį ekrano užimo komentarai (#). Juos galima ištrinti, tam, kad netrukdytų. Po eilutę NANO editoriuje galima ištrinti su Ctrl+k.\nKaip atrodo crontab eilutė:\n\n\n\n\n\n\n\n\n\n\n\nKą tai reiškia.\n* - reiškia bet kokią reikšmę, arba “kiekvieną”. jeigu * pailikta ties minute, tai reikš kiekvieną minutę, jiegu ties valanda - kiekvieną valandą ir t.t. , - naudojamas atksirti reikšmes pvz 0,9,18 ties valandomis riekšų jog cron užduotis pasileis vidurnaktį, 9 valandą ryto ir 18 valandą vakaro. - - naudoajmas nurodyti diapazoną, pvz 10-20 reikštų nuo 10 iki 20 minutės. / - reiškia žingnsius. pvz */5 ties minutės reiktų jog cron darbas paleidžiamas KAS 5 minutes\nRekomenduoju iššisaugoti https://crontab.guru/ šiame tinklapyje galima rasti skaičiuoklę, kuri padeda pagaminti norimą laiko pasirinkimą. Tačiau štai keli pvz:\n\n@reboot: kaskart restartavus kompiuterį (labai dažnai naudojama valymo darbams)\n@hourly : kas valandą (priklausomai nuo tada kada buvo įjungtas kompiuteris arba pirmą kartą pasileido cron užduotis).\n\nIš kurio vartootojo paskyros paleidžiamas cron darbas?\njeigu tu aktyvyuoji cron editorių be sudo, tu suplanuoji savo vartotojo cron darbus. tačiau gali naudoti sudo crontab -u &lt;username&gt; -e jeigu nori nustatyti cron darbą tam tikram vartootjui&lt;username&gt;.\nCron jobs are scheduled tasks managed by the system, independent of currently logged-in users. Thus, the cron job you scheduled for your user with crontab -e will run according to the specified schedule, regardless of which user is currently logged in. The job will execute with your user’s permissions, not the permissions of the logged-in user.\ncrontab -e:\nWhen you invoke crontab -e without sudo, you’re editing the cron jobs for your own user account. Any tasks you schedule will run with your user’s permissions, and the jobs will only affect your user environment. This means the cron jobs will only be able to access files and execute actions that your user has permission for. sudo crontab -e:\nUsing sudo with crontab -e allows you to edit the cron jobs for the root user. This means the tasks scheduled will run with root-level permissions. The cron jobs in this context have elevated privileges, which allows them to perform actions across the entire system, access files, and execute commands that would typically require superuser access. This is useful for scheduling tasks that need administrative privileges, such as system maintenance tasks or jobs that affect multiple users or system-wide settings.\n\nĮsivaizduok, jog tu turi bash scriptą, kuris patikrina, ar darbinis serveris veikia gerai. Skriptas prasisuka per 30 sekundžių. Todėl tu nusprendei, jog siekiant kokybiško monitoringo, tu ji paliesi kas 5 minutes kasdien. Darbo valandos tavo įmonėje 8-17, tačiau kadangi skriptas monitorina serverio užžimtumą, tu nori pamantyti ir 7 bei 18 vlaandos rodiklis, tam kad turėti palyginimą. Kitomis valandomis, tu nenori jog tavo skiprtas veiktų, nes visgi tam naudojama elektra o ir poreikio naktiniam monitoringui tu šiuo metu neturi. Tas pats pasakytina ir apie savaitgalius.\nParašyk paprasta bash scriptą, kuris naudotų: …..\nTavo norimi duomenys turėtų būti išsaugomi server_x.log faile ir turėtų turėti tokią struktūrą\n|date|time|cpu|memory|\n\n14.16 Argumentai\nTu jau žinai, jog komandos priima argumentus, pvz ls -l Downloads priima argumenta Downloads ir atspausdina šios direktorijos turinį. Lygiai taip pat, tu gali naudoti argumentus ir bash skriptams, jeigu nori, suteikti daugiau fleksibilumo jiems.\ntest_script.sh\n#!/bin/bash\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\n$1 reikiškia pirmą argumentą, kuris paduotas kartu su sciptu\n\n./test_script.sh Linux GNU Intell\nTačiau kas nutinka, jeigu vartotojas nenurodė argumento, nors jio buvo tikimasi\n./test_script.sh Linux GNU Intell\natrodo keistai.\nKaip galima tai išsrpęsti, tai naudoti if ir $# šis kintamasis parodo, kiek argumentų paduota skriptui.\n\nif [ $# -ne 3 ]\nthen\necho \"This script requires exactly 3 arguments and you provided $#\"\necho \"pabandyk dar kartą\"\nexit 1\nfi\n\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\nParašyk skriptą, kuris jeigu paduotas be argumento, parodys sekančių 7 dienų orų prgonozę Vilniui. Bet galimi argumentai gali būti vilnius, kaunas, klaipeda. priklausomai nuo argumento, turėtų būti parodomi atitinkami duomenys.\n\n\n\n14.17 Praktikumas: Serverio Backup skritpas\nhttps://cameronnokes.com/blog/the-most-useful-bash-commands-for-front-end-development/",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#argumentai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#argumentai",
    "title": "14  Bash Skriptai 1",
    "section": "14.16 Argumentai",
    "text": "14.16 Argumentai\nTu jau žinai, jog komandos priima argumentus, pvz ls -l Downloads priima argumenta Downloads ir atspausdina šios direktorijos turinį. Lygiai taip pat, tu gali naudoti argumentus ir bash skriptams, jeigu nori, suteikti daugiau fleksibilumo jiems.\ntest_script.sh\n#!/bin/bash\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\n$1 reikiškia pirmą argumentą, kuris paduotas kartu su sciptu\n\n./test_script.sh Linux GNU Intell\nTačiau kas nutinka, jeigu vartotojas nenurodė argumento, nors jio buvo tikimasi\n./test_script.sh Linux GNU Intell\natrodo keistai.\nKaip galima tai išsrpęsti, tai naudoti if ir $# šis kintamasis parodo, kiek argumentų paduota skriptui.\n\nif [ $# -ne 3 ]\nthen\necho \"This script requires exactly 3 arguments and you provided $#\"\necho \"pabandyk dar kartą\"\nexit 1\nfi\n\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\nParašyk skriptą, kuris jeigu paduotas be argumento, parodys sekančių 7 dienų orų prgonozę Vilniui. Bet galimi argumentai gali būti vilnius, kaunas, klaipeda. priklausomai nuo argumento, turėtų būti parodomi atitinkami duomenys.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas-serverio-backup-skritpas",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas-serverio-backup-skritpas",
    "title": "14  Bash Skriptai 1",
    "section": "14.17 Praktikumas: Serverio Backup skritpas",
    "text": "14.17 Praktikumas: Serverio Backup skritpas\nhttps://cameronnokes.com/blog/the-most-useful-bash-commands-for-front-end-development/",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html",
    "href": "d_bash_skriptai/14_bash_scripts_2.html",
    "title": "15  Bash Skriptai 1",
    "section": "",
    "text": "15.1 Kam man reikalingi BASH skriptai?\nKai administruoji (prižiūri) kompiuterius, arba nori automatizuoti tam tikrus procesus savo kompiuteryje, BASH skriptai tampa nepaimainoma pagalba. Štai keli pvz. perinstaliavus Linux, tu gali paleisti skriptą, kuris automatiškai instaliuos visas tavo naudojamas programas bei atstatys tavo nustatymus. O galbūt tu nori, kad kartą per savaitę failai esantys tavo Downloads direktorijoje susitvarkyt ir būtų išskirstyti, o šiukliadėžė išvalyta? O galbūt tu nori, kad reguliariai tavo kompiuteris padarytų savo backup kopiją ir ją patalpintų namų serveryje? Visokiems tokiems su kompiuteriu ar serveriu susijusius veiksmus lengviausia automatizuoti su BASH, nors tiesa, jog daugumą šių veiklų galima padaryti ir su Python arba kitomis programavimo kalbomis.\nNors BASH nėra tikrąją ta žodžio prasme programavimo kalba, BASH tai komandų interpretatorius skirtas interakcijai su tavo SHELL, visgi atzsižvelgiant į tai, jog BASH’e tu gali naudoti kintamuosius, ciklus ir t.t. padaro BASH beveik pilnaverte programavimo kalba.\nAr BASH skriptai reikalingi tik Linux adminsitratoriams? Ne, nors ko gero Linux administratoriai juos naudoja dažniausiai, šis įvadas į BASH skriptus padės geriau suprasti kompiuterinę logiką (ciklus), padės praktikuotis BASH komandas ir įgalins tave ne tik tapti dar labiau IT raštinga, bet ir paklos pamatus tiek Python, tiek Docker ir kitoms IT temoms, kuriose tu ir toliau naudosi Terminalą bei turėsi interakciją su Linux operacine sistema.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#kas-yra-bash-skriptas",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#kas-yra-bash-skriptas",
    "title": "15  Bash Skriptai 1",
    "section": "15.2 Kas yra bash skriptas?",
    "text": "15.2 Kas yra bash skriptas?\nIki šiol tu rašei komandas vieną paskui kitą tiesiogiai į terminalą. Nors išmokai jas sujungti (pipe) visgi tai nevsiada be galo patogus būdas, jeigu pvz norėtum paleisti 150 komandų vieną paskui kitą. Tam naudojami skriptai - tekstinis failas, kuriame surašyta visa komandų seka ir tavo SHELL skaito visas komandas ir vykdo jas vieną paskui kitą.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#hello-world",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#hello-world",
    "title": "15  Bash Skriptai 1",
    "section": "15.3 Hello World",
    "text": "15.3 Hello World\nPasileidus terminalą, susikurk norimoje vietoje direktoriją “learning_bash” naudojant mkdir. Su cd pereik į šią direktoriją. Kol dirbsime su bash skriptais, dirbsime iš šios direktorijos.\nDabar terminale paleisk NANO editorių ir sukuruk faila:\nnano hello_world.sh\nGriežtai žiūrint, .sh nėra reikalingas. Kompiuteris susiduręs su šiuo failu ir taip supras, ką jam daryti. Tačiau tam, kad kiti žmonės greitai pamatytų ir surpastų, jog tai skiptinis failas, įprastai naudoajamas .sh arba .bash.\nPačiame faile įrašyk\necho \"Hello world\"\nIšsaugok failą su Ctrl+s ir Ctrl+x\nAtspausdink su ls -l direktorijos turinį.\nKaip matai, šis failas neturi x taigi joks vartotojas neturi execution teisių. Naudojant sudo chmod 744 hello_world.sh suteik sau visas teises, paliekant grupei ir kitiems vartotojams tik skaitymo teises.\npasitikrink su ls -l ar tikrai turi visas reikiamas teises. Galimai dabar net skriptinis failas pakeitė spalvą ir tapo žalias (?).\nKaip dabar paleisti skirptą?\n./hello_world.sh\nPaleidus šį skriptą BASH interpretatorius skaito eilutę po eilutės ir vykdo komandas.\nTačiau šis skriptas dar nėra visai teisingas. Minėjau, jog failo indikatorius .sh nėra būtinas. tad kaip kompiuteris žino, jog tai skriptas? Įprastai (ir nuo šiol visada) mes pirmoje eilutė yįašome šebang #! kuris pasako SHELL interpretatoiui - “Hey, čia ne komentaras, o nurodymas, kokį interpretatoriu naudoti”. Kaip minėjau pačioje mokymų pradžioje, kai kuriuose kompiuteriuose gali būti BASH, ZSH ir kiti SHELL interpretatoriai. Komanduose jose gali šiek tiek skirtis (skirtingas dialektas, arba būdingos tam tikros komandos). Tam kad nekiltų problemų vykdant šį skriptą (angl. running script), mes nurodome koks būtent interpetatorius /bin/bash turėtų perskaityti ir vykdyti komandas.\n#!/bin/bash\n\necho \"Hello World\"\nSveikinu, tai pirmas pilnavertis tavo BASH skriptas. Pripažinkime, tai labai paprastas skriptas.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#kintamieji",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#kintamieji",
    "title": "15  Bash Skriptai 1",
    "section": "15.4 Kintamieji",
    "text": "15.4 Kintamieji\nKintamieji yra reikalingi tam, kad išsaugotų tam tikras reikšmes. Terminale išbandyk, tik gal įrašyk savo vardą. Svarbu, priešingai nei Python, BASH tarp kintamojo ir = negali būti space ir taip pat tarp = ir argumento!\nmanovardas=\"Justas\"\nmanoskaicius=14\nTol kol šita terminalo sesija rya aktivyi (ir tu neperrašei šių kintamųjų) jie bus pasiekiami tavo terminale. Išbandyk panaudoti šiuos kintamuosius naudojant echo komandą. Kad BASH žinotų, jog tu turi omenyje kintamąjį, reikia naudoti $ prieš kintamojo pavadinimą.Šis procesas vadinamas kintamųjų deklaravimu.\necho $manovardas\necho $manoskaicius\nO dabar pabandyk sudėti viską į vieną sakinį\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nPaskutinę komandą galėjome atspausdinti ir be \"\", tačiau jeigu naudotume '' nieko gero nesigautų. Išbandyk ir įsitikink\necho Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\necho 'Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius'\nŠtai todėl, dažniausiai ir naudojame \"\"\nKas nutiktu jeigu panaudtum kintamąjė, kuris nėra deklaruotas\necho $blabla\nOgi nieko. Bash tau neišmes klaidos ir atspausdins tiesiog tuščią vietą.\nPbanadyk uždaryti terminalą ir atsidaryk iš jį iš naujo. Pakartok komandą\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nir įsikitkink, jog kintamieji neišsisaugojo. Taigi, kintamieji kuriuos sukuri temrinalo sesijoje, glaioje tik toje terminalo sesijoje. Išjungus terminalą, ar restartavus kompiuterį - viskas dingsta.\nTam kad neprarasti kintamųjų, mes juos išsaugome kartu su komandomis skripto viduje. Su NANO sukurk naują skriptą apie_mane.sh\n#!/bin/bash\n\nmanovardas=\"Justas\"\nmanoskaicius=14\nmanoamzius='39'\n\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nŠiuo metu tavo skriptas yra begalo paprastas ir vienu žvilsniu suprantamas. Tačiau ilgainiui, tau gali reikėti pridėti komentarus, t.y. priminimus sau, arba paaiškinimus kitiems, kas vyksta kode ir t.t. Tam naudojami komentarai. Skritpuose komentarai pradedami # (nors gali naudoti ir kelis). Viskas į dešinė nuo # toje pačioje eilutė nebus interpretuojama kaip kodas, o BASH supras jog tai yra komentaras ir jo neskaitys.\nPridėkime kelis komentarus;\n#!/bin/bash\n# =====================================================\n# Data: 2024-10-30\n# Autorius: Justas Mundeikis\n# Paskirtis: Atspasdinti informaciją apie mane\n# =====================================================\n\n## Deklaracijos\nmanovardas=\"Justas\" # deklaruojamas vardas, pasikeisk į savo\nmanoskaicius=14 # deklaruojamas skaičius, pasikeisk į savo\nmanoamzius='39' # deklaruojamas amžius, pasikeisk į savo\n\n## Funkcijos\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nKaip matai, pridėjau skripto virųuje vaidnamą header (virtutinėje) dalyje, komentarus, kurie informuoja apie tai, kas, kada sukurė šį skriptą. Ar yra privalomi paminėti dalykai? Ne. Tačiau geroji praktika rodo, kad autorius, data ir paskirtis neretai rpaverčia net sau pačiamm atsidarius skriptus po kiek laiko, greičiau susigaudyti. Jeigu kažkada tavo skritpai taptų labai įmantrūs, tada komentaras header skiltyje galėtų būti dar išsamesnis, štai ChatGPT man pasiūlė net aprašyti kokie yra dependencies, pvz jeigu skriptas naudoja komanda,s kurios ali būti neinstaliuotos. Tada kitas vartotojas atsidaręs iškart matys ką turi instaliuoti, jog skriptas veiktų, o ne pirma paleidus skritpą ir sulaukus klaidos, ieškoti ko trūko.\n#!/bin/bash\n#====================================================================\n# Script Name: script_name.sh\n# Description: Briefly describe what the script does.\n# Usage: ./script_name.sh [options] [arguments]\n# Author: Your Name\n# Created Date: YYYY-MM-DD\n# Version: 1.0\n# Last Modified: YYYY-MM-DD\n# Dependencies: List dependencies like `curl`, `awk`, or other scripts.\n# Requirements: Any system requirements or permissions needed.\n# Notes: Additional helpful notes, warnings, or cautions.\n#====================================================================\nDabar tau gali kilti klausimas - o kodėl neparašius komandos, kad instaliuoti iškart šiuos dependencies? Nebent tavo skriptas yra skirtas programų instaliavimui ir kitas vartotojas tai supras ir tu tai dokumentavai, pvz README.md faile… nėra labai ger apraktika tiesiog paleisti instialiavią kažkieno kito kompiuteryje. Be to, tu negli būti tikra, ar tia Linux, ar MacOs sistema. O net Linux, gali būti naudoajmas ne apt programū menedžeris, o dnf ir t.t. Taigi, ir saugiau ir lengviau leisti tam tikruas programas susiinstaliuoti pačiam vartotojui.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#matematinės-funkcijos",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#matematinės-funkcijos",
    "title": "15  Bash Skriptai 1",
    "section": "15.5 Matematinės Funkcijos",
    "text": "15.5 Matematinės Funkcijos",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#if-else",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#if-else",
    "title": "15  Bash Skriptai 1",
    "section": "15.6 IF ELSE",
    "text": "15.6 IF ELSE",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#išeities-kodai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#išeities-kodai",
    "title": "15  Bash Skriptai 1",
    "section": "15.7 Išeities kodai",
    "text": "15.7 Išeities kodai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#while-ciklai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#while-ciklai",
    "title": "15  Bash Skriptai 1",
    "section": "15.8 WHILE ciklai",
    "text": "15.8 WHILE ciklai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas",
    "title": "15  Bash Skriptai 1",
    "section": "15.9 Praktikumas",
    "text": "15.9 Praktikumas",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#for-ciklai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#for-ciklai",
    "title": "15  Bash Skriptai 1",
    "section": "15.10 FOR ciklai",
    "text": "15.10 FOR ciklai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#kur-saugoti-skriptus",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#kur-saugoti-skriptus",
    "title": "15  Bash Skriptai 1",
    "section": "15.11 Kur saugoti skriptus?",
    "text": "15.11 Kur saugoti skriptus?",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#data-streams-stdin-stdout-stderror",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#data-streams-stdin-stdout-stderror",
    "title": "15  Bash Skriptai 1",
    "section": "15.12 Data Streams (stdin, stdout, stderror)",
    "text": "15.12 Data Streams (stdin, stdout, stderror)",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#funkcijos",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#funkcijos",
    "title": "15  Bash Skriptai 1",
    "section": "15.13 Funkcijos",
    "text": "15.13 Funkcijos",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#case",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#case",
    "title": "15  Bash Skriptai 1",
    "section": "15.14 CASE",
    "text": "15.14 CASE",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#cron",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#cron",
    "title": "15  Bash Skriptai 1",
    "section": "15.15 CRON",
    "text": "15.15 CRON",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#argumentai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#argumentai",
    "title": "15  Bash Skriptai 1",
    "section": "15.16 Argumentai",
    "text": "15.16 Argumentai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas-serverio-backup-skritpas",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas-serverio-backup-skritpas",
    "title": "15  Bash Skriptai 1",
    "section": "15.17 Praktikumas: Serverio Backup skritpas",
    "text": "15.17 Praktikumas: Serverio Backup skritpas",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  }
]