[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Linux ir programavimas",
    "section": "",
    "text": "Įvadas",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#operacinė-sistema",
    "href": "index.html#operacinė-sistema",
    "title": "Linux ir programavimas",
    "section": "Operacinė sistema",
    "text": "Operacinė sistema\nKai tu įjungi savo telefoną, kompiuterį ar mikrokompiuterį, jame pasileidžia programa - instrukcijų rinkinys, kuris nurodo, kaip tavo prietaisas turi veikti. Ši programa nurodo, pavyzdžiui, įjungus prietaisą pradėti šviesti ekranui, paspaudus klavišus abc suprasti, kad tu rašai, arba įjungus elektros kabelį pradėti krauti bateriją.\n\n\n\nKompiuteris. Autorius: Alessandro Oliverio\n\n\nŠis instrukcijų rinkinys dar nėra visavertė operacinė sistema. Tai yra vadinamasis branduolys (angl. - kernel), kuris nurodo, kaip turi veikti kompiuterinė įranga tarpusavyje.\nŠalia branduolio yra ir kita programinė įranga, kuri leidžia tau naudotis prietaisu - tai įvairiausios programos, pvz., skambinimo programėlė, kalkuliatorius, interneto naršyklė. Visa ši programinė įranga kartu su branduoliu sudaro operacinę sistemą (angl - operating system, arba - OS).\nTaigi operacinė sistema (OS) yra programinė įranga, kuri valdo kompiuterinės įrangos ir programų išteklius. Ji veikia kaip tarpininkė tarp vartotojo ir kompiuterio aparatūros. Pagrindinės populiarios operacinės sistemos yra Windows, UNIX šeimos OS - macOS, ir Linux.\n\nWindows: Microsoft korporacijos sukurta populiariausia operacinė sistema, naudojama tiek namų, tiek verslo kompiuteriuose. Ji žinoma dėl savo patogumo ir plataus programų pasirinkimo.\nmacOS: Apple korporacijos operacinė sistema, naudojama Mac kompiuteriuose. Ji žinoma dėl savo dizaino, stabilumo ir integracijos su Apple ekosistema.\nLinux: Atviro kodo operacinė sistema, kurią gali keisti ir dalintis visi norintys. Ją naudoja dauguma serverių ir technologijų entuziastų.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#ubuntu-skoniai",
    "href": "index.html#ubuntu-skoniai",
    "title": "Linux ir programavimas",
    "section": "Ubuntu skoniai",
    "text": "Ubuntu skoniai\nLinux yra atviro kodo operacinė sistema, todėl ją gali keisti ir dalintis visi norintys. Dėl to yra nemažai programuotojų, kurie nusprendžia pasidalinti savo pagamintais Linux variantais, vadinamais distribucijomis.\n\n\n\nLinux distribucijų medis\n\n\nKai tu įjungi telefoną arba kompiuterį, branduolys užtikrina, kad visi kompiuterio komponentai galėtų tarpusavyje bendrauti. Vis dar trūksta programų, kurios rodytų vaizdus ekrane, leistų įvesti tekstą ir pan. Tam yra reikalingos papildomos programos, dauguma jų buvo sukurtos GNU projekto metu. Tačiau tik branduolys ir GNU programos dar neleistų visavertiškai naudotis kompiuteriu, todėl papildomai diegiamos įvairios reikalingos programos, kurios padaro operacinę sistemą praktiška ir gražiai atrodančia.\nTaigi, pilną operacinę sistemą, dar kartais vadinamą Linux distribucija (distribution), sudaro:\n\nLinux branduolys (kernel)\nGNU programos\nPapildomos programos ir grafinis dizainas",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#kodėl-linux",
    "href": "index.html#kodėl-linux",
    "title": "Linux ir programavimas",
    "section": "Kodėl Linux",
    "text": "Kodėl Linux\nGrįžkime prie klausimo - “Kodėl Linux”?\n\nSaugumas: Linux dažnai laikoma saugesne operacine sistema dėl savo architektūros ir mažesnio virusų kiekio.\nServeriai: Linux arba jai giminingos UNIX sistemos veikia beveik visuose pasaulio serveriuose. Greičiausiai net tavo namuose yra ne vienas įrenginys, kuriame veikia Linux.\nUniversalumas: tiek iOS, tiek Android taip pat veikia UNIX pagrindu.\nLankstumas ir pritaikomumas: Linux leidžia tau būti labiau savarankiškam ir geriau suprasti, kaip veikia kompiuteriai. Tuo pačiu metu išmoksti dalykų, kurių nemoka kiti.\nProgramavimas: Linux yra gera pradžia kelionei į Python ir kitas programavimo kalbas, kurios naudojamos programuojant robotus, kuriant interneto svetaines ar atliekant skaičiavimus su dideliais duomenų kiekiais.\n\nŠiais laikais vis daugiau ir daugiau profesijų kasdienėje veikloje reikia programavimo. Buhelteriai naudojasi Python,kad greičiau apdorotų duomenis. Architektai ir inžinieriai, kad teisingai apskaičiuotų pastato konstrukcijas. Transporto srauto specialistai, kad planuotų ir valdytų automobilių srautus, o NASA darbuotojai, kad valdytų į kosmoosą kylančias raketas.\nTaigi Linux ir tam tikra prasme - programavimas, paruošia tave 21-ajam amžiui.\nNegana to, Linux veikia ant tokių paprastų mikrokompiuterių kaip Raspberry Pi Zero ir gali atgaivinti net 10-20 metų senumo nešiojamą kompiuterį. Taigi, tai padeda tausoti gamtą, nes savo technika gali naudotis ilgiau.\nBet yra ir kita medalio pusė. Ne visos tavo įprastos programos veikia Linux. Pavyzdžiui, Adobe produktai tiesiog neveikia Linux aplinkoje. Microsoft Excel ir Word taip pat nėra pritaikyti Linux. Jei tavo mokslui ar darbui yra būtinos tam tikros programos, Linux gali neatitikti tavo lūkesčių. Tačiau reikia žinoti, kad daugelis šių programų turi analogus Linux aplinkoje. Dažniausiai jie yra atviro kodo ir nemokami.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#linux-mint",
    "href": "index.html#linux-mint",
    "title": "Linux ir programavimas",
    "section": "Linux Mint",
    "text": "Linux Mint\nKaip jau minėjau, yra daug Linux distribucijų. Šiame vadovėlyje naudosime vieną iš paprasčiausių - Linux Mint distribuciją, kuri sukurta Ubuntu pagrindu.\nJą galima parsisiųsti iš linuxmint.com. Kaip ją instaliuoti, gali šiek tiek skirtis priklausomai nuo kompiuterio, tad geriausia šioje vietoje tiesiog paieškoti vaizdo įrašo Youtube svetainėje.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html",
    "href": "a_linux_pagrindai/1_linux_configure.html",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "",
    "text": "1.1 Intro",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#themes",
    "href": "a_linux_pagrindai/1_linux_configure.html#themes",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.2 Themes",
    "text": "1.2 Themes",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#backgrounds",
    "href": "a_linux_pagrindai/1_linux_configure.html#backgrounds",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.3 Backgrounds",
    "text": "1.3 Backgrounds",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#menu",
    "href": "a_linux_pagrindai/1_linux_configure.html#menu",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.4 Menu",
    "text": "1.4 Menu",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#panel",
    "href": "a_linux_pagrindai/1_linux_configure.html#panel",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.5 Panel",
    "text": "1.5 Panel",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#firewall",
    "href": "a_linux_pagrindai/1_linux_configure.html#firewall",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.6 Firewall",
    "text": "1.6 Firewall",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#languages",
    "href": "a_linux_pagrindai/1_linux_configure.html#languages",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.7 Languages",
    "text": "1.7 Languages",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#keyboard",
    "href": "a_linux_pagrindai/1_linux_configure.html#keyboard",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.8 Keyboard",
    "text": "1.8 Keyboard",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#time",
    "href": "a_linux_pagrindai/1_linux_configure.html#time",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.9 Time",
    "text": "1.9 Time",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#tips-tricks",
    "href": "a_linux_pagrindai/1_linux_configure.html#tips-tricks",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.10 Tips & Tricks",
    "text": "1.10 Tips & Tricks",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html",
    "href": "a_linux_pagrindai/2_linux_update.html",
    "title": "2  Linux atnaujinimas",
    "section": "",
    "text": "2.1 Pradžia\nVisuose kompiuteriuose yra daugybė įvairių programų. Pavyzdžiui, jau susipažinome su Terminal ir Files programomis. Taip pat išmokome naudoti kai kurias įdiegtas komandas: echo, cat, ir base64. Šių programų kūrėjai dažnai atnaujina savo programas, tad norėdami pasinaudoti naujausiomis funkcijomis ir pataisymais, turime įdiegti šiuos atnaujinimus (angl. - update).\nŠioje pamokoje sužinosime:\nBe to, išmoksime:\nŠis skyrius padės išmokti, kaip efektyviai tvarkytis su programomis ir jų atnaujinimais, kad kompiuteris visada būtų naujausias ir veiktų be trikdžių.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html#pradžia",
    "href": "a_linux_pagrindai/2_linux_update.html#pradžia",
    "title": "2  Linux atnaujinimas",
    "section": "",
    "text": "Kas yra veidrodiniai serveriai (angl. - mirrors).\nKaip atnaujinti programas naudojant Update Manager programą.\nKaip atlikti programų atnaujinimus naudojant terminalą.\n\n\n\nKaip įdiegti (angl. - install) programas naudojant Software Manager ir terminalą.\nKuo skiriasi System Package nuo Flatpak programų.\nKaip pašalinti (angl. - uninstall) nebereikalingas programas, kad kompiuteris būtų švaresnis ir veiktų sklandžiau.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html#update-manager",
    "href": "a_linux_pagrindai/2_linux_update.html#update-manager",
    "title": "2  Linux atnaujinimas",
    "section": "2.2 Update Manager",
    "text": "2.2 Update Manager\nUpdate Manager yra programa, kuri padeda atnaujinti kitas programas tavo kompiuteryje. Ji pati praneša, kai laikas atnaujinti programas. Kai internete yra prieinami atnaujinimai, dešiniame kampe atsiranda skydelio su raudonu tašku piktograma (raudonas taškas reiškia, kad yra naujų atnaujinimų).\n\n\nBet jei nematai šios piktogramos, gali paleisti “Update Manager” programą per Menu:\n.\nPirmą kartą paleidus šią programą, gali pamatyti tokį langą, kuris paaiškina, ką ji daro. Drąsiai spausk ant OK.\n\nJei pamatysi, kad pačiai programai reikia atnaujinimo, spausk ant “Apply the Update” (lt. - įdiegti atnaujinimą). Taip pat gali matyti užrašą switch to a local mirror, kol kas spausk No. Kas yra veidrodžiai (angl. - mirrors), pakalbėsime netrukus.\n\nJei paspaudus “Apply the Update” kompiuteris paprašys tavo slaptažodžio, įvesk jį. Taip kompiuteris įsitikina, kad tik tu ar kitas vartotojas, kuriam priklauso šis kompiuteris, gali atlikti pakeitimus. Drąsiai įvesk savo slaptažodį ir spausk Authenticate (lt. - patvirtinti tapatybę).\n\nNetrukus pamatysi vaizdą, kuris gali atrodyti panašiai - vienas ar keli, o gal net daugybė skirtingų programų atnaujinimų, kuriuos gali įdiegti savo kompiuteriui. Tačiau kol kas dar nieko nespauskime. Susipažinkime su tuo, ką čia matome:\n\n\n\nType - kokio tipo yra atnaujinimas? Jie gali būti:\n\nSecurity update - saugumo atnaujinimas. Jo simbolis yra skydelis. Tai svarbiausias atnaujinimas, kurį reikia kuo skubiau įdiegti, kad kompiuteris būtų saugus.\nKernel update - pagrindinės Linux sistemos atnaujinimas. Jo simbolis yra žaibas. Šie atnaujinimai pagerina, kaip veikia pats kompiuteris. Ar ekranas rodo gerai? Ar veikia pelė? Ir t.t.\nSoftware update - programų atnaujinimai. Tai atnaujinimai, kuriuos programų kūrėjai sukuria, kad jų programos veiktų geriau, turėtų daugiau funkcijų ir pan.\n\n\nŠiame lange taip pat gali paspausti ant:\n\n\nClear - išvalyti visus pasirinktus atnaujinimus\nSelect All - pasirinkti visus atnaujinimus\nRefresh - atnaujinti sąrašą atnaujinimų, kurie yra prieinami\nInstall Updates - įdiegti pasirinktus atnaujinimus\n\nBet kaip kompiuteris žino, kokias programas atnaujinti? Ir iš kur jis jas atsisiunčia?\n\n2.2.1 Mirrors ir Updates\nVeidrodėli, veidrodėli, kas pasaulyje gražiausia?\n\nPradėkime nuo pradžių…\nĮsivaizduok, kad programuotoja, kuri kuria programas, dirba iš namų, kaip ir tu. Po ilgos darbo savaitės, ji nusprendžia: “Viskas, programos atnaujinimas paruoštas. Ištaisyta klaida, įdiegti nauji patobulinimai”.\n\n(Nuotraukoje Jaime Gunther, kuri 38 metų nusprendė, kad mokysis savarankiškai programuoti ir tapo programuotoja)\nBet dabar įsivaizduok, kad keli milijonai žmonių bandytų parsisiųsti iš jos kompiuterio šiuos atnaujinimus. Jos kompiuteris negalėtų to atlaikyti, ir viskas strigtų bei vyktų labai lėtai.\nTodėl programuotoja naudoja serverius veidrodžius (angl. - mirrors).\n\nKas yra serveris? Serveris yra didelis kompiuteris, kuris pastatytas specialiose vietose ir gali aptarnauti milijonus žmonių vienu metu. (daugiau nuotraukų gali rasti čia)\n\n\n\nKodėl jie vadinami veidrodžiais (angl. - mirrors)? Nes jie atspindi tuos programinius pakeitimus, kuriuos programuotoja padarė savo namuose. Kai ji kažką atnaujina, šie serveriai iškart tai atspindi, ir tu gali parsisiųsti atnaujinimus neapkraudamas programuotojos namų kompiuterio!\n\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuris turi sąrašą, kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs, priklauso programų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitikrinti ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasties kartais tavo kompiuteris paklausia, ar nori prisijungti prie vietinių veidrodinių serverių - “Do you want to switch to a local mirror?”\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuriame yra sarašas kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs nutolęs, priklauso prgramų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitiktrinti, ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasies, kartais tavo kompiuteris paklausia, ar nori prisijngti prie lokalių veidrodžių.\nKaip tai padaryti?\n\nSpausk ant “Edit” (pakeitimai) ir tada ant “Software Sources” (programų šaltiniai).\nKompiuteris vėl paprašys tavo slaptažodžio, įvesk jį.\nAtsidariusiame naujame lange pamatysi Main ir Base veidrodžius. Jie gali būti nustatyti ne visai ten, kur gyveni tu.\nSpustelk pele prie Main. Atsidarys langas, kuriame bus serveriai, surūšiuoti pagal tai, kaip arti tavęs jie yra (pagal atsisiuntimo greitį). Tu pamatysi, kad po kelių sekundžių sąrašo viršus nebekinta. Tau nereikia laukti, kol kompiuteris parsisiųs visų serverių informaciją. Pasirink patį pirmą serverį\nPakartok tai su Base serveriu.\nSpustelk ant “Update the mirrors” (atnaujinti veidrodinius serverius). Tai gali truputį užtrukti.\nAtnaujinus, pamatysi, kad buvusius serverius pakeitė kiti, tavo pasirinkti serveriai.\nDabar gali uždaryti šį langą.\n\nVisas procesas šiame video:\nVideo\nDabar gali atnaujinti programas, paspaudus ant Install Updates. Gali atsirasti papildomi langai, kur paklaus, ar tikrai nori įdiegti atnaujinimus, gali paprašyti ir įvesti tavo slaptažodį dar kartą. Visur drąsiai sakyk “taip” ir įrašyk savo slaptažodį.\nTačiau yra ir kitas būdas! Naudojant Terminal.\nVeidrodinių serverių atnaujinimas yra būtinas net kai įdiegi atnaujinimus per Terminalą. Tad retkarčiais pasitikrink, ar pasirinkti vis dar sparčiausi veidroriniai serveriai.\n\n\n2.2.2 Atnaujinimų instalivimas per Terminal\nKodėl kartais geriau įdiegti atnaujinimus per Terminal programą? Visų pirma - tu praktikuojiesi BASH kalbos žinias! Visų antra, vėliau išmoksi, kaip vos kelių klavišų paspaudimu tai padaryti daug greičiau nei spaudant su pele ir naudojant Update Manager programą.\nŠtai taip atrodo kodas, kurį reikės įrašyti:\nsudo apt update && \nsudo apt full-upgrade -y && \nsudo apt autoremove -y && \nflatpak update\nDabar tavo galvoje gal atrodo taip:\n\nPradėkime nuo pradžių ir eikime per visas komandas, kad jas suprastume. Kai suprasi - pamatysi, kad viskas gana paprasta.\nMes galime visas komandas surašyti į vieną eilutę, bet paprastumo dėlei, terminale įrašyk komandą po komandos, kaip pateiktia žemiau.\n\nsudo apt update.\n\n\nčia iššaukiama komanda apt. Tai yra programa, kuri rūpinasi programų atnaujinimu.\nupdate yra argumentas, ką programa turi daryti. Priešingai nei atrodo, ji neatnaujina programų. Ką ji padaro, tai palygina tavo kompiuterio programas su tuo, kas yra veidrodiniuose serveriuose (mirror). Jeigu ji aptinka skirtumą, nes, pvz., serveryje programa yra naujesnė, apt tave informuos apie galimus atnaujinimus.\nO kas yra sudo? Atsimeni, kai Update Manager tavęs prašė įrašyti tavo slaptažodį? Kai tu jį įrašydavai, kompiuteris suprasdavo, jog tu turi kompiuterio administratoriaus teises. sudo padaro tą patį. Ši komanda pasako, kad po jo sekantis kodas būtų įvykdytas su kompiuterio administratoriaus teisėmis ir apsaugo, kad svetimi žmonės nieko negalėtų padaryti tavo kompiuteriui.\n\nSpausk Enter. Paleidus šią komandą, Terminal tavęs paprašys įrašyti savo slaptažodį. Jį rašant tu nieko nematysi (juk nenori, kad sėdint kavinėje, kas nors pamatytų tavo slaptažodį?). Įvesk ir spausk Enter dar kartą. Jeigu savo slaptažodį įvesi neteisingai - terminalas tau tai pasakys, tad galėsi bandyti dar kartą.\nJeigu tavo kompiuteriui yra pasiekiami atnaujinimai - tu pamatysi, kiek jų.\n\n\nsudo apt full-upgrade -y.\n\n\nŠi dalis pasako, kad sudo - elkis kaip administratorius\napt naudok programų atnaujinimų programą.\nfull-upgrade - atnaujink visas programas.\n-y yra nustatymas, panašus į ką jau matėme su base64 -d, tik šį kartą jis reiškia yes (lt - taip). Jeigu jo nepanaudotum, Terminal programa tavęs paklaustų, kokius atnaujinimus siūlo padaryti ir dar kartą klaustų, ar tikrai nori viską įdiegti. Tam kad išvengti šio papildomo klausimo, iš karto pasakome - yes.\n\nJeigu tu rašai šią komandą iškart po to, kai jau naudojai sudo apt update, Terminal programa tavęs gali ir nebeprašyti dar kartą įrašyti savo slaptažodį.\nPriklausomai nuo to, kiek yra atnaujinimų, šis procesas gali užtrukti kelioliką sekundžių, bet gali ir kelioliką minučių.\nVideo\n\nsudo apt autoremove -y.\n\n\nsudo ir apt jau žinome.\nauto-remove - šis nustatymas pasako apt komandai, kad jeigu yra kažkokių programų, kurios po atnaujinimo nebereikalingos, jas ištrintų. Nebijok, apt programa yra labai protinga ir atsargiai atsirenka, ką trinti ir ko ne.\n-y nustatymas pasako yes (taip), kad nereiktų patvirtinimo.\n\n\n\nflatpak update - kiek kita komanda. Čia mes iššaukiame programą flatpak, kuri, kaip ir programa apt, moka instaliuoti programas. Tačiau ją atnaujinti užtenka vos šių dviejų žodžių.\n\n\n\nO ką gi reiškia && toje ilgoje komandoje? Kai mes rašome komandas po vieną, kaip padarėme dabar, mes patys matome, ar nutiko kas nors netikėto, ar įvyko kokia nors klaida ir t.t. Tam, kad kompiuteris žinotų, jog tik padarius sudo apt update ir negavus jokių klaidų, jis eitų prie sekančios komandos sudo apt full-upgrade -y ir taip toliau, reikia šias komandas sujungti su &&. Jeigu prieš tai buvusi komanda nepavyktų, kompiuteris nutrauktų visas likusias komandas.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html#žodynėlis",
    "href": "a_linux_pagrindai/2_linux_update.html#žodynėlis",
    "title": "2  Linux atnaujinimas",
    "section": "2.3 Žodynėlis",
    "text": "2.3 Žodynėlis\n\n\n\n\n\n\n\n\nKomanda\nApibrėžimas\nPavyzdys\n\n\n\n\nsudo apt update\nKomanda, kuri atnaujina paketų sąrašą iš visų saugyklų, kad būtų galima gauti informaciją apie naujausias programinės įrangos versijas.\nPaleidus sudo apt update, sistema patikrina, ar yra naujų programinės įrangos paketų atnaujinimų.\n\n\nsudo apt full-upgrade\nKomanda, kuri atnaujina visus įdiegtus paketus į naujausias galimas versijas, automatiškai pašalindama arba įdiegdama paketus, kai reikia.\nNaudojant sudo apt full-upgrade, jūsų sistema bus atnaujinta į naujausias programinės įrangos versijas.\n\n\nsudo autoremove\nKomanda, kuri pašalina nereikalingus paketus, kurie buvo įdiegti kaip priklausomybės, bet dabar nebėra reikalingi.\nPaleidus sudo autoremove, bus pašalinti nereikalingi bibliotekų paketai, siekiant atlaisvinti vietos diske.\n\n\nflatpak update\nKomanda, kuri atnaujina visus įdiegtus Flatpak programas į naujausias versijas.\nNaudojant flatpak update, jūsų Flatpak programos bus atnaujintos į naujausias versijas.\n\n\nsudo apt install &lt;name&gt;\nKomanda, kuri įdiegia nurodytą programinės įrangos paketą iš saugyklos.\nPaleidus sudo apt install vim, bus įdiegta vim redaktoriaus programa.\n\n\nsudo apt remove &lt;name&gt;\nKomanda, kuri pašalina nurodytą programinės įrangos paketą iš sistemos.\nNaudojant sudo apt remove vim, bus pašalinta vim redaktoriaus programa.\n\n\nflatpak install &lt;name&gt;\nKomanda, kuri įdiegia nurodytą Flatpak programą iš Flatpak saugyklos.\nPaleidus flatpak install flathub org.gimp.GIMP, bus įdiegta GIMP programa.\n\n\nflatpak remove &lt;name&gt;\nKomanda, kuri pašalina nurodytą Flatpak programą iš sistemos.\nNaudojant flatpak remove org.gimp.GIMP, bus pašalinta GIMP programa.\n\n\n-y\nParametras, kuris automatiškai atsako “taip” į visus klausimus, kuriuos komanda gali užduoti, taip palengvinant automatizuotą diegimą ar pašalinimą.\nKomandoje sudo apt install -y vim, parametras -y užtikrina, kad diegimo procesas vyks be vartotojo įsikišimo.\n\n\n&&\nLoginis operatorius, naudojamas sujungti kelias komandas taip, kad antroji komanda būtų vykdoma tik tuo atveju, jei pirmoji komanda baigiasi sėkmingai.\nKomandoje sudo apt update && sudo apt upgrade, sudo apt upgrade bus vykdoma tik tada, jei sudo apt update sėkmingai baigiasi.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html",
    "href": "a_linux_pagrindai/3_linux_software.html",
    "title": "3  Linux programos",
    "section": "",
    "text": "4 Programų instaliavimas\nProgramų instaliavimas Linux yra gana paprastas. Užtenka susirasti ir atsidaryti Software Manager.\nJam atsidarius, iškart matome daug programų pasiūlymų. Drąsiai panaršyk šiame lange. Ar matai ką nors tave dominančio?",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-instaliavimas",
    "href": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-instaliavimas",
    "title": "3  Linux programos",
    "section": "4.1 Sisteminių paketų instaliavimas",
    "text": "4.1 Sisteminių paketų instaliavimas\nSisteminis paketas (angl. System Package) - tai programa, kurią Linux kūrėjai patikrino ir pritaikė tavo kompiuterio veikimui. Šios programos valdomos per apt programą.\nKita programų instaliavimo sistema yra Flatpak, su ja susipažinsime vėliau.\nĮdiekime “Bloboats” žaidimą.\nPaieškos viršuje įrašyk Bloboats ir paspausk ant programos piktogramos.\n\nKaip matai, sekantis langas parodo, jog tai System Package ir leidžia tau šią programą įdiegti. Spausk ant Install.\n\nSoftware Manager programa informuos tave, jei reikia įdiegti papildomas programas.\n\nJei taip nutiktų, spausk ant Continue, o tada įrašyk savo slaptažodį ir spausk ant Authenticate. Prisimeni, kai tu įrašai savo slaptažodį, kompiuteris komandas vykdo kaip sudo :)\n\nDabar gali spausti ant Launch (lt - paleisti), arba rasi šią programą tarp visų programų.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "href": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "title": "3  Linux programos",
    "section": "4.2 Sisteminių paketų įdiegimas Terminal lange",
    "text": "4.2 Sisteminių paketų įdiegimas Terminal lange\nSusiraskime kitą programą - 3dchess. Kaip matai, jos pavadinimas kompiuteriui yra parašytas šio lango apačioje:\n\nAtsidaryk terminalą ir įrašyk šią komandą, daug kas jau tau bus matyta:\nsudo apt install 3dchess\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia įdiegti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\ninstall - komanda, pasakanti apt, ką turi daryti, šįkart įdiegti naują programą.\n3dchess - argumentas, pasakantis, kokią programą įdiegti.\n\nMes taip pat galėjome pridėti -y, bet šįkart to nepadarysime. Pažiūrėkime, kas nutinka. Ar pastebėjai kompiuterio reikalavimą patvirtinti, jog tikrai nori instaliuoti šią programą? Do you want to Continue [Y/n]\nVideo\nKaip matai, kompiuteris manęs klausė, ar tikrai noriu, ir teko įrašyti Y raidę ir spustelėti Enter. Tiesa, kai matai [Y/n] tai reiškia, kad jeigu tiesiog paspausi Enter - kompiuteris galvos, kad tu renkiesi Y (Yes trumpinys), tad rašyti Yes tau net nereikia. Kartais tu gali pamatyti [N/y]. Taigi tas pasirinkimas, kuris parašytas didžiąja raide - bus automatiškai pasirinktas jeigu nieko neįrašysi, bet pasupausi Enter klavišą.\nJeigu būčiau įrašęs komandą\nsudo apt install 3dchess -y\nTerminal programa manęs neprašytų patvirtinti mano pasirinkimo. Nes priejus šiam klausimui Do you want to Continue [Y/n], nustatymas -y pasakytų iškart Yes.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#flatpak",
    "href": "a_linux_pagrindai/3_linux_software.html#flatpak",
    "title": "3  Linux programos",
    "section": "4.3 Flatpak",
    "text": "4.3 Flatpak\nFlatpak yra kitoks būdas instaliuoti programas. Kai tu instaliuoji Flatpak programą, tu atsisiunti ne tik pačią programą, bet ir visas kitas programas, kurios reikalingos, kad pagrindinė programa veiktų. Pabandykime tai paaiškinti kitaip.\nĮsivaizduok, kad tavo kompiuteris yra kaip namas. Namai turi kambarius, virtuvę, vonią ir t.t. Dabar įsivaizduok, kad nori naujos spintos. Kai tu parsisiunti spintą kaip System Package (sisteminį paketą), tai tarsi parsiveži ją iš IKEA parduotuvės ir pastatai savo kambaryje.\nFlatpak programos veikia kitaip. Kai tu atsisiunti Flatpak programą, tai tarsi parsineštum visą didelę palapinę, kurioje yra ne tik tavo spinta, bet ir visa kita - virtuvė, vonia ir dar keli kambariai. Kodėl taip daroma?\nKartais programoms reikia kitų programų, kad jos veiktų gerai. Tavo kompiuteryje ne visada yra visos šios reikalingos programos. Todėl kai parsisiunti Flatpak programą, ji atsisiunčia viską, ko jai reikia, kad veiktų be problemų. Tai reiškia, kad gauni naujesnę ir geriau veikiančią programą. Tačiau ši didelė palapinė užima daugiau vietos tavo kompiuteryje, nes joje yra viskas, ko reikia programai.\nPavyzdžiui, susiraskime programą “hedgewars”. Pasirink bet kurią piktogramą.\n\nKaip matai, šalia “System Package” arba “Flatpak” yra nedidelis trikampiukas. Paspaudus ant jo, pamatysi, jog gali įdiegti šią programą ir kitu formatu.\nTaip atrodo System Package:\n\nO štai taip Flatpak. Atkreipk dėmesį į programos versijos skirtumus ir kiek vietos reikia kompiuteryje.\n\nKaip System Package ši programa užima 194 MB vietos tavo kompiuteryje, o kaip Flatpak - 3.7 GB. 3.7 GB atitinka 3700 MB. Taigi beveik 20 kartų daugiau vietos. Tai reiškia, kad Flatpak programai reikia daugiau vietos, nes ji atsisiunčia viską, ko jai reikia.\nGera žinia yra ta, kad kai instaliuosi kitą programą su Flatpak, labai tikėtina, kad kita programa jau galės naudotis kai kuriais dalykais iš pirmosios palapinės. Tada naujai programai reikės mažiau vietos.\nFlatpak programas taip pat galima instaliuoti per Terminal programą.\nTačiau tai šiek tiek skiriasi:\n\nnereikia naudoti sudo\nvietoj apt reikia naudoti flatpak\nnaudojame install\nprogramos pavadinimą galima pasiimti iš Software Manager, bet daugiau Flatpak programų galima rasti ir flathub.org tinklapyje.\n\nVideo",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#software-manager",
    "href": "a_linux_pagrindai/3_linux_software.html#software-manager",
    "title": "3  Linux programos",
    "section": "5.1 Software Manager",
    "text": "5.1 Software Manager\nPirmiausia pažiūrėkime, kaip ištrinti programas naudojant Software Manager.\n\nAtidaryk Software Manager.\nPaspaudus ant trijų brūkšnelių spausk ant “Show Installed Application” (lt. parodyk įdiegtas programas).\n\n\n\nSurask programą, kurią nori ištrinti, ir spausk ant jos pavadinimo ar piktogramos.\n\n\n\nAtsidariusiame lange spausk ant Remove (lt. pašalinti).\n\n\n\nSoftware Manager programa paprašys patvirtinimo. Spausk Continue, įvesk savo slaptažodį ir spausk Authenticate.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#menu",
    "href": "a_linux_pagrindai/3_linux_software.html#menu",
    "title": "3  Linux programos",
    "section": "5.2 Menu",
    "text": "5.2 Menu\nKitas būdas ištrinti programas yra per Menu.\n\nAtidaryk meniu, kur randi visas savo programas.\nDešiniu pelės klavišu spustelk ant programos, kurią nori ištrinti. Prasiskleis papildomas meniu.\nPasirink Uninstall (lt. pašalinti).\nPasirodys patvirtinimo langas. Pasirink OK, įvesk savo slaptažodį ir spausk Authenticate.\n\nVideo",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#terminalas",
    "href": "a_linux_pagrindai/3_linux_software.html#terminalas",
    "title": "3  Linux programos",
    "section": "5.3 Terminalas",
    "text": "5.3 Terminalas\nProgramas taip pat galima ištrinti per terminalą.\n\n5.3.1 Sisteminis paketas\nNorėdami ištrinti sisteminį paketą, naudokime apt programą. Pavyzdžiui, jei nori ištrinti programą “3dchess”:\n\nAtidaryk terminalą.\nĮrašyk šią komandą: sudo apt remove 3dchess\n\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia ištrinti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\nremove - komanda, pasakanti apt, kad reikia ištrinti programą.\n3dchess - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#flatpak-1",
    "href": "a_linux_pagrindai/3_linux_software.html#flatpak-1",
    "title": "3  Linux programos",
    "section": "5.4 Flatpak",
    "text": "5.4 Flatpak\nPer Terminal irgi galime ištrinti Flatpak programą. Pavyzdžiui, jei nori ištrinti programą org.hedgewars.Hedgewars:\nflatpak uninstall org.hedgewars.Hedgewars\nPaaiškinkime, kas čia yra kas:\n\nflatpak - programa, kuri įdiegia, atnaujina ir pašalina Flatpak programas.\nuninstall - komanda, pasakanti flatpak, kad reikia ištrinti programą.\norg.hedgewars.Hedgewars - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#kodėl-per-terminal",
    "href": "a_linux_pagrindai/3_linux_software.html#kodėl-per-terminal",
    "title": "3  Linux programos",
    "section": "5.5 Kodėl per Terminal?",
    "text": "5.5 Kodėl per Terminal?\nKo gero tau dabar kyla klausimas, kodėl verta mokėti atnaujinti, įdiegti ir ištrinti programas naudojant Terminal?\nNaudoti Terminal gali atrodyti sudėtingiau nei spustelėti pelę, tačiau jis turi daug privalumų.\n\nTerminal leidžia tau atlikti daugybę užduočių labai greitai. Užuot naršant per meniu ir ieškant reikiamų funkcijų, tu gali tiesiog įvesti kelias komandas ir tavo darbas bus atliktas.\nTerminal suteikia daugiau galimybių ir lankstumo. Kai kuriuos dalykus gali padaryti tik per Terminal. Be to, Terminal naudoti gali būti smagu! Tai tarsi magija – tu rašai komandas, o kompiuteris jas vykdo.\nTerminal naudojimas gali padėti tau geriau suprasti, kaip veikia tavo kompiuteris. Kai tu įrašai komandas ir matai, kaip jos veikia, tu pradedi suvokti, kas vyksta tavo kompiuterio viduje.\nTerminal naudojimas gali padėti tau tapti tikru kompiuterių ekspertu. Ir kas žino, galbūt ateityje tave sudomins programavimo, duomenų analitikos ar tiesiog inžinerijos mokslai? Labai daug profesijų pradeda nautodi programavimą kasdieniuose savo darbuose. Aplinkosaugininkai gali tyrinėti kaip keičiasi klimatas ir kaip kinta gamta, buhalteriai gali paspasrtinti ataskaitų ruošimą, architektai apskaičiuoti kaip statyti namą, jog jis nesugriųtų vykstant žemės drebėjimui, robotikos specialistai - kaip sukonstruoti robotoą, kuris važinėja ir tyrinėja Marso planeta…\n\nSkamba truputį sudėtingai, tiesa? Pateiksiu tau pavyzdį. Įsivaizduok, kad tu turi draugę vardu Pelenė. Pelenė irgi turi kompiuterį, bet nežino, kaip įdiegti programas. Tačiau jūs norite kartu žaisti tą patį žaidimą - lenktyniauti žaidžiant Super Tux Cart. Ką daryti?\nTu gali jai parašyti žinutę ir pasakyti, kad nukopijuotų ir paleistų štai tokį kodą:\nsudo apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update && flatpak install net.supertuxkart.SuperTuxKart -y\nNa štai, jeigu jūs turite paskyras Super Tux Cart, dabar galite nuotoliniu būdu lenktyniauti kartu.\nDar neturi paskyros ir elektroninio pašto adreso? Sekančioje pamokoje tai ir susikursime.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html",
    "href": "a_linux_pagrindai/4_passwords_programms.html",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "",
    "text": "4.1 Intro\nAr žinai, kas kelia didžiausią riziką internete, tiek vaikams, tiek suaugusiems? Nesaugūs slaptažodžiai.\nTokie slaptažodžiai kaip:\nyra begalo pavojingi. Blogi pogramuotjai, dar vadinami “hakeriais”, nuolat bando nulaužti internetinas paskyras. Tam jie naudojasi teksto generatoriais, sukuria šimtus tūkstančių kombinacijų, pvz pelenė123 ir bando nulaužti internetinius slaptažodžius.\nkas gali nutikti blogiausia, jeigu tavo slaptažodį nulauš?\nScerijus:\nRetai, bet taip nutinka.\nŠioje pamokoje išmoksi kas yra saugus slaptažodis, kaip juos sukurti ir kaip juos saugoti. Taip tai ne visada yra patogu, bet deja, kaip visad gyvenime, reikia ieškoti kompromiso tarp saugumo ir patogumo.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html#intro",
    "href": "a_linux_pagrindai/4_passwords_programms.html#intro",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "",
    "text": "12345\nslaptažodis\nvardaspavardė\nmamos vardas\naugintinio vardas\n\n\n\n\n\nHackeris “nulaužia” t.y. atspėja tavo slaptažodį pvz Google paskyros\nNueina į tavo banko paskyrą, ir pranša, kad pamiršo savo slaptažodį. Bankas atsiunčia nuorodą į elektronį paštą, kuriame prideda nuorodą, leidžiančia sukurti naują slaptažodį bankui.\nPrisijungęs prie tavo banko paskyros - hackeris ištuština tavo visas santaupas. Dabar tu turi eiti skolintis, vien tam, kad turėti pinigų maistui.\nBet hackeris buvo ypač blogas, apart visko, jis dar ištrynė ir visas kitas tavo paskyras, nuotraukų kopijas esančias internete ir prikėtė visokių kitų šunybių.\nNa prie to pačio, dar ir užrakino tavo telefoną, ištrynė kontaktus, tad net nebežinai, kaip paskambinti draugams ir paprašyti pagalbos.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html#kas-yra-saugus-slaptažodis",
    "href": "a_linux_pagrindai/4_passwords_programms.html#kas-yra-saugus-slaptažodis",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "4.2 Kas yra saugus slaptažodis",
    "text": "4.2 Kas yra saugus slaptažodis\nPirmiausia, saugus slaptažodis yra toks, kurio tu nežinai! Jeigu tu nežinai savo slaptažodžio, tu negali jo užrašyti ant jokio popieriaus lapelio, tad niekas jo ir nepamatys.\nTai kaip prisijungti prie paskyrų internete, pvz, banke? prie elektroninio pašto?\nTam padeda slaptažodžių programos. Jų yra įvairių\n\ninternetinės programos tokios kaip Bitwarden, kurios sinchronizuoja, t.y. suvienodina informaciją per visus tavo įrenginius: kompiuterį, telefoną ir t.t.\nkompiuteryje instaliuotos programos, pvz keepassx, kuriose išsaugai slaptažodius ir kai reikia prisijungti, atsidarai jas ir iš jų nusikopijuoji slaptažodį, kurio reikia.\n\nKiti aspektai saugaus slaptažodžio:\n\nbent 16 simbolių (geriau naudoti daugiau, bet ne visur leidžiama)\nnaudoti tiek DIDŽIĄSIAS RAIDES, tiek mažąsas, tiek skaičius bet būtinai ir simpbolius tokius kaip !@#$%^&*()_\n\ntačiau pati svarbiausia taisyklė:\n\nnaudoti skirtingus slaptažodžius visur\n\nJeigu kam nors pavyktų nulaužti tavo vieną paskyrą, pvz kokios nors internetinės parduotuvės, tas hackeris negalėtų panaudoti išgauto slaptažožio norint prisijungti prie tavo elektroninio pašto.\nNaudojant tokias programėlės kaip Bitwarden, KeepassX ir kitas, su laiku tu pamatysi, kiek daug paskyrų turi ir kaip nelengva būtų visur turėti skirtingus slaptažodžius.\n\n4.2.1 KeepassX\nInstlaiuok keepassx savo kompiuteryje. Prisimink iš praėjusio skurio, kaip instaliuoti programas naudojantis Terminal Programos pavadinimas kurio reikės keepassx\nPagalba:\n\nsudo suteikia administratoriaus teises\napt programa kuri valdo programas\ninstall komanda kuri įdiegia programas\n&lt;argumentas&gt; programos pavadinimas, kurią norima įdiegti\n\n             Video Video\nTai dar kartą:\n\n16-20 simbolių slaptažodis\nsusidedantis iš įvairių raidžių, skaičių ir simbolių\nkiekvienam paskyrai skirtingas slaptažodis\nišsaugotas programėleje",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html#elektroninis-pašto-adresas",
    "href": "a_linux_pagrindai/4_passwords_programms.html#elektroninis-pašto-adresas",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "4.3 Elektroninis pašto adresas",
    "text": "4.3 Elektroninis pašto adresas\nDauguma žmonių turi elektroninį paštro adresą sukuart Google svetainėje. Tai labai paprarsta ir patogu, juo labiau, nemokama.\nBet vėlgi, patogumas netolygu saugumui. Visų pirma Google naudojasi visais turimais duomenis, failais, laiškais ir t.t. tam, kad pagerintų reklamos rodymą. Ne Google yra produktas, kurį naudoji, o TU tampi produktu Google.\nTačiau yra ir saugumo problema, jeigu kas nors pamato tavo ekrano slaptžodį ir pavogia telefoną, o ten yra Gmail programėle, tai jau beveik ir nebereikia spėlioti tavo slaptažodžių. Tu gali nespėti užblokuoti savo telefono, o banko sąskaita jau gali būti tuščia. Kaip? Velgi, vagišius pasinaudos “pamiršau savo slaptažodį” funkcija. Jam atsius laišką į gmail su nuoroda kaip susikurti naują slaptažodį, o patvirtinimui, akd ten “tikrai tu”, bankas atsiųs SMS žinutę. Viskas viename įrenginyje…\nO jeigu tavo Gmail laiškuose dar ir tavo žinutės tavo slaptai meilei?\nKą daryti?\nGeriausia turėti elektroninį pašto adresą kuris nėra google. Gera alternatyva - Prononmail.\nTad dabar pažiūrėsime kaip susikurti Protonmail ir kaip galėsi atsidaryti emailus Thunderbird laiškų probramėlėje kompiuteryje.\nLaišku programėlės į telefoną - net nediegsime, juk vėl padidintume riziką.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "",
    "text": "5.1 Shell ir Terminalas\nŠiek tiek istorijos… Senais laikais kompiuteriai buvo milžiniški. Kad būtų patogiau (santykinai) su jais dirbti, žmonės prisėsdavo prie ekrano su klaviatūra, kuris buvo sujungtas su kompiuteriu. Ši instaliacija – ekranas su klaviatūra – buvo vadinama terminalu. Darbuotojai rašydavo komandas, o kompiuteris jas vykdydavo ir grąžindavo rezultatus. Tais laikais buvo rašomos komandos, nes kompiuteriai dar nebuvo tokie galingi ir neturėjo GUI (graphical user interface, lt - grafinės vartotojo sąsajos). Taigi, terminalas buvo CLI (command line interface, lt- komandų eilutės sąsaja), nes priimdavo komandas. Tai yra vartotojo sąsaja, kurioje komandos įvedamos (input) tekstu, o rezultatai rodomi kaip teksto išvestis (output). Skirtingai nuo GUI, kur naudojami vizualiniai elementai, tokie kaip langai ir mygtukai, CLI leidžia tiesiogiai rašyti instrukcijas, kurias vykdo sistema.\nKiek vėliau, atsiradus ekranams…\nŠiais laikais, kai norime, kad kompiuteris vykdytų komandas, taip pat naudojamės terminalu, tik jau ne fiziniu, o program, kuri emuliuoja fizinį terminalą.\nPrograma, kuri priima ir vykdo komandas, bendrai vadinama Shell. Ji priima komandas, išverčia jas į kompiuterio suprantamą kalbą ir liepia kompiuteriui jas įvykdyti. Po to, gavusi rezultatus, ji juos parodo terminale. Yra keletas skirtingų Shell “kalbų” arba tipų. Populiariausi Shell tipai, tokie kaip Bash (Bourne Again Shell), yra standartinė kiekvienos Linux sistemos dalis. Zsh (Z Shell) yra standartinis Shell MacOS sistemose, tačiau jis vis labiau populiarėja ir tarp Linux vartotojų.\nShell programos leidžia automatizuoti įvairias užduotis ir vykdyti sudėtingas komandas. Be to, Shell turi programavimo kalbos savybių, leidžiančių rašyti skriptus – failus su komandomis, kurios vykdomos viena po kitos.\nTaigi terminalas yra CLI programa, kuri leidžia pasiekti Shell sąsają. Jį galima įsivaizduoti kaip langą kompiuteryje, per kurį įvedi komandas ir matai jų rezultatus. Terminalo programos naudojamos įvairiose operacinėse sistemose, nes jos leidžia efektyviau valdyti sistemą nei daugelis grafinių vartotojo sąsajų. Naudodajantis terminalu, gali atlikti įvairias užduotis greičiau ir tiksliau.\nAtidaryk terminalo programą ir įrašyk šią komandą. Ji parodys, kur yra Shell ir koks būtent Shell tipas naudojamas.\nAtsakymas (output) parodo vykdomojo Shell failo vietą – Shell programą, kuri šiuo metu naudojama tavo terminale. Iš output taip pat gali matyti, koks tai Shell tipas. Šiuo atveju, tai Bash.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#shell-ir-terminalas",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#shell-ir-terminalas",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "",
    "text": "The IBM 2741 Terminal IBM\n\n\n\n\n\n\n22.0 IBM Modell 360 / 370 IBM\n\n\n\n\n\n\n\nwhich $SHELL",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#iš-ko-susideda-cli-komanda",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#iš-ko-susideda-cli-komanda",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.2 Iš ko susideda CLI komanda?",
    "text": "5.2 Iš ko susideda CLI komanda?\nAtsidaryk terminalo programą. Štai ką turėtum pamatyti:\n\n\n\nTerminal su matomu prompt\n\n\n\nPrompt\n\nTerminale iškart matai prompt – tai teksto eilutė, kuri nurodo, kad sistema yra pasirengusi priimti komandą. Ši eilutė dažniausiai rodo informaciją apie dabartinę direktoriją, vartotojo vardą ar kitus naudingus duomenis. Pavyzdžiui:\njustas@linux-pc:~$\nČia rodoma: vartotojo vardas @ kompiuterio pavadinimas. Simbolis ~ nurodo aktyvią darbinę direktoriją (namų direktoriją), o $ reiškia, kad sistema laukia įvesties (todėl ir vadinama prompt – iššaukimas). Kas yra darbinė direktorija, sužinosime vėliau.\nŠtai pavyzdys, kai Shell yra užsiėmęs ir nėra pasirengęs priimti tavo komandos:\n\n\n\nTerminal vykdo užduotį\n\n\n\nŽymeklis (Cursor)\n\nMirksintis žymeklis (cursor) rodo, kad terminalas pasirengęs priimti kitą įvestį ir nurodo, kurioje vietoje eilutėje bus įrašas.\n\nKomanda (command)\n\nKomanda (angl. command) yra specifinis nurodymas, kurį vartotojas įveda, kad būtų atliktas tam tikras veiksmas sistemoje. Komandos gali būti naudojamos įvairiems veiksmams atlikti, pvz., failų kopijavimui, direktorijų kūrimui ar informacijos rodymui. Pavyzdžiui, komanda ls rodo dabartinės direktorijos failus ir subdirektorijas:\nls\nKai kurios komandos turi subkomandas. Pavyzdžiui, apt yra komanda, atsakinga už programinės įrangos (angl. software) valdymą, tačiau ji naudojama su subkomandomis:\n\napt update:: Atnaujina prieinamų programų sąrašą.\napt install: Instaliuoja nurodytą paketą.\napt remove: Pašalina nurodytą paketą.\napt upgrade: Atnaujina visus diegtus paketus į naujausias versijas\n\nKad bet kas negalėtų instaliuoti programų, ši komanda turi būti vykdoma su administratoriaus teisėmis, pasitelkiant komandą sudo. Todėl kartais naudojamos kelios komandos iš eilės:\nsudo apt update\nsudo apt install cowsay\n\nPasirinkimai ir argumentai (Option, Argument)\n\nPasirinkimas (angl. option) ir argumentas (angl. argument) yra papildomi parametrai, kurie gali būti pridėti prie komandos, siekiant tiksliau nurodyti, kaip komanda turėtų būti vykdoma.\nPasirinkimas (option): Pasirinkimas modifikuoja komandos elgesį. Jis dažnai pridedamas prie komandos su brūkšneliu (-) arba dvigubu brūkšneliu (--). Pavyzdžiui, naudojant ls -l, -l yra pasirinkimas, kuris rodo failų sąrašą ilgąja forma. Naudojant sutrumpintus pasirinkimus, naudojamas vienas brūkšnys -, o išrašant pilną pavadinimą – dvigubas brūkšnys --.\nArgumentas (argument): Argumentas yra papildoma informacija, kurią komanda naudoja veikimui. Pvz., ls Documents nurodo, kad komanda ls turėtų parodyti direktorijos Documents turinį. Šiuo atveju Documents yra argumentas.\n\n\n5.2.1 Praktika\n\nIdentifikuok užklausą (prompt), komandą (command), pasirinkimą (option) ir argumentą (argumentą). Nepanikuok, jei nepažįsti pačių komandų.\n\nmain-user@linux-mint:~$ sudo apt install -y cowsay\nmain-user@linux-mint:~$ cd Downloads\nmain-user@linux-mint:~$ rm -rf test/\nmain-user@linux-mint:~$ ls -alh /home/user/Downloads\nmain-user@linux-mint:~$ mkdir -p /project/data\n\nSurask būdą, kaip sukurti skirtukus (tabs) terminalo lange. Kartais yra labai patogu turėti kelis skirtingus terminalo skirtukus. Pavyzdžiui, viename galite stebėti kompiuterio temperatūrą, kitame valdyti ir paleisti programas, o trečiame - stebėti, ar sistema nefiksuoja kokių nors klaidų. Bet kaip atidaryti skirtukus? Koks yra klaviatūros trumpinys? Jei norėtumėte paleisti ne skirtuką, o atskirą langą, koks trumpinys tai padarytų?\n\n\n\nSusirask terminalo grafinius nustatymus ir pakeisk foną, teksto spalvą ir kitus stiliaus elementus. Rask tau patinkantį stilių. Nebijok eksperimentuoti!\n\n\n\nNors dažniausiai žymeklis yra blyksintis kvadratėlis, surask, kaip jį pakeisti į |?",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#linux-failų-sistema",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#linux-failų-sistema",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.3 Linux failų sistema",
    "text": "5.3 Linux failų sistema\nTerminai “direktorija”, “katalogas” ir “aplankas” dažnai vartojami kaip sinonimai ir paprastai reiškia tą patį – vietą failų sistemoje, kur gali būti saugomi failai ir kiti subkatalogai. Tačiau yra keletas kultūrinių ir kontekstinių niuansų:\n\nDirektorija (angl. directory): Techninis terminas, dažniausiai vartojamas Unix/Linux bendruomenėje ir kitose techninėse aplinkose. Jis pabrėžia hierarchinę failų sistemos struktūrą.\nKatalogas: Tai dar vienas techninis terminas, dažnai vartojamas kaip sinonimas direktorijai. Šis terminas paplitęs tiek techninėje, tiek kasdieninėje kalboje.\nAplankas (angl. folder): Terminas, dažniausiai naudojamas grafinėse vartotojo sąsajose (GUI), pavyzdžiui, Windows ir Mac OS. Nors jis iš esmės reiškia tą patį kaip direktorija ar katalogas, jis dažniau vartojamas GUI kontekste.\n\nČia aš naudosiu terminą „direktorija“, nes jis yra artimiausias angliškam „directory“. Tačiau kartais galiu panaudoti ir „aplanką“ ar „katalogą“, tad nenustebk.\n\n5.3.1 sudo\nPraeitame skyriuje aptarėme, kad tam tikroms komandoms vykdyti reikia naudoti sudo, t.y., eskaluoti (pakelti) savo vartotojo privilegijas iki administratoriaus (root) lygio. Tam reikia įvesti slaptažodį. Taip užtikrinamas saugumas, kad bet kas negalėtų vykdyti pavojingų veiksmų sistemoje.\nPaprastas vartotojas (user) ir administratorius (root) Linux sistemoje turi skirtingas teises ir privilegijas:\nuser:\n\nTeisės: Turi ribotas teises, gali atlikti veiksmus tik savo namų direkorijoje (home directory) ir kitose direktorijose, kuriose turi suteiktas teises.\nPriėjimas: Negali atlikti sisteminės administracijos užduočių, pvz., negali įdiegti ar pašalinti programinės įrangos, keisti sisteminių failų ar atlikti daugumos konfigūracijos pakeitimų.\n\nroot\n\nTeisės: Turi pilną administracinę prieigą prie visos sistemos. Gali atlikti bet kokias užduotis, įskaitant sisteminių failų modifikavimą, vartotojų administravimą, programinės įrangos diegimą ir pašalinimą.\nPriėjimas: Gali atlikti bet kokias operacijas be apribojimų.\n\nPaprastas vartotojas, vykdydamas sudo, gali laikinai gauti root teises, pvz.:\nsudo apt install &lt;programa&gt;\nPerėjimas iš paprasto vartotojo į root yra galimas tik tiems vartotojams, kurie yra įtraukti į sudo grupę. Instaliuojant Linux, pirmasis vartotojas automatiškai pridedamas prie šios grupės, tačiau vėliau sukurti vartotojai gali būti pridėti į sudo grupę pagal poreikį.\n\n\n5.3.2 root direktorija\nWindows operacinėje sistemoje turbūt matei diskus, pažymėtus raidėmis, pavyzdžiui, C:, D:, E:. Tai nereiškia, kad kompiuteryje yra keli fiziniai kietieji diskai. Dažniausiai tai yra vienas kietasis diskas, padalytas į logines dalis.\n\n\n\nŠaltinis OnlineComputerTips\n\n\nPavyzdžiui, C: diske paprastai saugomi Windows failai, o vartotojai dažnai naudoja kitą diską failams saugoti. Šie „diskai“ yra visiškai atskirti vienas nuo kito.\nLinux sistemoje viskas veikia šiek tiek kitaip. Net jei kompiuteryje būtų keli fiziniai diskai, jie gali būti sujungti į vieną loginę talpą (angl. logical volume) ir „pakišti“ po root direktorija, kuri žymima /.\nRoot direktorija yra failų sistemos viršūnė, žymima /. Visi kiti failai ir direktorijos yra šios šakninės direktorijos pavaldiniai. Tai atitinka Windows C: diską.\n\n\n\nŠaltinis\n\n\nČia rasi daug subdirektorijų. Svarbiausios iš jų:\n\n/root: Root vartotojo (administratoriaus) namų direktorija.\n/etc: Konfigūracijos failai, kurie kontroliuoja įvairių programų paleidimą ir veikimą.\n/home: Paprastų vartotojų namų direktorijos, pvz., /home/justas/, /home/ruprecht/.\n/mnt: Laikina vieta prijungtoms laikmenoms, tokioms kaip kietieji diskai ar tinklo diskai.\n/media: Katalogas, kuriame pritvirtinami USB, CD ar DVD įrenginiai.\n/bin: Sisteminiai vykdomieji failai, pvz., ls, cp, mv.\n/lib: Bibliotekos, būtinos sisteminėms programoms ir komandų vykdymui.\n\nKai atidarai failų naršyklę (Linux Mint tai programa Nemo), tavo namų direktorija bus po /home/vartotojas/. Štai kaip atrodytų naršy\n/\n└── home\n    ├── user name\n\nVisada gali pasitikrinti savo buvimo vietą, paspaudžiant ant „Toggle Location Entry“:\n\n\n\n5.3.3 Praktika\n\nAtsidaryk excalidraw naršyklėje ir nupiešk /, /home/, /media/ struktūros diagramą. Įsivaizduok, kad kompiuteryje yra trys vartotojai: justas, ruprechtas ir slibinas. Nupiešk jų namų direktorijas.\nĮkišk USB laikmeną į kompiuterį, atidaryk failų naršyklę (Nemo). Turėtum pamatyti kažką panašaus. Paspausk ant USB laikmenos, tada spustelėk „Toggle Location Entry“ ir identifikuok, kurioje failų sistemos vietoje yra USB laikmena. Pridėk tai prie diagramos, kurią piešei.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#keliavimas-failų-sistema",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#keliavimas-failų-sistema",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.4 Keliavimas failų sistema",
    "text": "5.4 Keliavimas failų sistema\nJau šiek tiek susipažinai su Linux failų sistemos struktūra. Kai atsidarai failų naršyklę (Nemo), matai šias direktorijas:\n\nDirektorijų medyje tai atrodytų taip:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\nŠiame skyriuje išmoksi, kaip sužinoti, kur esi, su komanda pwd, kaip pakeisti direktoriją su cd ir kaip atspausdinti failų bei direktorijų sąrašą su ls.\nTačiau prieš einant prie pačių komandų, tau dar reikis susipažinti su vienu svarbiu konceptu - absoliučiu ir relatyviu adresu (arba keliu, nes angliškai - path).\n\n5.4.1 Absoliutus kelias\nAbsoliutus kelias (angl. absolute path) yra pilnas kelias nuo šaknies direktorijos (/) iki konkretaus failo ar katalogo. Jis visada nurodo tą pačią vietą, nepriklausomai nuo to, kur esi šiuo metu.\nPavyzdžiui, šis kelias nurodo visą maršrutą nuo / per /home/, vartotojo namų direktoriją /justas/iki subdirektorijos Documents, kurioje yra failas data.csv:\n/home/justas/Documents/data.csv\n\n\n5.4.2 Relatyvus kelias\nRelatyvus kelias (angl. relative path) yra nurodomas atsižvelgiant į dabartinę darbinę direktoriją. Jis neturi pradinio /, todėl priklauso nuo to, kur esi.\nJeigu šiuo metu esi direktorijoje/home/justas, relatyvus kelias į failą data.csv subdirektorijoje Documents būtų:\nDocuments/data.csv\nKartais gali pamatyti relatyvų kelią su . (tašku), kuris reiškia “esama direktorija”. Taigi šis relatyvus kelias irgi tinka:\n./Documents/data.csv\n\n\n5.4.3 ~\nVartotojų vardai Linux sistemoje gali skirtis, pvz., justas, ruprechtas ir t.t. Tarkime, rašai skriptą, kuris turi veikti vartotojo Downloads direktorijoje. Tu negali žinoti vartotojo vardo, todėl naudoti absoliutų kelią /home/justas/Downloads būtų nepatogu.\nBet ir relatyvus kelias ./Downloads gali sukelti problemų, nes skriptas gali būti paleistas ne iš vartotojo namų direktorijos, o tiesiai iš Downloads direktorijos, kas sukurtų absurdišką Downloads/Downloads.\n/\n└── home\n    ├── justas\n    │   ├── Downloads\n    │     ├── ./Downloads\nŠtai čia gelbsti ~. Shell atpažįsta ~ kaip nuorodą į dabartinio vartotojo namų direktoriją.\nTaigi relatyvus kelias~/Downloads yra automatiškai keičiamas į /home/justas/Downloads, jeigu vartotojas yra justas, arba į /home/ruprecht/Downloads, jeigu vartotojo vardas yra ruprecht.\nKada naudoti ką?\n\nAbsoliutūs keliai dažniausiai naudojami skriptuose, konfigūracijų failuose, dokumentacijoje ir sisteminiuose veiksmuose.\nRelatyvūs keliai labiau tinka kasdieniam darbui su failais, naršymui ir interaktyviam scenarijų vykdymui.\n\n\n\n5.4.4 pwd\nJau kelis kartus minėjome darbinę direktoriją. Kas tai? Darbinė direktorija yra ta direktorija, kurioje šiuo metu “gyvena” shell. Įsijunk terminalą, įrašyk komandą pwd ir paspausk Enter, kad ją įvykdytum. Komanda pwd (angl. “print working directory”) parodo dabartinės darbinės direktorijos pilną kelią (path).\npwd\n\nŠiuo atveju darbinė direktorija yra /home/justas.\nTaigi, iš mano darbinės direktorijos, Downloads subdirektorijoje esantis failas data.csv man būtų pasiekiamas Downloads/data.csv keliu. Tačiau aš galiu pakeisti savo darbinę direktoriją pereidamas į kitas direktorijas su komanda cd.\n\n\n5.4.5 cd\nKomanda cd (angl. change directory) naudojama pereiti iš vienos direktorijos į kitą. Kai pereini į kitą direktoriją, pasikeičia ir darbinė direktorija, kartais dar vadinama aktyvia direktorija (angl. current directory).\nĮvedęs komandą:\ncd Downloads\nAš pereinu į Downloads subdirektoriją. Kadangi Downloads yra mano namų direktorijoje, galėjau pasinaudoti relatyviu keliu. Atkreipk dėmesį, kaip pasikeičia terminalo prompt: vietoj ~ (jau žinai, ką jis reiškia), dabar matosi ~/Downloads.\n\nDabar failas Downloads/data.csv tampa pasiekiamas tiesiog kaip data.csv.\nKomandai cd gali duoti absoliutų kelią, ir tada cd pakeis darbinę direktoriją, nesvarbu, kur tuo metu esi:\ncd /home/justas/Documents\nŠi komanda perkelia mane iš Downloads tiesiai į Documents.\n\nTačiau cd komandai gali nurodyti ir relatyvų kelią, svarbu, kad jis egzistuotų. Pavyzdžiui, aš galiu pereiti iš savo namų direktorijos į Downloads su cd Downloads/, tačiau negaliu pereiti į Documents, jei esu Downloads direktorijoje, nes Documents ten nėra. Tada gaunu klaidos pranešimą: bash: cd: Documents/: No such file or directory.\n\nPriminimui:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\nKaip jau minėjau, taškas . reiškia “čia”. Pvz., iš namų direktorijos galėčiau pereiti į Downloads su cd ./Downloads.\nYra ir .., du taškai, kurie reiškia direktoriją esančią aukščiau už dabartinę (.) direktoriją. Ji dažnai vadinama parent directory. Taigi, su komanda cd ./Downloads nuėjęs į Downloads, galiu vėl pakilti į viršų su cd ...\n\n.. taip pat gali būti naudojama pereiti relatyviai, pvz., iš Downloads į Documents. Būdamas Downloads direktorijoje, galiu naudoti komandą cd ../Documents, kad pakilčiau vienu lygiu aukščiau ir tada pereičiau į Documents.\n\n.. gali būti naudojama ir kelis kartus iš eilės, pvz., iš Downloads galima pakilti į home, naudojant cd ../...\n\nPriminimui\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\nKomandą cd gali naudoti ir be jokių argumentų, kad grįžtum į namų direktoriją, pvz., cd arba su cd ~.\n\nPereiti į ankstesnę direktoriją gali su komanda cd -. Tarkime, buvau home/justas/Downloads, perėjau į home/justas/Documents, bet supratau, kad padariau klaidą - norėčiau likti Downloads. Galiu grįžti atgal su cd -.\n\nSveikinu! Dabar jau moki naršyti po direktorijas naudojant terminalą. Nors tai gali atrodyti sudėtinga iš pradžių, laikui bėgant pastebėsi, kad paleisti terminalą su klaviatūros trumpiniu Ctrl-Alt-T ir, naudojant TAB greitesniam komandų ir argumentų užpildymui, greitai nueiti į norimą direktoriją bei redaguoti failus bus daug greičiau nei tai daryti su grafinės sąsajos (GUI) įrankiais.\nPvz., iš savo namų direktorijos pereinu į Documents, tada į project, tada į documentation, atspausdinu failų sąrašą su ls ir redaguoju failą su nano programa.\nVideo\nBet kas ta ls komanda?\n\n\n5.4.6 ls\nKomanda ls (angl. list storage) naudojama norint peržiūrėti failų ir katalogų sąrašą dabartinėje arba nurodytoje direktorijoje. Tai viena dažniausiai naudojamų komandų, naviguojant failų sistemoje.\nJei atidarytum failų naršyklę, pavyzdžiui, Nemo, matytum kažką panašaus:\n\nLygiai taip pat failų sąrašą gali parodyti ir terminale, įvedant komandą ls:\n\nKomanda ls gali priimti argumentą – direktorijos kelią, kurio turinį norima parodyti. Šis kelias gali būti tiek absoliutus, tiek relatyvus. Pavyzdžiui, ls /home/justas/Downloads parodys Downloads katalogo turinį. Atkreipk dėmesį į spalvas: failai yra balti, o katalogai – mėlyni.\n\nKartais pamatyti tik failų pavadinimus gali būti nepakankama. Galbūt norisi matyti daugiau informacijos, pvz., kada failai sukurti, kas turi teises juos valdyti ar matyti, ar kam jie priklauso.\n\nKaip ir failų naršyklėje, kur gali perjungti į “List View”, terminale gali naudoti komandos ls nustatymą -l, kuris išveda išsamų (ilgą) failų sąrašą su papildoma informacija: teisėmis, savininku, dydžiu ir paskutinio modifikavimo data.\n\nPavyzdžiui ką tokią eilutė reikšia, paaikšinsiu netrukus.\ndrwxr-xr-x 2 justas justas 4096 Sep 15 10:19 Desktop\nNorint pamatyti visus failus, įskaitant paslėptus (failai, kurių pavadinimai prasideda tašku), gali naudoti -a arba --all:\n\nNemo failų naršyklėje taip pat gali pamatyti paslėptus failus, jei aktyvuosi šią funkciją.\nVideo\nKai paleidi ls -l, failų dydžiai nurodomi baitais. Kartais naudingiau matyti dydžius, išreikštus žmonėms suprantamesniais vienetais, kaip kilobaitai (1000 baitų), megabaitai (1000 kilobaitų) ir t.t. Tam gali naudoti nustatymą --human-readable arba trumpinį -h - ls -lh\nŠios abi komandos ls -all -l --human-readable ir ls -alh yra teisingos, tačiau dažniau naudojamas trumpesnis variantas. Panaudojant ls -alh, galėsi matyti paslėptus failus, o failų dydžiai bus išreikšti žmonėms labiau suprantama forma.\n\nKartais gali prireikti rekursyvaus katalogo turinio peržiūros. Komanda ls -R arba ls --recursive parodys ne tik pasirinktos direktorijos, bet ir visų jos subdirektorijų turinį.\n\n\n\n5.4.7 Teisės ir tipai\nŠi eilutė rodo failų arba direktorijų sąrašą su jų detalėmis:\n\nPirmas stulpelis parodo, kokio tipo failas ar direktorija tai yra, ir kokias teises turi skirtingi vartotojai.\nPirmoji raidė gali būti:\n\nd – Direktorija (directory)\nl – Simbolinė nuoroda (link)\n- – Įprastas failas (regular file)\n\nLinux sistemoje yra trys vartotojų tipai:\n\nSavininkas – vartotojas, kuris sukūrė failą arba direktoriją. Šiuo atveju vartotojas yra justas.\nGrupė – Grupė, kuriai priklauso failo savininkas. Dažnai grupės vardas yra tas pats kaip ir savininko vartotojo vardas, pvz., justas. Vartotojai gali priklausyti kelioms grupėms, tačiau kiekvienas failas ir direktorija turi pagrindinę grupę, kuri turi tam tikras teises į tą failą arba direktoriją. Pameni minėjom, kad ne visi vartotojai priklauso sudo grupei? Čia panašiai, tik kita grupė.\nKiti (other) – Visi kiti vartotojai, kurie nėra nei savininkas, nei grupės nariai. Tai apima visus kitus sistemos vartotojus, kurie neturi specialių teisių šiam failui ar direktorijai.\n\nTeisės nurodomos pirmame stulpelyje trimis tripletais: xxx-xxx-xxx (be brūkšnių).\n\nr – Skaitymo teisė (read), leidžia matyti ir skaityti turinį.\nw – Rašymo teisė (write), leidžia perrašyti turinį.\nx – Vykdymo teisė (execute), leidžia vykdyti failą.\n\nPvz., teisės drwxr-xr-x:\n\nd – Direktorija (directory)\nrwx – Savininko teisės: skaitymas (read), rašymas (write), vykdymas (execute)\nr-x – Grupės teisės: skaitymas (read), vykdymas (execute)\nr-x – Kitų vartotojų teisės: skaitymas (read), vykdymas (execute)\n2 – Nuorodų skaičius į šią direktoriją. Tai apima nuorodą į pačią direktoriją ir bet kurias subdirektorijas. Pavyzdžiui, jei skaičius būtų 4, tai reikštų, kad direktorijoje yra trys subdirektorijos (ir arba failai) ir viena pati direktorija.\njustas – Direktorijos savininko vartotojo vardas.\njustas – Direktorijos grupės vardas.\n4096 – Direktorijos dydis baitais.\nSep 15 10:19 – Paskutinio direktorijos modifikavimo data ir laikas.\nDesktop – Direktorijos pavadinimas.\n\n\n\n5.4.8 Pagalbinės funkcijos terminale\n\n\n5.4.9 history\nKomanda history (liet. „istorija“) naudojama norint parodyti visų anksčiau įvestų komandų sąrašą dabartinėje terminalo sesijoje. Tai suteikia patogų būdą sekti ir kartoti anksčiau vykdytas komandas.\n\nJei nori parodyti tik paskutines n komandų, gali naudoti history n. Pvz., parodyti paskutines 10 komandų history 10:\n\nKartoti konkrečią komandą pagal numerį galima įrašius ! ir komandos numerį. Pavyzdžiui, jei nori pakartoti komandą, kurios numeris yra 99:\nhistory\n!99\n\nIštrinti komandų istoriją galima su history -c.\nhistory -c\nhisotry\n\n\n\n5.4.10 clear\nKomanda clear (liet. „valyti“) naudojama norint išvalyti terminalo ekraną, pašalinant visus anksčiau įvestus ir parodytus tekstinius duomenis. Tai palieka terminalą švarų ir patogesnį tolimesniam naudojimui. Svarbu: ši komanda neištrina terminalo istorijos (history); ji tik paslenka visą tekstą į viršų, už dabartinio vaizdo ribų.\nclear\n\n\n5.4.11 Ctrl-L\nAlternatyva komandos clear naudojimui yra klaviatūros trumpinys Ctrl-L. Šis trumpinys atlieka tą pačią funkciją kaip ir komanda clear, tačiau jis yra greitesnis ir patogesnis, ypač kai dirbi terminale ir nori greitai išvalyti ekraną. Naudojant Ctrl-L, terminalo ekranas bus išvalytas, tačiau terminalo istorija liks nepakitusi.\n\n\n5.4.12 Navigacija terminale\nRašant ilgas komandas, klaidos neišvengiamos. Pavyzdžiui, rašai „Hello World“ ir paspaudi Enter ⏎, tik tada supranti, kad reikėjo parašyti echo prieš „Hello World“.\nŠtai kaip tai gali ištaisyti:\n\nPakilk į ankstesnę eilutę naudodamas rodyklę į viršų ⬆️.\nPerkelk kursorių į eilutės pradžią naudodamas rodyklę į kairę ⬅️.\nPrirašyk echo ir pakartok komandą paspaudus Enter ⏎.\n\nVideo\nKartais eilutės būna gana ilgos:\nsud apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update\nJei praleidai raidę, pavyzdžiui, pirmame sudo truksta o, nereikia viską iš naujo rašyti\n\nPakilk į ankstesnę eilutę naudodamas rodyklę į viršų ⬆️.\nNaudokCtrl-A, kad perkeltum kursorių į eilutės pradžią.\n➡️ ➡️ ➡️ ir pridėti o raidę.\npabaigus taisymą tiesiog paspausti Enter ⏎ (nebūtina nueiti į eilutės pabaigą)\n\nVideo\nTavo žiniai:\n\nCtrl-A: perkelia kursorių į eilutės pradžią\nCtrl-E: perkelia kursorių į eilutės pabaigą\nCtrl-U: ištrina viską į dešinę nuo kursoriaus\n\nUžduotis:\nPastebėsi, kad Ctrl-C ir Ctrl-V neveikia taip, kaip esame įpratę. Terminalo nustatymuose (settings) rask derinį, kuris atitinka įprastines Ctrl-C ir Ctrl-V kombinacijas.Kokie jie?\n\n\n5.4.13 Ctrl-C ir Escape\nNaudojant komandinę eilutę, kartais terminalas gali „pakibti“. Pvz., jei pradėsi rašyti echo su kabutėmis, bet pamirši uždaryti kabutes, terminalas lauks, kol užbaigsi komandą.\nTokiais atvejais terminalas gali atrodyti „pakibęs“. Pabandyk paleisti šias komandas po vieną:\n$ echo \"hello\n$ grep foobar\n$ yes\n$ tail\n$ cat\nNorėdamas nutraukti „pakibusią“ komandą, naudok Ctrl-C. Šis derinys siunčia kontrolės signalą terminalui ir nutraukia vykdomą procesą. Pastaba: Ctrl-C čia reiškia „Cancel“ (nutraukti).\nKartais terminale gali pamatyti ^C, rodančią, kad buvo paspaustas Ctrl-C. Jei Ctrl-C neveikia, pabandyk ESC klavišą.\nVerta žinoti: kad kartais vietoj Ctrl- notacijos, gali sutikti ^ notaciją, pvz., ^C, ^O, ^X.\n\n\n5.4.14 Praktika\n\nKai paleidi terminalą, kurioje direktorijoje esi? Pakeisk direktoriją į Downloads. Uždaryk terminalą ir paleisk jį iš naujo. Kur dabar esi?\nIš/home/user/ direktorijos pereik į Downloads ir atspausdink direktorijos turinį naudojant ls. Užduotis:\n\nFailų dydis būtų suprantamas žmonėms.\nSąrašas būtų pateikiamas viename stulpelyje.\n\nIš /home/user/ direktorijos pereik į Documents. Iš ten atspausdink failų sąrašą Downloads (!!!) direktorijoje\n\nnaudojant absoliutų kelią\nnaudojant relatyvų kelią\n\n\nPagalbai:\nHome Directory/\n├── Desktop/\n├── Documents/\n├── Downloads/\n├── Music/\n├── Pictures/\n├── Public/\n├── Templates/\n└── Videos/\n\nNaudok clear, kad išvalytum terminalą, tada su history surask tau patinkančią komandą ir pakartok ją naudojant !n.\nVizualizuok vartotojų ir grupių santykius pagal šią lentelę. Naudok Excalidraw:\n\n\n\n\nVartotojas\nSudo grupė\nGrupė “namai”\n\n\n\n\nroot\nTaip\nTaip\n\n\njustas\nTaip\nTaip\n\n\nruprechtas\nNe\nTaip\n\n\n\n\nĮsivaizduok, kad failas /home/ruprechtas/info.txt turi tokias savybes:\n\n-rwx----- 2 ruprechtas namai 4096 Sep 15 10:19 info.txt\nAr vartotojas justas, priklausantis grupei namai, galės atidaryti ir perrašyti šį failą? Kodėl?\n\nKą reikėtų pakeisti, kad vartotojas justas galėtų matyti ir perrašyti šį failą? Atsakyk teoriškai (nes dar nežinai komandų, kuriomis tai apdaryti).\nNukopijuok ir paleisk šią komandą terminale.\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/e61bb3ab5cf28686f74a50e436b06fe6/raw | bash\nŠi komanda parsisiųs ir įvykdys skriptą, kuris sukurs test direktoriją tavo/home/username/ direktorijoje.\nPasinaudok ls, atspausdink visus failus, esančius (sub-)direktorijose ir atsakyk į šiuos klausimus:\n\nKiek yra subdirektorijų test direktorijoje?\nKiek iš viso suskaičiuoji failų? Suskaičiuok visus failus, esančius visose subdirektorijose.\nKokio tipo failų (pvz., .txt, .csv) yra daugiausia? Kurioje direktorijoje?",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#funkcijos",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#funkcijos",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.5 Funkcijos",
    "text": "5.5 Funkcijos\nVisos skyriuje panaudotos funkcijos\n\n\n\n\n\n\n\nFunkcija\nAprašymas\n\n\n\n\nwhich\nParodo vykdomojo failo vietą\n\n\npwd\nParodo dabartinės darbinės direktorijos pilną kelią\n\n\ncd\nPakeičia dabartinę direktoriją (esamą vietą) terminale\n\n\nls\nRodo failų ir katalogų sąrašą direktorijoje\n\n\nsudo\nLeidžia vykdyti komandas su kitokio vartotojo teisėmis (dažniausiai root)\n\n\nhistory\nRodo ankstesnių komandų istoriją\n\n\nclear\nIšvalo terminalo ekraną\n\n\nCtrl-A\nPerkelia kursorių į eilutės pradžią\n\n\nCtrl-E\nPerkelia kursorių į eilutės pabaigą\n\n\nCtrl-U\nIštrina viską į kairę nuo kursoriaus\n\n\nCtrl-C\nNutraukia vykdomą komandą terminale\n\n\nCtrl-L\nIšvalo terminalo ekraną (panašu į clear)\n\n\nShift-Ctrl-C\nKopijuoja tekstą iš terminalo\n\n\nShift-Ctrl-V\nĮkelia tekstą į terminalą\n\n\nShift-Ctrl-T\nSukuria naują terminalo skirtuką\n\n\nShift-Ctrl-N\nSukuria naują terminalo langą",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/6_bash_comands_basic.html",
    "href": "b_bash_pagrindai/6_bash_comands_basic.html",
    "title": "6  BASH komandos",
    "section": "",
    "text": "6.1 Failų ir direktorijų valdymas\nPraėjusiame skyriuje išmokai naviguoti terminale naudojant komandas pwd ir cd. Sužinojai apie Linux failų sistemą: kaip matyti visų failų ir katalogų sąrašą naudojant ls komandą, bei tai, kad Linux sistemoje vartotojai turi skirtingas teises, priklauso grupėms, ir kiekvienas failas turi savininko, grupės, bei kitų vartotojų teises naudotis tuo failu ar katalogu. Taip pat išmokai svarbių klaviatūros trumpinių, kaip peršokti į komandinės eilutės pradžią (Ctrl-A), pabaigą (Ctrl-E), nutrinti dalį (Ctrl-U), kaip kopijuoti ir įklijuoti į terminalą naudojant Ctrl-Shift-C ir Ctrl-Shift-V. Išmokai dirbti su terminalo istorija naudojant history ir kartoti komandas su !n.\nŠiame skyriuje skirsi dėmesį darbui su failais ir direktorijomis. Tu išmoksi kurti failus ir direktorijas, juos kopijuoti, perkelti, ištrinti. Taip pat išmoksi sujungti kelias komandas. Ir šio skyriaus pabaigoje pamatysi, kad tavo BASH įgūdžiai tampa dar stipresni!\nPrieš pradedant, įsitikink, kad turi keletą svarbių programų: jq ir curl. Kaip ir praėjusiame skyriuje, kai ieškojaiwhich $SHELL, komanda tau parodė, kur yra binary failas (programa). Dabar padaryk tą patį:\nJei tavo kompiuteris aptinka šias programas, terminalas atspausdins vietą, kur jos yra įdiegtos. Jei terminalas jų neranda, įdiek curl ir jq kaip sisteminius paketus naudojant apt. Jei pamiršai, kaip tai daryti, pakartok ankstesnę medžiagą.\nKai tai atliksi, nukopijuok ir paleisk šią komandą savo terminale - ji sukurs direktoriją shell_2_dalis tavo namų direktorijoje kartu su visais šiam skyriui reikalingais failais:\nJeigu viskas gerai, turėtum pamatyti:\nSu ls komanda atspausdink long formatu savo home directory turinį. Paaiškink visas šios eilutės reikšmes.\nPakeisk savo darbinę direktoriją į ~/shell_2_dalis. Kaip pasikeitė tavo prompt? Paaiškink, kas čia yra kas.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/6_bash_comands_basic.html#failų-ir-direktorijų-valdymas",
    "href": "b_bash_pagrindai/6_bash_comands_basic.html#failų-ir-direktorijų-valdymas",
    "title": "6  BASH komandos",
    "section": "",
    "text": "By J. Howard Miller - U.S. National Archives and Records Administration\n\n\n\n\nPatikrink, ar turi curl, su which curl.\nPatikrink, ar turi jq, su which jq.\n\n\n\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/b4bfc0d672a859afc0fe28f1e721e167/raw | bash\n\n\n\n\n\n\n\n\nTip\n\n\n\nPasikartok komandas cd, prisimink absoliutų ir reliatyvų kelią, bei ką reiškia ~, . ir ... Šiame skyriuje taip pat dažnai reikės naudoti ls, tad pasikartok šią komandą ir jos nustatymus dabar.\n\n\n\n\n\n\n\n6.1.1 echo\nKomanda echo naudojama norint atspausdinti vartotojo įvestį (input) terminale (dar vadinamą standartine išvestimi, angl. standard output). Tai paprasta, bet galinga komanda, dažnai naudojama skriptuose pranešimams rodyti arba kintamųjų reikšmėms tikrinti.\nNors nėra būtina tekstą apskliausti kabutėmis, dėl geresnio aiškumo ir įskaitomumo patartina tai daryti.\necho Hello World!\necho 'Hello World!'\necho \"Hello World!\"\nReikėtų atkreipti dėmesį, jog dvigubos kabutės (\" \") ir viengubos kabutės (' '’) šiek tiek skiriasi. Tekstas, esantis viengubose kabutėse (' '), atspausdinamas paraidžiui, nepaisant ten esančių kintamųjų. Tuo tarpu tekstas, esantis dvigubose kabutėse (\" \"), yra interpretuojamas, ir Shell leidžia naudoti kintamųjų vertes.\nPabandyk šias komandas, kurios naudoja kintamąjį $USER, atspausdinantį shell sesijos vartotojo vardą:\necho My username is $USER\necho 'My username is $USER'\necho \"My username is $USER\"\nAr pastebi, kuo skiriasi išvestis?\n\n\n\n6.1.2 &gt; ir &gt;&gt; operatoriai\n&gt; ir &gt;&gt; operatoriai naudojami išvesties nukreipimui (angl. output redirection). Jie nukreipia komandos išvestį (angl. output) į failą, o ne į terminalą. Šie operatoriai yra esminiai dirbant su failais ir automatizuojant užduotis skriptuose.\n&gt; operatorius nukreipia komandos išvestį į failą, perrašydamas jo turinį, jei failas jau egzistuoja. Jei failas neegzistuoja, jis bus sukurtas.\nŠi komanda sukuria (arba perrašo) failą hello_world.txt su tekstu “Hello World!”.\necho \"Hello World!\" &gt; hello_world.txt\nKaip echo komanda ir jos argumentas “Hello World!” buvo nukreipti į tekstinį failą, taip galime nukreipti ir kitų komandų išvestis į failus. Operatoriaus &gt; argumentas nebūtinai turi būti tik failo pavadinimas, tai gali būti ir failo pavadinimas su absoliučiu ar reliatyviu adresu.\nls &gt; mix/direktorijos_turinys.txt\nŠi komanda nukreipia ls komandos išvestį į failą direktorijos_turinys.txt, kuris yra mix subdirektorijoje. Atsidaryk šį failą ir patikrink, ar jis susikūrė teisingai. Turėtum matyti kažką panašaus į šį vaizdą:\n\n\n\n\n\n\n\nPraktika\n\n\n\nLiekant shell_part_2 direktorijoje, atspausdink namų direktorijos (angl. home directory) turinį su visais paslėptais failais, ilguoju formatu ir žmonėms geriau suprantamais failų ir direktorijų dydžiais, ir nukreipk išvestį į mix subdirektorijoje esantį failą direktorijos_turinys.txt, jį perrašant.\n\n\n\nIntarpas\nHey, ką tik gavai užduotį. Ateityje gausi panašias ir dar sudėtingesnes užduotis. Todėl šioje vietoje padarykime intarpą. Pakalbėkime apie vieną svarbiausių darbo būdų programavime (ir ne tik!) – darbų skaidymą (angl. break down).\nKartais gali gauti labai sudėtingą užduotį, kuri iš pradžių atrodys neįveikiama ar nesuprantama. Tai visiškai normalu. Nestresuok – giliai įkvėpk, iškvėpk, jei reikia, pasiimk popierių ir pieštuką ir pradėk skaidyti darbus į logines sekas. Pvz., prieš tai buvusią užduotį galima suskaidyti į tris dalis:\n\nreikia failų ir direktorijų sąrašo\natspausdinti perrašant\nfailo pavdinimas\n\n\nDabar galima skaidyti ar toliau detalizuoti kiekvieną iš šių dalių.\n\nls -alh pagamina sąrašą ilguoju, žmonėms suprantamų dydžių formatu\n&gt; perrašo\ndirektorijos_turinys.txt bus pavadinimas\n\n\nTačiau dabartinė darbinė direktorija yra ~/shell_part_2, todėl reikia\n\nls -alh kaip argumentą paduoti ~ arba atitinmai /home/username\ndirektorijos_turinys.txt turi būti mix subdirektorijoje\n\n\nSkaidant užduotį į mažesnes dalis, vis labiau suprasi, ką reikia padaryti. Turint daugiau patirties, geriau žinosi, kiek laiko gali prireikti kiekvienam žingsniui.\nPvz., duomenų analitikas gali gauti užduotį: suprognozuoti sekančių metų ledų pardavimus. Analitikas, žinodamas, kad ledų pardavimai priklauso nuo lauko temperatūros, gali suskaidyti darbus taip:\n\nImportuoti istorinius tam tikros vietos temperatūros duomenis\nPrognozuoti sekančių metų kiekvienos dienos temperatūras\nApskaičiuoti kiekvienos dienos pardavimus\nAprašyti duomenis ir pateikti juos užsakovui suprantamu formatu\n\n\n\n\nPhoto by Kamaji Ogino\n\n\nKiekvieną iš šių žingsnių analitikas gali suskaidyti į dar daugiau mažesnių užduočių.\nKodėl tai svarbu? Visų pirma, tai padeda geriau suprasti, ką reikia padaryti, ir kiek tai gali užtrukti. Kiekvienas žingsnis tampa atskiru procesu, ir jei nepavyksta vienas metodas, gali bandyti kitą.\nDarbų skaidymas yra intuityvus procesas kasdieniame darbe ir tu jau šį metodą ir taip taikai pasąmoningai, bet kai gauname naujas ir labai sudėtingas užduotis, vis tiek verta prisiminti šią strategiją, nes kartais mes pamirštame, kaip ji padeda išvengti pasimetimo.\n\n&gt;&gt; operatorius nukreipia komandos išvestį į failą, pridedant (angl. append) prie failo turinio. Jei failas neegzistuoja, jis bus sukurtas.\necho \"What a beatiful morning\" &gt;&gt; day.txt\necho \"What a beatiful day\" &gt;&gt; day.txt\necho \"What a beatiful evening\" &gt;&gt; day.txt\nŠios komandos prideda tekstą “What a beautiful morning”, “What a beautiful day” ir “What a beautiful evening” prie failo day.txt galo, neperrašydamos esamo turinio. Jei tokio failo nėra, jis bus sukurtas.\n\n\n\n\n\n\nPraktika\n\n\n\n\nSusirask tau patinkančios dainos tekstą internete.\nNaudojant komandą echo ir operatorių &gt;, sukurk failą favorite_song.txt. Failo turinys turėtų būti panašus į “My favorite song is ”.\nPirmas keturias dainos eilutes atspausdink į failą song_text.txt naudojant echo ir &gt;&gt;. Nepamiršk, kokie klaviatūros trumpiniai naudojami kopijuojant ir įkeliant tekstą į terminalą!\n\n\n\n\n\n6.1.3 cat\nKomanda cat (angl. concatenate, liet. „sujungti“) naudojama peržiūrėti, sujungti ir atspausdinti failus. Tai viena iš pagrindinių Linux komandų, nes leidžia greitai peržiūrėti failų turinį, įvesti turinį į kitus failus arba sujungti kelis failus į vieną.\nPraeitame skyriuje sukūrei du failus favorite_song.txt ir song_text.txt. Dabar juos ir naudosime.\nAtspausdink failo favorite_song.txt turinį į terminalą:\ncat favorite_song.txt\nPas mane tai atrodo taip:\n\ncat leidžia sujungti kelių failų turinį ir atspausdinti rezultatą terminale:\ncat favorite_song.txt song_text.txt\n\nKaip praeitame skyriuje išmokai, komandos išvestį (nesvarbu, ar tai būtų echo, ar ls) galima nukreipti į failą. Lygiai taip pat gali nukopijuoti failą naudojant cat ir &gt; arba &gt;&gt;:\ncat favorite_song.txt &gt; favorite_song_2.txt\nŠi komanda nukopijuoja failo favorite_song.txt turinį į naują failą favorite_song_2.txt, perrašydama jo turinį, jei toks failas jau egzistuoja.\n\n\n\n\n\n\nPraktika\n\n\n\n\nNaudojant echo ir &gt;&gt;, įrašyk dar 4 eilutes mėgstamiausios dainos teksto į failą song_text_2.txt.\nSujunk failus song_text.txt ir song_text_2.txt, nukreipiant rezultatą į song_text_full.txt:\nPagalvok, kaip naudojant visas iki šiol žinomas komandas, būtų galima gauti song_text.txt failą, kuriame būtų pirmas ketvertas eilučių ir antras ketvertas eilučių teksto?\n\n\n\n\n\n6.1.4 head ir tail\nKomandos head (galva) ir tail (uodega) naudojamos peržiūrėti pirmąsias arba paskutines failo eilutes. Įprastai jos atspausdina 10 eilučių teksto.\n\n\n\n\n\n\nNote\n\n\n\nDabar tavo failas song_text.txt turėtų turėti 8 eilutes teksto. Todėl tokiu pat būdu, kaip prieš tai, pridėk dar 4 eilutes teksto, kad turėtum bent 12.\n\n\nPeržiūrėk pirmas 10 eilučių song_text.txt su head:\nhead song_text.txt\nPeržiūrėk paskutines 10 failo eilučių:\ntail song_text.txt\nTiek head, tiek tail priima nustatymą (option) -n su argumentu, nurodančiu, kiek eilučių atspausdinti:\n\nNorint peržiūrėti pirmas 3 eilutes, naudok komandą: head -n 3 song_text.txt\nNorint peržiūrėti paskutines 5 eilutes, naudok komandą: tail -n 5 song_text.txt.\n\n\n\n\n\n\n\nPraktika\n\n\n\nKas nutiktų, jei panaudotum head arba tail su failu, kuriame nėra 10 eilučių? Pabandyk su favorite_song.txt\n\n\n\n\n\n\n\n\nPraktika\n\n\n\nDabar dirbsi su failu data/temp_vilnius.txt.\n\nNaudojant cat, atspausdink visą failą terminale\nPirmosios dienos prognozės gali turėti mažiau nei 24 valandas (pvz., likusios 6 valandos). Naudojant head, atspausdink tik šiandienos orų prognozes\nKadangi šiandienos oras jau aiškus, tavo draugei Amelijai reikia rytojaus orų prognozės. Derinant head ir tail, išfiltruok eilutes taip ir sukurk tarpinius failus, kad būtų nusiųstos tik rytojaus 24 valandų temperatūros prognozės. Rezultatą išsaugok į failą amelija_temp_vilnius.txt subdirektorijoje data. Naudojant cat įsitikink, jog turi tik rytojaus temperatūras.\n\n\n\n\n\n6.1.5 less\nPraėjusiame skyriuje jau turėjai atvejį, kai viso failo temp_vilnius.txt turinys netilpo į terminalo langą. Tikėtina, reikėjo pakeisti terminalo lango dydį arba slinkti su pele. Dabar tau galbūt kyla klausimas, kaip būtų galima matyti failo turinį gabaliukais?\nNors gali naudoti cat dideliems failams atspausdinti ir tada slinkti išvestį, paprastai patogiau failą rodyti puslapiais. Tam pirminė komanda buvo more, bet ją pakeitė galingesnė komanda less.\nNaudojant less &lt;failas&gt;, vienu metu matysi tik vieną failo puslapį. Spaudžiant ␣ (space) klavišą, pereisi į kitą puslapį; gali taip pat naudoti ↓ ir ↑ klavišus, kad judėtum po vieną eilutę žemyn arba aukštyn. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk data/temp_vilnius.txt su less, išbandyk judėjimą tekste žemyn, aukštyn ir uždaryk programą su q.\n\n\nJei less komandai nurodysi kelis failus, gali naudoti :n (next) pereiti prie kito failo, o :p (previous) sugrįžti prie ankstesnio failo. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk failus favorite_song.txt, data/temp_vilnius.txt ir text/seneles_pasaka.txt su less. Išbandyk judėjimą tekste žemyn, aukštyn, pereik tarp failų naudojant :n ir :p bei pabaigoje uždaryk less su q\n\n\n\n\n6.1.6 wc\nKomanda wc (angl. word count) naudojama atspausdinti naujų eilučių, žodžių ir baitų skaičių faile.\n\n\n\n\n\n\n\nNustatymas\nReikšmė\n\n\n\n\n-c\nAtspausdina baitų skaičių (angl. byte count), kiek vietos užima failas\n\n\n-m\nAtspausdina simbolių skaičių (angl. character count)\n\n\n-w\nAtspausdina žodžių skaičių (angl. word count)\n\n\n-l\nAtspausdina eilučių skaičių (angl. line count)\n\n\n\nPastaba: -c ir -m gali atspausdinti skirtingus rezultatus priklausomai nuo failo koduotės, nes simbolis gali užimti daugiau nei vieną baitą (pvz., specialūs lietuviški simboliai).\n\n\n\n\n\n\nPraktika\n\n\n\n\nKiek žodžių ir kiek eilučių yra text/seneles_pasaka.txt?\nKiek eilučių yra data/temp_vilnius.txt ir kiek data/temp_kaunas.txt?\n\n\n\n\n\n6.1.7 touch\nKomanda touch naudojama kuriant tuščią failą arba keičiant esamo failo metaduomenis, pvz., modifikavimo ar prieigos laiką. Ji yra universali ir ypač naudinga tais atvejais, kai reikia greitai sukurti failą arba atnaujinti failo laikus be jo turinio keitimo.\nJei failas neegzistuoja, touch jį sukurs. Jei failas jau yra, komanda tiesiog pakeis failo “paskutinio keitimo laiką” (modification time) į dabartinį laiką, nesikeičiant turinio.\nSukurk tuščią failą:\ntouch empty_1.txt\n\nJei nurodysi kelis failų pavadinimus, touch sukurs visus iš karto:\ntouch empty_2.txt empty_3.txt empty_4.txt\n\nJeigu failo pavadinimas yra nurodytas su absoliučiu ar reliatyviu keliu, failas bus sukurtas atitinkamoje direktorijoje, jei tokia direktorija egzistuoja. Jei direktorija neegzistuoja, bus pranešta apie klaidą, ir failas nebus sukurtas.\ntouch mix/empty_5.txt\ntouch tralala/empty_6.txt\n\ntouch taip pat leidžia atnaujinti failo prieigos arba modifikavimo laiką. Štai keli pavyzdžiai:\n\nAtnaujinti tiek prieigos, tiek modifikavimo laikus į dabartinį laiką:\n\ntouch empty_1.txt\n\nAtnaujinti tik prieigos laiką:\n\ntouch -a empty_1.txt\n\nAtnaujinti tik modifikavimo laiką:\n\ntouch -m empty_1.txt\n\nNustatyti tiek prieigos, tiek modifikavimo laikus į konkrečią datą, pvz., 2022 m. sausio 1 d., 12:00 val.:\n\ntouch -t 202201011200 empty_1.txt\n\nNaudoti -d parinktį, norint lankstesnio laiko nustatymo:\n\ntouch -d \"2023-07-04 15:45\" empty_1.txt\nDabar gali kilti klausimas - kam tai naudinga? Iš tiesų, failų laikų keitimas gali atrodyti nišinis, tačiau tai naudinga tam tikrais atvejais:\n\nJei nori išbandyti skriptą, kuris rūšiuoja ar archyvuoja failus pagal jų prieigos ar modifikavimo laiką, gali generuoti tuščius failus su netikrais laikais ir patikrinti, ar skriptas veikia teisingai.\nJei atstatai failus iš atsarginės kopijos, gali norėti atkurti ir jų originalius prieigos bei modifikavimo laikus, kad išsaugotum failų istoriją tiksliai tokia, kokia buvo prieš atsargines kopijas.\n\n\n\n6.1.8 mkdir\nKomanda mkdir (angl. make directory) naudojama naujų direktorijų kūrimui.\nNaują direktoriją gali sukurti taip:\nmkdir projektas1\nKaip ir su komanda touch, gali sukurti kelias direktorijas vienu metu, nurodant pavadinimus arba kelius į jas:\nmkdir projektas2 mix/projektas3\n\nKartais reikia sukurti direktorijų medį (hierarchiją). Jei tarpinės direktorijos dar neegzistuoja, gali naudoti -p argumentą, kuris automatiškai sukurs ir tarpines direktorijas. Pavyzdžiui:\nmkdir -p projektas0/duomenys\n\n\n\n\n\n\n\nPraktika\n\n\n\nNetrukus norėsime sukurti tam tikrų failų atsargines kopijas. Kaip pasiruošimą, užtikrink, kad shell_part_2 direktorijoje būtų:\n\nbackup/data\nbackup/text\n\nSukurk jas naudojant -p, nurodant abi direktorijas kaip du argumentus vienoje komandoje (vienoje eilutėje).\n\n\n\n\n6.1.9 cp\nPripažink, kopijuoti failą su cat failas.txt &gt; kopija.txt nėra labai intuityvu. O ką daryti, jei nori nukopijuoti ne tik failą, bet ir visą direktoriją?\nKomanda cp (angl. copy) naudojama failams ir direktorijoms kopijuoti.\nPaprasčiausiu atveju, kai nori sukurti failo kopiją, komandai cp nurodai originalaus failo pavadinimą ir kokiu pavadinimu turėtų būti sukurta kopija.\ncp song_text.txt song_text_copy.txt\nJei failas song_text_copy.txt jau egzistuotų, jis būtų perrašytas. Taigi cp veikia panašiai kaip &gt;.\nKaip ir su visomis BASH komandomis, gali naudoti tiek reliatyvius, tiek absoliučius kelius (angl. path). Pavyzdžiui, kopiją gali perkelti į kitą direktoriją:\ncp ./song_text.txt ./mix/song_text_copy.txt\n\nJeigu kaip antrąjį argumentą nurodysi egzistuojančios direktorijos pavadinimą, cp sukurs kopiją tokiu pačiu pavadinimu kaip originalas ir patalpins ją į nurodytą direktoriją. Šįkart praleidžiam\ncp song_text.txt mix\n\ncp gali kopijuoti ir direktorijas, tačiau tam, kad visa direktorija būtų nukopijuota rekursyviai (su visu turiniu), reikia naudoti nustatymą -r (recursive). Jeigu pamirši -r direktorija nebus nukopijuota!\ncp -r mix mix_copy\n\nKada naudoti cp -a?\nNustatymas -a (arba archive) naudojamas, kai reikia nukopijuoti failus ir direktorijas kartu su jų metaduomenimis (pvz., failo leidimais, nuosavybe, laikais). Tai naudinga, kai nori išsaugoti visas originalaus failo ar katalogo savybes. -a iš esmės yra kombinuotas cp -r (rekursija) ir kitų nustatymų rinkinys, kuris užtikrina, kad išsaugomi visi atributai.\ncp -a mix mix_copy_2\nDabar palyging metaduominis su ls -l.\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nPadaryk temp_vilnius.txt kopiją pavadinimu temp_vilnius.txt, bet kaip argumentą nurodyk direktoriją ir failo pavadinimą. Patalpink kopiją į backup/data.\nPadaryk temp_kaunas.txt ir temp_klaipeda.txt kopiją vienoje komandoje su originaliu pavadinimu, kaip trečią argumentą cp paduodant tik backup/data direktoriją.\nPadaryk text direktorijos kopiją su visu jos turinu į backup direktoriją. Išsaugok visus metaduomenis.\nTeorinis klausimas: kas nutiktų jeigu panaudotum cp -r text backup/text?\nAr darant temp_ failų atsargines kopijas išsaugojai metaduomenis? jeigu ne, pakartok komandas tik su teisingu nustatymu ir įsitikink, ar iš tiesų metaduomenys tokie pat!\n\n\n\n\n\n6.1.10 mv\nKomanda mv (angl. move) naudojama perkelti arba pervadinti failus ir direktorijas. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\nPvz., naudojant mv, gali pervadinti failą temp_vilnius.txt į temp_alytus.txt:\nmv data/temp_vilnius.txt data/temp_alytus.txt\n\nTaip pat su mv gali perkelti failus iš vienos direktorijos į kitą. Ši komanda perkelia failą temp_kaunas.txt į mix:\nmv data/temp_kaunas.txt mix\n\nmv komandai galima paduoti daugiau nei du argumentus. Pavyzdžiui, ši komanda perkelia failus temp_alytus.txt ir seneles_pasaka.txt į direktoriją mix. Čia svarbu, kad paskutinis argumentas būtų egzistuojanti direktorija:\nmv data/temp_alytus.txt text/seneles_pasaka.txt mix\nmv taip pat gali būti naudojama perkelti direktoriją ir visą jos turinį. Pavyzdžiui, ši komanda perkelia direktoriją mix_copy į mix:\nmv mix_copy mix\nPastaba: dirbant su direktorijomis:\n\njeigu mv origin target jeigu target neegzistuoja, tada mv pervadins direktoriją origin į target\njeigu mv origin target jeigu target egzistuoja, tada mv perkels origin į target direktoriją\n\nSvarbu: kaip ir naudojant &gt; ar cp, jeigu tikslinis failas jau egzistuoja, jis bus perrašytas, nebent pridėsi -i (interaktyvų režimą), kad būtų paprašyta patvirtinimo prieš perrašant.\n\n\n\n\n\n\nPraktika\n\n\n\n\nTeorinis klausimas: Kas nutiktų, jei įvykdytum šią komandą?\n\nmv temp_vilnius.txt temp_kaunas.txt ~/Documents ~/Downloads\n\nPerkelk Alytaus ir Kauno temperatūrų failus atgal iš mix į data naudojant mv. Pervadink Alytaus failą atgal į Vilniaus\nAtsidaryk Nemo ir rankiniu būdu ištrink data direktoriją. Dabar su terminal, padaryk backup/data kopiją (su cp ir reikalaingais nustatymais), jog vėl atsirastų /shell_part_2/data.\n\n\n\n\n\n6.1.11 rm\nTavo shell_part_2 direktorijoje dabar tikrai daug failų ir subdirektorijų, kurių nebereikia. Laikas įvesti šiek tiek tvarkos!\nKomanda rm (angl. remove) naudojama pašalinti failus ir direktorijas. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar direktorijos nėra perkeliami į šiukšliadėžę ir jų atkurti nebebus galima.\nNorint pašalinti failą, rm komandai paduodamas argumentas - failo pavadinimas arba absoliutus, arba reliatyvus kelias į failą.\nrm day.txt\nrm mix/empty_5.txt\nKomandai rm galima paduoti ir kelis failus vienu metu:\nrm empty_1.txt empty_2.txt \nTuščią direktoriją (kai joje nėra jokių kitų failų ar subdirektorijų) galima pašalinti arba naudojant rmdir (kuri yra mkdir priešingybė), arba su rm, nurodant nustatymą -d.\nrm -d projektas1\nrmdir projektas2\n\nTiesiog pašalinti direktoriją, kurioje yra kažkas, su rm arba rm -d nepavyks, nes BASH bando apsaugoti vartotoją nuo rizikos netyčia ištrinti daugiau failų nei reikia.\n\nJei reikia ištrinti visą direktoriją su visu jos turiniu, naudojamas parametras -r (recursive).\nrm -r projektas0\nKartais gali nutikti, jog rm -r negalės ištrinti direktorijos dėl failų teisių ar kitų kliūčių. Tokiu atveju pridedamas nustatymas -f (force), kuris priverstinai ištrina failus.\nrm -rf mix_copy_2\nintarpas: Wildcard’ų naudojimas *\nKartais BASH komandose norisi pažymėti arba pasirinkti daugiau nei vieną failą. Kaip jau matei, tiek cat, tiek cp, mv, rm, less komandos kuo puikiausiai dirba su keliais failais. Tad kyla klausimas, kaip tai padaryti efektyviau naudojant wildcard simbolius.\nPvz., tu galėtum rašyti:\nrm empty_1.txt empty_2.txt\nTačiau yra akivaizdu, jog šiuose failų pavadinimuose yra tam tikras dėsningumas – jie prasideda empty_ ir baigiasi .txt.\nBASH, kaip ir daugelyje kitų programavimo kalbų, yra vadinamieji wildcard - simboliai, kurie leidžia užpildyti vieną ar daugiau ženklų.\nPavyzdžiui, * simbolis pakeičia bet kokį skaičių ženklų. Taigi, galima būtų parašyti:\nrm empty_*.txt\nWildcard’ų simboliai:\n\n* reiškia jokio, vieną arba daugiau simbolių.\n? reiškia tiksliai vieną simbolį, pvz., 201?.txt galėtų atitikti 2017.txt, 2018.txt, bet ne 2017-01.txt.\n[...] reiškia vieną iš pateiktų simbolių, pvz., 201[78].txt atitiks 2017.txt arba 2018.txt, bet ne 2016.txt.\n{} reiškia vieną iš nurodytų reikšmių, pvz., rm {.txt,.csv} atitiks visus failus, kurių pavadinimas baigiasi .txt arba .csv, bet ne .pdf.\n\n\n\n\n\n\n\nPraktika\n\n\n\nTeorinė užduotis - pasakyk, kas nutiktų visais šiais atvejais:\n\nrm song*.txt\nrm *song*.txt\nrm *.txt\nrm *.*\nrm ./*\nrm *\nrm data/*\nrm text/*.txt\nPasitikrink atsakymą naudojant ChatGPT!\n\nPraktinė užduotis - naudojantis wildcard ištrink iš shell_part_2 visus failus:\n\nkurių pavadinime yra žodis song, neproklausomai nuo pozicijos ir failo tipo\nkurių failo tipas yra .txt\nvisus failus esančius mix subdirektorijoje. Tam gali prireikti papildomo nustatymo rm komandai, nes mix gali būti direktorijos!\nsubdirektorijas data ir text. O tada naudodojant cp ir būtinai reikiamą nustatymą metaduomenų išlaikymui, atkurti iš backup\n\n\n\nAtlikus visus valymus turėtum turėti:\n\n\n\n6.1.12 grep\nKartais tau gali prireikti nuskaityti tik tam tikras failo eilutes, kuriose yra konkretus tekstas. Komanda grep (angl. global regular expression print, liet. „globalus reguliariųjų išraiškų paieškos spausdinimas“) naudojama teksto paieškai pagal šabloną failuose arba išvestyje.\nPavyzdžiui, ši komanda surastų visas eilutes data/seneles_pasaka, kuriose yra žodis „Apie“:\ngrep Apie text/seneles_pasaka.text\n\nSuprantama, gali pateikti kelis failus vienu metu. Šiuo atveju komanda grep suras visas eilutes, kuriose yra 14:00:00 abiejuose jai pateiktuose failuose ir atitinkamas eilutes atspausdins tau į terminalą.\ngrep 14:00:00 data/temp_vilnius.txt data/temp_kaunas.txt \n\ngrep priima ir tam tikrus nustatymus, kurie padeda atlikti paiešką efektyviau:\n\n-c: atspausdina, kiek eilučių atitinka tavo pateiktą kriterijų.\n-h: neatspausdina failų pavadinimų, kuriuose rasti atitikimai, kai pateiki keli failai.\n-i: ignoruoja didžiąsias ir mažąsias raides (pvz., įrašius -i apie, ras ir „Apie“, „apie“, „APIE“ ir t.t.).\n-l: atspausdina tik failų pavadinimus, kuriuose rasti atitikimai.\n-n: atspausdina eilučių numerius šalia pačios eilutės.\n-v: ieško eilučių, kuriose nėra raktinio paieškos kriterijaus.\n\n\n\n\n\n\n\nPraktika\n\n\n\nDirbk su data/seneles_pasaka.txt\n\nKurios eilutės turi paminėtą žodį „pasaka“ (tik su mažąja raide)?\nKurios eilutės turi paminėtą žodį „pasaka“ (nesvarbu, ar rašyta didžiosiomis, ar mažosiomis raidėmis)?\nKiek eilučių (ieškome skaičiaus) turi paminėtą žodį „apie“, nepriklausomai nuo rašybos?\nKiek eilučių (ieškome skaičiaus) nepamini žodžio „apie“, nepriklausomai nuo rašybos?\n\n\n\nPastaba: komanda grep ieško tekstinės atitikties failuose, todėl ji nepriima loginių operatorių kaip &gt;, =, ar &lt;. Visgi, grep leidžia naudoti reguliarias išraiškas (regular expressions), kurios leidžia dar smulkiau atrinkti tekstą.\nŠtai kaip būtų galima panaudoti grep su reguliariomis išraiškomis, norint surasti visas eilutes, kuriose yra vienas skaitmuo prieš tašką, visuose temp_ failuose:\ngrep -P '\\t[0-9]\\.[0-9]' data/temp_*.txt\n\nĮ reguliarias išraiškas dabar neverta gilintis išsamiau, bet svarbu žinoti, kad jos egzistuoja ir gali būti labai naudingos dirbant su tekstiniais duomenimis. Jeigu kiltų noras pasibandyti, siūlau naudti https://regexr.com/.\n\n\n6.1.13 cut\nKartais tau gali prireikti išfiltruoti ne eilutes, o stulpelius. Pvz., komanda head data/temp_vilnius.txt parodo tarsi 3 stulpelius: datą, laiką ir temperatūrą. Pastebima, kad tarp datos ir laiko yra mažas tarpas (greičiausiai „space“), o tarp laiko ir temperatūros – didelis tarpas (tikėtina, “tab”). Tai šiek tiek apsunkina darbą, kol nesusipažinai su sed komanda, bet tai nereiškia, jog negalime išskaidyti failo į stulpelius pagal skirtingus skirtukus, pvz., „space“ ir „tab“.\n\nKomandai cut reikia tam tikrų nustatymų. Pagrindiniai nustatymai:\n\n-d (delimiter) – skirtukas, kuris skiria stulpelius. Pagal nutylėjimą skirtukas yra tabuliacija (tab), tad šio nustatymo keisti nereikia. Jeigu norėtum naudoti kitą skirtuką, pvz., tarpo ženklą, turėtum naudoti -d \" \". Jeigu skirtukas būtų kablelis, naudotum -d \",\" ir t.t.\n-f (fields) – nurodo, kuriuos stulpelius (laukelius) nori pasirinkti. Pvz., -f 2 pasirinktų antrą stulpelį, -f 2-5 pasirinktų nuo antro iki penkto stulpelio, o -f 2-5,8 pasirinktų antrą, trečią, ketvirtą, penktą ir aštuntą stulpelius.\n\nŠi komanda priima „space“ kaip skirtuką ir atspausdina pirmąjį stulpelį:\ncut -d \" \" -f 1 data/temp_vilnius.txt\n\nŠi komanda priima „tab“ kaip skirtuką ir atspausdina antrąjį stulpelį:\ncut -f 2  data/temp_vilnius.txt\n\nJeigu norėtum gauti tik metus, galėtum nurodyti skirtuką „-“ ir pasirinkti pirmąjį stulpelį:\ncut -d \"-\" -f 1 data/temp_vilnius.txt \n\n\n\n\n\n\n\nPraktika\n\n\n\nProgramuojant ir dirbant su duomenimis, svarbu išmokti išnaudoti AI galimybes. Šioje praktikoje tu turi nueiti į ChatGPT ir parašyti kažką panašaus:\n\nSugeneruok 25 eilučių .csv failą, kurio skirtukas būtų “,” su šiais stulpeliais:\n\nuser_id,\nage (18-99)\ncountry_code (LT, LV, EE)\norders (0-250)\n\n\nChatGPT sugeneruos .csv failą ir leis jį atsisiųsti. Šiam sugeneravimui ChatGPT pasinaudos Python programavimo kalba. Tu galėtum išsaugoti grąžintą kodą ir naudoti jį ateityje, nes tavo kompiuteryje šis kodas taip pat veiktų. Bet prie Python mes dar grįšime vėliau.\nPerkelk failą iš ~/Downloads į ~/shell_part_2/data. Tarkime, failas vadinasi sample_data.csv.\nVideo\nTurint failą:\n\nPervadink failą į balt_customers.csv.\nNaudojant žinomomis komandomis tyrinėk failą data/balt_customers.csv:\n\nKiek jame eilučių?\nKoks skirtukas naudojamas?\nKokie duomenys yra pirmoje eilutėje (antraštė ar duomenys)?\nKiek ir kurios eilutės yra duomenys?\n\n\nUžduotis: Tu dirbi su klientais iš Estijos (EE). Turi parašyti visiems klientams iš Estijos el. laišką ir pranešti apie jų užsakymų skaičių. Laiško rašymą perims programa, tačiau tu jai turi pateikti failą customers_ee.csv, kuris turėtų atrodyti taip (tavo duomenys gali skirtis dėl atsitiktinio jų sugeneravimo):\n\nKad įgyvendintum šią užduotį, tau prireiks komandų: head, cut, &gt; &gt;&gt;, cat ir grep bei sukurti kelis tarpinius failus, kuriuos vėliau galėsi ištrinti. Taip pat patarčiau bandyt skaidyti darbus :)\nSėkmės!\n\n\n\n\n6.1.14 Intarpas: Standartinė įvestis, išvestis ir klaidos\nIki šiol mes naudojome sąvokas, tokias kaip įvestis (input) ir išvestis (output). Įvestis buvo tai, ką tu įvedi klaviatūra į terminalą, o išvestis – tai, ką BASH atspausdina terminale arba ką tu nukreipi į failą naudodant &gt; arba &gt;&gt;. Tačiau iki šiol formaliai neaptarėme BASH srautų.\nLinux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenų įvestį ir išvestį programose bei komandose. Šie srautai vadinami standartine įvestimi (standard input), standartine išvestimi (standard output) ir standartine klaida (standard error). Kiekvienas srautas turi specifinę paskirtį ir failo aprašymo numerį.\nSvarbu: Linux’e viskas yra failai, net srautai (input/output) traktuojami kaip failai.\n\n6.1.14.1 Standartinė įvestis (stdin)\nStandartinė įvestis, sutrumpinta kaip stdin, yra srautas, iš kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, stdin yra prijungta prie klaviatūros, tačiau gali būti nukreipta iš failo ar kito srauto.\nPabandyk įrašyti cat, paspausti Enter, ir tada įvesk kelis žodžius, vis paspausdžiant Enter. Terminale matysi tekstą, kurį įvedi, nes jis bus perduotas kaip įvestis cat komandai, kuri atspausdins šį tekstą. Todėl matysi dvigubai tai, ką įvedei.\ncat\nNutraukti cat įvestį gali su Ctrl-D arba Ctrl-C.\nVideo\nĮvestis taip pat gali būti perduodama iš failo į komandą. Pavyzdžiui, komandai cat galime nurodyti failą taip:\ncat &lt; data/customers_ee.csv\nKodėl veikia &lt;?\nSimbolis &lt; nurodo komandai, kad vietoje įprastos įvesties iš klaviatūros naudotų failą kaip įvesties šaltinį. Pvz., cat &lt; data/customers_ee.csv reiškia, kad cat komanda skaitys duomenis iš failo data/customers_ee.csv, o ne iš klaviatūros.\n\nStandartinės įvesties aprašymo numeris: 0. Vėliau pamatysi, kam tie skaičiai naudingi.\n\n\n6.1.14.2 Standartinė išvestis (stdout)\nStandartinė išvestis, sutrumpinta kaip stdout, yra srautas, į kurį komanda ar programa rašo išvestį. Dirbant terminale, stdout prijungta prie terminalo ekrano. Pavyzdžiui, įrašius šią komandą, terminale atspausdinamas „Hello World“:\necho \"Hello World\"\nGalima nukreipti standartinę išvestį ne į terminalo langą, bet į failą, kaip jau esame darę anksčiau:\necho \"Hello World!\" &gt; hello_world.txt\nStandartinė išvestis turi numerį 1. Tai reiškia\necho \"Hello World!\" 1&gt; hello_world.txt\njog stdout srautas (1), kurį generuoja echo komanda, siunčiamas į failą hello_world.txt. Mes panaudojom srauto numerį, kad pasakyti kurį srautą siųsti į failą.\n\n\n6.1.14.3 Standartinė klaida (stderr)\nKai komanda negali atlikti tam tikro veiksmo, ji sugeneruoja klaidos pranešimą, kuris siunčiamas į standartinį klaidos srautą (stderr). Standartinės klaidos srautas turi numerį 2, ir jį taip pat galima nukreipti į failą.\nPabandyk komandą ls su neegzistuojančia direktorija, pvz.,:\nls abc\n\nKlaidos pranešimas bus išspausdintas terminale. Tačiau galime nukreipti tik klaidos srautą į failą:\nls abc 2&gt; error.log\nTerminale klaidos nebus matyti, bet gali naudoti komandas head arba cat, kad pažiūrėtum, kas yra error.log faile.\n\n\n\n\n6.1.15 Kaip visą tai taikyti praktikoje?\nĮsivaizduok, kad turi komandą ls, kuri kartais sugeneruoja išvestį, kurią nori nukreipti į list.txt, o klaidas – į error.log. Tam galėtum naudoti:\nls &lt;direktorija1&gt; &lt;direktorija2&gt; &lt;direktorija3&gt; 1&gt;&gt;list.txt 2&gt;&gt;error.log\nIšbandyk šią komandą su egzistuojančia ir neegzistuojančia direktorija (prieš tai su rm ištrink error.log jeigu toks egzistuoja)\nls -l data abc text 1&gt; list.txt 2&gt; error.log\n\nKartais gali prireikti, kad abu srautai būtų nukreipti į tą patį failą. Pvz., jeigu kas 10 minučių matuoji kompiuterio temperatūrą, gali nukreipti tiek stdout, tiek stderr į failą:\nkomanda 1&gt;temp.log 2&gt;&1\nArba gali klaidos srautą nukreipti į temp.log, o standartinę išvestį – į klaidų srautą:\nkomanda 2&gt;temp.log 1&gt;&2\nSimbolis & nurodo, kad mes kalbame apie srautą, o ne apie failo vardą. Kai rašai, pvz., 1&gt;&2, tai reiškia, kad standartinę išvestį (stdout, 1) nukreipi ne į failą, o į standartinį klaidų srautą (stderr, 2). Tai leidžia abu srautus sujungti ir siųsti į tą patį tikslą. Jei & nebūtų, sistema galvotų, kad „2“ yra failo pavadinimas, o ne kitas srautas. Analogiškai, 2&gt;&1 reiškia, kad klaidų srautas (stderr, 2) nukreipiamas į išvesties srautą (stdout, 1).\n\n\n6.1.16 pipe |\nIki šiol, kai reikėdavo vienos komandos išvestį panaudoti kitoje komandoje, pavyzdžiui, išfiltravus Estijos vartotojus su grep EE data/balt_customers.csv, turėjai juos išsaugoti į tarpinį failą (pvz., temporal.csv), o tik tada paduoti rezultatą į cut -d \",\" -f 1,4 temporal.csv, kad gautum norimą rezultatą. Tai yra neefektyvus metodas, nes:\n\nLieka daug tarpinių failų.\nKomandos būna suskaidytos per kelias eilutes, todėl jas sunku peržiūrėti su history.\n\nBASH siūlo kelis būdus, kaip efektyviau panaudoti vienos komandos rezultatus kitose, pavyzdžiui, su xargs arba kitais įrankiais. Tačiau dažniausiai naudojamas metodas yra pipe (angl. “vamzdis”).\n| (pipe) – tai vertikalus brūkšnys, kuris sujungia komandas į vieną srautą, kur vienos komandos išvestis tampa kitos komandos įvestimi.\n\nPabandyk sujungti šias komandas:\n\ngrep EE data/balt_customers.csv - išfiltruoti tik EE vartotojus.\nPanaudoti |, kuris pavers pirmosios komandos išvestį antrosios komandos įvestimi.\ncut -d \",\" -f 1,4 – iškirpti pirmą ir ketvirtą stulpelius.\nGalutinį rezultatą su &gt; nukreipk į failą data/customers_ee_2.csv.\n\n\ngrep EE data/balt_customers.csv | cut -d \",\" -f 1,4 &gt; data/customers_ee_2.csv\nPirma pabandyk paleisti komandą be &gt;, kad pamatytum rezultatą terminale:\n\nDabar paleisk pilną komandą, nukreipiančią išvestį į failą:\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nTerminale atspausdink pirmas 3 eilutes, kuriose yra žodis „Apie“ iš failo data/seneles_pasaka.txt.\nTerminale atspausdingk paskutines 3 eilutes kuriose yra 00:00:00 faile data/temp_vilnius.txt\n\n\n\n\n\n6.1.17 sort\nTu darai nuostabią pažangą ir jau moki naudoti grep, cut, head, tail, su kuriomis gali išfiltruoti eilutes, stulpelius ir t.t. Naudojant |, jau moki sujungti kelias komandas į vieną. Tačiau ko tu dar nemoki – kaip išrikiuoti reikšmes. Čia pravers komanda sort.\nsort labai gerai sąveikauja su pipe |.\nPagrindiniai nustatymai:\n\n-r – nuo didžiausios iki mažiausios reikšmės.\n-n – rikiuoti skaičius.\n-h – rikiuoti pagal dydį, jei dydis pateiktas human readable skaičiais (pvz., KB, MB, GB).\n-t – nurodo, koks yra skirtukas tarp stulpelių (delimiter).\n-k – pagal kurį stulpelį rikiuoti.\n\nSukurk šį failą:\necho -e \"A,101\\nB,3\\nC,2\\nD,40\" &gt; tosort\nAr pastebėjai, tosort neturi indikacijos, koks tai failas, nei .csv, nei .txt. Nieko tokio Linux operacinėje sistemoje, komandos veikia kuo puikiausiai ir be failo tipo indikatoriaus.\n\nPagal nutylėjimą sort priims failą kaip argumentą ir rikiuos pagal pirmą stulpelį. sort -r apsuks rikiavimo eigą.\nsort tosort\nsort -r tosort\n\nJei nori, kad BASH suprastų failą kaip turintį skirtingus stulpelius, turi nurodyti, koks yra skirtukas (delimiter) su -t \",\". Tuomet galima rikiuoti pagal konkretų stulpelį su -k 2. Jei nepridėsi -n, sort rikiuos taip, lyg skaičiai būtų tekstas, t.y., vertins pagal pirmą skaitmenį, tada pagal antrą ir t.t. Pridėjus -n, skaičiai vertinami kaip skaičiai.\nGalima apsieiti ir be kabučių aplink skirtuką, o -n pridėti prie -k 2, kad būtų rikiuojama pagal skaičius. Galų gale, tai tavo pasirinkimas.\nsort -t \",\" -k 2 tosort\nsort -t \",\" -k 2 -n tosort\nsort -t, -k2n tosort\n\n\n\n\n\n\n\nPraktika\n\n\n\nUžduotis: Įsivaizduok, kad esi IT administratorė arba administratorius, atsakingas už sistemų stebėjimą. Tau reikia periodiškai siųsti sąrašą su 5 didžiausiais failais ar direktorijomis pagal dydį namų direktorijoje (~). Šis sąrašas turėtų apimti visus paslėptus failus (kurie prasideda su “.” savo pavadinime), o dydis turėtų būti human readable formatu, o ne baitais. Taip pat norisi, kad maksimalus gylis būtų 1, t.y., jog būtų žiūrima į ~ ir vieną lygį giliau, t.y. ~/direktorija/.\nKadangi šią užduotį reikia atlikti kasdien, nusprendei sukurti ilgą BASH komandą.\nPagalba: Prieš pradedant nueik į ChatGPT ir paprašyk:\n\nPaaiškink man “du” komanda Linux ir jos nustatymus. Man reiktų matyti failus human readable formatu. Pateik kelis pvz.\n\nPerskaityk ką tau gražins ChatGPT, jeigu reikia pasitisklink užduodant papildomus klausimus.\n\nPabandyk sukurti komandų seką (pipeline) su du, sort, head. Eksperimentuok su nustatymais.\nKai terminalo lange matysi reikiamą išvestį, naudok echo, apskliausk visą komandą kabutėmis ir nukreipk į failą pavadinimu list_du_homedir.sh. Taigi, tai turėtų atrodyti daugmaž taip:\necho \"komanda komanda komanda\" &gt; list_du_homedir.sh\nO dabar pabandyk\nbash list_du_homedir.sh\narba su pipe\ncat list_du_homedir.sh | bash\nSveikinu, ką tik sukūrei savo pirmą skriptą! Tai komandų rinkinys, kurį gali perduoti BASH, ir jis jį įvykdys.\n\n\n\n\n6.1.18 sed\nsed komanda Linux sistemoje yra srauto redaktorius (stream editor), naudojamas tekstui apdoroti ir manipuliuoti. Ji leidžia atlikti įvairius teksto pakeitimus, pvz., ieškoti ir pakeisti žodžius, ištrinti eilutes arba modifikuoti tekstą pagal tam tikras taisykles, nespausdinant teksto į terminalą.\nVienas paprasčiausių būdų naudoti sed – tai pakeisti tam tikrą tekstą kitu tekstu: tam naudojama tokia sintaksė sed 's/ką keisti/kuo pakeisti/'.\nTaigi, ši komanda pakeičia „rytas“ į „vakaras“:\necho \"Labas rytas\" | sed 's/rytas/vakaras/'\nsed nėra agresyvi komanda, todėl ankstesnė komanda pakeičia tik pirmą rastą atitikmenį:\necho \"Labas rytas, pasakė senelė kai atėjo rytas\" | sed 's/rytas/vakaras/'\nMatyti, kad tik pirmas „rytas“ pakeistas į „vakaras“, o antrasis ne. Jei nori, kad visi atitikmenys būtų pakeisti, reikia pridėti nustatymą g:\necho \"Labas rytas, pasakė senelė kai atėjo rytas\" | sed 's/rytas/vakaras/g' \nSu sed taip pat galima ištrinti eilutes. Pavyzdžiui, jei ls -l komanda atspausdina „total …“, galima tai ištrinti naudojant sed '1d':\nls -l\nls -l |sed '1d'\nVietoje 1, kuris nurodo, kurią eilutę trinti, galima nurodyti ir diapazoną, pvz., nuo 1 iki 3 su sed '1,3d':\nls -l | sed '1,3d'\nTaip pat galima įterpti naujas eilutes:\nls -l | sed '3a/nauja eilutė'\nPora įdomybių:\nSu sed gali naudoti regular expressions. Štai keletas reikšmių:\n\n^ reiškia eilutės pradžią.\n$ reiškia eilutės pabaigą.\n\\t reiškia tabuliaciją (naudoti su sed -E).\n\\s reiškia tarpą (naudoti su sed -E).\n\nPvz., pridėti veiduką prieš kiekvieną eilutę:\nsed 's/^/😀/g' text/seneles_pasaka.txt\nJei nori, kad sed ignoruotų raidžių dydžius, pridėk nustatymą I. Tai panašu į grep -i.\necho Labas Rytas | sed 's/rytas/Vakaras/'\necho Labas Rytas | sed 's/rytas/Vakaras/I'\n\n\n\n\n\n\nPraktika\n\n\n\n\nDirbk su data/seneles_pasaka.txt. Tavo tikslas – padaryti pasaką labiau patrauklią vaikams, pakeičiant žodžius simboliais. Naudok sed komandą ir pakeisk šiuos žodžius į atitinkamus simbolius. Sujunk visas sed komandas į viena pipeline naudojant |.\n\nŽąsiną moliūgą – 🦢🎃 Vilką – 🐺 Baltą mešką – 🐻‍❄️ Joną – 👦🏻 Eglę - 🌲 Žalčio – 🐍 Ragana - 🧙‍♀️ Pamotė pikta – 😡\nIšsaugok pasaką kaip text/seneles_pasaka_emojies.txt\n\n\ndata/temp_vilnius.txt ir kitų miestų failai turi kelias problemas, kurias turėtum ištaisyti:\n\nVilniaus faile kiekvienos eilutės pradžioje įrašyk „Vilnius “ (su tarpeliu po miesto pavadinimo). Kituose miestuose atitinkmai “Kaunas” ir “Klaipėda”\nDabar pirmieji du skirtukai yra tarpai, o antrasis – tabuliacija. Paleisk sed komandą du kartus: vieną kartą pakeisk tarpus (space) į kablelius, o antrą kartą – tabuliacijas į kablelius.\nIšsaugok Vilniaus, Kauno, ir Klaipėdos failus kaip temp_vilnius.csv, temp_kaunas.csv, temp_klaipeda.csv (vietoje .txt naudok .csv plėtinį).\nKiekvienas miestas turėtų turėti visą komandą vienoje eilutėje naudojant |.\n\n\n\nSujunk visus Vilniaus, Kauno ir Klaipėdos failus į vieną ir pavadink rezultatą temp_lietuva.csv.\nPabandyk atidaryti šį failą su LibreOffice Calc:\n\nlibreoffice --calc temp_lietuva.csv\n\nPavaizduok sekančių dienų temperatūras.\n\n * Pabandyk atsidaryti visus tris pavienius failus su Excel Power Query ir apdorojus duomenis sukurti dashboard to slicer filtrais ir grafikais.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html",
    "title": "7  BASH advanced",
    "section": "",
    "text": "7.1 Pagalba sau\nPraeitame skyriuje susipažinai su daug komandų, kurios tau kuria pagrindą darbui su SHELL. Tu išmokai daug programų, su daug skirtingų nustatymų, tačiau kaip gali įsivaizduoti, tu tikrai neišmokai VISKO. Todėl prieš judant toliau, pradėkie turputi nuo to, kaip padėti sau, kai pastringi: kai neprisemeni kokias opcijas naudoti ir t.t.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#pagalba-sau",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#pagalba-sau",
    "title": "7  BASH advanced",
    "section": "",
    "text": "7.1.1 help\nvienas papraščiausių būdų rasti greitai paaiškinimą, kaip veika tam tikra komanda pasinaudoti help, dažniausiai help iššaukiama taip\nkomanda --help\nkaip pameni, -- naudoji prieš tuos nustatymus, kurie išrašyti pilnai, trumpiniams naudjoamas vienas -.\ntada tau terminale bus atspaudintas visas su šia komanda susijęs pagalbos tekstas.\ndažniausiai help sudaro:\n\n…\n….\n…..\n\nPabandyk rasti pagalba šioms komandoms: ls, cp, rm, sed.\n\n\n7.1.2 man\nExercise Exercise How can I get help for a command?\nTo find out what commands do, people used to use the man command (short for “manual”). For example, the command man head brings up this information:\nHEAD(1) BSD General Commands Manual HEAD(1)\nNAME head – display first lines of a file\nSYNOPSIS head [-n count | -c bytes] [file …]\nDESCRIPTION This filter displays the first count lines or bytes of each of the specified files, or of the standard input if no files are specified. If count is omitted it defaults to 10.\n If more than a single file is specified, each file is preceded by\n a header consisting of the string ``==&gt; XXX &lt;=='' where ``XXX''\n is the name of the file.\nSEE ALSO tail(1)\nman automatically invokes less, so you may need to press spacebar to page through the information and :q to quit.\nThe one-line description under NAME tells you briefly what the command does, and the summary under SYNOPSIS lists all the flags it understands. Anything that is optional is shown in square brackets […], either/or alternatives are separated by |, and things that can be repeated are shown by …, so head’s manual page is telling you that you can either give a line count with -n or a byte count with -c, and that you can give it any number of filenames.\nThe problem with the Unix manual is that you have to know what you’re looking for. If you don’t, you can search Stack Overflow, ask a question on DataCamp’s Slack channels, or look at the SEE ALSO sections of the commands you already know. Instructions 1/2 50 XP\n1\n\nRead the manual page for the tail command to find out what putting a + sign in front of the number used with the -n flag does. (Remember to press spacebar to page down and/or type q to quit.)\n2\nUse tail with the flag -n +7 to display all but the first six lines of seasonal/spring.csv.\n\n\n7.1.3 find\nKomanda find naudojama ieškoti failų ir katalogų pagal įvairius kriterijus.\n\nIeškoti failų dabartiniame kataloge pagal pavadinimą:\n\nfind . -name \"failas.txt\"\n\nIeškoti failų visoje sistemoje pagal pavadinimą:\n\nfind / -name \"failas.txt\"\n\n\n7.1.4 chmod\nKomanda chmod (angl. change mode, liet. “keisti režimą”) naudojama keisti failų ir katalogų teises.\n\nSuteikti vykdymo teisę failui:\n\nchmod +x failas.sh\n\nNustatyti konkrečias teises:\n\n\nchmod 755 failas.txt\n\n\n7.1.5 chown\nKomanda chown (angl. change owner, liet. “keisti savininką”) naudojama keisti failų ir katalogų savininką.\n\nKeisti failo savininką:\n\n\nsudo chown naujas_savininkas failas.txt\n\nKeisti failo savininką ir grupę:\n\n\nsudo chown naujas_savininkas:nauja_grupė failas.txt\n\n\n7.1.6 ps ir top\nKomandos ps ir top naudojamos valdyti ir stebėti procesus sistemoje.\n\nParodyti veikiančius procesus su ps:\n\nps aux\nRealiu laiku sekti procesus su top:\ntop",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#sed",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#sed",
    "title": "7  BASH advanced",
    "section": "7.2 sed",
    "text": "7.2 sed",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#xed",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#xed",
    "title": "7  BASH advanced",
    "section": "7.3 xed",
    "text": "7.3 xed",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#find-1",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#find-1",
    "title": "7  BASH advanced",
    "section": "7.4 find",
    "text": "7.4 find",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#ps",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#ps",
    "title": "7  BASH advanced",
    "section": "7.5 ps",
    "text": "7.5 ps\n\n7.5.1 tldr",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#file-permissions-and-ownership",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#file-permissions-and-ownership",
    "title": "7  BASH advanced",
    "section": "8.1 1. File Permissions and Ownership",
    "text": "8.1 1. File Permissions and Ownership\n\nUnderstanding Permissions\n\nRecap of r, w, x permissions.\n\nCommands to Manage Permissions\n\nchmod: Change file permissions.\nchown: Change file ownership.\nchgrp: Change group ownership.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#environment-variables",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#environment-variables",
    "title": "7  BASH advanced",
    "section": "8.2 2. Environment Variables",
    "text": "8.2 2. Environment Variables\n\nIntroduction to Environment Variables\n\nImportance and usage in scripting.\n\nCommands\n\nexport: Set environment variables.\nenv, printenv: Display environment variables.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#text-processing-tools",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#text-processing-tools",
    "title": "7  BASH advanced",
    "section": "8.3 3. Text Processing Tools",
    "text": "8.3 3. Text Processing Tools\n\nAdvanced Text Processing\n\nawk: Basic usage for pattern scanning and processing.\npaste: Merging lines of files.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#basic-networking-commands",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#basic-networking-commands",
    "title": "7  BASH advanced",
    "section": "8.4 4. Basic Networking Commands",
    "text": "8.4 4. Basic Networking Commands\n\nNetworking Basics\n\nping: Checking network connectivity.\ncurl or wget: Fetching files or data from the web.\nnc: Networking tool for reading/writing data across network connections.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#job-control-light-coverage",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#job-control-light-coverage",
    "title": "7  BASH advanced",
    "section": "8.5 5. Job Control (Light Coverage)",
    "text": "8.5 5. Job Control (Light Coverage)\n\nUnderstanding Job Control\n\nOverview of foreground and background processes.\nBasic commands: jobs, bg, fg, kill.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#command-history-and-aliases",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#command-history-and-aliases",
    "title": "7  BASH advanced",
    "section": "8.6 6. Command History and Aliases",
    "text": "8.6 6. Command History and Aliases\n\nManaging Command History\n\nhistory: Viewing command history.\n\nCreating Shortcuts\n\nalias: Define shortcuts for commands.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#file-compression-and-archiving",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#file-compression-and-archiving",
    "title": "7  BASH advanced",
    "section": "8.7 7. File Compression and Archiving",
    "text": "8.7 7. File Compression and Archiving\n\nFile Management\n\ntar: Archive files and directories.\ngzip: Compress files.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#disk-usage-commands",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#disk-usage-commands",
    "title": "7  BASH advanced",
    "section": "8.8 8. Disk Usage Commands",
    "text": "8.8 8. Disk Usage Commands\n\nDisk Usage Overview\n\ndf: Report file system disk space usage.\ndu: Estimate file and directory space usage.\nncdu: Disk usage analyzer with a text-based interface.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#secure-file-transfer",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#secure-file-transfer",
    "title": "7  BASH advanced",
    "section": "8.9 9. Secure File Transfer",
    "text": "8.9 9. Secure File Transfer\n\nTransferring Files Securely\n\nscp: Secure copy protocol.\nrsync: Efficiently transfer files and directories.\nssh: Secure shell for remote access.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#command-execution-and-debugging",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#command-execution-and-debugging",
    "title": "7  BASH advanced",
    "section": "8.10 10. Command Execution and Debugging",
    "text": "8.10 10. Command Execution and Debugging\n\nCommand Substitution\n\neval: Execute commands stored in variables.\n\nDebugging Scripts\n\nIntroduction to debugging scripts (using set -x for tracing execution).",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#wrap-up",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#wrap-up",
    "title": "7  BASH advanced",
    "section": "8.11 Wrap-Up",
    "text": "8.11 Wrap-Up\n\nIntegration and Practice\n\nCombine learned commands in small exercises to reinforce concepts.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html",
    "title": "8  BASH advanced 2",
    "section": "",
    "text": "8.0.1 whoami\nKomanda whoami parodo dabartinio vartotojo (user) vardą, su kuriuo esate prisijungę prie sistemos. Tai paprastas ir naudingas būdas patikrinti, kokį vartotojo prisijungimą naudojate, ypač kai dirbate su keliais vartotojais toje pačioje sistemoje.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#locate",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#locate",
    "title": "8  BASH advanced 2",
    "section": "8.1 locate",
    "text": "8.1 locate",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#whereis",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#whereis",
    "title": "8  BASH advanced 2",
    "section": "8.2 whereis",
    "text": "8.2 whereis",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#path-1",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#path-1",
    "title": "8  BASH advanced 2",
    "section": "8.3 path",
    "text": "8.3 path",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#man",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#man",
    "title": "8  BASH advanced 2",
    "section": "8.4 man",
    "text": "8.4 man",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#help",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#help",
    "title": "8  BASH advanced 2",
    "section": "8.5 –help",
    "text": "8.5 –help",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#tldr",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#tldr",
    "title": "8  BASH advanced 2",
    "section": "8.6 tldr",
    "text": "8.6 tldr\nman puslapiai yra begalo išsamūs, tačiau jie ir ganėtinai ilgi. &lt;command&gt; --help arba &lt;command&gt; -h kartais būna gani trumpi ir aiškūs pagalbos puslpiai, tačiau jeigu komanda turi daug nustatymų ir argumentų, net --help puslapiai gali būti perdaug sudėtingi, ypač pačioje pradžioje naudojantis Linux.\nInstaliuok programa yt-dlp ir paleisk jos --help puslapį. Gana ilgas tiesa?\nKita programa, kuri stengiasi padėti CLI naudotojams, yra tldr (akronimias reiškiantis “too long;didn’t read it” = santrauka)\ninstaliuok programa tldr ir paleisk ją su argumentu yt-dlp\ntldr yt-dlp\nŠi programa pateikia dažniausius komandos naudjimo scenarijus ir labai trumpą paaiškinimą apie komandą. Tad tai dar vienas instrumentas tavo arsenale, primiršus prismint kaip veikia komanda, ką ji daro ir kokie nustatymai ir argumentai yra galimi. 5. Pabandyk tldr tldr",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html",
    "href": "d_bash_skriptai/13_bash_scripts_1.html",
    "title": "14  Bash Skriptai 1",
    "section": "",
    "text": "14.1 Kam man reikalingi BASH skriptai?\nKai administruoji (prižiūri) kompiuterius, arba nori automatizuoti tam tikrus procesus savo kompiuteryje, BASH skriptai tampa nepaimainoma pagalba. Štai keli pvz. perinstaliavus Linux, tu gali paleisti skriptą, kuris automatiškai instaliuos visas tavo naudojamas programas bei atstatys tavo nustatymus. O galbūt tu nori, kad kartą per savaitę failai esantys tavo Downloads direktorijoje susitvarkyt ir būtų išskirstyti, o šiukliadėžė išvalyta? O galbūt tu nori, kad reguliariai tavo kompiuteris padarytų savo backup kopiją ir ją patalpintų namų serveryje? Visokiems tokiems su kompiuteriu ar serveriu susijusius veiksmus lengviausia automatizuoti su BASH, nors tiesa, jog daugumą šių veiklų galima padaryti ir su Python arba kitomis programavimo kalbomis.\nNors BASH nėra tikrąją ta žodžio prasme programavimo kalba, BASH tai komandų interpretatorius skirtas interakcijai su tavo SHELL, visgi atzsižvelgiant į tai, jog BASH’e tu gali naudoti kintamuosius, ciklus ir t.t. padaro BASH beveik pilnaverte programavimo kalba.\nAr BASH skriptai reikalingi tik Linux adminsitratoriams? Ne, nors ko gero Linux administratoriai juos naudoja dažniausiai, šis įvadas į BASH skriptus padės geriau suprasti kompiuterinę logiką (ciklus), padės praktikuotis BASH komandas ir įgalins tave ne tik tapti dar labiau IT raštinga, bet ir paklos pamatus tiek Python, tiek Docker ir kitoms IT temoms, kuriose tu ir toliau naudosi Terminalą bei turėsi interakciją su Linux operacine sistema.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#kas-yra-bash-skriptas",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#kas-yra-bash-skriptas",
    "title": "14  Bash Skriptai 1",
    "section": "14.2 Kas yra bash skriptas?",
    "text": "14.2 Kas yra bash skriptas?\nIki šiol tu rašei komandas vieną paskui kitą tiesiogiai į terminalą. Nors išmokai jas sujungti (pipe) visgi tai nevsiada be galo patogus būdas, jeigu pvz norėtum paleisti 150 komandų vieną paskui kitą. Tam naudojami skriptai - tekstinis failas, kuriame surašyta visa komandų seka ir tavo SHELL skaito visas komandas ir vykdo jas vieną paskui kitą.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#hello-world",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#hello-world",
    "title": "14  Bash Skriptai 1",
    "section": "14.3 Hello World",
    "text": "14.3 Hello World\nPasileidus terminalą, susikurk norimoje vietoje direktoriją “learning_bash” naudojant mkdir. Su cd pereik į šią direktoriją. Kol dirbsime su bash skriptais, dirbsime iš šios direktorijos.\nDabar terminale paleisk NANO editorių ir sukuruk faila:\nnano hello_world.sh\nGriežtai žiūrint, .sh nėra reikalingas. Kompiuteris susiduręs su šiuo failu ir taip supras, ką jam daryti. Tačiau tam, kad kiti žmonės greitai pamatytų ir surpastų, jog tai skiptinis failas, įprastai naudoajamas .sh arba .bash.\nPačiame faile įrašyk\necho \"Hello world\"\nIšsaugok failą su Ctrl+s ir Ctrl+x\nAtspausdink su ls -l direktorijos turinį.\nKaip matai, šis failas neturi x taigi joks vartotojas neturi execution teisių. Naudojant sudo chmod 744 hello_world.sh suteik sau visas teises, paliekant grupei ir kitiems vartotojams tik skaitymo teises.\npasitikrink su ls -l ar tikrai turi visas reikiamas teises. Galimai dabar net skriptinis failas pakeitė spalvą ir tapo žalias (?).\nKaip dabar paleisti skirptą?\n./hello_world.sh\nPaleidus šį skriptą BASH interpretatorius skaito eilutę po eilutės ir vykdo komandas.\nTačiau šis skriptas dar nėra visai teisingas. Minėjau, jog failo indikatorius .sh nėra būtinas. tad kaip kompiuteris žino, jog tai skriptas? Įprastai (ir nuo šiol visada) mes pirmoje eilutė yįašome šebang #! kuris pasako SHELL interpretatoiui - “Hey, čia ne komentaras, o nurodymas, kokį interpretatoriu naudoti”. Kaip minėjau pačioje mokymų pradžioje, kai kuriuose kompiuteriuose gali būti BASH, ZSH ir kiti SHELL interpretatoriai. Komanduose jose gali šiek tiek skirtis (skirtingas dialektas, arba būdingos tam tikros komandos). Tam kad nekiltų problemų vykdant šį skriptą (angl. running script), mes nurodome koks būtent interpetatorius /bin/bash turėtų perskaityti ir vykdyti komandas.\n#!/bin/bash\n\necho \"Hello World\"\nSveikinu, tai pirmas pilnavertis tavo BASH skriptas. Pripažinkime, tai labai paprastas skriptas.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#kintamieji",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#kintamieji",
    "title": "14  Bash Skriptai 1",
    "section": "14.4 Kintamieji",
    "text": "14.4 Kintamieji\nKintamieji yra reikalingi tam, kad išsaugotų tam tikras reikšmes. Terminale išbandyk, tik gal įrašyk savo vardą. Svarbu, priešingai nei Python, BASH tarp kintamojo ir = negali būti space ir taip pat tarp = ir argumento!\nmanovardas=\"Justas\"\nmanoskaicius=14\nTol kol šita terminalo sesija rya aktivyi (ir tu neperrašei šių kintamųjų) jie bus pasiekiami tavo terminale. Išbandyk panaudoti šiuos kintamuosius naudojant echo komandą. Kad BASH žinotų, jog tu turi omenyje kintamąjį, reikia naudoti $ prieš kintamojo pavadinimą.Šis procesas vadinamas kintamųjų deklaravimu.\necho $manovardas\necho $manoskaicius\nO dabar pabandyk sudėti viską į vieną sakinį\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nPaskutinę komandą galėjome atspausdinti ir be \"\", tačiau jeigu naudotume '' nieko gero nesigautų. Išbandyk ir įsitikink\necho Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\necho 'Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius'\nŠtai todėl, dažniausiai ir naudojame \"\"\nKas nutiktu jeigu panaudtum kintamąjė, kuris nėra deklaruotas\necho $blabla\nOgi nieko. Bash tau neišmes klaidos ir atspausdins tiesiog tuščią vietą.\nPbanadyk uždaryti terminalą ir atsidaryk iš jį iš naujo. Pakartok komandą\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nir įsikitkink, jog kintamieji neišsisaugojo. Taigi, kintamieji kuriuos sukuri temrinalo sesijoje, glaioje tik toje terminalo sesijoje. Išjungus terminalą, ar restartavus kompiuterį - viskas dingsta.\nTam kad neprarasti kintamųjų, mes juos išsaugome kartu su komandomis skripto viduje. Su NANO sukurk naują skriptą apie_mane.sh\n#!/bin/bash\n\nmanovardas=\"Justas\"\nmanoskaicius=14\nmanoamzius='39'\n\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nŠiuo metu tavo skriptas yra begalo paprastas ir vienu žvilsniu suprantamas. Tačiau ilgainiui, tau gali reikėti pridėti komentarus, t.y. priminimus sau, arba paaiškinimus kitiems, kas vyksta kode ir t.t. Tam naudojami komentarai. Skritpuose komentarai pradedami # (nors gali naudoti ir kelis). Viskas į dešinė nuo # toje pačioje eilutė nebus interpretuojama kaip kodas, o BASH supras jog tai yra komentaras ir jo neskaitys.\nPridėkime kelis komentarus;\n#!/bin/bash\n# =====================================================\n# Data: 2024-10-30\n# Autorius: Justas Mundeikis\n# Paskirtis: Atspasdinti informaciją apie mane\n# =====================================================\n\n## Deklaracijos\nmanovardas=\"Justas\" # deklaruojamas vardas, pasikeisk į savo\nmanoskaicius=14 # deklaruojamas skaičius, pasikeisk į savo\nmanoamzius='39' # deklaruojamas amžius, pasikeisk į savo\n\n## Funkcijos\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nKaip matai, pridėjau skripto virųuje vaidnamą header (virtutinėje) dalyje, komentarus, kurie informuoja apie tai, kas, kada sukurė šį skriptą. Ar yra privalomi paminėti dalykai? Ne. Tačiau geroji praktika rodo, kad autorius, data ir paskirtis neretai rpaverčia net sau pačiamm atsidarius skriptus po kiek laiko, greičiau susigaudyti. Jeigu kažkada tavo skritpai taptų labai įmantrūs, tada komentaras header skiltyje galėtų būti dar išsamesnis, štai ChatGPT man pasiūlė net aprašyti kokie yra dependencies, pvz jeigu skriptas naudoja komanda,s kurios ali būti neinstaliuotos. Tada kitas vartotojas atsidaręs iškart matys ką turi instaliuoti, jog skriptas veiktų, o ne pirma paleidus skritpą ir sulaukus klaidos, ieškoti ko trūko.\n#!/bin/bash\n#====================================================================\n# Script Name: script_name.sh\n# Description: Briefly describe what the script does.\n# Usage: ./script_name.sh [options] [arguments]\n# Author: Your Name\n# Created Date: YYYY-MM-DD\n# Version: 1.0\n# Last Modified: YYYY-MM-DD\n# Dependencies: List dependencies like `curl`, `awk`, or other scripts.\n# Requirements: Any system requirements or permissions needed.\n# Notes: Additional helpful notes, warnings, or cautions.\n#====================================================================\nDabar tau gali kilti klausimas - o kodėl neparašius komandos, kad instaliuoti iškart šiuos dependencies? Nebent tavo skriptas yra skirtas programų instaliavimui ir kitas vartotojas tai supras ir tu tai dokumentavai, pvz README.md faile… nėra labai ger apraktika tiesiog paleisti instialiavią kažkieno kito kompiuteryje. Be to, tu negli būti tikra, ar tia Linux, ar MacOs sistema. O net Linux, gali būti naudoajmas ne apt programū menedžeris, o dnf ir t.t. Taigi, ir saugiau ir lengviau leisti tam tikruas programas susiinstaliuoti pačiam vartotojui.\nDabar tau gali kilti klausimas, kam reikaligi tie kintamieji? Viena pagrindini7 pri=a2i7, kam naudojami kinatiemiji, tia tma, kad i6vengti dagybinio perrašymo. štai pvz:\n#!/bin/bash\necho \"Linux is awesome\"\necho \"Android is awesome\"\necho \"Nextcloud is awesome\"\nJeigu šiame banaliame skipte nusprestume pakeisti žodį awesome į cool, tada tai reiktų daryti net trijose skirtingose eilutėse. O dabar įsivaizduok, kad tavo skriptas yra kelių šimtų eilučių ilgumo… Tam kad išvengti pasikarotimų, naudojami kintamieji, tad tokiu atveju užtenka pakeisti vieną kintamąjį vienoje eilutėje ir visame kode pasikeičia norimos riekšmės\n#!/bin/bash\nvar=\"awesome\"\necho \"Linux is $var\"\necho \"Android is $var\"\necho \"Nextcloud is $var\"\no dabar pakeiskime i cool\n#!/bin/bash\nvar=\"cool\"\necho \"Linux is $var\"\necho \"Android is $var\"\necho \"Nextcloud is $var\"\n\n14.4.1 Subshell\nKartais tau gali prireikti įvykdyti komandas ir jų rezultatą panaudoti. tam tu gali pasinaudoti bash skripte (aktyvioje shell aplinkoje), iššaukiant sub shell, tai gali padaryti su $(). [tik čia ne temrinale o skripte]\n#!/bin/bash\nfiles=$(ls)\necho $files\nKas čia įvyksta? kai shell skaito ir vykdo tavo skiptą, $() iššaukia subshell, šioje subshell įvykdoma ls komanda ir visas rezultatas spriskiriamas files kintamajam.\nŠtai kiek nauddinesgnis pavyzdys. Tarkime tu rašai skriptą ir nori pasinaudoti date komandą, su kuria jau susipažinau bash pagrindų skyriuoje. Takrime skiprto pačioje pradžioje bash turi sukurti direktoriją, kurios pavadinimas būtų šiandienos data, ne spvz tu į ta direktoriją patalpinsi šiandienos duomenis.\n#!/bin/bash\nnow=$(date)\necho \"Systemos data ir laikas yra:\"\necho $now\nIš esmės tai atitinktų\n#!/bin/bash\necho \"Systemos data ir laikas yra:\"\ndate\n## Aplinkos kintamieji\nKai kurie kintamieji yra deklaruoti automatiškai, kai tik prasideda tavo kompiuteriio sesija, štai keli jų\nŠie kintamieji nustatomi visai sistemai ir yra prieinami visiems procesams:\n\n$HOME – vartotojo namų katalogo kelias (pvz., /home/user).\n$USER – prisijungusio vartotojo vardas.\n$PATH – katalogų, kuriuose ieškoma vykdomųjų failų, sąrašas, atskirtas dvitaškiais.\n$SHELL – numatytojo terminalo kelias (pvz., /bin/bash).\n$PWD – dabartinis darbinis katalogas.\n$OLDPWD – ankstesnis darbinis katalogas (prieš cd komandą).\n$LANG – numatytoji sistemos kalba.\n$EDITOR – numatytasis teksto redaktorius (pvz., vim arba nano).\n$TERM – naudojamas terminalo tipas (pvz., xterm).\n$HOSTNAME – kompiuterio arba serverio vardas.\n\nKaip matai jie visi didžiosiomis raidėmis. tam kad atksirti, kurie kintamieji sukruti varotojo, kurie systemos, patarmaia savo kintamuosius rašyti mažosiomis raidėmis, o sisteminius kintamauosius tada galima atpažinti iš didžiųjųraidžių. bet tai labiau rekomendacija, kurios nėra privaloma laikytis.\nkokius visus aplinkos kintamuosius turi, gali pamayti terinae paleidus komanda env",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#matematinės-funkcijos",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#matematinės-funkcijos",
    "title": "14  Bash Skriptai 1",
    "section": "14.5 Matematinės Funkcijos",
    "text": "14.5 Matematinės Funkcijos\nexpr 2 + 2\nexpr 2 / 4",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#if-else",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#if-else",
    "title": "14  Bash Skriptai 1",
    "section": "14.6 IF ELSE",
    "text": "14.6 IF ELSE\nIki šiol tu susipažinai su tuo, kaip yra kuriami bash scriptai, tačiau iki šiol, tai nebuvo labai prasmingi skriptai. Daugumą jų, tu galėtum net greičiau atlikti tiesiog surašant reikaimas komandas Terminal lange. Tikroji skiptų galia pasirodo tada, kai skiprtas įgauna šiek tiek daugiau logikos. Vienas iš logikos veksmų, yra atlikti tam tikrus veiksmus, kai (if) tam tikra sąlyga yra išpildyta.\nŠtai pavyzdys nano if_clause.sh\n#!/bin/Bash\nmy_num=200\n\nif [ $my_num -eq 200 ]\nthen\necho \"The condition is true\"\nfi\nchmod 744 if_clause.sh\n\nmy_num=200 susikuriam kintamajį, prieš kurį validuosime logiką\nif pradeda, of fi uždaro if bloką\n[ &lt;logika&gt; ] po ir prieš kvadratinius skliaustelius turi būti !!!\n$my_num -eq 200 testuojama ar kintamasis yra lygus (-eq) 200\n\njeigu taip, einame į then\n\n\nelse nėra būtinas. Jeigu sąlyga atitiks testą (loginis testas gražins True), tada skritpas įvykdys tai, kas yra numatyta then dalyje. Jeigu loginis testas gražins False skriptas žiūrės ar yra ar yra else jeigu ne, šis loginis testas bus nutrauktas ir bash skaitys skiptą toliau.\nPakeiskime nano if_clause.sh\n#!/bin/Bash\nmy_num=200\n\nif [ $my_num -eq 100 ]\nthen\n  echo \"Number is 100\"\nelse\n  echo \"Number is 200\"\nfi\nŠauktukas apsuka loginį testą. Jeigu loginis testas grąžintų TRUE, tada ! TRUE tampa FALSE\nmy_num=200\n\nif [ $my_num -eq 100 ]\nif [ ! $my_num -eq 100 ]\nVisgi šauktukas gali būt kiek sudėtingiau suprantamas, tad kur kas geriau naudti -ne , kas reikia not equal\nŠiek tiek galimų variantų:\n\n-eq ==\n-ne !=\n-gt &gt;\n-ge &gt;=\n-lt &lt;\n-le &lt;=\n\nBet yra ir kitų testų:\n\n[ -f &lt;failas&gt;] patikrina, ar failas egzituoja, jeigu taip, loginis testras gražina true\n\nsukurk šitą skirptą pavadinimu test_if_file_exists.sh, kuris testuoja ar failas test_file egizstuoja. suteik execute teises ir paleisk jį.\nif [ -f test_file ]\nthen \necho \"test_file exists\"\nelse\necho \"test_file does not exist\"\nfi\ndabar terminale naudojant touch komandą sukurk šį failą ir išbandyk, ar pakito tai, ką gražina šis skirptas. su rm ištrink failą ir dar kartą išbandyk skriptą, dabar jis turėtų gražinti informaciją, jog failas neezgistuoja. Ar pavyko?\nKokių dar yra testų?\n\n-d ar direktorija egiztuoja\n-f ar failas egistuoja\n\nwhich komandą tu jau pažinai pirmuose skyriuose, ji parodo, kur randasi proogramos binarinis kodas.\nwhich bash\nBet jeigu tu įrašai pvz which htop ji nieko negražins, nes tikėtina, tu dar nesi instaliavusi šios programos! išbandyk which htop. htop yra sistemos monitoringo progframa, kuri parodo kiek procesocoairuas, darbinėįs atminties dabar tavo kompiuteris naudoja, kurie procesai tai daro ir.t.t. tam tikr aprasme tai task manager, kurį galbūt pameni iš Windows.\nKo gero jau nujauti, kas bus dabar? Tu moki valdyti logiką, tu moki patikinrti ar programa aptinkama kompiuteryje… tad dabar pažiūrėkime, kaip galima išnaudoti bash skriptus ir instlaiuoti trūkstamas programas.\nnano install_requirements.sh\n#!/bin/bash\n\nbinary=/usr/bin/htop\n\nif [ -f $binary ]\nthen \necho \"htop is present\"\nelse\necho \"htop is not present. Installing it now\"\nsudo apt update && sudo apt install htop -y\nfi\nSuprantama, šiuo metu tai vis dar nėra labai prasmingas, nes tu turi žinoti, kurioje vietoje turėtų būti instaliuotas htop.\nBet tu jau moki iššaukti subshell ir jos rezultatus priskirti kintamajam. Ką reiktų viršuje esančiame skripte pakeisti? Būtent, panaudokime which kuri sukurs binary kintamąjį, kurio vertė arba bus tuščia, jeigu htop binary nėra sistemoje, arba su adresu binary failo.\n#!/bin/bash\n\nbinary=$(which htop)\n\nif [ -f $binary ]\nthen \necho \"htop is present\"\nelse\necho \"htop is not present. Installing it now\"\nsudo apt update && sudo apt install htop -y\nfi\nBet kas dabar negarai su šiuo kodu? mes 3 kartus parašome tą patį htop\n[]\nPabandykime pakeisti ir optimizuoti kodą. kaiskime htop kintamuoju, kuriam priskirsime pavadinimą htop.\n#!/bin/bash\n\nprogramm=htop\nbinary=$(which $programm)\n\nif [ -f $binary ]\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nNuostabu, dabar jeigu nuspręstum pakeisti programos pavadinimą į kokią nors kitą, tau tereiktų skripte atnaujinti tai vienoje vinetinleėje vietoje!\nGalima ir šiokia tokia variacija. Jeigu atsisakysime testo, ar failas egzistuoja, galima supraprastinti loginį testą iki to, ar komanda egzistuoja su command -v.\nPrieš taisant skriptą išbandyk temrinale command -v htop ir command -v abc. Jeigu argumentas (komanda) egzistuoja, temrinal gražins binary, jeigu ne, tada ne.\n#!/bin/bash\n\nprogramm=htop\n\nif command -v $programm\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nar galėtume command pakeisti which? TAIP!\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nbet abiems atvejais… mes gaunam kelią į binary, jeigu jis egzistuoja. Galbūt mes to nenorime. Ar pameni, stdin, stdout ir stderror ir jų nukreipimus? padarikime taip, which $programm atsakymą nukreipkime į /dev/null, tam, kad skirptas negrąžintu nieko mums.\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm &gt;/dev/null 2&gt;&1\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nSVEIKINU! tu parašei pirmą, ganėtinai prasmingą skriptą. Gerai pagalvok ir sudėliok kelis scenarijus, kaip galėtum tai panaudoti ateityje? Kaip galbūt reiktų papildomai pakeisti šį ar panašų skriptą? Aptark!",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#išeities-kodai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#išeities-kodai",
    "title": "14  Bash Skriptai 1",
    "section": "14.7 Išeities kodai",
    "text": "14.7 Išeities kodai\nKiekvieną kartą, kai tu paleidi kažkurią komandą, ji arba suveikia, arba ne. Jeigu ji suveikia, tu pamatai aiškų tikimasi rezultatą. Jeigu ne, dažniausiai bash tave informuoja apie problemą. Tačiau tau nematant, kiekvienos komandos įvykdymas sugeneruoja ir tam tikrus išeities kodus (exit codes), ty skaičius, kuris turi tam tikrą reiškmę. Ši elgsena nėra reta IT pasaulyje, pvz įvedus netinkama URL adresą, neretai gali išvyst 404\n[404]\nPanašiai ir BASH. Po kiekvienos komandos įvykdymo, bash sukuria kintamajį, su išeities kodu. Paskutinis išeities kodas galima pamatyti su echo $?\nls\necho $?\nls tralala\necho $?\n\nišeities kodas 0 reiškia, jog nebuvo jokių klaidų\nvisi kiti kodai, reiškia, jog buvo kažkokia klaida\n\nDabar gali pagalvboti, kaip galėtum derinti išeities kodus su if [ exit_code -eq 0] arba if [ exit_code -ne 0]\nšiame skripte:\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm &gt;/dev/null 2&gt;&1\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nŠioje vietoje, ko gero prasmingiausia būtų atspausdinti, ar $prgramm instaliavimas buvo sėkmginas ar ne.\n::: Praktikumas\nsukurt antra if clause skripte, kuris atspausintų pranešimą, ar programa buvo ar nebuvo sėkmingai instaliuota. Tačiau gerai pagalvok apie logiką. Jeigu tu idėsi antrą if clause po pirmojo, tada antrassis if vertins tiek išeities kodą kai programa egistuoja, tiek kai programa neegistuoja ir einama instaliavimo keliu\npapildomas reikalavimas, pagalvok, kaip apdaryti, jog temrinale nebūtų spausdinami apt update ir apt install pranešimai, kurie užildo visą terminalo langą. apt update tu gali drąsiai pasiųsti į /dev/null, tačiau install pranešimus, tu norėtum nusiųsti į script.log failą, jog bet kada galėtum pamatyti,kas vyko. Suprantama, tu nenori, kad failas būtų kaskart perrašomas, o kauptų istoriją.\nTaigi tavo logiką turėtų atrodyti daug maž taip.\n[caldidraw]\nišinstaliuok htop ir su skruptų vėl sintaliuok, tada pakeisk scriptą, kad paketas btūtų “notexist”. peržiūrėk log failus su cat. :::\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm &gt;/dev/null 2&gt;&1\nthen \n        echo \"$programm is present\"\nelse\n        echo \"$programm is not present. Installing it now\"\n        sudo apt update &gt;/dev/null 2&gt;&1 && sudo apt install $programm -y &gt;&gt; \n        if [ $? -eq 0 ]\n        then \n                echo \"Installation of $programm was successfull\"\n        else\n                echo \"Installation of $programm was not successfull\"\n        fi\nfi\njeigu nori pašalinti htop ir pažiūrėti kaip veikia skriptas gali naudoti sudo apt remove htop -y",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#while-ciklai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#while-ciklai",
    "title": "14  Bash Skriptai 1",
    "section": "14.8 WHILE ciklai",
    "text": "14.8 WHILE ciklai\nIki šiol tu išmokai IF ciklą, IF TRUE THEN DO ELSE DO THAT. Tai labai galingas ciklas, nes jis įgalina taov skriptą veikti logiškai. Jeigu programos X nėra, skiprtas ją instaliuota, jeigu ji yra, tai jos instaliuoti nereikia. Tačiau tai nevienintinlis ciklas. Kitas ciklas yra WHILE. WHILE (angl kol), veikia tol, kol tam tirka salyga yra teisinga.\npvz. kol lyja neiti iš namų. Toks ciklas reišktų, kad tu neinit tol iš namų, kol lyja. bet tik nustos lyti, tu galėsi eiti iš namų. Bet čia tu matai ir jau vieną problemą, WHILE ciklai gali būti pavojingi, tu juk nenori eiši iš namų 3 nakties?.\n[lunatic]\nŠtai pavyzdys, kurį aptarsime išsamiau run_while.sh:\n\npirma sukuriame kintamąjėį var ir priksieame jam reikšmę 1\ntad apaleidžiame WHILE ciklą, kuris testuoja ar var &lt;=15 ir kol taip yra WHILE paleidia savo cikla\nWHILE ciklas pradedas do ir užbaigiamas done\ncikle atspausdinamas var\nbet tam kad var neliktų 1, reikia jį inkrepemtuoti (padidinti vienetu), tam man iš sukuriame naują įvertį, prie $var prideda 1 Ėvar +1, bet liepiema tai apdaryti subshell $(), tačiau tu matai, jog šįkart mes panaudojaom dvigubus skliaustelius $((…)), taip rya todėl, nes\nsleep 0.5 priverčia kompiuterėį pauzuoti pusę sekndunės tarp kiekvieno ciklo, tam kad tu geriau matytum jog tai pavieniai ciklai\nkai var pasieks 16, tada while taps FALSE ir ciklas nepasileis\n\n#!/bin/bash\n\nvar=1\n\nwhile [ $var -le 15 ]\ndo\n        echo \"$var\"\n        var=$(($var +1))\n        sleep 0.5\ndone\necho \"While ciklas baigtas\"\naltrernatyva naudoti gryną aritmetika ((var++)) čia pvar++ reiškia, jog paimamas var kintamais ir padidinaimas vientu ir tada rezultatatas priskiriamas tam pačiam var kintamajam.\n#!/bin/bash\n\nvar=1\n\nwhile [ $var -le 15 ]\ndo\n        echo \"$var\"\n        ((var++))\n        sleep 0.5\ndone\necho \"While ciklas baigtas\"\nKitas pvz.\n#!/bin/bash\n\ntouch ~/testfile\n\nwhile [ -f ~/testfile ]\ndo\n        echo \"$(date) Failas egzistuoja\"\n        sleep 1\ndone\necho \"$(date) Failas nebeegizstuoja\"\nO dabar kitame terminale, su rm testfile panaiking failą\nSualvbok bent 3 scenarijus, kada tu pasirinktum naudoti WHILE ciklus?\nŠtai mano keli scenarijai. Tiesa, kai kuriuos iš jų, būtų lengviau suprogramuoti su Python nei su bash\n\nKol naktis, tol išjungiamas internetas namuose (while + date)\nKas 24 valandas parsiųsti vilniaus temperatūrų prognozes (while + sleep )\nKai namuose atsiranda vaiko telefonas (pasijungia prie wifi, išsiųsti žinutę tėvams). Tai daryti kas 15min, kol tėvų išmaniųjų telefonų nėra namuose. (while + ping + sleep)\nKai namų serverio procesoriaus temperatūra pakylą virš XX C, išsiųsti pranešimą apie kaistantį procvesorių per Telegram.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas",
    "title": "14  Bash Skriptai 1",
    "section": "14.9 Praktikumas",
    "text": "14.9 Praktikumas\nParašyk universal_update.sh skriptą.\n\nif [ -d /etc/pacman.d ]\nthen\n  sudo pacman -Syu\nfi\n\nif [ -d /etc/apt ]\nthen \n  sudo apt update\n  sudo apt full-upgrade -y\nfi\n\nosr=/etc/os-release\nif grep -qi “ubuntu” /etc/os-release\nUžduotis, surask kokios dar versijos egzituoja ir kokios komandos atnaujintų sistemą. Paisnoaudok tam chat gpt\n||\nif grep -qi “ubuntu” $osr || grep -qi “debian” $osr\n\n|| OR\n&& AND",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#for-ciklai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#for-ciklai",
    "title": "14  Bash Skriptai 1",
    "section": "14.10 FOR ciklai",
    "text": "14.10 FOR ciklai\nJau moki IF clause, kuris įvyką vieną ciklą jeigu salyga teisinga, bei WHILE ciklą, kuris nuolat sukasi tol, kol sąlygos testvimas gražina TRUE. Tačiau kartais tau nereikia kad skritpas suktūsi be galo, o tik tam tikra ciklų skaičių. Tuo tiklsu naudojami FOR ciklai.\nskaiciai_1_10.sh\n#!/bin/Bash\n\nfor nr in 1 2 3 4 5 6 7 8 9 10\ndo \n  echo $nr\n  sleep 0.5\ndone\necho \"Finished\"\nKas čia vyksta?\n\nfor pradeda for ciklą, o do ir done, kaip ri while cikle apibrėžia ciklo ribas\nnr sukuria kintamąjį kuris yra in sekoje. pirmą karta nr priims vertę 1, antra karta 2, ir t.t. kol apsieks paskutinę vertę - 10\n\nTiesa, toks skaičių išrašymas yra labai neefektyvus. Skaičių seką tu gali sukurti {1..10}. Pabandyk\nBet skaičiai nėra vienintelis kintamojo reikšmė, kuri gali būti naudojami it tekstinai kintamieji.\n#!/bin/Bash\n\nfor nr in 'uobolys' 'citrina' 'mangas'\ndo \n  echo $nr\n  sleep 0.5\ndone\necho \"Finished\"\n#!/bin/bash \n\nfor file in zip_files/*.zip\n\ndo \n  zip $file.zip\ndone\n#!/bin/bash \n\nfor file in zip_files/*.zip\n\ndo \n  unzip file\ndone\n#!/bin/bash\n\n# File containing the URLs\nfile=\"urls.txt\"\n\n# Loop through each line in the file\nfor url in $(cat \"$file\"); do\n    echo \"Fetching $url\"\n    curl -O \"$url\"  # Use -O to save the file with the same name as the remote file\ndone\n\necho \"All URLs have been processed.\"",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#kur-saugoti-skriptus",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#kur-saugoti-skriptus",
    "title": "14  Bash Skriptai 1",
    "section": "14.11 Kur saugoti skriptus?",
    "text": "14.11 Kur saugoti skriptus?\nFHS flilesysteh hierachy standard\n/usr/local/bin\nsudo mv &lt;scriptane.sh&gt; /usr/local/bin  sudo move update.sh /usr/lcoal/bin/update taigi be sh\nptiktinkime teises, matome, kad teisės yra vartotojo, tad pakeiskime į root\nsudo chown root:root /usr/local/bin/update\n.sh failo pratęsimas (file extension) yra skirtas labiau vartotojui, nei kad kompiuteriui. Tai šiek tiek skiriasi nuo Microsoft Windows,, kur failo tipoas yra pivalomas.\nKas įvyksta: /usr/local/bin guli tavo PATH kelyje, kur linux tirkina ar yra tam tikri failai… tad kai tu terminale įrašai tiesiog update bash eidamas per visas direktrijas numatytas PATH, randa update ir jį įvyko. jeigu paliktum update.sh, tai nesuveiktu.\nštai pvz. perkelk šituos du skriptus į /usr/local/bin viena pavading call_1 kitą call_2.sh, suteik root privilegijas ir dabar temrinale įrašyk call_1, call_1sh, call_2, call_2.sh\n[rezultatas]\nir dabar šį skritpą gali nukopijuoti į bet kokį kitą linux kompiuterį. sugalvok 2-3 skirptus, kurie būtų rpamsingi tavo ir kitų kompiuteriuose?\nenv sąraše pamatysi path bet gali path iššaukti ir taip. which komanda pereina per šias direktrijas, kai iešįko programos binary failo. pvz which htop.\nkas, jeigu /usr/local/bin nera path? tokiu atveju tu galėtum pridėti:\nexport PATH=/usr/local/bin:$PATH\nbet dabar tau to tikėinta daryti nereikia. Tačiau turėk omenyje, kad taip pridedamos vietos prie path, ir ateityje nauddoajnt tam tikras programas, tavo path gali prailgėti.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#data-streams-stdin-stdout-stderror",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#data-streams-stdin-stdout-stderror",
    "title": "14  Bash Skriptai 1",
    "section": "14.12 Data Streams (stdin, stdout, stderror)",
    "text": "14.12 Data Streams (stdin, stdout, stderror)\nTrumpas priminimas apie data streams stdin stdout ir stder\nJau žinai, kaip galima atpažinti klaidas, taip pat žinai, jog su echo $? gali atspasdinti paskutinės komandos išeities kodą. Tačiau būna atveju, kai tavo komanda gražina tiek stdout tiek stderr vienu metu.\nštai geras pvz, jeigu ieškai failo\nfind /etc -type f\nir išbandyk echo $?\nPaskrollinus terminale, tu rasi daug įrašu, kuriuos gali matayti, bet lygiai taip pat pamatysi įrašy, kur Permission denied, nes kamndą įvykei ne su sudo ir neturi pakankamai priveligejų. Taigi šiuo atveju gravai ir stdout ir stderr viename lange!\nTu jau žinai, jog komandos išvestis galima nukreipti, tad šiuo atveju, nukreipk klaidas į /dev/null\nfind /etc -type f 2&gt;/dev/null\nir išbandyk echo $? Kaip matai, paskutinė komanda nebuvo įkydyta be klaidų, tačiau klaidų tu nematei, nes jas nusiuntei į /dev/null.\nO dabar išbandyk nusiust sdtdout į /dev/null, tam kad pamatytum, kuriems failams tu neturi prieigos teisių\npritayk šias žinias\n#!/bin/bash\nrelease_file=/etc/os-release\nlog_file=/var/log/updter.log\nerror_log=/var/log/updater_error.log\n\nif grep -qi 'arch' $release_file\nthen\n  sudo pacman -Syu 1&gt;&gt;$log_file 2&gt;&gt;$error_log\n  if [ $? -ne 0 ]\n  then echo \"Error occured\"\n  fi\nfi\n\nif grep -qi 'debian' $release_file || grep -qi 'ubuntu' $release_file\nthen \n  sudo apt update 1&gt;&gt;$log_file 2&gt;&gt;$error_log\n   if [ $? -ne 0 ]\n  then echo \"Error occured\"\n  fi\n  sudo apt full-upgrade -y 1&gt;&gt;$log_file 2&gt;&gt;$error_log\n  if [ $? -ne 0 ]\n  then echo \"Error occured\"\n  fi\nfi\nO kaip apie stdin?\n#!/bin/bash\n\necho \"Echo please enter your name\"\nread myname\necho \"Hello $myname, how is your day?\"\nŠiuo atveju read iššaukia stdin, t.y. kad varotojas įrašytų kažką klaviatūra. Tai kas įrašyta, mes galime prisikrti kintamajam ir toliau jį naudoti.\nPabandyk. Šiame pvz neveikia logika {$x..$y} nes {} priima tik skaičius, ne kintamuosius, todėl pasitelksime kitą funckiją seq\n#!/bin/bash\n\necho \"Nuo kokio skaičiaus skaičiuosime? \"\nread x\necho \"Iki kokio skaičiaus skaičiuosime? \"\nread y\n\nfor i in $(seq $x $y)\ndo\n    echo $i\n    sleep 0.5\ndone",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#funkcijos",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#funkcijos",
    "title": "14  Bash Skriptai 1",
    "section": "14.13 Funkcijos",
    "text": "14.13 Funkcijos\nhttps://www.cloudbooklet.com/developer/how-to-create-and-use-bash-functions-in-linux\nJeigu tu kažką parašei jau du kartus - geras ženklas, jog tai turėtų būti funkcija, o ne tieiosg kodas.\nŠi filosofija labai gerai apibūdina prorgramavimą bendrai, tiek bash, python, R ir t.t.\nPeržiūrėk ką tu pakartojai update skripte? sudo nano /usr/local/bin/update\n[]\nTu gali refaktorizuoti dalį kodo, kuri kartojasi panaudojant funkciją\ncheck_exit_status() {\n  if [ $? - ne 0 ]\n  then ....\n  fi\n}\ndabar kodas atrodo taip\ncode",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#case",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#case",
    "title": "14  Bash Skriptai 1",
    "section": "14.14 CASE",
    "text": "14.14 CASE\n#!/bin/bash\n\necho \"Kaip tavo diena?\"\necho \"1 - nelabai gera\"\necho \"2 - nei gera, nei bloga\"\necho \"3 - labai gera\"\necho \"įrašyk skaičių\"\n\nread value\n\ncase $value in\n  1) echo \"Gal pakalbam?\";;\n  2) echo \"Papasakok\";;\n  3) echo \"Kaip faina, pasidalink!\";;\n  *) echo \"Gal pabandyk dar kartą, tarp 1 ir 3?\"\nesac\nKaip matai, pabandius vieną kartą skritpas pasibaigia. Bet įrašius 999 ir gavus pasiūlymą bandyt dar kartą. Šioje vietoje, tau labai rpaverstų while ciklas. Pagalvok, ką būtų galima čia pakeisti? O tada žiūrėk į atsakymą žemiau\n#!/bin/bash\n\npabaiga=0\n\nwhile [ $pabaiga -eq 0 ]\ndo \n\necho \"Kaip tavo diena?\"\necho \"1 - nelabai gera\"\necho \"2 - nei gera, nei bloga\"\necho \"3 - labai gera\"\necho \"įrašyk skaičių\"\necho \"kai norėsi pabaigti, parašyk 'stop' \"\n\nread value\n\ncase $value in\n  1) echo \"Gal pakalbam?\";;\n  2) echo \"Papasakok\";;\n  3) echo \"Kaip faina, pasidalink!\";;\n  stop) pabaiga=1\n  *) \"Gal pabandyk tarp 1 ir 3 arba stop\"\nesac\ndone\n\nTu - katinas Leopoldas, kuriam priklauso kačių kavinė. Kavinėje dirba 4 katės: Luci, Nora ir Bumas ir Floras. Jie priima užsakymus. Tiesa, kačių kavinės meniu nera didelis, svečiai gali pasirinkti “Ledai”, “Pyragas”, “Kava”. Ledai kainuoja 2.5, Pyragas 4.5, p kava tik 2 eurus. Kačių kavinės savininko - Leopoldo noras, dienos pabaigoje pamatyti, kur iš kačių aptarnavo daugiausiai ir kiek ko buvo parduota. Leopoldo lūkestis matyti tokius duomenis, pvz:\ndata,laikas,katė,produktas,kaina 2024-10-01,10:00,Luci,Kava,2.0 2024-10-01,10:00,Luci,Pyragas,4.5 2024-10-01,10:30,Floras,Ledai,2.5\nLeopoldas - nusprendė jog planšetėje paleis skriptą, į kuri kačių kavinės personalas galės suvesti ir tai bus labai didelis palengvinimas vedant apskaitą. Bet kad nepakrauti kačių, jis nusprendė jos jos suves tik: vardą ir kas buvo parduota. Kaina ir laikas - turi būti sugeneruoti automatiškai.\nŠiame projekte naudok case, while, if, echo, &gt;&gt; po visos dienos, Leopoldas tikisi rasti failą “pardavimai.csv”\nKai pabaigsi projektą, suvesk atlik bent 10 įvedimus už kates, o tada naudojant Excel arba LibreOffice Calc, importuok duomenis ir atvaizduok juos.\n\n\nSugalvok bent 2-3 kitas idėjas panašiames skriptams. Tada trumpai ant popieriau lapo nupaišyk logiką, kaip veiktų skriptas, kokios dalys būtų, kur būtųš if, while, for, case….\n\n#!/bin/bash\n\nwhile true; do\n  value=$(whiptail --title \"Dienos nuotaika\" --menu \"Kaip tavo diena?\" 15 60 4 \\\n    \"1\" \"nelabai gera\" \\\n    \"2\" \"nei gera, nei bloga\" \\\n    \"3\" \"labai gera\" 3&gt;&1 1&gt;&2 2&gt;&3)\n\n  exitstatus=$?\n  if [ $exitstatus = 0 ]; then\n    case $value in\n      1) whiptail --msgbox \"Gal pakalbam?\" 8 45;;\n      2) whiptail --msgbox \"Papasakok\" 8 45;;\n      3) whiptail --msgbox \"Kaip faina, pasidalink!\" 8 45;;\n    esac\n  else\n    break\n  fi\ndone",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#cron",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#cron",
    "title": "14  Bash Skriptai 1",
    "section": "14.15 CRON",
    "text": "14.15 CRON\nAutomatinis paleidimas (sheduling) yra labai svarbus konceptas. Prieš atsirandant tokiems instrumentams kaip Airflow, duomenų inžinieriai anksčiau automatizuodavo darbus manualiai su CRON. Nemažai įmonių ir dabar, CRON vis dar naudojamas automatizuoti tam tikrus darbų paleidimus. Bet ir asmeniniame kompiuteryje ar namų serveryje CRON yra labai naudingas instrumentas. CRON yra automatiškai įdiegtas visuose Linux sistemose. Tačiau rekomenduoju apsitikrinti, ar tu jį turi su which cron. taip pat išbandyk, ar turi at su which at. Jeigu neturi, instaliuok!.\nat komanda yra labai paprasta. Ką ji padaro, tai tiesiog suteikia galimybę paleisti tam tikrą komandą tam tikru metu Susikurk šitą skriptą example_for_at.sh\n  GNU nano 7.2                                                            example_for_at.sh                                                                     \n#!/bin/bash\nlogfile=at_logfile.log\n\nfor i in {1..10}\ndo \necho \"This is $i run at $(date)\" &gt;&gt;$logfile\nsleep 1\ndone\nsuteik execute teises su chmod 744 example_for_at.sh\nišabndyk prirmą skriptą manualiai ir su cat įsitikink, jgo skriptas iš tiesų veikia ir nėra jokių klaidų.\no dabar su at pasirink kada paleisti skriptą. Pasirink laiką, tarkime už kelių miniučių nuo dabar, kad nereiktų ilgai laukti ir pamatyti, jog iš tiesų at suveikė. Nepamiršk su rm ištrinti senajo log failo. Ir nurodyk atitinkmą kelią, arba absoliutų arba relatyvų.\nat 10:00 -f ~/example_for_at.sh\nJeigu nori pamatyti, kokie darbai yra suplantuoti:\natq\nČia pamatysi job id, kurė galėsi ištrinti su atrm &lt;id&gt;\nTarkime nori suplanuoti tiklsiesnę datą\nat 10:00 2024-12-31 -f ~/example_for_at.sh\nat yra patogi komanda, bet ji paleidžia komandą ar skriptą tik vieną kartą. Ir tai ali būti nepakankama, nes pvz,, galbūt tu nori, jog duomenys parsisiųstų kasnakt? O galbūt, kad kiekvieną sekmadienį tavo Downloads direktorijije esantys failai būtų perkeltį į namų serverį / Nextcloud, tam kad turėti jų atsarginę kopiją?\ncron\nfully qualified path for commands ir kodėl jas reikia naudoti cron paruoštiems skriptams, bet galbūt geriau ir bendrai visada.\n\ncron gali veikti ne shell\nkas nros gali sukurti komanda vz kaip ems update ir tik ją pavadint, pvz echo ir tada pekitus path, cron galėtų paimti tą komandą…\n\nTačiau prieš pradedant automatizuoti\ncrontab -e iššaukia crontab editorių pasirink teksto editorių su kuriuo norėsi dirbti. rekomenduoju - NANO. Atsidarius crontab -e nemžą dalį ekrano užimo komentarai (#). Juos galima ištrinti, tam, kad netrukdytų. Po eilutę NANO editoriuje galima ištrinti su Ctrl+k.\nKaip atrodo crontab eilutė:\n\n\n\n\n\n\n\n\n\n\n\nKą tai reiškia.\n* - reiškia bet kokią reikšmę, arba “kiekvieną”. jeigu * pailikta ties minute, tai reikš kiekvieną minutę, jiegu ties valanda - kiekvieną valandą ir t.t. , - naudojamas atksirti reikšmes pvz 0,9,18 ties valandomis riekšų jog cron užduotis pasileis vidurnaktį, 9 valandą ryto ir 18 valandą vakaro. - - naudoajmas nurodyti diapazoną, pvz 10-20 reikštų nuo 10 iki 20 minutės. / - reiškia žingnsius. pvz */5 ties minutės reiktų jog cron darbas paleidžiamas KAS 5 minutes\nRekomenduoju iššisaugoti https://crontab.guru/ šiame tinklapyje galima rasti skaičiuoklę, kuri padeda pagaminti norimą laiko pasirinkimą. Tačiau štai keli pvz:\n\n@reboot: kaskart restartavus kompiuterį (labai dažnai naudojama valymo darbams)\n@hourly : kas valandą (priklausomai nuo tada kada buvo įjungtas kompiuteris arba pirmą kartą pasileido cron užduotis).\n\nIš kurio vartootojo paskyros paleidžiamas cron darbas?\njeigu tu aktyvyuoji cron editorių be sudo, tu suplanuoji savo vartotojo cron darbus. tačiau gali naudoti sudo crontab -u &lt;username&gt; -e jeigu nori nustatyti cron darbą tam tikram vartootjui&lt;username&gt;.\nCron jobs are scheduled tasks managed by the system, independent of currently logged-in users. Thus, the cron job you scheduled for your user with crontab -e will run according to the specified schedule, regardless of which user is currently logged in. The job will execute with your user’s permissions, not the permissions of the logged-in user.\ncrontab -e:\nWhen you invoke crontab -e without sudo, you’re editing the cron jobs for your own user account. Any tasks you schedule will run with your user’s permissions, and the jobs will only affect your user environment. This means the cron jobs will only be able to access files and execute actions that your user has permission for. sudo crontab -e:\nUsing sudo with crontab -e allows you to edit the cron jobs for the root user. This means the tasks scheduled will run with root-level permissions. The cron jobs in this context have elevated privileges, which allows them to perform actions across the entire system, access files, and execute commands that would typically require superuser access. This is useful for scheduling tasks that need administrative privileges, such as system maintenance tasks or jobs that affect multiple users or system-wide settings.\n\nĮsivaizduok, jog tu turi bash scriptą, kuris patikrina, ar darbinis serveris veikia gerai. Skriptas prasisuka per 30 sekundžių. Todėl tu nusprendei, jog siekiant kokybiško monitoringo, tu ji paliesi kas 5 minutes kasdien. Darbo valandos tavo įmonėje 8-17, tačiau kadangi skriptas monitorina serverio užžimtumą, tu nori pamantyti ir 7 bei 18 vlaandos rodiklis, tam kad turėti palyginimą. Kitomis valandomis, tu nenori jog tavo skiprtas veiktų, nes visgi tam naudojama elektra o ir poreikio naktiniam monitoringui tu šiuo metu neturi. Tas pats pasakytina ir apie savaitgalius.\nParašyk paprasta bash scriptą, kuris naudotų: …..\nTavo norimi duomenys turėtų būti išsaugomi server_x.log faile ir turėtų turėti tokią struktūrą\n|date|time|cpu|memory|\n\n14.16 Argumentai\nTu jau žinai, jog komandos priima argumentus, pvz ls -l Downloads priima argumenta Downloads ir atspausdina šios direktorijos turinį. Lygiai taip pat, tu gali naudoti argumentus ir bash skriptams, jeigu nori, suteikti daugiau fleksibilumo jiems.\ntest_script.sh\n#!/bin/bash\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\n$1 reikiškia pirmą argumentą, kuris paduotas kartu su sciptu\n\n./test_script.sh Linux GNU Intell\nTačiau kas nutinka, jeigu vartotojas nenurodė argumento, nors jio buvo tikimasi\n./test_script.sh Linux GNU Intell\natrodo keistai.\nKaip galima tai išsrpęsti, tai naudoti if ir $# šis kintamasis parodo, kiek argumentų paduota skriptui.\n\nif [ $# -ne 3 ]\nthen\necho \"This script requires exactly 3 arguments and you provided $#\"\necho \"pabandyk dar kartą\"\nexit 1\nfi\n\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\nParašyk skriptą, kuris jeigu paduotas be argumento, parodys sekančių 7 dienų orų prgonozę Vilniui. Bet galimi argumentai gali būti vilnius, kaunas, klaipeda. priklausomai nuo argumento, turėtų būti parodomi atitinkami duomenys.\n\n\n\n14.17 Praktikumas: Serverio Backup skritpas\nhttps://cameronnokes.com/blog/the-most-useful-bash-commands-for-front-end-development/",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#argumentai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#argumentai",
    "title": "14  Bash Skriptai 1",
    "section": "14.16 Argumentai",
    "text": "14.16 Argumentai\nTu jau žinai, jog komandos priima argumentus, pvz ls -l Downloads priima argumenta Downloads ir atspausdina šios direktorijos turinį. Lygiai taip pat, tu gali naudoti argumentus ir bash skriptams, jeigu nori, suteikti daugiau fleksibilumo jiems.\ntest_script.sh\n#!/bin/bash\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\n$1 reikiškia pirmą argumentą, kuris paduotas kartu su sciptu\n\n./test_script.sh Linux GNU Intell\nTačiau kas nutinka, jeigu vartotojas nenurodė argumento, nors jio buvo tikimasi\n./test_script.sh Linux GNU Intell\natrodo keistai.\nKaip galima tai išsrpęsti, tai naudoti if ir $# šis kintamasis parodo, kiek argumentų paduota skriptui.\n\nif [ $# -ne 3 ]\nthen\necho \"This script requires exactly 3 arguments and you provided $#\"\necho \"pabandyk dar kartą\"\nexit 1\nfi\n\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\nParašyk skriptą, kuris jeigu paduotas be argumento, parodys sekančių 7 dienų orų prgonozę Vilniui. Bet galimi argumentai gali būti vilnius, kaunas, klaipeda. priklausomai nuo argumento, turėtų būti parodomi atitinkami duomenys.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas-serverio-backup-skritpas",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas-serverio-backup-skritpas",
    "title": "14  Bash Skriptai 1",
    "section": "14.17 Praktikumas: Serverio Backup skritpas",
    "text": "14.17 Praktikumas: Serverio Backup skritpas\nhttps://cameronnokes.com/blog/the-most-useful-bash-commands-for-front-end-development/",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html",
    "href": "d_bash_skriptai/14_bash_scripts_2.html",
    "title": "15  Bash Skriptai 1",
    "section": "",
    "text": "15.1 Kam man reikalingi BASH skriptai?\nKai administruoji (prižiūri) kompiuterius, arba nori automatizuoti tam tikrus procesus savo kompiuteryje, BASH skriptai tampa nepaimainoma pagalba. Štai keli pvz. perinstaliavus Linux, tu gali paleisti skriptą, kuris automatiškai instaliuos visas tavo naudojamas programas bei atstatys tavo nustatymus. O galbūt tu nori, kad kartą per savaitę failai esantys tavo Downloads direktorijoje susitvarkyt ir būtų išskirstyti, o šiukliadėžė išvalyta? O galbūt tu nori, kad reguliariai tavo kompiuteris padarytų savo backup kopiją ir ją patalpintų namų serveryje? Visokiems tokiems su kompiuteriu ar serveriu susijusius veiksmus lengviausia automatizuoti su BASH, nors tiesa, jog daugumą šių veiklų galima padaryti ir su Python arba kitomis programavimo kalbomis.\nNors BASH nėra tikrąją ta žodžio prasme programavimo kalba, BASH tai komandų interpretatorius skirtas interakcijai su tavo SHELL, visgi atzsižvelgiant į tai, jog BASH’e tu gali naudoti kintamuosius, ciklus ir t.t. padaro BASH beveik pilnaverte programavimo kalba.\nAr BASH skriptai reikalingi tik Linux adminsitratoriams? Ne, nors ko gero Linux administratoriai juos naudoja dažniausiai, šis įvadas į BASH skriptus padės geriau suprasti kompiuterinę logiką (ciklus), padės praktikuotis BASH komandas ir įgalins tave ne tik tapti dar labiau IT raštinga, bet ir paklos pamatus tiek Python, tiek Docker ir kitoms IT temoms, kuriose tu ir toliau naudosi Terminalą bei turėsi interakciją su Linux operacine sistema.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#kas-yra-bash-skriptas",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#kas-yra-bash-skriptas",
    "title": "15  Bash Skriptai 1",
    "section": "15.2 Kas yra bash skriptas?",
    "text": "15.2 Kas yra bash skriptas?\nIki šiol tu rašei komandas vieną paskui kitą tiesiogiai į terminalą. Nors išmokai jas sujungti (pipe) visgi tai nevsiada be galo patogus būdas, jeigu pvz norėtum paleisti 150 komandų vieną paskui kitą. Tam naudojami skriptai - tekstinis failas, kuriame surašyta visa komandų seka ir tavo SHELL skaito visas komandas ir vykdo jas vieną paskui kitą.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#hello-world",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#hello-world",
    "title": "15  Bash Skriptai 1",
    "section": "15.3 Hello World",
    "text": "15.3 Hello World\nPasileidus terminalą, susikurk norimoje vietoje direktoriją “learning_bash” naudojant mkdir. Su cd pereik į šią direktoriją. Kol dirbsime su bash skriptais, dirbsime iš šios direktorijos.\nDabar terminale paleisk NANO editorių ir sukuruk faila:\nnano hello_world.sh\nGriežtai žiūrint, .sh nėra reikalingas. Kompiuteris susiduręs su šiuo failu ir taip supras, ką jam daryti. Tačiau tam, kad kiti žmonės greitai pamatytų ir surpastų, jog tai skiptinis failas, įprastai naudoajamas .sh arba .bash.\nPačiame faile įrašyk\necho \"Hello world\"\nIšsaugok failą su Ctrl+s ir Ctrl+x\nAtspausdink su ls -l direktorijos turinį.\nKaip matai, šis failas neturi x taigi joks vartotojas neturi execution teisių. Naudojant sudo chmod 744 hello_world.sh suteik sau visas teises, paliekant grupei ir kitiems vartotojams tik skaitymo teises.\npasitikrink su ls -l ar tikrai turi visas reikiamas teises. Galimai dabar net skriptinis failas pakeitė spalvą ir tapo žalias (?).\nKaip dabar paleisti skirptą?\n./hello_world.sh\nPaleidus šį skriptą BASH interpretatorius skaito eilutę po eilutės ir vykdo komandas.\nTačiau šis skriptas dar nėra visai teisingas. Minėjau, jog failo indikatorius .sh nėra būtinas. tad kaip kompiuteris žino, jog tai skriptas? Įprastai (ir nuo šiol visada) mes pirmoje eilutė yįašome šebang #! kuris pasako SHELL interpretatoiui - “Hey, čia ne komentaras, o nurodymas, kokį interpretatoriu naudoti”. Kaip minėjau pačioje mokymų pradžioje, kai kuriuose kompiuteriuose gali būti BASH, ZSH ir kiti SHELL interpretatoriai. Komanduose jose gali šiek tiek skirtis (skirtingas dialektas, arba būdingos tam tikros komandos). Tam kad nekiltų problemų vykdant šį skriptą (angl. running script), mes nurodome koks būtent interpetatorius /bin/bash turėtų perskaityti ir vykdyti komandas.\n#!/bin/bash\n\necho \"Hello World\"\nSveikinu, tai pirmas pilnavertis tavo BASH skriptas. Pripažinkime, tai labai paprastas skriptas.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#kintamieji",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#kintamieji",
    "title": "15  Bash Skriptai 1",
    "section": "15.4 Kintamieji",
    "text": "15.4 Kintamieji\nKintamieji yra reikalingi tam, kad išsaugotų tam tikras reikšmes. Terminale išbandyk, tik gal įrašyk savo vardą. Svarbu, priešingai nei Python, BASH tarp kintamojo ir = negali būti space ir taip pat tarp = ir argumento!\nmanovardas=\"Justas\"\nmanoskaicius=14\nTol kol šita terminalo sesija rya aktivyi (ir tu neperrašei šių kintamųjų) jie bus pasiekiami tavo terminale. Išbandyk panaudoti šiuos kintamuosius naudojant echo komandą. Kad BASH žinotų, jog tu turi omenyje kintamąjį, reikia naudoti $ prieš kintamojo pavadinimą.Šis procesas vadinamas kintamųjų deklaravimu.\necho $manovardas\necho $manoskaicius\nO dabar pabandyk sudėti viską į vieną sakinį\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nPaskutinę komandą galėjome atspausdinti ir be \"\", tačiau jeigu naudotume '' nieko gero nesigautų. Išbandyk ir įsitikink\necho Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\necho 'Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius'\nŠtai todėl, dažniausiai ir naudojame \"\"\nKas nutiktu jeigu panaudtum kintamąjė, kuris nėra deklaruotas\necho $blabla\nOgi nieko. Bash tau neišmes klaidos ir atspausdins tiesiog tuščią vietą.\nPbanadyk uždaryti terminalą ir atsidaryk iš jį iš naujo. Pakartok komandą\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nir įsikitkink, jog kintamieji neišsisaugojo. Taigi, kintamieji kuriuos sukuri temrinalo sesijoje, glaioje tik toje terminalo sesijoje. Išjungus terminalą, ar restartavus kompiuterį - viskas dingsta.\nTam kad neprarasti kintamųjų, mes juos išsaugome kartu su komandomis skripto viduje. Su NANO sukurk naują skriptą apie_mane.sh\n#!/bin/bash\n\nmanovardas=\"Justas\"\nmanoskaicius=14\nmanoamzius='39'\n\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nŠiuo metu tavo skriptas yra begalo paprastas ir vienu žvilsniu suprantamas. Tačiau ilgainiui, tau gali reikėti pridėti komentarus, t.y. priminimus sau, arba paaiškinimus kitiems, kas vyksta kode ir t.t. Tam naudojami komentarai. Skritpuose komentarai pradedami # (nors gali naudoti ir kelis). Viskas į dešinė nuo # toje pačioje eilutė nebus interpretuojama kaip kodas, o BASH supras jog tai yra komentaras ir jo neskaitys.\nPridėkime kelis komentarus;\n#!/bin/bash\n# =====================================================\n# Data: 2024-10-30\n# Autorius: Justas Mundeikis\n# Paskirtis: Atspasdinti informaciją apie mane\n# =====================================================\n\n## Deklaracijos\nmanovardas=\"Justas\" # deklaruojamas vardas, pasikeisk į savo\nmanoskaicius=14 # deklaruojamas skaičius, pasikeisk į savo\nmanoamzius='39' # deklaruojamas amžius, pasikeisk į savo\n\n## Funkcijos\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nKaip matai, pridėjau skripto virųuje vaidnamą header (virtutinėje) dalyje, komentarus, kurie informuoja apie tai, kas, kada sukurė šį skriptą. Ar yra privalomi paminėti dalykai? Ne. Tačiau geroji praktika rodo, kad autorius, data ir paskirtis neretai rpaverčia net sau pačiamm atsidarius skriptus po kiek laiko, greičiau susigaudyti. Jeigu kažkada tavo skritpai taptų labai įmantrūs, tada komentaras header skiltyje galėtų būti dar išsamesnis, štai ChatGPT man pasiūlė net aprašyti kokie yra dependencies, pvz jeigu skriptas naudoja komanda,s kurios ali būti neinstaliuotos. Tada kitas vartotojas atsidaręs iškart matys ką turi instaliuoti, jog skriptas veiktų, o ne pirma paleidus skritpą ir sulaukus klaidos, ieškoti ko trūko.\n#!/bin/bash\n#====================================================================\n# Script Name: script_name.sh\n# Description: Briefly describe what the script does.\n# Usage: ./script_name.sh [options] [arguments]\n# Author: Your Name\n# Created Date: YYYY-MM-DD\n# Version: 1.0\n# Last Modified: YYYY-MM-DD\n# Dependencies: List dependencies like `curl`, `awk`, or other scripts.\n# Requirements: Any system requirements or permissions needed.\n# Notes: Additional helpful notes, warnings, or cautions.\n#====================================================================\nDabar tau gali kilti klausimas - o kodėl neparašius komandos, kad instaliuoti iškart šiuos dependencies? Nebent tavo skriptas yra skirtas programų instaliavimui ir kitas vartotojas tai supras ir tu tai dokumentavai, pvz README.md faile… nėra labai ger apraktika tiesiog paleisti instialiavią kažkieno kito kompiuteryje. Be to, tu negli būti tikra, ar tia Linux, ar MacOs sistema. O net Linux, gali būti naudoajmas ne apt programū menedžeris, o dnf ir t.t. Taigi, ir saugiau ir lengviau leisti tam tikruas programas susiinstaliuoti pačiam vartotojui.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#matematinės-funkcijos",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#matematinės-funkcijos",
    "title": "15  Bash Skriptai 1",
    "section": "15.5 Matematinės Funkcijos",
    "text": "15.5 Matematinės Funkcijos",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#if-else",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#if-else",
    "title": "15  Bash Skriptai 1",
    "section": "15.6 IF ELSE",
    "text": "15.6 IF ELSE",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#išeities-kodai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#išeities-kodai",
    "title": "15  Bash Skriptai 1",
    "section": "15.7 Išeities kodai",
    "text": "15.7 Išeities kodai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#while-ciklai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#while-ciklai",
    "title": "15  Bash Skriptai 1",
    "section": "15.8 WHILE ciklai",
    "text": "15.8 WHILE ciklai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas",
    "title": "15  Bash Skriptai 1",
    "section": "15.9 Praktikumas",
    "text": "15.9 Praktikumas",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#for-ciklai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#for-ciklai",
    "title": "15  Bash Skriptai 1",
    "section": "15.10 FOR ciklai",
    "text": "15.10 FOR ciklai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#kur-saugoti-skriptus",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#kur-saugoti-skriptus",
    "title": "15  Bash Skriptai 1",
    "section": "15.11 Kur saugoti skriptus?",
    "text": "15.11 Kur saugoti skriptus?",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#data-streams-stdin-stdout-stderror",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#data-streams-stdin-stdout-stderror",
    "title": "15  Bash Skriptai 1",
    "section": "15.12 Data Streams (stdin, stdout, stderror)",
    "text": "15.12 Data Streams (stdin, stdout, stderror)",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#funkcijos",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#funkcijos",
    "title": "15  Bash Skriptai 1",
    "section": "15.13 Funkcijos",
    "text": "15.13 Funkcijos",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#case",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#case",
    "title": "15  Bash Skriptai 1",
    "section": "15.14 CASE",
    "text": "15.14 CASE",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#cron",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#cron",
    "title": "15  Bash Skriptai 1",
    "section": "15.15 CRON",
    "text": "15.15 CRON",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#argumentai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#argumentai",
    "title": "15  Bash Skriptai 1",
    "section": "15.16 Argumentai",
    "text": "15.16 Argumentai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas-serverio-backup-skritpas",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas-serverio-backup-skritpas",
    "title": "15  Bash Skriptai 1",
    "section": "15.17 Praktikumas: Serverio Backup skritpas",
    "text": "15.17 Praktikumas: Serverio Backup skritpas",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  }
]