[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Linux ir programavimas",
    "section": "",
    "text": "Įvadas",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#operacinė-sistema",
    "href": "index.html#operacinė-sistema",
    "title": "Linux ir programavimas",
    "section": "Operacinė sistema",
    "text": "Operacinė sistema\nKai tu įjungi savo telefoną, kompiuterį ar mikrokompiuterį, jame pasileidžia programa - instrukcijų rinkinys, kuris nurodo, kaip tavo prietaisas turi veikti. Ši programa nurodo, pavyzdžiui, įjungus prietaisą pradėti šviesti ekranui, paspaudus klavišus abc suprasti, kad tu rašai, arba įjungus elektros kabelį pradėti krauti bateriją.\n\n\n\nKompiuteris. Autorius: Alessandro Oliverio\n\n\nŠis instrukcijų rinkinys dar nėra visavertė operacinė sistema. Tai yra vadinamasis branduolys (angl. - kernel), kuris nurodo, kaip turi veikti kompiuterinė įranga tarpusavyje.\nŠalia branduolio yra ir kita programinė įranga, kuri leidžia tau naudotis prietaisu - tai įvairiausios programos, pvz., skambinimo programėlė, kalkuliatorius, interneto naršyklė. Visa ši programinė įranga kartu su branduoliu sudaro operacinę sistemą (angl - operating system, arba - OS).\nTaigi operacinė sistema (OS) yra programinė įranga, kuri valdo kompiuterinės įrangos ir programų išteklius. Ji veikia kaip tarpininkė tarp vartotojo ir kompiuterio aparatūros. Pagrindinės populiarios operacinės sistemos yra Windows, UNIX šeimos OS - macOS, ir Linux.\n\nWindows: Microsoft korporacijos sukurta populiariausia operacinė sistema, naudojama tiek namų, tiek verslo kompiuteriuose. Ji žinoma dėl savo patogumo ir plataus programų pasirinkimo.\nmacOS: Apple korporacijos operacinė sistema, naudojama Mac kompiuteriuose. Ji žinoma dėl savo dizaino, stabilumo ir integracijos su Apple ekosistema.\nLinux: Atviro kodo operacinė sistema, kurią gali keisti ir dalintis visi norintys. Ją naudoja dauguma serverių ir technologijų entuziastų.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#ubuntu-skoniai",
    "href": "index.html#ubuntu-skoniai",
    "title": "Linux ir programavimas",
    "section": "Ubuntu skoniai",
    "text": "Ubuntu skoniai\nLinux yra atviro kodo operacinė sistema, todėl ją gali keisti ir dalintis visi norintys. Dėl to yra nemažai programuotojų, kurie nusprendžia pasidalinti savo pagamintais Linux variantais, vadinamais distribucijomis.\n\n\n\nLinux distribucijų medis\n\n\nKai tu įjungi telefoną arba kompiuterį, branduolys užtikrina, kad visi kompiuterio komponentai galėtų tarpusavyje bendrauti. Vis dar trūksta programų, kurios rodytų vaizdus ekrane, leistų įvesti tekstą ir pan. Tam yra reikalingos papildomos programos, dauguma jų buvo sukurtos GNU projekto metu. Tačiau tik branduolys ir GNU programos dar neleistų visavertiškai naudotis kompiuteriu, todėl papildomai diegiamos įvairios reikalingos programos, kurios padaro operacinę sistemą praktiška ir gražiai atrodančia.\nTaigi, pilną operacinę sistemą, dar kartais vadinamą Linux distribucija (distribution), sudaro:\n\nLinux branduolys (kernel)\nGNU programos\nPapildomos programos ir grafinis dizainas",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#kodėl-linux",
    "href": "index.html#kodėl-linux",
    "title": "Linux ir programavimas",
    "section": "Kodėl Linux",
    "text": "Kodėl Linux\nGrįžkime prie klausimo - “Kodėl Linux”?\n\nSaugumas: Linux dažnai laikoma saugesne operacine sistema dėl savo architektūros ir mažesnio virusų kiekio.\nServeriai: Linux arba jai giminingos UNIX sistemos veikia beveik visuose pasaulio serveriuose. Greičiausiai net tavo namuose yra ne vienas įrenginys, kuriame veikia Linux.\nUniversalumas: tiek iOS, tiek Android taip pat veikia UNIX pagrindu.\nLankstumas ir pritaikomumas: Linux leidžia tau būti labiau savarankiškam ir geriau suprasti, kaip veikia kompiuteriai. Tuo pačiu metu išmoksti dalykų, kurių nemoka kiti.\nProgramavimas: Linux yra gera pradžia kelionei į Python ir kitas programavimo kalbas, kurios naudojamos programuojant robotus, kuriant interneto svetaines ar atliekant skaičiavimus su dideliais duomenų kiekiais.\n\nŠiais laikais vis daugiau ir daugiau profesijų kasdienėje veikloje reikia programavimo. Buhelteriai naudojasi Python,kad greičiau apdorotų duomenis. Architektai ir inžinieriai, kad teisingai apskaičiuotų pastato konstrukcijas. Transporto srauto specialistai, kad planuotų ir valdytų automobilių srautus, o NASA darbuotojai, kad valdytų į kosmoosą kylančias raketas.\nTaigi Linux ir tam tikra prasme - programavimas, paruošia tave 21-ajam amžiui.\nNegana to, Linux veikia ant tokių paprastų mikrokompiuterių kaip Raspberry Pi Zero ir gali atgaivinti net 10-20 metų senumo nešiojamą kompiuterį. Taigi, tai padeda tausoti gamtą, nes savo technika gali naudotis ilgiau.\nBet yra ir kita medalio pusė. Ne visos tavo įprastos programos veikia Linux. Pavyzdžiui, Adobe produktai tiesiog neveikia Linux aplinkoje. Microsoft Excel ir Word taip pat nėra pritaikyti Linux. Jei tavo mokslui ar darbui yra būtinos tam tikros programos, Linux gali neatitikti tavo lūkesčių. Tačiau reikia žinoti, kad daugelis šių programų turi analogus Linux aplinkoje. Dažniausiai jie yra atviro kodo ir nemokami.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#linux-mint",
    "href": "index.html#linux-mint",
    "title": "Linux ir programavimas",
    "section": "Linux Mint",
    "text": "Linux Mint\nKaip jau minėjau, yra daug Linux distribucijų. Šiame vadovėlyje naudosime vieną iš paprasčiausių - Linux Mint distribuciją, kuri sukurta Ubuntu pagrindu.\nJą galima parsisiųsti iš linuxmint.com. Kaip ją instaliuoti, gali šiek tiek skirtis priklausomai nuo kompiuterio, tad geriausia šioje vietoje tiesiog paieškoti vaizdo įrašo Youtube svetainėje.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html",
    "href": "a_linux_pagrindai/1_linux_configure.html",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "",
    "text": "1.1 Intro",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#themes",
    "href": "a_linux_pagrindai/1_linux_configure.html#themes",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.2 Themes",
    "text": "1.2 Themes",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#backgrounds",
    "href": "a_linux_pagrindai/1_linux_configure.html#backgrounds",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.3 Backgrounds",
    "text": "1.3 Backgrounds",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#menu",
    "href": "a_linux_pagrindai/1_linux_configure.html#menu",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.4 Menu",
    "text": "1.4 Menu",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#panel",
    "href": "a_linux_pagrindai/1_linux_configure.html#panel",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.5 Panel",
    "text": "1.5 Panel",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#firewall",
    "href": "a_linux_pagrindai/1_linux_configure.html#firewall",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.6 Firewall",
    "text": "1.6 Firewall",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#languages",
    "href": "a_linux_pagrindai/1_linux_configure.html#languages",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.7 Languages",
    "text": "1.7 Languages",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#keyboard",
    "href": "a_linux_pagrindai/1_linux_configure.html#keyboard",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.8 Keyboard",
    "text": "1.8 Keyboard",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#time",
    "href": "a_linux_pagrindai/1_linux_configure.html#time",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.9 Time",
    "text": "1.9 Time",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/1_linux_configure.html#tips-tricks",
    "href": "a_linux_pagrindai/1_linux_configure.html#tips-tricks",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.10 Tips & Tricks",
    "text": "1.10 Tips & Tricks",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html",
    "href": "a_linux_pagrindai/2_linux_update.html",
    "title": "2  Linux atnaujinimas",
    "section": "",
    "text": "2.1 Pradžia\nVisuose kompiuteriuose yra daugybė įvairių programų. Pavyzdžiui, jau susipažinome su Terminal ir Files programomis. Taip pat išmokome naudoti kai kurias įdiegtas komandas: echo, cat, ir base64. Šių programų kūrėjai dažnai atnaujina savo programas, tad norėdami pasinaudoti naujausiomis funkcijomis ir pataisymais, turime įdiegti šiuos atnaujinimus (angl. - update).\nŠioje pamokoje sužinosime:\nBe to, išmoksime:\nŠis skyrius padės išmokti, kaip efektyviai tvarkytis su programomis ir jų atnaujinimais, kad kompiuteris visada būtų naujausias ir veiktų be trikdžių.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html#pradžia",
    "href": "a_linux_pagrindai/2_linux_update.html#pradžia",
    "title": "2  Linux atnaujinimas",
    "section": "",
    "text": "Kas yra veidrodiniai serveriai (angl. - mirrors).\nKaip atnaujinti programas naudojant Update Manager programą.\nKaip atlikti programų atnaujinimus naudojant terminalą.\n\n\n\nKaip įdiegti (angl. - install) programas naudojant Software Manager ir terminalą.\nKuo skiriasi System Package nuo Flatpak programų.\nKaip pašalinti (angl. - uninstall) nebereikalingas programas, kad kompiuteris būtų švaresnis ir veiktų sklandžiau.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html#update-manager",
    "href": "a_linux_pagrindai/2_linux_update.html#update-manager",
    "title": "2  Linux atnaujinimas",
    "section": "2.2 Update Manager",
    "text": "2.2 Update Manager\nUpdate Manager yra programa, kuri padeda atnaujinti kitas programas tavo kompiuteryje. Ji pati praneša, kai laikas atnaujinti programas. Kai internete yra prieinami atnaujinimai, dešiniame kampe atsiranda skydelio su raudonu tašku piktograma (raudonas taškas reiškia, kad yra naujų atnaujinimų).\n\n\nBet jei nematai šios piktogramos, gali paleisti “Update Manager” programą per Menu:\n.\nPirmą kartą paleidus šią programą, gali pamatyti tokį langą, kuris paaiškina, ką ji daro. Drąsiai spausk ant OK.\n\nJei pamatysi, kad pačiai programai reikia atnaujinimo, spausk ant “Apply the Update” (lt. - įdiegti atnaujinimą). Taip pat gali matyti užrašą switch to a local mirror, kol kas spausk No. Kas yra veidrodžiai (angl. - mirrors), pakalbėsime netrukus.\n\nJei paspaudus “Apply the Update” kompiuteris paprašys tavo slaptažodžio, įvesk jį. Taip kompiuteris įsitikina, kad tik tu ar kitas vartotojas, kuriam priklauso šis kompiuteris, gali atlikti pakeitimus. Drąsiai įvesk savo slaptažodį ir spausk Authenticate (lt. - patvirtinti tapatybę).\n\nNetrukus pamatysi vaizdą, kuris gali atrodyti panašiai - vienas ar keli, o gal net daugybė skirtingų programų atnaujinimų, kuriuos gali įdiegti savo kompiuteriui. Tačiau kol kas dar nieko nespauskime. Susipažinkime su tuo, ką čia matome:\n\n\n\nType - kokio tipo yra atnaujinimas? Jie gali būti:\n\nSecurity update - saugumo atnaujinimas. Jo simbolis yra skydelis. Tai svarbiausias atnaujinimas, kurį reikia kuo skubiau įdiegti, kad kompiuteris būtų saugus.\nKernel update - pagrindinės Linux sistemos atnaujinimas. Jo simbolis yra žaibas. Šie atnaujinimai pagerina, kaip veikia pats kompiuteris. Ar ekranas rodo gerai? Ar veikia pelė? Ir t.t.\nSoftware update - programų atnaujinimai. Tai atnaujinimai, kuriuos programų kūrėjai sukuria, kad jų programos veiktų geriau, turėtų daugiau funkcijų ir pan.\n\n\nŠiame lange taip pat gali paspausti ant:\n\n\nClear - išvalyti visus pasirinktus atnaujinimus\nSelect All - pasirinkti visus atnaujinimus\nRefresh - atnaujinti sąrašą atnaujinimų, kurie yra prieinami\nInstall Updates - įdiegti pasirinktus atnaujinimus\n\nBet kaip kompiuteris žino, kokias programas atnaujinti? Ir iš kur jis jas atsisiunčia?\n\n2.2.1 Mirrors ir Updates\nVeidrodėli, veidrodėli, kas pasaulyje gražiausia?\n\nPradėkime nuo pradžių…\nĮsivaizduok, kad programuotoja, kuri kuria programas, dirba iš namų, kaip ir tu. Po ilgos darbo savaitės, ji nusprendžia: “Viskas, programos atnaujinimas paruoštas. Ištaisyta klaida, įdiegti nauji patobulinimai”.\n\n(Nuotraukoje Jaime Gunther, kuri 38 metų nusprendė, kad mokysis savarankiškai programuoti ir tapo programuotoja)\nBet dabar įsivaizduok, kad keli milijonai žmonių bandytų parsisiųsti iš jos kompiuterio šiuos atnaujinimus. Jos kompiuteris negalėtų to atlaikyti, ir viskas strigtų bei vyktų labai lėtai.\nTodėl programuotoja naudoja serverius veidrodžius (angl. - mirrors).\n\nKas yra serveris? Serveris yra didelis kompiuteris, kuris pastatytas specialiose vietose ir gali aptarnauti milijonus žmonių vienu metu. (daugiau nuotraukų gali rasti čia)\n\n\n\nKodėl jie vadinami veidrodžiais (angl. - mirrors)? Nes jie atspindi tuos programinius pakeitimus, kuriuos programuotoja padarė savo namuose. Kai ji kažką atnaujina, šie serveriai iškart tai atspindi, ir tu gali parsisiųsti atnaujinimus neapkraudamas programuotojos namų kompiuterio!\n\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuris turi sąrašą, kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs, priklauso programų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitikrinti ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasties kartais tavo kompiuteris paklausia, ar nori prisijungti prie vietinių veidrodinių serverių - “Do you want to switch to a local mirror?”\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuriame yra sarašas kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs nutolęs, priklauso prgramų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitiktrinti, ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasies, kartais tavo kompiuteris paklausia, ar nori prisijngti prie lokalių veidrodžių.\nKaip tai padaryti?\n\nSpausk ant “Edit” (pakeitimai) ir tada ant “Software Sources” (programų šaltiniai).\nKompiuteris vėl paprašys tavo slaptažodžio, įvesk jį.\nAtsidariusiame naujame lange pamatysi Main ir Base veidrodžius. Jie gali būti nustatyti ne visai ten, kur gyveni tu.\nSpustelk pele prie Main. Atsidarys langas, kuriame bus serveriai, surūšiuoti pagal tai, kaip arti tavęs jie yra (pagal atsisiuntimo greitį). Tu pamatysi, kad po kelių sekundžių sąrašo viršus nebekinta. Tau nereikia laukti, kol kompiuteris parsisiųs visų serverių informaciją. Pasirink patį pirmą serverį\nPakartok tai su Base serveriu.\nSpustelk ant “Update the mirrors” (atnaujinti veidrodinius serverius). Tai gali truputį užtrukti.\nAtnaujinus, pamatysi, kad buvusius serverius pakeitė kiti, tavo pasirinkti serveriai.\nDabar gali uždaryti šį langą.\n\nVisas procesas šiame video:\nVideo\nDabar gali atnaujinti programas, paspaudus ant Install Updates. Gali atsirasti papildomi langai, kur paklaus, ar tikrai nori įdiegti atnaujinimus, gali paprašyti ir įvesti tavo slaptažodį dar kartą. Visur drąsiai sakyk “taip” ir įrašyk savo slaptažodį.\nTačiau yra ir kitas būdas! Naudojant Terminal.\nVeidrodinių serverių atnaujinimas yra būtinas net kai įdiegi atnaujinimus per Terminalą. Tad retkarčiais pasitikrink, ar pasirinkti vis dar sparčiausi veidroriniai serveriai.\n\n\n2.2.2 Atnaujinimų instalivimas per Terminal\nKodėl kartais geriau įdiegti atnaujinimus per Terminal programą? Visų pirma - tu praktikuojiesi BASH kalbos žinias! Visų antra, vėliau išmoksi, kaip vos kelių klavišų paspaudimu tai padaryti daug greičiau nei spaudant su pele ir naudojant Update Manager programą.\nŠtai taip atrodo kodas, kurį reikės įrašyti:\nsudo apt update && \nsudo apt full-upgrade -y && \nsudo apt autoremove -y && \nflatpak update\nDabar tavo galvoje gal atrodo taip:\n\nPradėkime nuo pradžių ir eikime per visas komandas, kad jas suprastume. Kai suprasi - pamatysi, kad viskas gana paprasta.\nMes galime visas komandas surašyti į vieną eilutę, bet paprastumo dėlei, terminale įrašyk komandą po komandos, kaip pateiktia žemiau.\n\nsudo apt update.\n\n\nčia iššaukiama komanda apt. Tai yra programa, kuri rūpinasi programų atnaujinimu.\nupdate yra argumentas, ką programa turi daryti. Priešingai nei atrodo, ji neatnaujina programų. Ką ji padaro, tai palygina tavo kompiuterio programas su tuo, kas yra veidrodiniuose serveriuose (mirror). Jeigu ji aptinka skirtumą, nes, pvz., serveryje programa yra naujesnė, apt tave informuos apie galimus atnaujinimus.\nO kas yra sudo? Atsimeni, kai Update Manager tavęs prašė įrašyti tavo slaptažodį? Kai tu jį įrašydavai, kompiuteris suprasdavo, jog tu turi kompiuterio administratoriaus teises. sudo padaro tą patį. Ši komanda pasako, kad po jo sekantis kodas būtų įvykdytas su kompiuterio administratoriaus teisėmis ir apsaugo, kad svetimi žmonės nieko negalėtų padaryti tavo kompiuteriui.\n\nSpausk Enter. Paleidus šią komandą, Terminal tavęs paprašys įrašyti savo slaptažodį. Jį rašant tu nieko nematysi (juk nenori, kad sėdint kavinėje, kas nors pamatytų tavo slaptažodį?). Įvesk ir spausk Enter dar kartą. Jeigu savo slaptažodį įvesi neteisingai - terminalas tau tai pasakys, tad galėsi bandyti dar kartą.\nJeigu tavo kompiuteriui yra pasiekiami atnaujinimai - tu pamatysi, kiek jų.\n\n\nsudo apt full-upgrade -y.\n\n\nŠi dalis pasako, kad sudo - elkis kaip administratorius\napt naudok programų atnaujinimų programą.\nfull-upgrade - atnaujink visas programas.\n-y yra nustatymas, panašus į ką jau matėme su base64 -d, tik šį kartą jis reiškia yes (lt - taip). Jeigu jo nepanaudotum, Terminal programa tavęs paklaustų, kokius atnaujinimus siūlo padaryti ir dar kartą klaustų, ar tikrai nori viską įdiegti. Tam kad išvengti šio papildomo klausimo, iš karto pasakome - yes.\n\nJeigu tu rašai šią komandą iškart po to, kai jau naudojai sudo apt update, Terminal programa tavęs gali ir nebeprašyti dar kartą įrašyti savo slaptažodį.\nPriklausomai nuo to, kiek yra atnaujinimų, šis procesas gali užtrukti kelioliką sekundžių, bet gali ir kelioliką minučių.\nVideo\n\nsudo apt autoremove -y.\n\n\nsudo ir apt jau žinome.\nauto-remove - šis nustatymas pasako apt komandai, kad jeigu yra kažkokių programų, kurios po atnaujinimo nebereikalingos, jas ištrintų. Nebijok, apt programa yra labai protinga ir atsargiai atsirenka, ką trinti ir ko ne.\n-y nustatymas pasako yes (taip), kad nereiktų patvirtinimo.\n\n\n\nflatpak update - kiek kita komanda. Čia mes iššaukiame programą flatpak, kuri, kaip ir programa apt, moka instaliuoti programas. Tačiau ją atnaujinti užtenka vos šių dviejų žodžių.\n\n\n\nO ką gi reiškia && toje ilgoje komandoje? Kai mes rašome komandas po vieną, kaip padarėme dabar, mes patys matome, ar nutiko kas nors netikėto, ar įvyko kokia nors klaida ir t.t. Tam, kad kompiuteris žinotų, jog tik padarius sudo apt update ir negavus jokių klaidų, jis eitų prie sekančios komandos sudo apt full-upgrade -y ir taip toliau, reikia šias komandas sujungti su &&. Jeigu prieš tai buvusi komanda nepavyktų, kompiuteris nutrauktų visas likusias komandas.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/2_linux_update.html#žodynėlis",
    "href": "a_linux_pagrindai/2_linux_update.html#žodynėlis",
    "title": "2  Linux atnaujinimas",
    "section": "2.3 Žodynėlis",
    "text": "2.3 Žodynėlis\n\n\n\n\n\n\n\n\nKomanda\nApibrėžimas\nPavyzdys\n\n\n\n\nsudo apt update\nKomanda, kuri atnaujina paketų sąrašą iš visų saugyklų, kad būtų galima gauti informaciją apie naujausias programinės įrangos versijas.\nPaleidus sudo apt update, sistema patikrina, ar yra naujų programinės įrangos paketų atnaujinimų.\n\n\nsudo apt full-upgrade\nKomanda, kuri atnaujina visus įdiegtus paketus į naujausias galimas versijas, automatiškai pašalindama arba įdiegdama paketus, kai reikia.\nNaudojant sudo apt full-upgrade, jūsų sistema bus atnaujinta į naujausias programinės įrangos versijas.\n\n\nsudo autoremove\nKomanda, kuri pašalina nereikalingus paketus, kurie buvo įdiegti kaip priklausomybės, bet dabar nebėra reikalingi.\nPaleidus sudo autoremove, bus pašalinti nereikalingi bibliotekų paketai, siekiant atlaisvinti vietos diske.\n\n\nflatpak update\nKomanda, kuri atnaujina visus įdiegtus Flatpak programas į naujausias versijas.\nNaudojant flatpak update, jūsų Flatpak programos bus atnaujintos į naujausias versijas.\n\n\nsudo apt install &lt;name&gt;\nKomanda, kuri įdiegia nurodytą programinės įrangos paketą iš saugyklos.\nPaleidus sudo apt install vim, bus įdiegta vim redaktoriaus programa.\n\n\nsudo apt remove &lt;name&gt;\nKomanda, kuri pašalina nurodytą programinės įrangos paketą iš sistemos.\nNaudojant sudo apt remove vim, bus pašalinta vim redaktoriaus programa.\n\n\nflatpak install &lt;name&gt;\nKomanda, kuri įdiegia nurodytą Flatpak programą iš Flatpak saugyklos.\nPaleidus flatpak install flathub org.gimp.GIMP, bus įdiegta GIMP programa.\n\n\nflatpak remove &lt;name&gt;\nKomanda, kuri pašalina nurodytą Flatpak programą iš sistemos.\nNaudojant flatpak remove org.gimp.GIMP, bus pašalinta GIMP programa.\n\n\n-y\nParametras, kuris automatiškai atsako “taip” į visus klausimus, kuriuos komanda gali užduoti, taip palengvinant automatizuotą diegimą ar pašalinimą.\nKomandoje sudo apt install -y vim, parametras -y užtikrina, kad diegimo procesas vyks be vartotojo įsikišimo.\n\n\n&&\nLoginis operatorius, naudojamas sujungti kelias komandas taip, kad antroji komanda būtų vykdoma tik tuo atveju, jei pirmoji komanda baigiasi sėkmingai.\nKomandoje sudo apt update && sudo apt upgrade, sudo apt upgrade bus vykdoma tik tada, jei sudo apt update sėkmingai baigiasi.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html",
    "href": "a_linux_pagrindai/3_linux_software.html",
    "title": "3  Linux programos",
    "section": "",
    "text": "4 Programų instaliavimas\nProgramų instaliavimas Linux yra gana paprastas. Užtenka susirasti ir atsidaryti Software Manager.\nJam atsidarius, iškart matome daug programų pasiūlymų. Drąsiai panaršyk šiame lange. Ar matai ką nors tave dominančio?",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-instaliavimas",
    "href": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-instaliavimas",
    "title": "3  Linux programos",
    "section": "4.1 Sisteminių paketų instaliavimas",
    "text": "4.1 Sisteminių paketų instaliavimas\nSisteminis paketas (angl. System Package) - tai programa, kurią Linux kūrėjai patikrino ir pritaikė tavo kompiuterio veikimui. Šios programos valdomos per apt programą.\nKita programų instaliavimo sistema yra Flatpak, su ja susipažinsime vėliau.\nĮdiekime “Bloboats” žaidimą.\nPaieškos viršuje įrašyk Bloboats ir paspausk ant programos piktogramos.\n\nKaip matai, sekantis langas parodo, jog tai System Package ir leidžia tau šią programą įdiegti. Spausk ant Install.\n\nSoftware Manager programa informuos tave, jei reikia įdiegti papildomas programas.\n\nJei taip nutiktų, spausk ant Continue, o tada įrašyk savo slaptažodį ir spausk ant Authenticate. Prisimeni, kai tu įrašai savo slaptažodį, kompiuteris komandas vykdo kaip sudo :)\n\nDabar gali spausti ant Launch (lt - paleisti), arba rasi šią programą tarp visų programų.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "href": "a_linux_pagrindai/3_linux_software.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "title": "3  Linux programos",
    "section": "4.2 Sisteminių paketų įdiegimas Terminal lange",
    "text": "4.2 Sisteminių paketų įdiegimas Terminal lange\nSusiraskime kitą programą - 3dchess. Kaip matai, jos pavadinimas kompiuteriui yra parašytas šio lango apačioje:\n\nAtsidaryk terminalą ir įrašyk šią komandą, daug kas jau tau bus matyta:\nsudo apt install 3dchess\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia įdiegti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\ninstall - komanda, pasakanti apt, ką turi daryti, šįkart įdiegti naują programą.\n3dchess - argumentas, pasakantis, kokią programą įdiegti.\n\nMes taip pat galėjome pridėti -y, bet šįkart to nepadarysime. Pažiūrėkime, kas nutinka. Ar pastebėjai kompiuterio reikalavimą patvirtinti, jog tikrai nori instaliuoti šią programą? Do you want to Continue [Y/n]\nVideo\nKaip matai, kompiuteris manęs klausė, ar tikrai noriu, ir teko įrašyti Y raidę ir spustelėti Enter. Tiesa, kai matai [Y/n] tai reiškia, kad jeigu tiesiog paspausi Enter - kompiuteris galvos, kad tu renkiesi Y (Yes trumpinys), tad rašyti Yes tau net nereikia. Kartais tu gali pamatyti [N/y]. Taigi tas pasirinkimas, kuris parašytas didžiąja raide - bus automatiškai pasirinktas jeigu nieko neįrašysi, bet pasupausi Enter klavišą.\nJeigu būčiau įrašęs komandą\nsudo apt install 3dchess -y\nTerminal programa manęs neprašytų patvirtinti mano pasirinkimo. Nes priejus šiam klausimui Do you want to Continue [Y/n], nustatymas -y pasakytų iškart Yes.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#flatpak",
    "href": "a_linux_pagrindai/3_linux_software.html#flatpak",
    "title": "3  Linux programos",
    "section": "4.3 Flatpak",
    "text": "4.3 Flatpak\nFlatpak yra kitoks būdas instaliuoti programas. Kai tu instaliuoji Flatpak programą, tu atsisiunti ne tik pačią programą, bet ir visas kitas programas, kurios reikalingos, kad pagrindinė programa veiktų. Pabandykime tai paaiškinti kitaip.\nĮsivaizduok, kad tavo kompiuteris yra kaip namas. Namai turi kambarius, virtuvę, vonią ir t.t. Dabar įsivaizduok, kad nori naujos spintos. Kai tu parsisiunti spintą kaip System Package (sisteminį paketą), tai tarsi parsiveži ją iš IKEA parduotuvės ir pastatai savo kambaryje.\nFlatpak programos veikia kitaip. Kai tu atsisiunti Flatpak programą, tai tarsi parsineštum visą didelę palapinę, kurioje yra ne tik tavo spinta, bet ir visa kita - virtuvė, vonia ir dar keli kambariai. Kodėl taip daroma?\nKartais programoms reikia kitų programų, kad jos veiktų gerai. Tavo kompiuteryje ne visada yra visos šios reikalingos programos. Todėl kai parsisiunti Flatpak programą, ji atsisiunčia viską, ko jai reikia, kad veiktų be problemų. Tai reiškia, kad gauni naujesnę ir geriau veikiančią programą. Tačiau ši didelė palapinė užima daugiau vietos tavo kompiuteryje, nes joje yra viskas, ko reikia programai.\nPavyzdžiui, susiraskime programą “hedgewars”. Pasirink bet kurią piktogramą.\n\nKaip matai, šalia “System Package” arba “Flatpak” yra nedidelis trikampiukas. Paspaudus ant jo, pamatysi, jog gali įdiegti šią programą ir kitu formatu.\nTaip atrodo System Package:\n\nO štai taip Flatpak. Atkreipk dėmesį į programos versijos skirtumus ir kiek vietos reikia kompiuteryje.\n\nKaip System Package ši programa užima 194 MB vietos tavo kompiuteryje, o kaip Flatpak - 3.7 GB. 3.7 GB atitinka 3700 MB. Taigi beveik 20 kartų daugiau vietos. Tai reiškia, kad Flatpak programai reikia daugiau vietos, nes ji atsisiunčia viską, ko jai reikia.\nGera žinia yra ta, kad kai instaliuosi kitą programą su Flatpak, labai tikėtina, kad kita programa jau galės naudotis kai kuriais dalykais iš pirmosios palapinės. Tada naujai programai reikės mažiau vietos.\nFlatpak programas taip pat galima instaliuoti per Terminal programą.\nTačiau tai šiek tiek skiriasi:\n\nnereikia naudoti sudo\nvietoj apt reikia naudoti flatpak\nnaudojame install\nprogramos pavadinimą galima pasiimti iš Software Manager, bet daugiau Flatpak programų galima rasti ir flathub.org tinklapyje.\n\nVideo",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#software-manager",
    "href": "a_linux_pagrindai/3_linux_software.html#software-manager",
    "title": "3  Linux programos",
    "section": "5.1 Software Manager",
    "text": "5.1 Software Manager\nPirmiausia pažiūrėkime, kaip ištrinti programas naudojant Software Manager.\n\nAtidaryk Software Manager.\nPaspaudus ant trijų brūkšnelių spausk ant “Show Installed Application” (lt. parodyk įdiegtas programas).\n\n\n\nSurask programą, kurią nori ištrinti, ir spausk ant jos pavadinimo ar piktogramos.\n\n\n\nAtsidariusiame lange spausk ant Remove (lt. pašalinti).\n\n\n\nSoftware Manager programa paprašys patvirtinimo. Spausk Continue, įvesk savo slaptažodį ir spausk Authenticate.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#menu",
    "href": "a_linux_pagrindai/3_linux_software.html#menu",
    "title": "3  Linux programos",
    "section": "5.2 Menu",
    "text": "5.2 Menu\nKitas būdas ištrinti programas yra per Menu.\n\nAtidaryk meniu, kur randi visas savo programas.\nDešiniu pelės klavišu spustelk ant programos, kurią nori ištrinti. Prasiskleis papildomas meniu.\nPasirink Uninstall (lt. pašalinti).\nPasirodys patvirtinimo langas. Pasirink OK, įvesk savo slaptažodį ir spausk Authenticate.\n\nVideo",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#terminalas",
    "href": "a_linux_pagrindai/3_linux_software.html#terminalas",
    "title": "3  Linux programos",
    "section": "5.3 Terminalas",
    "text": "5.3 Terminalas\nProgramas taip pat galima ištrinti per terminalą.\n\n5.3.1 Sisteminis paketas\nNorėdami ištrinti sisteminį paketą, naudokime apt programą. Pavyzdžiui, jei nori ištrinti programą “3dchess”:\n\nAtidaryk terminalą.\nĮrašyk šią komandą: sudo apt remove 3dchess\n\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia ištrinti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\nremove - komanda, pasakanti apt, kad reikia ištrinti programą.\n3dchess - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#flatpak-1",
    "href": "a_linux_pagrindai/3_linux_software.html#flatpak-1",
    "title": "3  Linux programos",
    "section": "5.4 Flatpak",
    "text": "5.4 Flatpak\nPer Terminal irgi galime ištrinti Flatpak programą. Pavyzdžiui, jei nori ištrinti programą org.hedgewars.Hedgewars:\nflatpak uninstall org.hedgewars.Hedgewars\nPaaiškinkime, kas čia yra kas:\n\nflatpak - programa, kuri įdiegia, atnaujina ir pašalina Flatpak programas.\nuninstall - komanda, pasakanti flatpak, kad reikia ištrinti programą.\norg.hedgewars.Hedgewars - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/3_linux_software.html#kodėl-per-terminal",
    "href": "a_linux_pagrindai/3_linux_software.html#kodėl-per-terminal",
    "title": "3  Linux programos",
    "section": "5.5 Kodėl per Terminal?",
    "text": "5.5 Kodėl per Terminal?\nKo gero tau dabar kyla klausimas, kodėl verta mokėti atnaujinti, įdiegti ir ištrinti programas naudojant Terminal?\nNaudoti Terminal gali atrodyti sudėtingiau nei spustelėti pelę, tačiau jis turi daug privalumų.\n\nTerminal leidžia tau atlikti daugybę užduočių labai greitai. Užuot naršant per meniu ir ieškant reikiamų funkcijų, tu gali tiesiog įvesti kelias komandas ir tavo darbas bus atliktas.\nTerminal suteikia daugiau galimybių ir lankstumo. Kai kuriuos dalykus gali padaryti tik per Terminal. Be to, Terminal naudoti gali būti smagu! Tai tarsi magija – tu rašai komandas, o kompiuteris jas vykdo.\nTerminal naudojimas gali padėti tau geriau suprasti, kaip veikia tavo kompiuteris. Kai tu įrašai komandas ir matai, kaip jos veikia, tu pradedi suvokti, kas vyksta tavo kompiuterio viduje.\nTerminal naudojimas gali padėti tau tapti tikru kompiuterių ekspertu. Ir kas žino, galbūt ateityje tave sudomins programavimo, duomenų analitikos ar tiesiog inžinerijos mokslai? Labai daug profesijų pradeda nautodi programavimą kasdieniuose savo darbuose. Aplinkosaugininkai gali tyrinėti kaip keičiasi klimatas ir kaip kinta gamta, buhalteriai gali paspasrtinti ataskaitų ruošimą, architektai apskaičiuoti kaip statyti namą, jog jis nesugriųtų vykstant žemės drebėjimui, robotikos specialistai - kaip sukonstruoti robotoą, kuris važinėja ir tyrinėja Marso planeta…\n\nSkamba truputį sudėtingai, tiesa? Pateiksiu tau pavyzdį. Įsivaizduok, kad tu turi draugę vardu Pelenė. Pelenė irgi turi kompiuterį, bet nežino, kaip įdiegti programas. Tačiau jūs norite kartu žaisti tą patį žaidimą - lenktyniauti žaidžiant Super Tux Cart. Ką daryti?\nTu gali jai parašyti žinutę ir pasakyti, kad nukopijuotų ir paleistų štai tokį kodą:\nsudo apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update && flatpak install net.supertuxkart.SuperTuxKart -y\nNa štai, jeigu jūs turite paskyras Super Tux Cart, dabar galite nuotoliniu būdu lenktyniauti kartu.\nDar neturi paskyros ir elektroninio pašto adreso? Sekančioje pamokoje tai ir susikursime.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html",
    "href": "a_linux_pagrindai/4_passwords_programms.html",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "",
    "text": "4.1 Intro\nAr žinai, kas kelia didžiausią riziką internete, tiek vaikams, tiek suaugusiems? Nesaugūs slaptažodžiai.\nTokie slaptažodžiai kaip:\nyra begalo pavojingi. Blogi pogramuotjai, dar vadinami “hakeriais”, nuolat bando nulaužti internetinas paskyras. Tam jie naudojasi teksto generatoriais, sukuria šimtus tūkstančių kombinacijų, pvz pelenė123 ir bando nulaužti internetinius slaptažodžius.\nkas gali nutikti blogiausia, jeigu tavo slaptažodį nulauš?\nScerijus:\nRetai, bet taip nutinka.\nŠioje pamokoje išmoksi kas yra saugus slaptažodis, kaip juos sukurti ir kaip juos saugoti. Taip tai ne visada yra patogu, bet deja, kaip visad gyvenime, reikia ieškoti kompromiso tarp saugumo ir patogumo.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html#intro",
    "href": "a_linux_pagrindai/4_passwords_programms.html#intro",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "",
    "text": "12345\nslaptažodis\nvardaspavardė\nmamos vardas\naugintinio vardas\n\n\n\n\n\nHackeris “nulaužia” t.y. atspėja tavo slaptažodį pvz Google paskyros\nNueina į tavo banko paskyrą, ir pranša, kad pamiršo savo slaptažodį. Bankas atsiunčia nuorodą į elektronį paštą, kuriame prideda nuorodą, leidžiančia sukurti naują slaptažodį bankui.\nPrisijungęs prie tavo banko paskyros - hackeris ištuština tavo visas santaupas. Dabar tu turi eiti skolintis, vien tam, kad turėti pinigų maistui.\nBet hackeris buvo ypač blogas, apart visko, jis dar ištrynė ir visas kitas tavo paskyras, nuotraukų kopijas esančias internete ir prikėtė visokių kitų šunybių.\nNa prie to pačio, dar ir užrakino tavo telefoną, ištrynė kontaktus, tad net nebežinai, kaip paskambinti draugams ir paprašyti pagalbos.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html#kas-yra-saugus-slaptažodis",
    "href": "a_linux_pagrindai/4_passwords_programms.html#kas-yra-saugus-slaptažodis",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "4.2 Kas yra saugus slaptažodis",
    "text": "4.2 Kas yra saugus slaptažodis\nPirmiausia, saugus slaptažodis yra toks, kurio tu nežinai! Jeigu tu nežinai savo slaptažodžio, tu negali jo užrašyti ant jokio popieriaus lapelio, tad niekas jo ir nepamatys.\nTai kaip prisijungti prie paskyrų internete, pvz, banke? prie elektroninio pašto?\nTam padeda slaptažodžių programos. Jų yra įvairių\n\ninternetinės programos tokios kaip Bitwarden, kurios sinchronizuoja, t.y. suvienodina informaciją per visus tavo įrenginius: kompiuterį, telefoną ir t.t.\nkompiuteryje instaliuotos programos, pvz keepassx, kuriose išsaugai slaptažodius ir kai reikia prisijungti, atsidarai jas ir iš jų nusikopijuoji slaptažodį, kurio reikia.\n\nKiti aspektai saugaus slaptažodžio:\n\nbent 16 simbolių (geriau naudoti daugiau, bet ne visur leidžiama)\nnaudoti tiek DIDŽIĄSIAS RAIDES, tiek mažąsas, tiek skaičius bet būtinai ir simpbolius tokius kaip !@#$%^&*()_\n\ntačiau pati svarbiausia taisyklė:\n\nnaudoti skirtingus slaptažodžius visur\n\nJeigu kam nors pavyktų nulaužti tavo vieną paskyrą, pvz kokios nors internetinės parduotuvės, tas hackeris negalėtų panaudoti išgauto slaptažožio norint prisijungti prie tavo elektroninio pašto.\nNaudojant tokias programėlės kaip Bitwarden, KeepassX ir kitas, su laiku tu pamatysi, kiek daug paskyrų turi ir kaip nelengva būtų visur turėti skirtingus slaptažodžius.\n\n4.2.1 KeepassX\nInstlaiuok keepassx savo kompiuteryje. Prisimink iš praėjusio skurio, kaip instaliuoti programas naudojantis Terminal Programos pavadinimas kurio reikės keepassx\nPagalba:\n\nsudo suteikia administratoriaus teises\napt programa kuri valdo programas\ninstall komanda kuri įdiegia programas\n&lt;argumentas&gt; programos pavadinimas, kurią norima įdiegti\n\n             Video Video\nTai dar kartą:\n\n16-20 simbolių slaptažodis\nsusidedantis iš įvairių raidžių, skaičių ir simbolių\nkiekvienam paskyrai skirtingas slaptažodis\nišsaugotas programėleje",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "a_linux_pagrindai/4_passwords_programms.html#elektroninis-pašto-adresas",
    "href": "a_linux_pagrindai/4_passwords_programms.html#elektroninis-pašto-adresas",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "4.3 Elektroninis pašto adresas",
    "text": "4.3 Elektroninis pašto adresas\nDauguma žmonių turi elektroninį paštro adresą sukuart Google svetainėje. Tai labai paprarsta ir patogu, juo labiau, nemokama.\nBet vėlgi, patogumas netolygu saugumui. Visų pirma Google naudojasi visais turimais duomenis, failais, laiškais ir t.t. tam, kad pagerintų reklamos rodymą. Ne Google yra produktas, kurį naudoji, o TU tampi produktu Google.\nTačiau yra ir saugumo problema, jeigu kas nors pamato tavo ekrano slaptžodį ir pavogia telefoną, o ten yra Gmail programėle, tai jau beveik ir nebereikia spėlioti tavo slaptažodžių. Tu gali nespėti užblokuoti savo telefono, o banko sąskaita jau gali būti tuščia. Kaip? Velgi, vagišius pasinaudos “pamiršau savo slaptažodį” funkcija. Jam atsius laišką į gmail su nuoroda kaip susikurti naują slaptažodį, o patvirtinimui, akd ten “tikrai tu”, bankas atsiųs SMS žinutę. Viskas viename įrenginyje…\nO jeigu tavo Gmail laiškuose dar ir tavo žinutės tavo slaptai meilei?\nKą daryti?\nGeriausia turėti elektroninį pašto adresą kuris nėra google. Gera alternatyva - Prononmail.\nTad dabar pažiūrėsime kaip susikurti Protonmail ir kaip galėsi atsidaryti emailus Thunderbird laiškų probramėlėje kompiuteryje.\nLaišku programėlės į telefoną - net nediegsime, juk vėl padidintume riziką.",
    "crumbs": [
      "Linux Pagrindai",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "",
    "text": "5.1 Shell ir Terminalas\nŠiek tiek istorijos… Senais laikais kompiuteriai buvo milžiniški. Kad būtų patogiau (santykinai) su jais dirbti, žmonės prisėsdavo prie ekrano su klaviatūra, kuris buvo sujungtas su kompiuteriu. Ši instaliacija – ekranas su klaviatūra – buvo vadinama terminalu. Darbuotojai rašydavo komandas, o kompiuteris jas vykdydavo ir grąžindavo rezultatus. Tais laikais buvo rašomos komandos, nes kompiuteriai dar nebuvo tokie galingi ir neturėjo GUI (graphical user interface, lt - grafinės vartotojo sąsajos). Taigi, terminalas buvo CLI (command line interface, lt- komandų eilutės sąsaja), nes priimdavo komandas. Tai yra vartotojo sąsaja, kurioje komandos įvedamos (input) tekstu, o rezultatai rodomi kaip teksto išvestis (output). Skirtingai nuo GUI, kur naudojami vizualiniai elementai, tokie kaip langai ir mygtukai, CLI leidžia tiesiogiai rašyti instrukcijas, kurias vykdo sistema.\nKiek vėliau, atsiradus ekranams…\nŠiais laikais, kai norime, kad kompiuteris vykdytų komandas, taip pat naudojamės terminalu, tik jau ne fiziniu, o program, kuri emuliuoja fizinį terminalą.\nPrograma, kuri priima ir vykdo komandas, bendrai vadinama Shell. Ji priima komandas, išverčia jas į kompiuterio suprantamą kalbą ir liepia kompiuteriui jas įvykdyti. Po to, gavusi rezultatus, ji juos parodo terminale. Yra keletas skirtingų Shell “kalbų” arba tipų. Populiariausi Shell tipai, tokie kaip Bash (Bourne Again Shell), yra standartinė kiekvienos Linux sistemos dalis. Zsh (Z Shell) yra standartinis Shell MacOS sistemose, tačiau jis vis labiau populiarėja ir tarp Linux vartotojų.\nShell programos leidžia automatizuoti įvairias užduotis ir vykdyti sudėtingas komandas. Be to, Shell turi programavimo kalbos savybių, leidžiančių rašyti skriptus – failus su komandomis, kurios vykdomos viena po kitos.\nTaigi terminalas yra CLI programa, kuri leidžia pasiekti Shell sąsają. Jį galima įsivaizduoti kaip langą kompiuteryje, per kurį įvedi komandas ir matai jų rezultatus. Terminalo programos naudojamos įvairiose operacinėse sistemose, nes jos leidžia efektyviau valdyti sistemą nei daugelis grafinių vartotojo sąsajų. Naudodajantis terminalu, gali atlikti įvairias užduotis greičiau ir tiksliau.\nAtidaryk terminalo programą ir įrašyk šią komandą. Ji parodys, kur yra Shell ir koks būtent Shell tipas naudojamas.\nAtsakymas (output) parodo vykdomojo Shell failo vietą – Shell programą, kuri šiuo metu naudojama tavo terminale. Iš output taip pat gali matyti, koks tai Shell tipas. Šiuo atveju, tai Bash.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#shell-ir-terminalas",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#shell-ir-terminalas",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "",
    "text": "The IBM 2741 Terminal IBM\n\n\n\n\n\n\n22.0 IBM Modell 360 / 370 IBM\n\n\n\n\n\n\n\nwhich $SHELL",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#iš-ko-susideda-cli-komanda",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#iš-ko-susideda-cli-komanda",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.2 Iš ko susideda CLI komanda?",
    "text": "5.2 Iš ko susideda CLI komanda?\nAtsidaryk terminalo programą. Štai ką turėtum pamatyti:\n\n\n\nTerminal su matomu prompt\n\n\n\nPrompt\n\nTerminale iškart matai prompt – tai teksto eilutė, kuri nurodo, kad sistema yra pasirengusi priimti komandą. Ši eilutė dažniausiai rodo informaciją apie dabartinę direktoriją, vartotojo vardą ar kitus naudingus duomenis. Pavyzdžiui:\njustas@linux-pc:~$\nČia rodoma: vartotojo vardas @ kompiuterio pavadinimas. Simbolis ~ nurodo aktyvią darbinę direktoriją (namų direktoriją), o $ reiškia, kad sistema laukia įvesties (todėl ir vadinama prompt – iššaukimas). Kas yra darbinė direktorija, sužinosime vėliau.\nŠtai pavyzdys, kai Shell yra užsiėmęs ir nėra pasirengęs priimti tavo komandos:\n\n\n\nTerminal vykdo užduotį\n\n\n\nŽymeklis (Cursor)\n\nMirksintis žymeklis (cursor) rodo, kad terminalas pasirengęs priimti kitą įvestį ir nurodo, kurioje vietoje eilutėje bus įrašas.\n\nKomanda (command)\n\nKomanda (angl. command) yra specifinis nurodymas, kurį vartotojas įveda, kad būtų atliktas tam tikras veiksmas sistemoje. Komandos gali būti naudojamos įvairiems veiksmams atlikti, pvz., failų kopijavimui, direktorijų kūrimui ar informacijos rodymui. Pavyzdžiui, komanda ls rodo dabartinės direktorijos failus ir subdirektorijas:\nls\nKai kurios komandos turi subkomandas. Pavyzdžiui, apt yra komanda, atsakinga už programinės įrangos (angl. software) valdymą, tačiau ji naudojama su subkomandomis:\n\napt update:: Atnaujina prieinamų programų sąrašą.\napt install: Instaliuoja nurodytą paketą.\napt remove: Pašalina nurodytą paketą.\napt upgrade: Atnaujina visus diegtus paketus į naujausias versijas\n\nKad bet kas negalėtų instaliuoti programų, ši komanda turi būti vykdoma su administratoriaus teisėmis, pasitelkiant komandą sudo. Todėl kartais naudojamos kelios komandos iš eilės:\nsudo apt update\nsudo apt install cowsay\n\nPasirinkimai ir argumentai (Option, Argument)\n\nPasirinkimas (angl. option) ir argumentas (angl. argument) yra papildomi parametrai, kurie gali būti pridėti prie komandos, siekiant tiksliau nurodyti, kaip komanda turėtų būti vykdoma.\nPasirinkimas (option): Pasirinkimas modifikuoja komandos elgesį. Jis dažnai pridedamas prie komandos su brūkšneliu (-) arba dvigubu brūkšneliu (--). Pavyzdžiui, naudojant ls -l, -l yra pasirinkimas, kuris rodo failų sąrašą ilgąja forma. Naudojant sutrumpintus pasirinkimus, naudojamas vienas brūkšnys -, o išrašant pilną pavadinimą – dvigubas brūkšnys --.\nArgumentas (argument): Argumentas yra papildoma informacija, kurią komanda naudoja veikimui. Pvz., ls Documents nurodo, kad komanda ls turėtų parodyti direktorijos Documents turinį. Šiuo atveju Documents yra argumentas.\n\n\n5.2.1 Praktika\n\nIdentifikuok užklausą (prompt), komandą (command), pasirinkimą (option) ir argumentą (argumentą). Nepanikuok, jei nepažįsti pačių komandų.\n\nmain-user@linux-mint:~$ sudo apt install -y cowsay\nmain-user@linux-mint:~$ cd Downloads\nmain-user@linux-mint:~$ rm -rf test/\nmain-user@linux-mint:~$ ls -alh /home/user/Downloads\nmain-user@linux-mint:~$ mkdir -p /project/data\n\nSurask būdą, kaip sukurti skirtukus (tabs) terminalo lange. Kartais yra labai patogu turėti kelis skirtingus terminalo skirtukus. Pavyzdžiui, viename galite stebėti kompiuterio temperatūrą, kitame valdyti ir paleisti programas, o trečiame - stebėti, ar sistema nefiksuoja kokių nors klaidų. Bet kaip atidaryti skirtukus? Koks yra klaviatūros trumpinys? Jei norėtumėte paleisti ne skirtuką, o atskirą langą, koks trumpinys tai padarytų?\n\n\n\nSusirask terminalo grafinius nustatymus ir pakeisk foną, teksto spalvą ir kitus stiliaus elementus. Rask tau patinkantį stilių. Nebijok eksperimentuoti!\n\n\n\nNors dažniausiai žymeklis yra blyksintis kvadratėlis, surask, kaip jį pakeisti į |?",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#linux-failų-sistema",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#linux-failų-sistema",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.3 Linux failų sistema",
    "text": "5.3 Linux failų sistema\nTerminai “direktorija”, “katalogas” ir “aplankas” dažnai vartojami kaip sinonimai ir paprastai reiškia tą patį – vietą failų sistemoje, kur gali būti saugomi failai ir kiti subkatalogai. Tačiau yra keletas kultūrinių ir kontekstinių niuansų:\n\nDirektorija (angl. directory): Techninis terminas, dažniausiai vartojamas Unix/Linux bendruomenėje ir kitose techninėse aplinkose. Jis pabrėžia hierarchinę failų sistemos struktūrą.\nKatalogas: Tai dar vienas techninis terminas, dažnai vartojamas kaip sinonimas direktorijai. Šis terminas paplitęs tiek techninėje, tiek kasdieninėje kalboje.\nAplankas (angl. folder): Terminas, dažniausiai naudojamas grafinėse vartotojo sąsajose (GUI), pavyzdžiui, Windows ir Mac OS. Nors jis iš esmės reiškia tą patį kaip direktorija ar katalogas, jis dažniau vartojamas GUI kontekste.\n\nČia aš naudosiu terminą „direktorija“, nes jis yra artimiausias angliškam „directory“. Tačiau kartais galiu panaudoti ir „aplanką“ ar „katalogą“, tad nenustebk.\n\n5.3.1 sudo\nPraeitame skyriuje aptarėme, kad tam tikroms komandoms vykdyti reikia naudoti sudo, t.y., eskaluoti (pakelti) savo vartotojo privilegijas iki administratoriaus (root) lygio. Tam reikia įvesti slaptažodį. Taip užtikrinamas saugumas, kad bet kas negalėtų vykdyti pavojingų veiksmų sistemoje.\nPaprastas vartotojas (user) ir administratorius (root) Linux sistemoje turi skirtingas teises ir privilegijas:\nuser:\n\nTeisės: Turi ribotas teises, gali atlikti veiksmus tik savo namų direkorijoje (home directory) ir kitose direktorijose, kuriose turi suteiktas teises.\nPriėjimas: Negali atlikti sisteminės administracijos užduočių, pvz., negali įdiegti ar pašalinti programinės įrangos, keisti sisteminių failų ar atlikti daugumos konfigūracijos pakeitimų.\n\nroot\n\nTeisės: Turi pilną administracinę prieigą prie visos sistemos. Gali atlikti bet kokias užduotis, įskaitant sisteminių failų modifikavimą, vartotojų administravimą, programinės įrangos diegimą ir pašalinimą.\nPriėjimas: Gali atlikti bet kokias operacijas be apribojimų.\n\nPaprastas vartotojas, vykdydamas sudo, gali laikinai gauti root teises, pvz.:\nsudo apt install &lt;programa&gt;\nPerėjimas iš paprasto vartotojo į root yra galimas tik tiems vartotojams, kurie yra įtraukti į sudo grupę. Instaliuojant Linux, pirmasis vartotojas automatiškai pridedamas prie šios grupės, tačiau vėliau sukurti vartotojai gali būti pridėti į sudo grupę pagal poreikį.\n\n\n5.3.2 root direktorija\nWindows operacinėje sistemoje turbūt matei diskus, pažymėtus raidėmis, pavyzdžiui, C:, D:, E:. Tai nereiškia, kad kompiuteryje yra keli fiziniai kietieji diskai. Dažniausiai tai yra vienas kietasis diskas, padalytas į logines dalis.\n\n\n\nŠaltinis OnlineComputerTips\n\n\nPavyzdžiui, C: diske paprastai saugomi Windows failai, o vartotojai dažnai naudoja kitą diską failams saugoti. Šie „diskai“ yra visiškai atskirti vienas nuo kito.\nLinux sistemoje viskas veikia šiek tiek kitaip. Net jei kompiuteryje būtų keli fiziniai diskai, jie gali būti sujungti į vieną loginę talpą (angl. logical volume) ir „pakišti“ po root direktorija, kuri žymima /.\nRoot direktorija yra failų sistemos viršūnė, žymima /. Visi kiti failai ir direktorijos yra šios šakninės direktorijos pavaldiniai. Tai atitinka Windows C: diską.\n\n\n\nŠaltinis\n\n\nČia rasi daug subdirektorijų. Svarbiausios iš jų:\n\n/root: Root vartotojo (administratoriaus) namų direktorija.\n/etc: Konfigūracijos failai, kurie kontroliuoja įvairių programų paleidimą ir veikimą.\n/home: Paprastų vartotojų namų direktorijos, pvz., /home/justas/, /home/ruprecht/.\n/mnt: Laikina vieta prijungtoms laikmenoms, tokioms kaip kietieji diskai ar tinklo diskai.\n/media: Katalogas, kuriame pritvirtinami USB, CD ar DVD įrenginiai.\n/bin: Sisteminiai vykdomieji failai, pvz., ls, cp, mv.\n/lib: Bibliotekos, būtinos sisteminėms programoms ir komandų vykdymui.\n\nKai atidarai failų naršyklę (Linux Mint tai programa Nemo), tavo namų direktorija bus po /home/vartotojas/. Štai kaip atrodytų naršy\n/\n└── home\n    ├── user name\n\nVisada gali pasitikrinti savo buvimo vietą, paspaudžiant ant „Toggle Location Entry“:\n\n\n\n5.3.3 Praktika\n\nAtsidaryk excalidraw naršyklėje ir nupiešk /, /home/, /media/ struktūros diagramą. Įsivaizduok, kad kompiuteryje yra trys vartotojai: justas, ruprechtas ir slibinas. Nupiešk jų namų direktorijas.\nĮkišk USB laikmeną į kompiuterį, atidaryk failų naršyklę (Nemo). Turėtum pamatyti kažką panašaus. Paspausk ant USB laikmenos, tada spustelėk „Toggle Location Entry“ ir identifikuok, kurioje failų sistemos vietoje yra USB laikmena. Pridėk tai prie diagramos, kurią piešei.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#keliavimas-failų-sistema",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#keliavimas-failų-sistema",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.4 Keliavimas failų sistema",
    "text": "5.4 Keliavimas failų sistema\nJau šiek tiek susipažinai su Linux failų sistemos struktūra. Kai atsidarai failų naršyklę (Nemo), matai šias direktorijas:\n\nDirektorijų medyje tai atrodytų taip:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\nŠiame skyriuje išmoksi, kaip sužinoti, kur esi, su komanda pwd, kaip pakeisti direktoriją su cd ir kaip atspausdinti failų bei direktorijų sąrašą su ls.\nTačiau prieš einant prie pačių komandų, tau dar reikis susipažinti su vienu svarbiu konceptu - absoliučiu ir relatyviu adresu (arba keliu, nes angliškai - path).\n\n5.4.1 Absoliutus kelias\nAbsoliutus kelias (angl. absolute path) yra pilnas kelias nuo šaknies direktorijos (/) iki konkretaus failo ar katalogo. Jis visada nurodo tą pačią vietą, nepriklausomai nuo to, kur esi šiuo metu.\nPavyzdžiui, šis kelias nurodo visą maršrutą nuo / per /home/, vartotojo namų direktoriją /justas/iki subdirektorijos Documents, kurioje yra failas data.csv:\n/home/justas/Documents/data.csv\n\n\n5.4.2 Relatyvus kelias\nRelatyvus kelias (angl. relative path) yra nurodomas atsižvelgiant į dabartinę darbinę direktoriją. Jis neturi pradinio /, todėl priklauso nuo to, kur esi.\nJeigu šiuo metu esi direktorijoje/home/justas, relatyvus kelias į failą data.csv subdirektorijoje Documents būtų:\nDocuments/data.csv\nKartais gali pamatyti relatyvų kelią su . (tašku), kuris reiškia “esama direktorija”. Taigi šis relatyvus kelias irgi tinka:\n./Documents/data.csv\n\n\n5.4.3 ~\nVartotojų vardai Linux sistemoje gali skirtis, pvz., justas, ruprechtas ir t.t. Tarkime, rašai skriptą, kuris turi veikti vartotojo Downloads direktorijoje. Tu negali žinoti vartotojo vardo, todėl naudoti absoliutų kelią /home/justas/Downloads būtų nepatogu.\nBet ir relatyvus kelias ./Downloads gali sukelti problemų, nes skriptas gali būti paleistas ne iš vartotojo namų direktorijos, o tiesiai iš Downloads direktorijos, kas sukurtų absurdišką Downloads/Downloads.\n/\n└── home\n    ├── justas\n    │   ├── Downloads\n    │     ├── ./Downloads\nŠtai čia gelbsti ~. Shell atpažįsta ~ kaip nuorodą į dabartinio vartotojo namų direktoriją.\nTaigi relatyvus kelias~/Downloads yra automatiškai keičiamas į /home/justas/Downloads, jeigu vartotojas yra justas, arba į /home/ruprecht/Downloads, jeigu vartotojo vardas yra ruprecht.\nKada naudoti ką?\n\nAbsoliutūs keliai dažniausiai naudojami skriptuose, konfigūracijų failuose, dokumentacijoje ir sisteminiuose veiksmuose.\nRelatyvūs keliai labiau tinka kasdieniam darbui su failais, naršymui ir interaktyviam scenarijų vykdymui.\n\n\n\n5.4.4 pwd\nJau kelis kartus minėjome darbinę direktoriją. Kas tai? Darbinė direktorija yra ta direktorija, kurioje šiuo metu “gyvena” shell. Įsijunk terminalą, įrašyk komandą pwd ir paspausk Enter, kad ją įvykdytum. Komanda pwd (angl. “print working directory”) parodo dabartinės darbinės direktorijos pilną kelią (path).\npwd\n\nŠiuo atveju darbinė direktorija yra /home/justas.\nTaigi, iš mano darbinės direktorijos, Downloads subdirektorijoje esantis failas data.csv man būtų pasiekiamas Downloads/data.csv keliu. Tačiau aš galiu pakeisti savo darbinę direktoriją pereidamas į kitas direktorijas su komanda cd.\n\n\n5.4.5 cd\nKomanda cd (angl. change directory) naudojama pereiti iš vienos direktorijos į kitą. Kai pereini į kitą direktoriją, pasikeičia ir darbinė direktorija, kartais dar vadinama aktyvia direktorija (angl. current directory).\nĮvedęs komandą:\ncd Downloads\nAš pereinu į Downloads subdirektoriją. Kadangi Downloads yra mano namų direktorijoje, galėjau pasinaudoti relatyviu keliu. Atkreipk dėmesį, kaip pasikeičia terminalo prompt: vietoj ~ (jau žinai, ką jis reiškia), dabar matosi ~/Downloads.\n\nDabar failas Downloads/data.csv tampa pasiekiamas tiesiog kaip data.csv.\nKomandai cd gali duoti absoliutų kelią, ir tada cd pakeis darbinę direktoriją, nesvarbu, kur tuo metu esi:\ncd /home/justas/Documents\nŠi komanda perkelia mane iš Downloads tiesiai į Documents.\n\nTačiau cd komandai gali nurodyti ir relatyvų kelią, svarbu, kad jis egzistuotų. Pavyzdžiui, aš galiu pereiti iš savo namų direktorijos į Downloads su cd Downloads/, tačiau negaliu pereiti į Documents, jei esu Downloads direktorijoje, nes Documents ten nėra. Tada gaunu klaidos pranešimą: bash: cd: Documents/: No such file or directory.\n\nPriminimui:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\nKaip jau minėjau, taškas . reiškia “čia”. Pvz., iš namų direktorijos galėčiau pereiti į Downloads su cd ./Downloads.\nYra ir .., du taškai, kurie reiškia direktoriją esančią aukščiau už dabartinę (.) direktoriją. Ji dažnai vadinama parent directory. Taigi, su komanda cd ./Downloads nuėjęs į Downloads, galiu vėl pakilti į viršų su cd ...\n\n.. taip pat gali būti naudojama pereiti relatyviai, pvz., iš Downloads į Documents. Būdamas Downloads direktorijoje, galiu naudoti komandą cd ../Documents, kad pakilčiau vienu lygiu aukščiau ir tada pereičiau į Documents.\n\n.. gali būti naudojama ir kelis kartus iš eilės, pvz., iš Downloads galima pakilti į home, naudojant cd ../...\n\nPriminimui\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\nKomandą cd gali naudoti ir be jokių argumentų, kad grįžtum į namų direktoriją, pvz., cd arba su cd ~.\n\nPereiti į ankstesnę direktoriją gali su komanda cd -. Tarkime, buvau home/justas/Downloads, perėjau į home/justas/Documents, bet supratau, kad padariau klaidą - norėčiau likti Downloads. Galiu grįžti atgal su cd -.\n\nSveikinu! Dabar jau moki naršyti po direktorijas naudojant terminalą. Nors tai gali atrodyti sudėtinga iš pradžių, laikui bėgant pastebėsi, kad paleisti terminalą su klaviatūros trumpiniu Ctrl-Alt-T ir, naudojant TAB greitesniam komandų ir argumentų užpildymui, greitai nueiti į norimą direktoriją bei redaguoti failus bus daug greičiau nei tai daryti su grafinės sąsajos (GUI) įrankiais.\nPvz., iš savo namų direktorijos pereinu į Documents, tada į project, tada į documentation, atspausdinu failų sąrašą su ls ir redaguoju failą su nano programa.\nVideo\nBet kas ta ls komanda?\n\n\n5.4.6 ls\nKomanda ls (angl. list storage) naudojama norint peržiūrėti failų ir katalogų sąrašą dabartinėje arba nurodytoje direktorijoje. Tai viena dažniausiai naudojamų komandų, naviguojant failų sistemoje.\nJei atidarytum failų naršyklę, pavyzdžiui, Nemo, matytum kažką panašaus:\n\nLygiai taip pat failų sąrašą gali parodyti ir terminale, įvedant komandą ls:\n\nKomanda ls gali priimti argumentą – direktorijos kelią, kurio turinį norima parodyti. Šis kelias gali būti tiek absoliutus, tiek relatyvus. Pavyzdžiui, ls /home/justas/Downloads parodys Downloads katalogo turinį. Atkreipk dėmesį į spalvas: failai yra balti, o katalogai – mėlyni.\n\nKartais pamatyti tik failų pavadinimus gali būti nepakankama. Galbūt norisi matyti daugiau informacijos, pvz., kada failai sukurti, kas turi teises juos valdyti ar matyti, ar kam jie priklauso.\n\nKaip ir failų naršyklėje, kur gali perjungti į “List View”, terminale gali naudoti komandos ls nustatymą -l, kuris išveda išsamų (ilgą) failų sąrašą su papildoma informacija: teisėmis, savininku, dydžiu ir paskutinio modifikavimo data.\n\nPavyzdžiui ką tokią eilutė reikšia, paaikšinsiu netrukus.\ndrwxr-xr-x 2 justas justas 4096 Sep 15 10:19 Desktop\nNorint pamatyti visus failus, įskaitant paslėptus (failai, kurių pavadinimai prasideda tašku), gali naudoti -a arba --all:\n\nNemo failų naršyklėje taip pat gali pamatyti paslėptus failus, jei aktyvuosi šią funkciją.\nVideo\nKai paleidi ls -l, failų dydžiai nurodomi baitais. Kartais naudingiau matyti dydžius, išreikštus žmonėms suprantamesniais vienetais, kaip kilobaitai (1000 baitų), megabaitai (1000 kilobaitų) ir t.t. Tam gali naudoti nustatymą --human-readable arba trumpinį -h - ls -lh\nŠios abi komandos ls -all -l --human-readable ir ls -alh yra teisingos, tačiau dažniau naudojamas trumpesnis variantas. Panaudojant ls -alh, galėsi matyti paslėptus failus, o failų dydžiai bus išreikšti žmonėms labiau suprantama forma.\n\nKartais gali prireikti rekursyvaus katalogo turinio peržiūros. Komanda ls -R arba ls --recursive parodys ne tik pasirinktos direktorijos, bet ir visų jos subdirektorijų turinį.\n\n\n\n5.4.7 Teisės ir tipai\nŠi eilutė rodo failų arba direktorijų sąrašą su jų detalėmis:\n\nPirmas stulpelis parodo, kokio tipo failas ar direktorija tai yra, ir kokias teises turi skirtingi vartotojai.\nPirmoji raidė gali būti:\n\nd – Direktorija (directory)\nl – Simbolinė nuoroda (link)\n- – Įprastas failas (regular file)\n\nLinux sistemoje yra trys vartotojų tipai:\n\nSavininkas – vartotojas, kuris sukūrė failą arba direktoriją. Šiuo atveju vartotojas yra justas.\nGrupė – Grupė, kuriai priklauso failo savininkas. Dažnai grupės vardas yra tas pats kaip ir savininko vartotojo vardas, pvz., justas. Vartotojai gali priklausyti kelioms grupėms, tačiau kiekvienas failas ir direktorija turi pagrindinę grupę, kuri turi tam tikras teises į tą failą arba direktoriją. Pameni minėjom, kad ne visi vartotojai priklauso sudo grupei? Čia panašiai, tik kita grupė.\nKiti (other) – Visi kiti vartotojai, kurie nėra nei savininkas, nei grupės nariai. Tai apima visus kitus sistemos vartotojus, kurie neturi specialių teisių šiam failui ar direktorijai.\n\nTeisės nurodomos pirmame stulpelyje trimis tripletais: xxx-xxx-xxx (be brūkšnių).\n\nr – Skaitymo teisė (read), leidžia matyti ir skaityti turinį.\nw – Rašymo teisė (write), leidžia perrašyti turinį.\nx – Vykdymo teisė (execute), leidžia vykdyti failą.\n\nPvz., teisės drwxr-xr-x:\n\nd – Direktorija (directory)\nrwx – Savininko teisės: skaitymas (read), rašymas (write), vykdymas (execute)\nr-x – Grupės teisės: skaitymas (read), vykdymas (execute)\nr-x – Kitų vartotojų teisės: skaitymas (read), vykdymas (execute)\n2 – Nuorodų skaičius į šią direktoriją. Tai apima nuorodą į pačią direktoriją ir bet kurias subdirektorijas. Pavyzdžiui, jei skaičius būtų 4, tai reikštų, kad direktorijoje yra trys subdirektorijos (ir arba failai) ir viena pati direktorija.\njustas – Direktorijos savininko vartotojo vardas.\njustas – Direktorijos grupės vardas.\n4096 – Direktorijos dydis baitais.\nSep 15 10:19 – Paskutinio direktorijos modifikavimo data ir laikas.\nDesktop – Direktorijos pavadinimas.\n\n\n\n5.4.8 Pagalbinės funkcijos terminale\n\n\n5.4.9 history\nKomanda history (liet. „istorija“) naudojama norint parodyti visų anksčiau įvestų komandų sąrašą dabartinėje terminalo sesijoje. Tai suteikia patogų būdą sekti ir kartoti anksčiau vykdytas komandas.\n\nJei nori parodyti tik paskutines n komandų, gali naudoti history n. Pvz., parodyti paskutines 10 komandų history 10:\n\nKartoti konkrečią komandą pagal numerį galima įrašius ! ir komandos numerį. Pavyzdžiui, jei nori pakartoti komandą, kurios numeris yra 99:\nhistory\n!99\n\nIštrinti komandų istoriją galima su history -c.\nhistory -c\nhisotry\n\n\n\n5.4.10 clear\nKomanda clear (liet. „valyti“) naudojama norint išvalyti terminalo ekraną, pašalinant visus anksčiau įvestus ir parodytus tekstinius duomenis. Tai palieka terminalą švarų ir patogesnį tolimesniam naudojimui. Svarbu: ši komanda neištrina terminalo istorijos (history); ji tik paslenka visą tekstą į viršų, už dabartinio vaizdo ribų.\nclear\n\n\n5.4.11 Ctrl-L\nAlternatyva komandos clear naudojimui yra klaviatūros trumpinys Ctrl-L. Šis trumpinys atlieka tą pačią funkciją kaip ir komanda clear, tačiau jis yra greitesnis ir patogesnis, ypač kai dirbi terminale ir nori greitai išvalyti ekraną. Naudojant Ctrl-L, terminalo ekranas bus išvalytas, tačiau terminalo istorija liks nepakitusi.\n\n\n5.4.12 Navigacija terminale\nRašant ilgas komandas, klaidos neišvengiamos. Pavyzdžiui, rašai „Hello World“ ir paspaudi Enter ⏎, tik tada supranti, kad reikėjo parašyti echo prieš „Hello World“.\nŠtai kaip tai gali ištaisyti:\n\nPakilk į ankstesnę eilutę naudodamas rodyklę į viršų ⬆️.\nPerkelk kursorių į eilutės pradžią naudodamas rodyklę į kairę ⬅️.\nPrirašyk echo ir pakartok komandą paspaudus Enter ⏎.\n\nVideo\nKartais eilutės būna gana ilgos:\nsud apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update\nJei praleidai raidę, pavyzdžiui, pirmame sudo truksta o, nereikia viską iš naujo rašyti\n\nPakilk į ankstesnę eilutę naudodamas rodyklę į viršų ⬆️.\nNaudokCtrl-A, kad perkeltum kursorių į eilutės pradžią.\n➡️ ➡️ ➡️ ir pridėti o raidę.\npabaigus taisymą tiesiog paspausti Enter ⏎ (nebūtina nueiti į eilutės pabaigą)\n\nVideo\nTavo žiniai:\n\nCtrl-A: perkelia kursorių į eilutės pradžią\nCtrl-E: perkelia kursorių į eilutės pabaigą\nCtrl-U: ištrina viską į dešinę nuo kursoriaus\n\nUžduotis:\nPastebėsi, kad Ctrl-C ir Ctrl-V neveikia taip, kaip esame įpratę. Terminalo nustatymuose (settings) rask derinį, kuris atitinka įprastines Ctrl-C ir Ctrl-V kombinacijas.Kokie jie?\n\n\n5.4.13 Ctrl-C ir Escape\nNaudojant komandinę eilutę, kartais terminalas gali „pakibti“. Pvz., jei pradėsi rašyti echo su kabutėmis, bet pamirši uždaryti kabutes, terminalas lauks, kol užbaigsi komandą.\nTokiais atvejais terminalas gali atrodyti „pakibęs“. Pabandyk paleisti šias komandas po vieną:\n$ echo \"hello\n$ grep foobar\n$ yes\n$ tail\n$ cat\nNorėdamas nutraukti „pakibusią“ komandą, naudok Ctrl-C. Šis derinys siunčia kontrolės signalą terminalui ir nutraukia vykdomą procesą. Pastaba: Ctrl-C čia reiškia „Cancel“ (nutraukti).\nKartais terminale gali pamatyti ^C, rodančią, kad buvo paspaustas Ctrl-C. Jei Ctrl-C neveikia, pabandyk ESC klavišą.\nVerta žinoti: kad kartais vietoj Ctrl- notacijos, gali sutikti ^ notaciją, pvz., ^C, ^O, ^X.\n\n\n5.4.14 Praktika\n\nKai paleidi terminalą, kurioje direktorijoje esi? Pakeisk direktoriją į Downloads. Uždaryk terminalą ir paleisk jį iš naujo. Kur dabar esi?\nIš/home/user/ direktorijos pereik į Downloads ir atspausdink direktorijos turinį naudojant ls. Užduotis:\n\nFailų dydis būtų suprantamas žmonėms.\nSąrašas būtų pateikiamas viename stulpelyje.\n\nIš /home/user/ direktorijos pereik į Documents. Iš ten atspausdink failų sąrašą Downloads (!!!) direktorijoje\n\nnaudojant absoliutų kelią\nnaudojant relatyvų kelią\n\n\nPagalbai:\nHome Directory/\n├── Desktop/\n├── Documents/\n├── Downloads/\n├── Music/\n├── Pictures/\n├── Public/\n├── Templates/\n└── Videos/\n\nNaudok clear, kad išvalytum terminalą, tada su history surask tau patinkančią komandą ir pakartok ją naudojant !n.\nVizualizuok vartotojų ir grupių santykius pagal šią lentelę. Naudok Excalidraw:\n\n\n\n\nVartotojas\nSudo grupė\nGrupė “namai”\n\n\n\n\nroot\nTaip\nTaip\n\n\njustas\nTaip\nTaip\n\n\nruprechtas\nNe\nTaip\n\n\n\n\nĮsivaizduok, kad failas /home/ruprechtas/info.txt turi tokias savybes:\n\n-rwx----- 2 ruprechtas namai 4096 Sep 15 10:19 info.txt\nAr vartotojas justas, priklausantis grupei namai, galės atidaryti ir perrašyti šį failą? Kodėl?\n\nKą reikėtų pakeisti, kad vartotojas justas galėtų matyti ir perrašyti šį failą? Atsakyk teoriškai (nes dar nežinai komandų, kuriomis tai apdaryti).\nNukopijuok ir paleisk šią komandą terminale.\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/e61bb3ab5cf28686f74a50e436b06fe6/raw | bash\nŠi komanda parsisiųs ir įvykdys skriptą, kuris sukurs test direktoriją tavo/home/username/ direktorijoje.\nPasinaudok ls, atspausdink visus failus, esančius (sub-)direktorijose ir atsakyk į šiuos klausimus:\n\nKiek yra subdirektorijų test direktorijoje?\nKiek iš viso suskaičiuoji failų? Suskaičiuok visus failus, esančius visose subdirektorijose.\nKokio tipo failų (pvz., .txt, .csv) yra daugiausia? Kurioje direktorijoje?",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/5_bash_terminal_filesystem.html#funkcijos",
    "href": "b_bash_pagrindai/5_bash_terminal_filesystem.html#funkcijos",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.5 Funkcijos",
    "text": "5.5 Funkcijos\nVisos skyriuje panaudotos funkcijos\n\n\n\n\n\n\n\nFunkcija\nAprašymas\n\n\n\n\nwhich\nParodo vykdomojo failo vietą\n\n\npwd\nParodo dabartinės darbinės direktorijos pilną kelią\n\n\ncd\nPakeičia dabartinę direktoriją (esamą vietą) terminale\n\n\nls\nRodo failų ir katalogų sąrašą direktorijoje\n\n\nsudo\nLeidžia vykdyti komandas su kitokio vartotojo teisėmis (dažniausiai root)\n\n\nhistory\nRodo ankstesnių komandų istoriją\n\n\nclear\nIšvalo terminalo ekraną\n\n\nCtrl-A\nPerkelia kursorių į eilutės pradžią\n\n\nCtrl-E\nPerkelia kursorių į eilutės pabaigą\n\n\nCtrl-U\nIštrina viską į kairę nuo kursoriaus\n\n\nCtrl-C\nNutraukia vykdomą komandą terminale\n\n\nCtrl-L\nIšvalo terminalo ekraną (panašu į clear)\n\n\nShift-Ctrl-C\nKopijuoja tekstą iš terminalo\n\n\nShift-Ctrl-V\nĮkelia tekstą į terminalą\n\n\nShift-Ctrl-T\nSukuria naują terminalo skirtuką\n\n\nShift-Ctrl-N\nSukuria naują terminalo langą",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/6_bash_comands_basic.html",
    "href": "b_bash_pagrindai/6_bash_comands_basic.html",
    "title": "6  BASH komandos",
    "section": "",
    "text": "6.1 Failų ir direktorijų valdymas\nPraėjusiame skyriuje išmokai naviguoti terminale naudojant komandas pwd ir cd. Sužinojai apie Linux failų sistemą: kaip matyti visų failų ir katalogų sąrašą naudojant ls komandą, bei tai, kad Linux sistemoje vartotojai turi skirtingas teises, priklauso grupėms, ir kiekvienas failas turi savininko, grupės, bei kitų vartotojų teises naudotis tuo failu ar katalogu. Taip pat išmokai svarbių klaviatūros trumpinių, kaip peršokti į komandinės eilutės pradžią (Ctrl-A), pabaigą (Ctrl-E), nutrinti dalį (Ctrl-U), kaip kopijuoti ir įklijuoti į terminalą naudojant Ctrl-Shift-C ir Ctrl-Shift-V. Išmokai dirbti su terminalo istorija naudojant history ir kartoti komandas su !n.\nŠiame skyriuje skirsi dėmesį darbui su failais ir direktorijomis. Tu išmoksi kurti failus ir direktorijas, juos kopijuoti, perkelti, ištrinti. Taip pat išmoksi sujungti kelias komandas. Ir šio skyriaus pabaigoje pamatysi, kad tavo BASH įgūdžiai tampa dar stipresni!\nPrieš pradedant, įsitikink, kad turi keletą svarbių programų: jq ir curl. Kaip ir praėjusiame skyriuje, kai ieškojaiwhich $SHELL, komanda tau parodė, kur yra binary failas (programa). Dabar padaryk tą patį:\nJei tavo kompiuteris aptinka šias programas, terminalas atspausdins vietą, kur jos yra įdiegtos. Jei terminalas jų neranda, įdiek curl ir jq kaip sisteminius paketus naudojant apt. Jei pamiršai, kaip tai daryti, pakartok ankstesnę medžiagą.\nKai tai atliksi, nukopijuok ir paleisk šią komandą savo terminale - ji sukurs direktoriją shell_2_dalis tavo namų direktorijoje kartu su visais šiam skyriui reikalingais failais:\nJeigu viskas gerai, turėtum pamatyti:\nSu ls komanda atspausdink long formatu savo home directory turinį. Paaiškink visas šios eilutės reikšmes.\nPakeisk savo darbinę direktoriją į ~/shell_2_dalis. Kaip pasikeitė tavo prompt? Paaiškink, kas čia yra kas.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/6_bash_comands_basic.html#failų-ir-direktorijų-valdymas",
    "href": "b_bash_pagrindai/6_bash_comands_basic.html#failų-ir-direktorijų-valdymas",
    "title": "6  BASH komandos",
    "section": "",
    "text": "By J. Howard Miller - U.S. National Archives and Records Administration\n\n\n\n\nPatikrink, ar turi curl, su which curl.\nPatikrink, ar turi jq, su which jq.\n\n\n\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/b4bfc0d672a859afc0fe28f1e721e167/raw | bash\n\n\n\n\n\n\n\n\nTip\n\n\n\nPasikartok komandas cd, prisimink absoliutų ir reliatyvų kelią, bei ką reiškia ~, . ir ... Šiame skyriuje taip pat dažnai reikės naudoti ls, tad pasikartok šią komandą ir jos nustatymus dabar.\n\n\n\n\n\n\n\n6.1.1 echo\nKomanda echo naudojama norint atspausdinti vartotojo įvestį (input) terminale (dar vadinamą standartine išvestimi, angl. standard output). Tai paprasta, bet galinga komanda, dažnai naudojama skriptuose pranešimams rodyti arba kintamųjų reikšmėms tikrinti.\nNors nėra būtina tekstą apskliausti kabutėmis, dėl geresnio aiškumo ir įskaitomumo patartina tai daryti.\necho Hello World!\necho 'Hello World!'\necho \"Hello World!\"\nReikėtų atkreipti dėmesį, jog dvigubos kabutės (\" \") ir viengubos kabutės (' '’) šiek tiek skiriasi. Tekstas, esantis viengubose kabutėse (' '), atspausdinamas paraidžiui, nepaisant ten esančių kintamųjų. Tuo tarpu tekstas, esantis dvigubose kabutėse (\" \"), yra interpretuojamas, ir Shell leidžia naudoti kintamųjų vertes.\nPabandyk šias komandas, kurios naudoja kintamąjį $USER, atspausdinantį shell sesijos vartotojo vardą:\necho My username is $USER\necho 'My username is $USER'\necho \"My username is $USER\"\nAr pastebi, kuo skiriasi išvestis?\n\n\n\n6.1.2 &gt; ir &gt;&gt; operatoriai\n&gt; ir &gt;&gt; operatoriai naudojami išvesties nukreipimui (angl. output redirection). Jie nukreipia komandos išvestį (angl. output) į failą, o ne į terminalą. Šie operatoriai yra esminiai dirbant su failais ir automatizuojant užduotis skriptuose.\n&gt; operatorius nukreipia komandos išvestį į failą, perrašydamas jo turinį, jei failas jau egzistuoja. Jei failas neegzistuoja, jis bus sukurtas.\nŠi komanda sukuria (arba perrašo) failą hello_world.txt su tekstu “Hello World!”.\necho \"Hello World!\" &gt; hello_world.txt\nKaip echo komanda ir jos argumentas “Hello World!” buvo nukreipti į tekstinį failą, taip galime nukreipti ir kitų komandų išvestis į failus. Operatoriaus &gt; argumentas nebūtinai turi būti tik failo pavadinimas, tai gali būti ir failo pavadinimas su absoliučiu ar reliatyviu adresu.\nls &gt; mix/direktorijos_turinys.txt\nŠi komanda nukreipia ls komandos išvestį į failą direktorijos_turinys.txt, kuris yra mix subdirektorijoje. Atsidaryk šį failą ir patikrink, ar jis susikūrė teisingai. Turėtum matyti kažką panašaus į šį vaizdą:\n\n\n\n\n\n\n\nPraktika\n\n\n\nLiekant shell_part_2 direktorijoje, atspausdink namų direktorijos (angl. home directory) turinį su visais paslėptais failais, ilguoju formatu ir žmonėms geriau suprantamais failų ir direktorijų dydžiais, ir nukreipk išvestį į mix subdirektorijoje esantį failą direktorijos_turinys.txt, jį perrašant.\n\n\n\nIntarpas\nHey, ką tik gavai užduotį. Ateityje gausi panašias ir dar sudėtingesnes užduotis. Todėl šioje vietoje padarykime intarpą. Pakalbėkime apie vieną svarbiausių darbo būdų programavime (ir ne tik!) - darbų skaidymą (angl. break down).\nKartais gali gauti labai sudėtingą užduotį, kuri iš pradžių atrodys neįveikiama ar nesuprantama. Tai visiškai normalu. Nestresuok - giliai įkvėpk, iškvėpk, jei reikia, pasiimk popierių ir pieštuką ir pradėk skaidyti darbus į logines sekas. Pvz., prieš tai buvusią užduotį galima suskaidyti į tris dalis:\n\nreikia failų ir direktorijų sąrašo\natspausdinti perrašant\nfailo pavdinimas\n\n\nDabar galima skaidyti ar toliau detalizuoti kiekvieną iš šių dalių.\n\nls -alh pagamina sąrašą ilguoju, žmonėms suprantamų dydžių formatu\n&gt; perrašo\ndirektorijos_turinys.txt bus pavadinimas\n\n\nTačiau dabartinė darbinė direktorija yra ~/shell_part_2, todėl reikia\n\nls -alh kaip argumentą paduoti ~ arba atitinmai /home/username\ndirektorijos_turinys.txt turi būti mix subdirektorijoje\n\n\nSkaidant užduotį į mažesnes dalis, vis labiau suprasi, ką reikia padaryti. Turint daugiau patirties, geriau žinosi, kiek laiko gali prireikti kiekvienam žingsniui.\nPvz., duomenų analitikas gali gauti užduotį: suprognozuoti sekančių metų ledų pardavimus. Analitikas, žinodamas, kad ledų pardavimai priklauso nuo lauko temperatūros, gali suskaidyti darbus taip:\n\nImportuoti istorinius tam tikros vietos temperatūros duomenis\nPrognozuoti sekančių metų kiekvienos dienos temperatūras\nApskaičiuoti kiekvienos dienos pardavimus\nAprašyti duomenis ir pateikti juos užsakovui suprantamu formatu\n\n\n\n\nPhoto by Kamaji Ogino\n\n\nKiekvieną iš šių žingsnių analitikas gali suskaidyti į dar daugiau mažesnių užduočių.\nKodėl tai svarbu? Visų pirma, tai padeda geriau suprasti, ką reikia padaryti, ir kiek tai gali užtrukti. Kiekvienas žingsnis tampa atskiru procesu, ir jei nepavyksta vienas metodas, gali bandyti kitą.\nDarbų skaidymas yra intuityvus procesas kasdieniame darbe ir tu jau šį metodą ir taip taikai pasąmoningai, bet kai gauname naujas ir labai sudėtingas užduotis, vis tiek verta prisiminti šią strategiją, nes kartais mes pamirštame, kaip ji padeda išvengti pasimetimo.\n\n&gt;&gt; operatorius nukreipia komandos išvestį į failą, pridedant (angl. append) prie failo turinio. Jei failas neegzistuoja, jis bus sukurtas.\necho \"What a beatiful morning\" &gt;&gt; day.txt\necho \"What a beatiful day\" &gt;&gt; day.txt\necho \"What a beatiful evening\" &gt;&gt; day.txt\nŠios komandos prideda tekstą “What a beautiful morning”, “What a beautiful day” ir “What a beautiful evening” prie failo day.txt galo, neperrašydamos esamo turinio. Jei tokio failo nėra, jis bus sukurtas.\n\n\n\n\n\n\nPraktika\n\n\n\n\nSusirask tau patinkančios dainos tekstą internete.\nNaudojant komandą echo ir operatorių &gt;, sukurk failą favorite_song.txt. Failo turinys turėtų būti panašus į “My favorite song is ”.\nPirmas keturias dainos eilutes atspausdink į failą song_text.txt naudojant echo ir &gt;&gt;. Nepamiršk, kokie klaviatūros trumpiniai naudojami kopijuojant ir įkeliant tekstą į terminalą!\n\n\n\n\n\n6.1.3 cat\nKomanda cat (angl. concatenate, liet. „sujungti“) naudojama peržiūrėti, sujungti ir atspausdinti failus. Tai viena iš pagrindinių Linux komandų, nes leidžia greitai peržiūrėti failų turinį, įvesti turinį į kitus failus arba sujungti kelis failus į vieną.\nPraeitame skyriuje sukūrei du failus favorite_song.txt ir song_text.txt. Dabar juos ir naudosime.\nAtspausdink failo favorite_song.txt turinį į terminalą:\ncat favorite_song.txt\nPas mane tai atrodo taip:\n\ncat leidžia sujungti kelių failų turinį ir atspausdinti rezultatą terminale:\ncat favorite_song.txt song_text.txt\n\nKaip praeitame skyriuje išmokai, komandos išvestį (nesvarbu, ar tai būtų echo, ar ls) galima nukreipti į failą. Lygiai taip pat gali nukopijuoti failą naudojant cat ir &gt; arba &gt;&gt;:\ncat favorite_song.txt &gt; favorite_song_2.txt\nŠi komanda nukopijuoja failo favorite_song.txt turinį į naują failą favorite_song_2.txt, perrašydama jo turinį, jei toks failas jau egzistuoja.\n\n\n\n\n\n\nPraktika\n\n\n\n\nNaudojant echo ir &gt;&gt;, įrašyk dar 4 eilutes mėgstamiausios dainos teksto į failą song_text_2.txt.\nSujunk failus song_text.txt ir song_text_2.txt, nukreipiant rezultatą į song_text_full.txt:\nPagalvok, kaip naudojant visas iki šiol žinomas komandas, būtų galima gauti song_text.txt failą, kuriame būtų pirmas ketvertas eilučių ir antras ketvertas eilučių teksto?\n\n\n\n\n\n6.1.4 head ir tail\nKomandos head (galva) ir tail (uodega) naudojamos peržiūrėti pirmąsias arba paskutines failo eilutes. Įprastai jos atspausdina 10 eilučių teksto.\n\n\n\n\n\n\nNote\n\n\n\nDabar tavo failas song_text.txt turėtų turėti 8 eilutes teksto. Todėl tokiu pat būdu, kaip prieš tai, pridėk dar 4 eilutes teksto, kad turėtum bent 12.\n\n\nPeržiūrėk pirmas 10 eilučių song_text.txt su head:\nhead song_text.txt\nPeržiūrėk paskutines 10 failo eilučių:\ntail song_text.txt\nTiek head, tiek tail priima nustatymą (option) -n su argumentu, nurodančiu, kiek eilučių atspausdinti:\n\nNorint peržiūrėti pirmas 3 eilutes, naudok komandą: head -n 3 song_text.txt\nNorint peržiūrėti paskutines 5 eilutes, naudok komandą: tail -n 5 song_text.txt.\n\n\n\n\n\n\n\nPraktika\n\n\n\nKas nutiktų, jei panaudotum head arba tail su failu, kuriame nėra 10 eilučių? Pabandyk su favorite_song.txt\n\n\n\n\n\n\n\n\nPraktika\n\n\n\nDabar dirbsi su failu data/temp_vilnius.txt.\n\nNaudojant cat, atspausdink visą failą terminale\nPirmosios dienos prognozės gali turėti mažiau nei 24 valandas (pvz., likusios 6 valandos). Naudojant head, atspausdink tik šiandienos orų prognozes\nKadangi šiandienos oras jau aiškus, tavo draugei Amelijai reikia rytojaus orų prognozės. Derinant head ir tail, išfiltruok eilutes taip ir sukurk tarpinius failus, kad būtų nusiųstos tik rytojaus 24 valandų temperatūros prognozės. Rezultatą išsaugok į failą amelija_temp_vilnius.txt subdirektorijoje data. Naudojant cat įsitikink, jog turi tik rytojaus temperatūras.\n\n\n\n\n\n6.1.5 less\nPraėjusiame skyriuje jau turėjai atvejį, kai viso failo temp_vilnius.txt turinys netilpo į terminalo langą. Tikėtina, reikėjo pakeisti terminalo lango dydį arba slinkti su pele. Dabar tau galbūt kyla klausimas, kaip būtų galima matyti failo turinį gabaliukais?\nNors gali naudoti cat dideliems failams atspausdinti ir tada slinkti išvestį, paprastai patogiau failą rodyti puslapiais. Tam pirminė komanda buvo more, bet ją pakeitė galingesnė komanda less.\nNaudojant less &lt;failas&gt;, vienu metu matysi tik vieną failo puslapį. Spaudžiant ␣ (space) klavišą, pereisi į kitą puslapį; gali taip pat naudoti ↓ ir ↑ klavišus, kad judėtum po vieną eilutę žemyn arba aukštyn. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk data/temp_vilnius.txt su less, išbandyk judėjimą tekste žemyn, aukštyn ir uždaryk programą su q.\n\n\nJei less komandai nurodysi kelis failus, gali naudoti :n (next) pereiti prie kito failo, o :p (previous) sugrįžti prie ankstesnio failo. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk failus favorite_song.txt, data/temp_vilnius.txt ir text/seneles_pasaka.txt su less. Išbandyk judėjimą tekste žemyn, aukštyn, pereik tarp failų naudojant :n ir :p bei pabaigoje uždaryk less su q\n\n\n\n\n6.1.6 wc\nKomanda wc (angl. word count) naudojama atspausdinti naujų eilučių, žodžių ir baitų skaičių faile.\n\n\n\n\n\n\n\nNustatymas\nReikšmė\n\n\n\n\n-c\nAtspausdina baitų skaičių (angl. byte count), kiek vietos užima failas\n\n\n-m\nAtspausdina simbolių skaičių (angl. character count)\n\n\n-w\nAtspausdina žodžių skaičių (angl. word count)\n\n\n-l\nAtspausdina eilučių skaičių (angl. line count)\n\n\n\nPastaba: -c ir -m gali atspausdinti skirtingus rezultatus priklausomai nuo failo koduotės, nes simbolis gali užimti daugiau nei vieną baitą (pvz., specialūs lietuviški simboliai).\n\n\n\n\n\n\nPraktika\n\n\n\n\nKiek žodžių ir kiek eilučių yra text/seneles_pasaka.txt?\nKiek eilučių yra data/temp_vilnius.txt ir kiek data/temp_kaunas.txt?\n\n\n\n\n\n6.1.7 touch\nKomanda touch naudojama kuriant tuščią failą arba keičiant esamo failo metaduomenis, pvz., modifikavimo ar prieigos laiką. Ji yra universali ir ypač naudinga tais atvejais, kai reikia greitai sukurti failą arba atnaujinti failo laikus be jo turinio keitimo.\nJei failas neegzistuoja, touch jį sukurs. Jei failas jau yra, komanda tiesiog pakeis failo “paskutinio keitimo laiką” (modification time) į dabartinį laiką, nesikeičiant turinio.\nSukurk tuščią failą:\ntouch empty_1.txt\n\nJei nurodysi kelis failų pavadinimus, touch sukurs visus iš karto:\ntouch empty_2.txt empty_3.txt empty_4.txt\n\nJeigu failo pavadinimas yra nurodytas su absoliučiu ar reliatyviu keliu, failas bus sukurtas atitinkamoje direktorijoje, jei tokia direktorija egzistuoja. Jei direktorija neegzistuoja, bus pranešta apie klaidą, ir failas nebus sukurtas.\ntouch mix/empty_5.txt\ntouch tralala/empty_6.txt\n\ntouch taip pat leidžia atnaujinti failo prieigos arba modifikavimo laiką. Štai keli pavyzdžiai:\n\nAtnaujinti tiek prieigos, tiek modifikavimo laikus į dabartinį laiką:\n\ntouch empty_1.txt\n\nAtnaujinti tik prieigos laiką:\n\ntouch -a empty_1.txt\n\nAtnaujinti tik modifikavimo laiką:\n\ntouch -m empty_1.txt\n\nNustatyti tiek prieigos, tiek modifikavimo laikus į konkrečią datą, pvz., 2022 m. sausio 1 d., 12:00 val.:\n\ntouch -t 202201011200 empty_1.txt\n\nNaudoti -d parinktį, norint lankstesnio laiko nustatymo:\n\ntouch -d \"2023-07-04 15:45\" empty_1.txt\nDabar gali kilti klausimas - kam tai naudinga? Iš tiesų, failų laikų keitimas gali atrodyti nišinis, tačiau tai naudinga tam tikrais atvejais:\n\nJei nori išbandyti skriptą, kuris rūšiuoja ar archyvuoja failus pagal jų prieigos ar modifikavimo laiką, gali generuoti tuščius failus su netikrais laikais ir patikrinti, ar skriptas veikia teisingai.\nJei atstatai failus iš atsarginės kopijos, gali norėti atkurti ir jų originalius prieigos bei modifikavimo laikus, kad išsaugotum failų istoriją tiksliai tokia, kokia buvo prieš atsargines kopijas.\n\n\n\n6.1.8 mkdir\nKomanda mkdir (angl. make directory) naudojama naujų direktorijų kūrimui.\nNaują direktoriją gali sukurti taip:\nmkdir projektas1\nKaip ir su komanda touch, gali sukurti kelias direktorijas vienu metu, nurodant pavadinimus arba kelius į jas:\nmkdir projektas2 mix/projektas3\n\nKartais reikia sukurti direktorijų medį (hierarchiją). Jei tarpinės direktorijos dar neegzistuoja, gali naudoti -p argumentą, kuris automatiškai sukurs ir tarpines direktorijas. Pavyzdžiui:\nmkdir -p projektas0/duomenys\n\n\n\n\n\n\n\nPraktika\n\n\n\nNetrukus norėsime sukurti tam tikrų failų atsargines kopijas. Kaip pasiruošimą, užtikrink, kad shell_part_2 direktorijoje būtų:\n\nbackup/data\nbackup/text\n\nSukurk jas naudojant -p, nurodant abi direktorijas kaip du argumentus vienoje komandoje (vienoje eilutėje).\n\n\n\n\n6.1.9 cp\nPripažink, kopijuoti failą su cat failas.txt &gt; kopija.txt nėra labai intuityvu. O ką daryti, jei nori nukopijuoti ne tik failą, bet ir visą direktoriją?\nKomanda cp (angl. copy) naudojama failams ir direktorijoms kopijuoti.\nPaprasčiausiu atveju, kai nori sukurti failo kopiją, komandai cp nurodai originalaus failo pavadinimą ir kokiu pavadinimu turėtų būti sukurta kopija.\ncp song_text.txt song_text_copy.txt\nJei failas song_text_copy.txt jau egzistuotų, jis būtų perrašytas. Taigi cp veikia panašiai kaip &gt;.\nKaip ir su visomis BASH komandomis, gali naudoti tiek reliatyvius, tiek absoliučius kelius (angl. path). Pavyzdžiui, kopiją gali perkelti į kitą direktoriją:\ncp ./song_text.txt ./mix/song_text_copy.txt\n\nJeigu kaip antrąjį argumentą nurodysi egzistuojančios direktorijos pavadinimą, cp sukurs kopiją tokiu pačiu pavadinimu kaip originalas ir patalpins ją į nurodytą direktoriją. Šįkart praleidžiam\ncp song_text.txt mix\n\ncp gali kopijuoti ir direktorijas, tačiau tam, kad visa direktorija būtų nukopijuota rekursyviai (su visu turiniu), reikia naudoti nustatymą -r (recursive). Jeigu pamirši -r direktorija nebus nukopijuota!\ncp -r mix mix_copy\n\nKada naudoti cp -a?\nNustatymas -a (arba archive) naudojamas, kai reikia nukopijuoti failus ir direktorijas kartu su jų metaduomenimis (pvz., failo leidimais, nuosavybe, laikais). Tai naudinga, kai nori išsaugoti visas originalaus failo ar katalogo savybes. -a iš esmės yra kombinuotas cp -r (rekursija) ir kitų nustatymų rinkinys, kuris užtikrina, kad išsaugomi visi atributai.\ncp -a mix mix_copy_2\nDabar palyging metaduominis su ls -l.\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nPadaryk temp_vilnius.txt kopiją pavadinimu temp_vilnius.txt, bet kaip argumentą nurodyk direktoriją ir failo pavadinimą. Patalpink kopiją į backup/data.\nPadaryk temp_kaunas.txt ir temp_klaipeda.txt kopiją vienoje komandoje su originaliu pavadinimu, kaip trečią argumentą cp paduodant tik backup/data direktoriją.\nPadaryk text direktorijos kopiją su visu jos turinu į backup direktoriją. Išsaugok visus metaduomenis.\nTeorinis klausimas: kas nutiktų jeigu panaudotum cp -r text backup/text?\nAr darant temp_ failų atsargines kopijas išsaugojai metaduomenis? jeigu ne, pakartok komandas tik su teisingu nustatymu ir įsitikink, ar iš tiesų metaduomenys tokie pat!\n\n\n\n\n\n6.1.10 mv\nKomanda mv (angl. move) naudojama perkelti arba pervadinti failus ir direktorijas. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\nPvz., naudojant mv, gali pervadinti failą temp_vilnius.txt į temp_alytus.txt:\nmv data/temp_vilnius.txt data/temp_alytus.txt\n\nTaip pat su mv gali perkelti failus iš vienos direktorijos į kitą. Ši komanda perkelia failą temp_kaunas.txt į mix:\nmv data/temp_kaunas.txt mix\n\nmv komandai galima paduoti daugiau nei du argumentus. Pavyzdžiui, ši komanda perkelia failus temp_alytus.txt ir seneles_pasaka.txt į direktoriją mix. Čia svarbu, kad paskutinis argumentas būtų egzistuojanti direktorija:\nmv data/temp_alytus.txt text/seneles_pasaka.txt mix\nmv taip pat gali būti naudojama perkelti direktoriją ir visą jos turinį. Pavyzdžiui, ši komanda perkelia direktoriją mix_copy į mix:\nmv mix_copy mix\nPastaba: dirbant su direktorijomis:\n\njeigu mv origin target jeigu target neegzistuoja, tada mv pervadins direktoriją origin į target\njeigu mv origin target jeigu target egzistuoja, tada mv perkels origin į target direktoriją\n\nSvarbu: kaip ir naudojant &gt; ar cp, jeigu tikslinis failas jau egzistuoja, jis bus perrašytas, nebent pridėsi -i (interaktyvų režimą), kad būtų paprašyta patvirtinimo prieš perrašant.\n\n\n\n\n\n\nPraktika\n\n\n\n\nTeorinis klausimas: Kas nutiktų, jei įvykdytum šią komandą?\n\nmv temp_vilnius.txt temp_kaunas.txt ~/Documents ~/Downloads\n\nPerkelk Alytaus ir Kauno temperatūrų failus atgal iš mix į data naudojant mv. Pervadink Alytaus failą atgal į Vilniaus\nAtsidaryk Nemo ir rankiniu būdu ištrink data direktoriją. Dabar su terminal, padaryk backup/data kopiją (su cp ir reikalaingais nustatymais), jog vėl atsirastų /shell_part_2/data.\n\n\n\n\n\n6.1.11 rm\nTavo shell_part_2 direktorijoje dabar tikrai daug failų ir subdirektorijų, kurių nebereikia. Laikas įvesti šiek tiek tvarkos!\nKomanda rm (angl. remove) naudojama pašalinti failus ir direktorijas. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar direktorijos nėra perkeliami į šiukšliadėžę ir jų atkurti nebebus galima.\nNorint pašalinti failą, rm komandai paduodamas argumentas - failo pavadinimas arba absoliutus, arba reliatyvus kelias į failą.\nrm day.txt\nrm mix/empty_5.txt\nKomandai rm galima paduoti ir kelis failus vienu metu:\nrm empty_1.txt empty_2.txt \nTuščią direktoriją (kai joje nėra jokių kitų failų ar subdirektorijų) galima pašalinti arba naudojant rmdir (kuri yra mkdir priešingybė), arba su rm, nurodant nustatymą -d.\nrm -d projektas1\nrmdir projektas2\n\nTiesiog pašalinti direktoriją, kurioje yra kažkas, su rm arba rm -d nepavyks, nes BASH bando apsaugoti vartotoją nuo rizikos netyčia ištrinti daugiau failų nei reikia.\n\nJei reikia ištrinti visą direktoriją su visu jos turiniu, naudojamas parametras -r (recursive).\nrm -r projektas0\nKartais gali nutikti, jog rm -r negalės ištrinti direktorijos dėl failų teisių ar kitų kliūčių. Tokiu atveju pridedamas nustatymas -f (force), kuris priverstinai ištrina failus.\nrm -rf mix_copy_2\nintarpas: Wildcard’ų naudojimas *\nKartais BASH komandose norisi pažymėti arba pasirinkti daugiau nei vieną failą. Kaip jau matei, tiek cat, tiek cp, mv, rm, less komandos kuo puikiausiai dirba su keliais failais. Tad kyla klausimas, kaip tai padaryti efektyviau naudojant wildcard simbolius.\nPvz., tu galėtum rašyti:\nrm empty_1.txt empty_2.txt\nTačiau yra akivaizdu, jog šiuose failų pavadinimuose yra tam tikras dėsningumas - jie prasideda empty_ ir baigiasi .txt.\nBASH, kaip ir daugelyje kitų programavimo kalbų, yra vadinamieji wildcard - simboliai, kurie leidžia užpildyti vieną ar daugiau ženklų.\nPavyzdžiui, * simbolis pakeičia bet kokį skaičių ženklų. Taigi, galima būtų parašyti:\nrm empty_*.txt\nWildcard’ų simboliai:\n\n* reiškia jokio, vieną arba daugiau simbolių.\n? reiškia tiksliai vieną simbolį, pvz., 201?.txt galėtų atitikti 2017.txt, 2018.txt, bet ne 2017-01.txt.\n[...] reiškia vieną iš pateiktų simbolių, pvz., 201[78].txt atitiks 2017.txt arba 2018.txt, bet ne 2016.txt.\n{} reiškia vieną iš nurodytų reikšmių, pvz., rm {.txt,.csv} atitiks visus failus, kurių pavadinimas baigiasi .txt arba .csv, bet ne .pdf.\n\n\n\n\n\n\n\nPraktika\n\n\n\nTeorinė užduotis - pasakyk, kas nutiktų visais šiais atvejais:\n\nrm song*.txt\nrm *song*.txt\nrm *.txt\nrm *.*\nrm ./*\nrm *\nrm data/*\nrm text/*.txt\nPasitikrink atsakymą naudojant ChatGPT!\n\nPraktinė užduotis - naudojantis wildcard ištrink iš shell_part_2 visus failus:\n\nkurių pavadinime yra žodis song, neproklausomai nuo pozicijos ir failo tipo\nkurių failo tipas yra .txt\nvisus failus esančius mix subdirektorijoje. Tam gali prireikti papildomo nustatymo rm komandai, nes mix gali būti direktorijos!\nsubdirektorijas data ir text. O tada naudodojant cp ir būtinai reikiamą nustatymą metaduomenų išlaikymui, atkurti iš backup\n\n\n\nAtlikus visus valymus turėtum turėti:\n\n\n\n6.1.12 grep\nKartais tau gali prireikti nuskaityti tik tam tikras failo eilutes, kuriose yra konkretus tekstas. Komanda grep (angl. global regular expression print, liet. „globalus reguliariųjų išraiškų paieškos spausdinimas“) naudojama teksto paieškai pagal šabloną failuose arba išvestyje.\nPavyzdžiui, ši komanda surastų visas eilutes data/seneles_pasaka, kuriose yra žodis „Apie“:\ngrep Apie text/seneles_pasaka.text\n\nSuprantama, gali pateikti kelis failus vienu metu. Šiuo atveju komanda grep suras visas eilutes, kuriose yra 14:00:00 abiejuose jai pateiktuose failuose ir atitinkamas eilutes atspausdins tau į terminalą.\ngrep 14:00:00 data/temp_vilnius.txt data/temp_kaunas.txt \n\ngrep priima ir tam tikrus nustatymus, kurie padeda atlikti paiešką efektyviau:\n\n-c: atspausdina, kiek eilučių atitinka tavo pateiktą kriterijų.\n-h: neatspausdina failų pavadinimų, kuriuose rasti atitikimai, kai pateiki keli failai.\n-i: ignoruoja didžiąsias ir mažąsias raides (pvz., įrašius -i apie, ras ir „Apie“, „apie“, „APIE“ ir t.t.).\n-l: atspausdina tik failų pavadinimus, kuriuose rasti atitikimai.\n-n: atspausdina eilučių numerius šalia pačios eilutės.\n-v: ieško eilučių, kuriose nėra raktinio paieškos kriterijaus.\n\n\n\n\n\n\n\nPraktika\n\n\n\nDirbk su data/seneles_pasaka.txt\n\nKurios eilutės turi paminėtą žodį „pasaka“ (tik su mažąja raide)?\nKurios eilutės turi paminėtą žodį „pasaka“ (nesvarbu, ar rašyta didžiosiomis, ar mažosiomis raidėmis)?\nKiek eilučių (ieškome skaičiaus) turi paminėtą žodį „apie“, nepriklausomai nuo rašybos?\nKiek eilučių (ieškome skaičiaus) nepamini žodžio „apie“, nepriklausomai nuo rašybos?\n\n\n\nPastaba: komanda grep ieško tekstinės atitikties failuose, todėl ji nepriima loginių operatorių kaip &gt;, =, ar &lt;. Visgi, grep leidžia naudoti reguliarias išraiškas (regular expressions), kurios leidžia dar smulkiau atrinkti tekstą.\nŠtai kaip būtų galima panaudoti grep su reguliariomis išraiškomis, norint surasti visas eilutes, kuriose yra vienas skaitmuo prieš tašką, visuose temp_ failuose:\ngrep -P '\\t[0-9]\\.[0-9]' data/temp_*.txt\n\nĮ reguliarias išraiškas dabar neverta gilintis išsamiau, bet svarbu žinoti, kad jos egzistuoja ir gali būti labai naudingos dirbant su tekstiniais duomenimis. Jeigu kiltų noras pasibandyti, siūlau naudti https://regexr.com/.\n\n\n6.1.13 cut\nKartais tau gali prireikti išfiltruoti ne eilutes, o stulpelius. Pvz., komanda head data/temp_vilnius.txt parodo tarsi 3 stulpelius: datą, laiką ir temperatūrą. Pastebima, kad tarp datos ir laiko yra mažas tarpas (greičiausiai „space“), o tarp laiko ir temperatūros - didelis tarpas (tikėtina, “tab”). Tai šiek tiek apsunkina darbą, kol nesusipažinai su sed komanda, bet tai nereiškia, jog negalime išskaidyti failo į stulpelius pagal skirtingus skirtukus, pvz., „space“ ir „tab“.\n\nKomandai cut reikia tam tikrų nustatymų. Pagrindiniai nustatymai:\n\n-d (delimiter) - skirtukas, kuris skiria stulpelius. Pagal nutylėjimą skirtukas yra tabuliacija (tab), tad šio nustatymo keisti nereikia. Jeigu norėtum naudoti kitą skirtuką, pvz., tarpo ženklą, turėtum naudoti -d \" \". Jeigu skirtukas būtų kablelis, naudotum -d \",\" ir t.t.\n-f (fields) - nurodo, kuriuos stulpelius (laukelius) nori pasirinkti. Pvz., -f 2 pasirinktų antrą stulpelį, -f 2-5 pasirinktų nuo antro iki penkto stulpelio, o -f 2-5,8 pasirinktų antrą, trečią, ketvirtą, penktą ir aštuntą stulpelius.\n\nŠi komanda priima „space“ kaip skirtuką ir atspausdina pirmąjį stulpelį:\ncut -d \" \" -f 1 data/temp_vilnius.txt\n\nŠi komanda priima „tab“ kaip skirtuką ir atspausdina antrąjį stulpelį:\ncut -f 2  data/temp_vilnius.txt\n\nJeigu norėtum gauti tik metus, galėtum nurodyti skirtuką „-“ ir pasirinkti pirmąjį stulpelį:\ncut -d \"-\" -f 1 data/temp_vilnius.txt \n\n\n\n\n\n\n\nPraktika\n\n\n\nProgramuojant ir dirbant su duomenimis, svarbu išmokti išnaudoti AI galimybes. Šioje praktikoje tu turi nueiti į ChatGPT ir parašyti kažką panašaus:\n\nSugeneruok 25 eilučių .csv failą, kurio skirtukas būtų “,” su šiais stulpeliais:\n\nuser_id,\nage (18-99)\ncountry_code (LT, LV, EE)\norders (0-250)\n\n\nChatGPT sugeneruos .csv failą ir leis jį atsisiųsti. Šiam sugeneravimui ChatGPT pasinaudos Python programavimo kalba. Tu galėtum išsaugoti grąžintą kodą ir naudoti jį ateityje, nes tavo kompiuteryje šis kodas taip pat veiktų. Bet prie Python mes dar grįšime vėliau.\nPerkelk failą iš ~/Downloads į ~/shell_part_2/data. Tarkime, failas vadinasi sample_data.csv.\nVideo\nTurint failą:\n\nPervadink failą į balt_customers.csv.\nNaudojant žinomomis komandomis tyrinėk failą data/balt_customers.csv:\n\nKiek jame eilučių?\nKoks skirtukas naudojamas?\nKokie duomenys yra pirmoje eilutėje (antraštė ar duomenys)?\nKiek ir kurios eilutės yra duomenys?\n\n\nUžduotis: Tu dirbi su klientais iš Estijos (EE). Turi parašyti visiems klientams iš Estijos el. laišką ir pranešti apie jų užsakymų skaičių. Laiško rašymą perims programa, tačiau tu jai turi pateikti failą customers_ee.csv, kuris turėtų atrodyti taip (tavo duomenys gali skirtis dėl atsitiktinio jų sugeneravimo):\n\nKad įgyvendintum šią užduotį, tau prireiks komandų: head, cut, &gt; &gt;&gt;, cat ir grep bei sukurti kelis tarpinius failus, kuriuos vėliau galėsi ištrinti. Taip pat patarčiau bandyt skaidyti darbus :)\nSėkmės!\n\n\n\n\n6.1.14 Intarpas: Standartinė įvestis, išvestis ir klaidos\nIki šiol mes naudojome sąvokas, tokias kaip įvestis (input) ir išvestis (output). Įvestis buvo tai, ką tu įvedi klaviatūra į terminalą, o išvestis - tai, ką BASH atspausdina terminale arba ką tu nukreipi į failą naudodant &gt; arba &gt;&gt;. Tačiau iki šiol formaliai neaptarėme BASH srautų.\nLinux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenų įvestį ir išvestį programose bei komandose. Šie srautai vadinami standartine įvestimi (standard input), standartine išvestimi (standard output) ir standartine klaida (standard error). Kiekvienas srautas turi specifinę paskirtį ir failo aprašymo numerį.\nSvarbu: Linux’e viskas yra failai, net srautai (input/output) traktuojami kaip failai.\n\n6.1.14.1 Standartinė įvestis (stdin)\nStandartinė įvestis, sutrumpinta kaip stdin, yra srautas, iš kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, stdin yra prijungta prie klaviatūros, tačiau gali būti nukreipta iš failo ar kito srauto.\nPabandyk įrašyti cat, paspausti Enter, ir tada įvesk kelis žodžius, vis paspausdžiant Enter. Terminale matysi tekstą, kurį įvedi, nes jis bus perduotas kaip įvestis cat komandai, kuri atspausdins šį tekstą. Todėl matysi dvigubai tai, ką įvedei.\ncat\nNutraukti cat įvestį gali su Ctrl-D arba Ctrl-C.\nVideo\nĮvestis taip pat gali būti perduodama iš failo į komandą. Pavyzdžiui, komandai cat galime nurodyti failą taip:\ncat &lt; data/customers_ee.csv\nKodėl veikia &lt;?\nSimbolis &lt; nurodo komandai, kad vietoje įprastos įvesties iš klaviatūros naudotų failą kaip įvesties šaltinį. Pvz., cat &lt; data/customers_ee.csv reiškia, kad cat komanda skaitys duomenis iš failo data/customers_ee.csv, o ne iš klaviatūros.\n\nStandartinės įvesties aprašymo numeris: 0. Vėliau pamatysi, kam tie skaičiai naudingi.\n\n\n6.1.14.2 Standartinė išvestis (stdout)\nStandartinė išvestis, sutrumpinta kaip stdout, yra srautas, į kurį komanda ar programa rašo išvestį. Dirbant terminale, stdout prijungta prie terminalo ekrano. Pavyzdžiui, įrašius šią komandą, terminale atspausdinamas „Hello World“:\necho \"Hello World\"\nGalima nukreipti standartinę išvestį ne į terminalo langą, bet į failą, kaip jau esame darę anksčiau:\necho \"Hello World!\" &gt; hello_world.txt\nStandartinė išvestis turi numerį 1. Tai reiškia\necho \"Hello World!\" 1&gt; hello_world.txt\njog stdout srautas (1), kurį generuoja echo komanda, siunčiamas į failą hello_world.txt. Mes panaudojom srauto numerį, kad pasakyti kurį srautą siųsti į failą.\n\n\n6.1.14.3 Standartinė klaida (stderr)\nKai komanda negali atlikti tam tikro veiksmo, ji sugeneruoja klaidos pranešimą, kuris siunčiamas į standartinį klaidos srautą (stderr). Standartinės klaidos srautas turi numerį 2, ir jį taip pat galima nukreipti į failą.\nPabandyk komandą ls su neegzistuojančia direktorija, pvz.,:\nls abc\n\nKlaidos pranešimas bus išspausdintas terminale. Tačiau galime nukreipti tik klaidos srautą į failą:\nls abc 2&gt; error.log\nTerminale klaidos nebus matyti, bet gali naudoti komandas head arba cat, kad pažiūrėtum, kas yra error.log faile.\n\n\n\n\n6.1.15 Kaip visą tai taikyti praktikoje?\nĮsivaizduok, kad turi komandą ls, kuri kartais sugeneruoja išvestį, kurią nori nukreipti į list.txt, o klaidas - į error.log. Tam galėtum naudoti:\nls &lt;direktorija1&gt; &lt;direktorija2&gt; &lt;direktorija3&gt; 1&gt;&gt;list.txt 2&gt;&gt;error.log\nIšbandyk šią komandą su egzistuojančia ir neegzistuojančia direktorija (prieš tai su rm ištrink error.log jeigu toks egzistuoja)\nls -l data abc text 1&gt; list.txt 2&gt; error.log\n\nKartais gali prireikti, kad abu srautai būtų nukreipti į tą patį failą. Pvz., jeigu kas 10 minučių matuoji kompiuterio temperatūrą, gali nukreipti tiek stdout, tiek stderr į failą:\nkomanda 1&gt;temp.log 2&gt;&1\nArba gali klaidos srautą nukreipti į temp.log, o standartinę išvestį - į klaidų srautą:\nkomanda 2&gt;temp.log 1&gt;&2\nSimbolis & nurodo, kad mes kalbame apie srautą, o ne apie failo vardą. Kai rašai, pvz., 1&gt;&2, tai reiškia, kad standartinę išvestį (stdout, 1) nukreipi ne į failą, o į standartinį klaidų srautą (stderr, 2). Tai leidžia abu srautus sujungti ir siųsti į tą patį tikslą. Jei & nebūtų, sistema galvotų, kad „2“ yra failo pavadinimas, o ne kitas srautas. Analogiškai, 2&gt;&1 reiškia, kad klaidų srautas (stderr, 2) nukreipiamas į išvesties srautą (stdout, 1).\n\n\n6.1.16 pipe |\nIki šiol, kai reikėdavo vienos komandos išvestį panaudoti kitoje komandoje, pavyzdžiui, išfiltravus Estijos vartotojus su grep EE data/balt_customers.csv, turėjai juos išsaugoti į tarpinį failą (pvz., temporal.csv), o tik tada paduoti rezultatą į cut -d \",\" -f 1,4 temporal.csv, kad gautum norimą rezultatą. Tai yra neefektyvus metodas, nes:\n\nLieka daug tarpinių failų.\nKomandos būna suskaidytos per kelias eilutes, todėl jas sunku peržiūrėti su history.\n\nBASH siūlo kelis būdus, kaip efektyviau panaudoti vienos komandos rezultatus kitose, pavyzdžiui, su xargs arba kitais įrankiais. Tačiau dažniausiai naudojamas metodas yra pipe (angl. “vamzdis”).\n| (pipe) - tai vertikalus brūkšnys, kuris sujungia komandas į vieną srautą, kur vienos komandos išvestis tampa kitos komandos įvestimi.\n\nPabandyk sujungti šias komandas:\n\ngrep EE data/balt_customers.csv - išfiltruoti tik EE vartotojus.\nPanaudoti |, kuris pavers pirmosios komandos išvestį antrosios komandos įvestimi.\ncut -d \",\" -f 1,4 - iškirpti pirmą ir ketvirtą stulpelius.\nGalutinį rezultatą su &gt; nukreipk į failą data/customers_ee_2.csv.\n\n\ngrep EE data/balt_customers.csv | cut -d \",\" -f 1,4 &gt; data/customers_ee_2.csv\nPirma pabandyk paleisti komandą be &gt;, kad pamatytum rezultatą terminale:\n\nDabar paleisk pilną komandą, nukreipiančią išvestį į failą:\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nTerminale atspausdink pirmas 3 eilutes, kuriose yra žodis „Apie“ iš failo data/seneles_pasaka.txt.\nTerminale atspausdingk paskutines 3 eilutes kuriose yra 00:00:00 faile data/temp_vilnius.txt\n\n\n\n\n\n6.1.17 sort\nTu darai nuostabią pažangą ir jau moki naudoti grep, cut, head, tail, su kuriomis gali išfiltruoti eilutes, stulpelius ir t.t. Naudojant |, jau moki sujungti kelias komandas į vieną. Tačiau ko tu dar nemoki - kaip išrikiuoti reikšmes. Čia pravers komanda sort.\nsort labai gerai sąveikauja su pipe |.\nPagrindiniai nustatymai:\n\n-r - nuo didžiausios iki mažiausios reikšmės.\n-n - rikiuoti skaičius.\n-h - rikiuoti pagal dydį, jei dydis pateiktas human readable skaičiais (pvz., KB, MB, GB).\n-t - nurodo, koks yra skirtukas tarp stulpelių (delimiter).\n-k - pagal kurį stulpelį rikiuoti.\n\nSukurk šį failą:\necho -e \"A,101\\nB,3\\nC,2\\nD,40\" &gt; tosort\nAr pastebėjai, tosort neturi indikacijos, koks tai failas, nei .csv, nei .txt. Nieko tokio Linux operacinėje sistemoje, komandos veikia kuo puikiausiai ir be failo tipo indikatoriaus.\n\nPagal nutylėjimą sort priims failą kaip argumentą ir rikiuos pagal pirmą stulpelį. sort -r apsuks rikiavimo eigą.\nsort tosort\nsort -r tosort\n\nJei nori, kad BASH suprastų failą kaip turintį skirtingus stulpelius, turi nurodyti, koks yra skirtukas (delimiter) su -t \",\". Tuomet galima rikiuoti pagal konkretų stulpelį su -k 2. Jei nepridėsi -n, sort rikiuos taip, lyg skaičiai būtų tekstas, t.y., vertins pagal pirmą skaitmenį, tada pagal antrą ir t.t. Pridėjus -n, skaičiai vertinami kaip skaičiai.\nGalima apsieiti ir be kabučių aplink skirtuką, o -n pridėti prie -k 2, kad būtų rikiuojama pagal skaičius. Galų gale, tai tavo pasirinkimas.\nsort -t \",\" -k 2 tosort\nsort -t \",\" -k 2 -n tosort\nsort -t, -k2n tosort\n\n\n\n\n\n\n\nPraktika\n\n\n\nUžduotis: Įsivaizduok, kad esi IT administratorė arba administratorius, atsakingas už sistemų stebėjimą. Tau reikia periodiškai siųsti sąrašą su 5 didžiausiais failais ar direktorijomis pagal dydį namų direktorijoje (~). Šis sąrašas turėtų apimti visus paslėptus failus (kurie prasideda su “.” savo pavadinime), o dydis turėtų būti human readable formatu, o ne baitais. Taip pat norisi, kad maksimalus gylis būtų 1, t.y., jog būtų žiūrima į ~ ir vieną lygį giliau, t.y. ~/direktorija/.\nKadangi šią užduotį reikia atlikti kasdien, nusprendei sukurti ilgą BASH komandą.\nPagalba: Prieš pradedant nueik į ChatGPT ir paprašyk:\n\nPaaiškink man “du” komanda Linux ir jos nustatymus. Man reiktų matyti failus human readable formatu. Pateik kelis pvz.\n\nPerskaityk ką tau gražins ChatGPT, jeigu reikia pasitisklink užduodant papildomus klausimus.\n\nPabandyk sukurti komandų seką (pipeline) su du, sort, head. Eksperimentuok su nustatymais.\nKai terminalo lange matysi reikiamą išvestį, naudok echo, apskliausk visą komandą kabutėmis ir nukreipk į failą pavadinimu list_du_homedir.sh. Taigi, tai turėtų atrodyti daugmaž taip:\necho \"komanda komanda komanda\" &gt; list_du_homedir.sh\nO dabar pabandyk\nbash list_du_homedir.sh\narba su pipe\ncat list_du_homedir.sh | bash\nSveikinu, ką tik sukūrei savo pirmą skriptą! Tai komandų rinkinys, kurį gali perduoti BASH, ir jis jį įvykdys.\n\n\n\n\n6.1.18 sed\nsed komanda Linux sistemoje yra srauto redaktorius (stream editor), naudojamas tekstui apdoroti ir manipuliuoti. Ji leidžia atlikti įvairius teksto pakeitimus, pvz., ieškoti ir pakeisti žodžius, ištrinti eilutes arba modifikuoti tekstą pagal tam tikras taisykles, nespausdinant teksto į terminalą.\nVienas paprasčiausių būdų naudoti sed - tai pakeisti tam tikrą tekstą kitu tekstu: tam naudojama tokia sintaksė sed 's/ką keisti/kuo pakeisti/'.\nTaigi, ši komanda pakeičia „rytas“ į „vakaras“:\necho \"Labas rytas\" | sed 's/rytas/vakaras/'\nsed nėra agresyvi komanda, todėl ankstesnė komanda pakeičia tik pirmą rastą atitikmenį:\necho \"Labas rytas, pasakė senelė kai atėjo rytas\" | sed 's/rytas/vakaras/'\nMatyti, kad tik pirmas „rytas“ pakeistas į „vakaras“, o antrasis ne. Jei nori, kad visi atitikmenys būtų pakeisti, reikia pridėti nustatymą g:\necho \"Labas rytas, pasakė senelė kai atėjo rytas\" | sed 's/rytas/vakaras/g' \nSu sed taip pat galima ištrinti eilutes. Pavyzdžiui, jei ls -l komanda atspausdina „total …“, galima tai ištrinti naudojant sed '1d':\nls -l\nls -l |sed '1d'\nVietoje 1, kuris nurodo, kurią eilutę trinti, galima nurodyti ir diapazoną, pvz., nuo 1 iki 3 su sed '1,3d':\nls -l | sed '1,3d'\nTaip pat galima įterpti naujas eilutes:\nls -l | sed '3a/nauja eilutė'\nPora įdomybių:\nSu sed gali naudoti regular expressions. Štai keletas reikšmių:\n\n^ reiškia eilutės pradžią.\n$ reiškia eilutės pabaigą.\n\\t reiškia tabuliaciją (naudoti su sed -E).\n\\s reiškia tarpą (naudoti su sed -E).\n\nPvz., pridėti veiduką prieš kiekvieną eilutę:\nsed 's/^/😀/g' text/seneles_pasaka.txt\nJei nori, kad sed ignoruotų raidžių dydžius, pridėk nustatymą I. Tai panašu į grep -i.\necho Labas Rytas | sed 's/rytas/Vakaras/'\necho Labas Rytas | sed 's/rytas/Vakaras/I'\n\n\n\n\n\n\nPraktika\n\n\n\n\nDirbk su data/seneles_pasaka.txt. Tavo tikslas - padaryti pasaką labiau patrauklią vaikams, pakeičiant žodžius simboliais. Naudok sed komandą ir pakeisk šiuos žodžius į atitinkamus simbolius. Sujunk visas sed komandas į viena pipeline naudojant |.\n\n\nŽąsiną moliūgą - 🦢🎃\nVilką - 🐺\nBaltą mešką - 🐻‍❄️\nJoną - 👦🏻\nEglę - 🌲\nŽalčio - 🐍\nRagana - 🧙‍♀️\nPamotė pikta - 😡\n\nIšsaugok pasaką kaip text/seneles_pasaka_emojies.txt\n\n\ndata/temp_vilnius.txt ir kitų miestų failai turi kelias problemas, kurias turėtum ištaisyti:\n\nVilniaus faile kiekvienos eilutės pradžioje įrašyk „Vilnius “ (su tarpeliu po miesto pavadinimo). Kituose miestuose atitinkmai “Kaunas” ir “Klaipėda”\nDabar pirmieji du skirtukai yra tarpai, o antrasis - tabuliacija. Paleisk sed komandą du kartus: vieną kartą pakeisk tarpus (space) į kablelius, o antrą kartą - tabuliacijas į kablelius.\nIšsaugok Vilniaus, Kauno, ir Klaipėdos failus kaip temp_vilnius.csv, temp_kaunas.csv, temp_klaipeda.csv (vietoje .txt naudok .csv plėtinį).\nKiekvienas miestas turėtų turėti visą komandą vienoje eilutėje naudojant |.\n\n\n\nSujunk visus Vilniaus, Kauno ir Klaipėdos failus į vieną ir pavadink rezultatą temp_lietuva.csv.\nPabandyk atidaryti šį failą su LibreOffice Calc:\n\nlibreoffice --calc temp_lietuva.csv\n\nPavaizduok sekančių dienų temperatūras.\n\n * Pabandyk atsidaryti visus tris pavienius failus su Excel Power Query ir apdorojus duomenis sukurti dashboard to slicer filtrais ir grafikais.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html",
    "title": "7  BASH pažengusiems",
    "section": "",
    "text": "7.1 Įvadas\nPraėjusiame skyriuje susipažinai su įvairiomis CLI (command line interface) komandomis, suteikiančiomis pagrindinius įrankius darbui su shell aplinka. Išmokai naudoti echo, cat, head, tail, less, wc, touch, mkdir, cp, mv, rm, grep, cut, sort, sed, taip pat operatorius &gt;, &gt;&gt;, bei |. Šios komandos leidžia dirbti su failais, kurti direktorijas, atlikti filtravimą pagal eilutes ir stulpelius bei automatizuoti užduotis.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#įvadas",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#įvadas",
    "title": "7  BASH pažengusiems",
    "section": "",
    "text": "7.1.1 Šiame skyriuje\nŠiame skyriuje dar gilinsimės į failų valdymą ir apdorojimą. Sužinosi:\n\nPagalbos komandas - mokysiesi naudotis help, man ir tldr, kad greitai rastum informaciją apie komandas.\nTinklo komandas - išmoksi naudoti ping, wget ir curl kad galėtum patikrinti ryšį bei atsisiųsti duomenis.\nKaip ieškoti failų - naudosi find, locate ir whereis, kad efektyviai surastum failus ir suprastum jų vietą.\nTeksto apdorojimą - susipažinsi su uniq bei jq komandomis, kad galėtum analizuoti tekstinius ir JSON failus.\nFailų teises ir savininkystę - sužinosi apie chmod, chown ir chgrp, kurie padės valdyti failų teises ir naudotojus.\nProcesų valdymą - sužinosi, kaip stebėti ir valdyti procesus naudojant ps ir top ir htop.\nNano editorius ir alias - išmoksi naudoti nano ir alias, kad galėtum redaguoti tekstinius failus terminale ir kurti komandų trumpinius.\n\nŠis skyrius suteiks tvirtesnį pagrindą darbui su Linux aplinka, padės efektyviau valdyti failus ir suprasti esminius failų teisių, procesų bei tinklo valdymo aspektus. Tai leis tau dirbti su Linux savarankiškiau ir produktyviau.\n\n\n7.1.2 ChatGPT Naudojimas\nŠiame skyriuje vis dažniau bus pateikiamos nuorodos naudotis ChatGPT. Svarbiausia - išmokti naudotis šiuo įrankiu ne tam, kad jis už tave spręstų problemas, bet kad padėtų greičiau rasti tinkamiausią sprendimą. Štai keletas patarimų:\n\nKonsultantas ir patarėjas - naudok ChatGPT kaip priemonę savo idėjų ir sprendimų tikrinimui.\nTikslūs klausimai - suformuluok aiškius ir tikslius klausimus, kurie padės greičiau rasti atsakymą.\nEksperimentavimas - nebijok išbandyti skirtingus užklausų formatus, jei atsakymas neaiškus ar nepakankamas.\nMokymasis per tobulinimą - naudok ChatGPT kaip pagalbininką tobulinant savo darbo rezultatus ir įgyjant naujų žinių.\n\n\n\n7.1.3 Refleksijos Metodika\nPo kiekvienos dalies perskaitymo atlik šiuos veiksmus:\n\nUžrašyk, ką išmokai - pasistenk glaustai užfiksuoti pagrindinius aspektus.\nPritaikymas praktikoje - sugalvok, kur galėtum pritaikyti šias žinias realiose situacijose.\nAnalizuok sunkumus - užfiksuok, kas buvo sudėtinga, ir galvok, kaip tai galėtum įveikti ateityje.\nKonspektuok - pradėk kurti savo mokymosi užrašus patogiame įrankyje, pvz., Obsidian. Suskirstyk juos pagal temas ir pateik konkrečius komandų pavyzdžius. Tai padės tau greičiau rasti reikalingą informaciją.\n\n\n\n\n\n\n\nPraktika\n\n\n\nSavo namų direktorijoje susikurk mokymuisi skirtą subdirektoriją, pvz., bash_advanced. Pereik į ją ir visus šiame skyriuje reikalingus failus ir duomenis laikyk joje.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#pagalbos-komandos-help-man-ir-tldr",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#pagalbos-komandos-help-man-ir-tldr",
    "title": "7  BASH pažengusiems",
    "section": "7.2 Pagalbos Komandos: help, man ir tldr",
    "text": "7.2 Pagalbos Komandos: help, man ir tldr\nNaudojant Linux, komandos gali turėti daugybę nustatymų bei opcijų, kurių kartais sunku prisiminti. Pavyzdžiui, gali kilti klausimas, ar sort komandai reikia naudoti -d ar -t flagą, arba norisi prisiminti, kuo sed skiriasi nuo grep. Šiame skyriuje išmoksi, kaip efektyviai naudotis pagalbos įrankiais, kurie padės greitai rasti informaciją apie komandas ir jų naudojimo būdus, kai kyla klausimų.\nKodėl svarbu mokėti rasti informaciją?\nNet patyrę Linux vartotojai retai kada iškart prisimena visus flagus ar argumentus. Mokėjimas greitai rasti informaciją - vienas svarbiausių įgūdžių dirbant su terminalu. Šiame skyriuje išmoksi naudotis pagalbos įrankiais, kad greitai rastum informaciją apie komandas ir jų naudojimo būdus. Tai apims:\n\n--help - greita pagalba komandai: santrauka apie dažniausiai naudojamus nustatymus ir sintaksę.\nman - išsamus komandų vadovas su skyriais, struktūruotais pagal oficialią dokumentaciją.\ntldr - paprasti pavyzdžiai ir scenarijai, pateikiantys svarbiausias komandos savybes.\nChatGPT - kaip naudoti jį sudėtingesnėms problemoms aiškintis.\n\nScenarijus\nŠioje dalyje pasikartosi prieš tai išmoktas komandas analizuojant fizinių asmenų elektros suvartojimo duomenis naudojant bash.\n\nParsisiųsk duomenis\n\ncurl https://get.data.gov.lt/datasets/gov/eso/fizin_asm_elektros_suvartojimas/FizinAsmElektraSuvartojimas/:format/csv -o raw_data_hh_customers.csv\n\nFailas yra apie 2 GB - tai prilygsta maždaug 130 000 puslapių Word dokumentų. Tad kantreybė tavo sąjungininkė. Pasidaryk ☕\n\n\n\nNusprendei susipažinti su duomenimis, analizuojant pirmas 15 eilučių terminale, tačiau pamiršai, kokie flagai naudojami su wc, head ir cut komandomis 🤦🏻. Šioje dalyje išmoksi gauti reikiamą pagalbą.\nKonspektavimas: Tekstiniame dokumente užsirašyk, ką bandei padaryti, kokie naudingi flagai, ir pateik pavyzdines komandas.\n\n\n7.2.1 --help\nDauguma komandų turi flagą (opciją) --help, kuris pateikia santrauką apie komandos veikimą ir galimus flagus. Kai kurios komandos taip pat turi trumpesnį -h flagą. Jei --help neveikia, pabandyk -h. Atmink, kad --help veikia tik pagrindinei komandai (pvz., apt --help), tačiau subkomandoms (pvz., apt update --help) ji gali neveikti.\nIšbandyk ls --help.\n\n\n\n\n\n\n\nPraktika\n\n\n\nKiek eilučių yra raw_data_hh_customers.csv faile? Naudok wc --help, kad sužinotum flagą, skirtą eilučių skaičiavimui.\n\n\n\n\n7.2.2 man: manual pages\nKartais reikia daugiau informacijos, kad suprastum, kaip kas veikia. Būtent šią funkciją atlieka man komanda. Jos pagalba gali peržiūrėti išsamius komandų aprašymus. Kadangi man puslapiai yra ilgesni nei --help, jie atspausdinami naudojant less, kurį jau pažįsti iš ankstesnio skyriaus. Keisti puslapius gali su space klavišu, o išeiti su q.\nman puslapis įprastai turi tokią struktūrą:\n\nNAME - komandos pavadinimas ir trumpas aprašymas.\nSYNOPSIS - pagrindinė komandos sintaksė, įskaitant flagus ir argumentus.\nDESCRIPTION - detali informacija apie naudojimą.\nOPTIONS - visų galimų flagų paaiškinimai.\nEXAMPLES - kartais pateikiami praktiniai pavyzdžiai.\n\nman ls\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nPrisimeni, jog su head ir tail galėjai nurodyti kiek eilučių spausdinti? Pvz., head -n 15 atspausdina pirmas 15 eilučių. Atsiversk man head ir susirask -n. Ten aprašytas naudojimas - skaičiaus. Dabar pažiūrėk man tail ir rask -n su + naudojimu.\nDabar tavo failas raw_data_hh_customers.csv turi antraštes (header) ir duomenis. Pasinaudojus head arba tail (pagalvok, kuri čia labiau tinka) bei išmoktais flagais, sukurk naują failą pure_data.csv, kuriame būtų visos originalaus failo eilutės, bet ne antraštė.\nPalygink su wc eilučių skaičių viename ir kitame faile ir įsitikink, jog skirtumas tik 1 eilutė.\nSu ls -lh arba ls -l palygink, kiek sutaupei vietos, atsisakius vienos eilutės “duomenų”.\nKonspektuok head ir tail tame pačiame dokumente, kaip ir wc.\n\n\n\n\n\n7.2.3 tldr\nman puslapiai yra labai išsamūs, tačiau kartais jie gali pasirodyti per ilgi. --help gali suteikti trumpą ir aiškią informaciją, tačiau net ir šie puslapiai gali būti per daug sudėtingi pradedantiesiems. Čia į pagalbą ateina tldr - programa, kuri pateikia dažniausiai naudojamus scenarijus ir labai trumpą paaiškinimą apie komandą. Tai dar viena priemonė tavo arsenale, jei pamiršai, kaip veikia komanda.\n\n\n\n\n\n\nPraktika\n\n\n\n\nPasitikrink, ar turi tldr naudodant which tldr.\nPrisimink žingsnius, kuriuos reikia atlikti, norint įdiegti programą.\nĮdiek tldr.\nJeigu reikia, konspektuokis!\n\n\n\ntldr komanda priima kaip argumentą kitą komandą. Daugumai standartinių komandų, tldr terminale atspausdins dažniausiai naudojamus flagus bei kelis jų taikymo pavyzdžius.\nPabandyk:\n\ntldr head\ntldr wc\ntldr cut\ntldr tldr\n\n\nKaip matai, tldr aprašo ir pačią tldr komandą.\n\n\n\n\n\n\nPraktika\n\n\n\n\nNorėtum palaipsniui išnagrinėti raw_data_hh_customers.csv failą, bet pamiršai, kaip pasirinkti tam tikrą stulpelį. Pasinaudok tldr cut.\nJei paleisi cut ... raw_data_hh_customers.csv, komanda tau atspausdins daug eilučių. Tai būtų neefektyvu. Prisimink, kaip sujungti skirtingas komandas ir pagalvok, kaip galėtum inspektuoti kiekvieną stulpelį atskirai, matant tik pirmas 15 eilučių. Inspektuok terminale pirmus 10 stulpelių, pabandyk suprasti, ar jie būtų vertingi analizei ar ne.\n\n\n\n\n\n7.2.4 ChatGPT\nChatGPT yra naudingas įrankis Linux naudotojams. Jis nėra labai protingas, bet gana efektyvus, jog padėtų tau dirbti. Keli svarbūs dalykai:\n\npo registracijos tu gali naudotis geresniu modeliu (yra limitas užklausoms, po to įsijungia paprastensis modelis)\npo registracijos išsisaugo tavo užklausų istorija, o tai padeda turėti ilgesnes sesijas. Ilgesnės sesijos yra naudingos, nes ChatGPT reaguoja į visą sesijos kontekstą.\n\nSvarbu pratintis rašyti užklausas ChatGPT. Štai keli patarimai:\n\nAngliškai ChatGPT supranta ir atsako geriau nei lietuviškai dėl didesnio duomenų kiekio anglų kalba, iš kurio ChatGPT mokėsi.\nPradėk užklausą suteikiant kontekstą, o ne tik rašant klausimą.\nKartais gali norėti, jog ChatGPT elgtųsi kaip tam tikras asmuo. Tai gali suformuluoti savo užklausoje.\n\n\n\n\n\n\n\nPraktika\n\n\n\nPrieš tai tu panaudojai\n\nhead 15 raw_data_hh_customers.csv | cut -d \",\" -f 1 arba\n\ncut -d \",\" -f 1 raw_data_hh_customers.csv | head 15\n\nTačiau kuris variantas yra geresnis? Išbandyk šias užklausas ir palygink jų atsakymus. Rašyk užklausas pradedant vis naują chat’ą, tai simuliuos atskiras užklausas ir neleis ChatGPT mokytis einamojoje sesijoje.\n\n“Ar galima naudoti cut -d \",\" -f 1 raw_data_hh_customers.csv | head 1”\n“Kuri komanda yra efektyvesnė: head 15 raw_data_hh_customers.csv | cut -d \",\" -f 1 ar cut -d \",\" -f 1 raw_data_hh_customers.csv | head 15”\nDabar suteik daugiau konteksto ir įvertink GPT atsakymą į klausimą: “Aš dirbu su 4 mln. eilučių failu raw_data_hh_customers.csv. Mano tikslas yra peržiūrėti pirmas 15 eilučių kiekvieno stulpelio. Koks komandų head ir cut eiliškumas šioje situacijoje būtų geriausias? Paaiškink savo atsakymą. Elkis taip, tarsi būtum labai patyręs shell (bash) programuotojas.”\n\nAr pastebėjai skirtumą? Pateikus kontekstą bei paprašius argumentuoti savo pasirinkimą, GPT pateikia kur kas tikslesnį atsakymą. Papildomas prašymas veikti kaip patyręs bash programuotojas dažnai duoda naudingesnę informaciją.\n\n\nĮsimink:\n\nKontekstas: ką tu darai\nTikslas: kokį rezultatą nori gauti\nProblemos: ką gauni vietoj to, ko negauni, arba kur matai problemą\nPrašymas paaiškinti savo pasirinkimą\n“Agento” kūrimas, pasakant, kaip turėtų elgtis GPT\n\nYra žingsniai, kurie padės efektyviau dirbti.\n\n\n7.2.5 Konspektavimas\nGalbūt jau pastebi, kad prisiminti visas komandas nėra lengva. Kai kurios taps įprasta ir nuolat naudojama atmintimi, tačiau kitos gali pranykti iš atminties. Dirbant analitikoje ar programavime, niekada neprisiminsi visko. Tiesiog reikia įprasti naudotis savo “antrinėmis smegenimis” - konspektuotis viską taip, kad prireikus galėtum greitai rasti reikiamą informaciją.\nPavyzdžiui, analitikai dažnai išsisaugo ilgus duomenų užklausų kodų gabalus (code chunks), ypač jei jų prireikia reguliariai. Programuotojai taip pat dažnai naudoja įrankius kaip Obsidian ar Joplin konspektams.\nAš dažnai naudoju Obsidian arba Joplin, kad konspektuočiausi apie kilusias problemas, kaip jas sprendžiau, kas veikė ir kas ne. Konspektavimas prasideda dar tebesitęsiant problemai. Pvz., kai mano kompiuteris negalėjo sukurti VPN tunelio, kartu su ChatGPT bandžiau spręsti kilusias problemas. Visa šį procesą aš užfiksavau, kad ateityje galėčiau greičiau rasti sprendimus.\nKitas scenarijus - kaip aš įdiegiu savo Linux sistemą. Kadangi mano kompiuteris naudojamas tiek darbo, tiek asmeniniais tikslais, man svarbu turėti gerai aprašytą procesą, ką turiu instaliuoti, po ko ir kodėl. Po instaliavimo proceso, nuolat pridedu naujas programas į šį dokumentą, kad visada turėčiau aktualiausią jo versiją. Nedarydamas to, sukuriu techninę skolą (tech debt) - terminą, naudojamą IT pasaulyje, kai kažkas padaroma greitai, paliekant problemas ateičiai. Visada venk tech debt, nes dažnai sutaupai tuo metu 5 minutes, kurios paskui tau kainuos 55.\n\nPeržiūrėk Getting Started pirmus 4 skyrius apie Obsidian.\nĮdiek Obsidian naudojant Flatpak. Susikurk “vault” (direktoriją, kurioje bus visi Obsidian užrašai, idealu - į savo namų serverį Nextcloud).\nPerkelk savo konspektus kaip naujus užrašus. Pagalvok, kokia būtų geriausia aplankų ir failų struktūra. Nebijok, ji keisis ateityje.\n\nObsidian naudoja Markdown formatą. Peržiūrėk šį Cheat Sheet, kaip jis naudojamas.\nTaip pat rekomenduoju peržiūrėti / skaityti:\n\nI learned a system for remembering everything\nI learned a productivity system for organizing life\nTF kanale: PARA metdas- 4 video",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#tinklo-komandos",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#tinklo-komandos",
    "title": "7  BASH pažengusiems",
    "section": "7.3 Tinklo komandos",
    "text": "7.3 Tinklo komandos\nŠioje dalyje išmoksi naudoti ping, curl ir wget, kad galėtum patikrinti ryšį bei atsisiųsti duomenis.\n\n7.3.1 ping komanda\nFilmuose apie povandeninius laivus dažnai girdime sonarų “ping” garsą, kuris naudojamas sekant objektus po vandeniu. Panašiai ir tu gali naudoti ping komandą, kuri padeda patikrinti, ar turi prieigą prie interneto, ir ar tavo norimas pasiekti serveris yra pasiekiamas.\n\nJeigu nėra garso, originalas Youtube\nLinux sistemoje komanda ping &lt;host&gt; leidžia nurodyti norimą URL ar IP adresą. Skirtingai nei Windows sistemoje, Linux ping komanda nesustoja automatiškai, todėl rekomenduojama naudoti -c (count) flagą, kad nurodytum, kiek ping signalų turėtų būti siunčiama, pvz., 5.\nPabandyk\nping -c 5 infraplanas.lt\nTu turėtum pamatyti panašią išvestį:\n\nPing išvestis\n\nping nurodo, kokį adresą pingina, ir pateikia IP adresą (pvz., 65.108.247.94).\nTurėtum gauti 5 eilutes ping’ų atgal su meta duomenimis, tarp jų - kiek laiko užtruko signalui nueiti ir grįžti.\nping komanda sustos po 5 kartų\n\nDabar tu gali pabandyti naudoti šį adresą norint atsidaryti tinklapį:\nbrave-browser 65.108.247.94\nGali brave-browser pakeisti firefox ar kita sistemoje įdiegta interneto naršykle.\n\nKaip matai, tai veikia. Bet taip nebus visada. Pateiksiu trumpą paaiškinimą po praktikos.\n\n\n\n\n\n\nPraktika\n\n\n\n\nPasinaudok tldr ir identifikuok pagrindinius ping flagus. Kada ir kokius naudotum? Konspektuokis.\nPabandyk pinginti 3 kartus vinted.lt.\nBandyk atsidaryti pingintą IP su brave-browser &lt;host ip&gt;.\n\n\n\nKodėl ping veikia, bet atidaryti tinklapį pagal IP kartais nepavyksta?\nTrumpai apie tai, kodėl tau pavyko pingtini vinted.lt, bet nepavyko atsidaryti 172.64.150.26.\n\nKai naršyklėje įrašai, pvz., vinted.lt, tavo kompiuteris dar neturi informacijos, koks tai konkretus IP adresas. Todėl jis siunčia užklausą į DNS (Domain Name System) serverį, kuris pasako, koks IP adresas atitinka tą domeną. Kai žinai IP, tavo kompiuteris gali siųsti užklausas tiesiai į tą serverį.\nKai kurie tinklapiai, kaip infraplanas.lt, gali būti pasiekiami tiesiogiai per IP, nes jie yra paprasti ir neturi papildomų saugumo sluoksnių. Tačiau dauguma šiuolaikinių svetainių naudoja apsaugos priemones, kaip Cloudflare, kurios veikia kaip ugniasienė ir apsaugo serverius nuo kenkėjiškų veiksmų. Kai bandai pasiekti tokį serverį tiesiai per IP, Cloudflare gali neleisti užmegzti ryšio, nes IP užklausos neperduoda visos būtinos kontekstinės informacijos, pvz., kokiame URL kontekste užklausa buvo atlikta, t.y. trūksta tam tikros informarijos užklausos header dalyje.\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nPabandyk atjungti savo Wi-Fi ryšį ir pinginti, pvz., lrt.lt. Gauni kitokią išvestį. Pagalvok, ar tai yra stdout ar stderr? Ar galėtum skirtingai nukreipti išvestis? Paeksperimentuok.\n\n\n\n\n\n\n7.3.2 curl ir wget\ncurl ir wget yra įrankiai darbui su tinklo užklausomis, tačiau jų paskirtis skiriasi. wget yra orientuotas į failų atsisiuntimą, palaiko rekursyvų atsisiuntimą ir automatiškai atnaujina nutrauktus parsisiuntimus. curl yra universalesnis ir tinka ne tik failų atsisiuntimui, bet ir duomenų siuntimui (pvz., API užklausoms). Pagal nutylėjimą, curl išveda duomenis į terminalą.\n\n7.3.2.1 wget\nAtsidaryk https://data.gov.lt/ ir surask “Transporto priemonių valstybiniai numeriai pagal markę ir modelį” duomenis.\nPapaudus ant “Duomenys” ir “Atsiųsti”, tu suprantama gali atsisiųsti duomenis. Bet toks būdas nebūtų automatizuojamas ateityje, kai norėsi atnaujinti duomenis.\n\nNueik į API skiltį, nusikopijuok adresą esančios užklausos adrese.\n\nTerminale irašyk ir paleisk šią komandą:\nwget https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris\n\nPeržiūrėk išvestį. wget iš pradžių rezolvin’a URL adresą ir gauna IP (pvz., 193.219.12.192), tada jungiasi prie jo. Gauni atsakymą, kad prisijungti pavyko (200 OK), ir tada duomenys pradeda parsisiųsti. Failas išsaugomas kaip ValstybinisNumeris.\n\nTačiau, jei bandysi naudoti komandą head ValstybinisNumeris, pastebėsi, kad terminalas nesustoja spausdinti išvesties. Taip yra dėl to, kad duomenys yra JSON formatu, kuriame visi duomenys yra įrašyti vienoje eilutėje. JSON formatas yra labai naudingas duomenų mainams, tačiau šiuo atveju jis nėra tinkamas, kai nori peržiūrėti duomenis eilutėmis. Šis formatas bus aptartas išsamiau vėliau.\nNet ir naudojant flagą --output-document ValstybinisNumeris.csv, kuris leidžia nurodyti pageidaujamą failo pavadinimą, po .csv failu vis tiek slėpsis JSON formatu užkoduoti duomenys. Pabandyk dar kartą atsisiųsti failą su komanda:\nwget https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris --output-document ValstybinisNumeris.csv\nKai atidarysi šį failą naudojant LibreOffice Calc, pastebėsi, kad duomenys nėra tinkamai suformatuoti:\nlibreoffice --calc ValstybinisNumeris.csv\n.\nPanašu, kad duomenys serveryje saugomi ne visai tokiu formatu, koks mums būtų patogiausias. Priežastis ta, kad https://data.gov.lt/ veikia kaip vartotojui draugiškas fasadas, tačiau už jo slepiasi sudėtingesnė sistema, pavadinta duomenų spinta. Ši sistema gali pateikti duomenis įvairiais formatais.\nNorint pasiekti tą mažiau gražią “spintą”, sek šias nuorodas:\n.\nViršuje pamatysi visus galimus duomenų parsisiuntimo formatus. Jei naršyklėje paspausi kairės pelės mygtuku ant CSV, pradėsi automatiškai atsisiųsti failą ValstybinisNumeris.csv. Norint gauti nuorodą, kurią gali panaudoti wget komandoje, spausk dešiniu pelės mygtuku ant CSV ir meniu pasirink “Kopijuoti nuorodą” (copy link).\n.\nNuoroda, kurią turėtum gauti, atrodo taip:\nhttps://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris/:format/csv\nKaip matai, ji nedaug tesiskiria nuo tos kurią turėjai:\nhttps://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris\nMatomas skirtumas yra /:format/csv dalelė URL adrese, kuri nurodo, jog duomenys turi būti parsiunčiami CSV formatu. Šis papildymas užtikrina teisingą duomenų formatą tavo naudojimui.\nTai užtikrins, kad naudojant wget komandą, gausi duomenis būtent CSV formatu - tokiu, kuris yra lengvai analizuojamas ir atidaromas su įprastinėmis programomis, tokiomis kaip LibreOffice Calc ar Excel.\n\n\n\n\n\n\nPraktika\n\n\n\n\nNaudojant rm išsivalyk darbo direktoriją nuo nereikalingų failų.\nNaudodajant wget ir nukopijuotą nuorodą, parsiųsk duomenis su --output-document ValstybinisNumeris.csv.\nKol duomenys siunčiasi - pasidaryk kavos ☕.\nAtspausdink pirmas 5 ValstybinisNumeris.csv failo eilutes ir įsitikink, jog duomenys tokie, kokių tikėjaisi.\n\n\n\n\n\n\n\n7.3.3 curl\ncurl yra universalesnė programa, tinkama ne tik failų atsisiuntimui, bet ir duomenų siuntimui (pvz., API užklausoms). Ji veikia su daugiau tinklo protokolų ir pagal nutylėjimą išveda duomenis į terminalą, o ne į failą.\nJei paleistum curl be nustatymų, kaip pvz.,:\ncurl https://get.data.gov.lt/datasets/gov/regitra/ktpr/ValstybinisNumeris/:format/csv\npamatytum, kaip duomenys skrieja terminale:\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nNaudok tldr curl, curl --help ir ChatGPT, kad identifikuotum pagrindinius flagus curl komandai\nNaudojant curl, parsisiųsk ValstybinisNumeris.csv failą.\nTinklapyje https://data.gov.lt susirask duomenis Valstybės apdovanojimai. Parsisiųsk juos .csv formatu su wget ir išsaugok pavadinimu apdovanojimai.csv. Prisimink, jog URL adresą gali pasiimti iš API skiltyje esančios užklausos adreso, tik turėtum pridėti /:format/csv.\nSu curl parsisiųsk “Pacientų registracijos paslaugoms Žalgirio klinikoje” ir išsaugok kaip reg_zalgiris.csv.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failų-redagavimas-ir-apdorojimas",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failų-redagavimas-ir-apdorojimas",
    "title": "7  BASH pažengusiems",
    "section": "7.4 Failų Redagavimas ir Apdorojimas",
    "text": "7.4 Failų Redagavimas ir Apdorojimas\nPraeitame skyriuje tu jau išmokai naudotis komanda sed, kuri yra labai galinga apdorojant raw duomenis. Dabar dar praplėsi savo supratimą, kaip gali išnaudoti uniq, kad geriau susipažintum su failo struktūra ar netgi atliktum mini analizes. Taip pat susipažinsi su JSON formatu, nes ne visada gali pavykti jo išvengti, o apdoroti JSON duomenis nėra labai sudėtinga net ir naudojant bash. Tiesa, Python tai padaryti lengviau.\n\n7.4.1 uniq\nTu jau moki surūšiuoti failo eilutes su komanda sort, tiek didėjančia (A-Z), tiek mažėjančia (Z-A) tvarka, taip pat surūšiuoti pagal skaičius. uniq komanda leidžia tau parodyti unikalias eilutes ir, jei reikia, jas suskaičiuoti.\nŠis komandų junginys head reg_zalgiris.csv | cut -d \",\" -f 13 | sort paima pirmas 10 eilučių iš reg_zalgiris.csv failo, supjaustydamas pagal , kaip skirtuką tarp stulpelių, pasirenka 13-ą stulpelį, o sort surikiuoja duomenis didėjančia tvarka (A-Z).\n\nKomanda uniq leidžia pamatyti unikalias reikšmes, tik uniq aptinka duplikatus tik tada, kai jie yra šalia. Todėl uniq beveik visada naudojama kartu su sort. Pvz., head reg_zalgiris.csv | cut -d \",\" -f 13 | sort | uniq.\n\nRetais atvejais tau gali būti įdomu sužinoti tik eilutes, kurios neturi duplikatų. Tada naudotum flagą -u. Šiuo atveju, jei „gydytojo_specialybe“ kartojasi tik vieną kartą (natūralu, nes tai duomenų antraštė), todėl uniq -u grąžina tik šią eilutę.\n\nKur kas praktiškesnis yra flagas -c, kuris suskaičiuoja, kiek yra vienodų eilučių.\n\nKaip matai, turime problemą - stulpelio antraštė (header) figūruoja kaip duomenys. Jei tau tik reikia grubiai įvertinti duomenų teisingumą ir juos geriau suprasti, tai gali netrukdyti. Bet galima ir išsivalyti.\n\n\n\n\n\n\nPraktika\n\n\n\n\nKokias 2 strategijas (komandas) reg_zalgiris.csv turi savo arsenale, kad neįtrauktum eilutės su gydytojo_specialybe į tolimesnius veiksmus? Prisimink, ką išmokai --help dalyje, bei prisimink komandą, kuri filtruoja eilutes - grep.\nPasinaudok viena iš šių strategijų ir suskaičiuok, pas kokių specialybių daktarus buvo daugiausiai ir mažiausiai registracijų.\n\nTurėtum gauti šį rezultatą:\n\nKaip matai, rezultatas nėra tobulas, nes dabar turi 6622 “Ortodontė” ir 6727 “Ortodontas”. Nors specialybė ta pati. Jei tave domintų, kiek buvo registracijų pagal specialybes, reikėtų sukurti taisykles su sed komanda, kur suvienodintum profesijų pavadinimus ir padarytum juos neutralius lyčiai.\n\n\n\n\n7.4.2 JSON\n\n7.4.2.1 JSON Duomenų Formatas\nJSON (JavaScript Object Notation) yra dažnai naudojamas duomenų formatas IT pasaulyje, nes jis leidžia hierarchiškai organizuoti duomenis viename tekstiniame dokumente su .json plėtiniu. Tai ypač naudinga, kai pavieniai objektai gali turėti skirtingą atributų kiekį.\nPavyzdžiui, JSON struktūroje galėtume turėti tokius duomenis:\n{\n  \"Tėtis\": {\n    \"amžius\": 30,\n    \"lytis\": \"V\"\n  },\n  \"Mama\": {\n    \"amžius\": 30,\n    \"lytis\": \"V\",\n    \"profesija\": \"IT analitikė\",\n    \"buvusios_darbovietės\": {\n      \"AUDI\": {\"profesija\": \"IT testuotoja\"},\n      \"BMW\": {\"profesija\": \"Inžinierė\"}\n    }\n  },\n  \"Vaikas\": {\n    \"amžius\": 3,\n    \"lytis\": \"M\"\n  }\n}\nJeigu bandytum tokią hierarchinę struktūrą perkelti į tabuliarinę lentelę, tai būtų gana sudėtinga. Analitikoje tai vyksta su duomenų bazėmis, kur tam tikri atributai yra tam tikrose atskirose lentelėse. Tačiau interneto platformose kartais reikia paprasto ir greito būdo atvaizduoti panašius hierarchinius duomenis.\nJSON dažnai naudojamas duomenų perdavimui tarp kliento ir serverio, nes jis yra plačiai palaikomas daugelyje programavimo kalbų. Todėl su šiuo formatu susiduria tiek „back-end“ inžinieriai, turintys jį integruoti į duomenų bazes, tiek „front-end“ kūrėjai, kurie šį formatą naudoja tinklapių atvaizdavimui, tiek dažnai ir duomenų analitikai, kurie turi mokėti konvertuoti (angl. parse) šiuos duomenis į tabuliarinius duomenis analizei.\n\n\n7.4.2.2 JSON Struktūros Pagrindinės Savybės\n\nJSON duomenys organizuojami „raktas:vertė“ (key:value) poromis, pvz., “amžius”: 30, “lytis”: “V”.\nJSON palaiko paprastas ir sudėtingas duomenų struktūras, tokias kaip objektai ir masyvai.\nAiškiai struktūrizuota forma leidžia lengvai suprasti duomenis ir jų kontekstą, padedant vizualizuoti hierarchiją, kaip panašu žemiau aprašytuose pavyzdžiuose.\n\nJSON Reikšmių Tipai\n\nTekstas (string): “Ruprechtas”\nSkaičius (number): pvz., 10, 55, 99\nLoginė reikšmė (boolean): true, false\nJokia reikšmė: null\nObjektas - prasideda ir baigiasi {}, viduje turinčios key-value poras (dar vadinama dictionary kai kuriose kalbose, pvz., Python).\nMasyvas - prasideda ir baigiasi [], angliškai vadinamas array arba list; tai yra sąrašas su bet kokio tipo duomenimis, įskaitant objektus, skaičius ir tekstą.\n\nJSON Objektas\n\nTai struktūra, kuri sudaryta iš raktų ir reikšmių porų.\nKiekvienas raktas (key) yra unikalus ir turi susietą reikšmę (value).\nJSON objektas naudojamas apibūdinti vieną dalyką arba vieną įrašą (pvz., žmogų, knygą, įmonę ir t.t.).\nTai panašu į “laukai ir reikšmės” formą lentelėje.\nPuikiai tinka, kai reikia saugoti susijusią informaciją (pvz., žmogaus vardas, amžius, el. paštas).\n\n{\n  \"name\": \"Jonas\",\n  \"age\": 30,\n  \"email\": \"jonas@example.com\"\n}\nJSON Masyvas\n\nStruktūra, sudaryta iš reikšmių sąrašo (reikšmės gali būti objektai, skaičiai, tekstai ir kt.).\nReikšmės masyve nėra unikalios, bet turi tvarką (indeksus).\n\n[\n  {\"name\": \"Jonas\", \"age\": 30},\n  {\"name\": \"Petras\", \"age\": 25},\n  {\"name\": \"Ona\", \"age\": 28}\n]\nJSON Objekto ir Masyvo Naudojimas Kartu\nJSON dažnai jungia objektus ir masyvus, kad galėtų lanksčiai aprašyti struktūras, pvz., studentų sąrašą:\n{\n  \"students\": [\n    {\"name\": \"Jonas\", \"age\": 30, \"food\": [\"Ledai\", \"Lazanija\"]},\n    {\"name\": \"Petras\", \"age\": 25, \"food\": [\"Vištiena\"]},\n    {\"name\": \"Ona\", \"age\": 28, \"food\": [\"Vištiena\", \"Suši\"]}\n  ]\n}\nJSON Naudojimas API\nSu JSON formatu tu susidursi tada, kai dirbsi su front-end ir back-end, o taip pat, jeigu turėsi komunikuoti duomenis per API (An application programming interface).\nAPI yra įrankių ir protokolų rinkinys, leidžiantis skirtingoms programoms bendrauti vienai su kita. Tai kaip „tiltas“, leidžiantis vienai programai naudoti kitos funkcijas arba duomenis, nesigilinant į jų vidinį veikimą.\nPvz., programa gali bendrauti su meteorologine tarnyba ir gauti orų prognozes. API nurodo, kaip siųsti užklausas ir kaip bus pateikiami atsakymai. Programai nesvarbu, kaip tarnyba suranda informaciją duomenų bazėje. Svarbiausia, kad ji supranta API taisykles.\nPopuliarūs API stiliai:\n\nREST (Representational State Transfer) – dažno naudojimo API dizaino stilius, naudojantis HTTP protokolą dėl savo paprastumo ir flexibilumo.\nSOAP (Simple Object Access Protocol)\nGraphQL WebSocket\n\n\n\n\n7.4.3 jq\njq yra galingas komandinės eilutės įrankis, skirtas JSON duomenų apdorojimui Linux aplinkoje. Šis įrankis leidžia lengvai analizuoti, filtruoti, modifikuoti ir formatuoti JSON duomenis tiesiogiai terminale. Tai ypač naudinga dirbant su API atsakymais arba duomenų failais, pateiktais JSON formatu.\nPirmiausia įsitikink, kad jq yra įdiegtas tavo sistemoje. Jei ne, instaliuok su sudo apt install jq.\njq komandos sintaksė yra paprasta:\njq &lt;filtras&gt; &lt;failas&gt;\nČia  nurodo, kurie duomenys ir kaip turėtų būti apdorojami, o  – tai JSON failo pavadinimas, kuriuo dirbi.\nJei JSON duomenys ateina iš kitos komandos:\nkomanda | jq &lt;filtras&gt;\nJSON Duomenų Gražinimas\nJSON objekto duomenis galima išvesti gražiai suformatuotus. Paprasčiausias filtras yra . - jis išveda visą JSON struktūrą. Verta prisiminti, kad jq filtrų tekstą reikia įdėti į viengubas kabutes '&lt;filtras&gt;', kad išvengtum sintaksės konfliktų su komanda.\n\n7.4.3.1 Darbas su JSON Objektais\nJSON objektas dažniausiai sudarytas iš raktų (key) ir verčių (value) porų.\nPavyzdinis JSON objektas: Sukurk failą user.json.\necho '{\n  \"name\": \"Jonas\",\n  \"age\": 30,\n  \"email\": \"jonas@example.com\"\n}' &gt; user.json\nGražus Atvaizdavimas\nNaudojant jq ., gali išvesti visą JSON turinį suformuotą skaitymui. . čia reiškia visą objektą, ir jq jį „gražina” su lygiavimo tarpais, kad būtų lengviau perskaityti.\njq '.' user.json\nPavienių Verčių Gavimo Technika\nNorint ištraukti konkrečią informaciją, galime nurodyti konkretų raktą. Tai išspausdina tik to rakto vertę, šiuo atveju - “Jonas”.\njq '.name' user.json\nKelių Rakčių Vertės\nJei nori gauti kelias reikšmes, gali jas atskirti kableliais. Ši komanda atspausdina vardą ir amžių kaip dvi atskiras eilutes.\njq '.name, .age' user.json\nRaktų ir Reikšmių Poros Atrinkimas\nKai nori išvesti ne tik vertę, bet ir raktą su verte, gali suformuoti naują objektą. Tai sukuria JSON objektą tik su pasirinktais raktais, šiuo atveju name arba name ir age.\njq '. | {name}' user.json\njq '. | {name, age}' user.json\n\n\n7.4.3.2 Darbas su JSON Masyvais\nJSON masyvas leidžia sukaupti kelis objektus arba vertes į vieną struktūrą.\nSukurk JSON masyvą students.json, apimantį kelis žmonių objektus.\necho '[\n  {\"name\": \"Jonas\", \"age\": 30},\n  {\"name\": \"Petras\", \"age\": 25},\n  {\"name\": \"Ona\", \"age\": 28}\n]' &gt; students.json\nViso Masyvo Atvaizdavimas\nNorint gražiai peržiūrėti masyvą, naudok:\njq '.' students.json\nTai pateikia visą JSON failo turinį, tinkamu formatu.\nAtskirų Elementų Atrinkimas\nPasirink pirmą masyvo objektą (atkreipk dėmesį į nulio indeksavimą). Tai duoda pirmąją masyvo vertę, kuris yra Jonas objektas.\njq '.[0]' students.json\nGali apsirinkti ir kelis objektus\njq '.[0,1]' students.json\nVisų Elementų Iteracija\nNorint atspausdinti visus name elementus:\njq '.[] | .name' students.json\n. ir [] nurodo, kad nori peržvelgti (iteruoti) per visus masyvo elementus.\n\n\n\n\n\n\nPraktika\n\n\n\nŠioje užduotyje dirbsi su JSON objektu, kuriame yra raktų ir reikšmių poros, taip pat masyvas ir objektas kaip reikšmė. Sukurk failą info.json ir dirbk su juo atliekant užduotis pateiktas žemiau.\n{\n  \"name\": \"Jonas\",\n  \"age\": 30,\n  \"email\": \"jonas@example.com\",\n  \"isStudent\": false,\n  \"courses\": [\n    \"Matematika\",\n    \"Informatika\",\n    \"Fizika\"\n  ],\n  \"address\": {\n    \"street\": \"Gedimino pr. 1\",\n    \"city\": \"Vilnius\",\n    \"country\": \"Lietuva\"\n  }\n}\n\nSurask JSON objekte esantį rakto „name“ vertę ir atspausdink ją terminale.\n\nTurėtum gauti: \"Jonas\"\n\nGrąžink vardo rakto ir reikšmės porą kaip JSON objektą.\n\nTikimasi gauti: {\"name\": \"Jonas\"}\n\nIšvesk masyvą su vardo ir amžiaus reikšmėmis.\n\nKaip rezultatą turėtum matyti masyvą: [\"Jonas\", 30]\n\nGrąžink objektą su vardo ir amžiaus raktais bei reikšmėmis.\n\nRezultatas turi būti: {\"name\": \"Jonas\", \"age\": 30}\n\nAtvaizduok visą „courses” masyvą.\n\nTurėtum gauti masyvą: [\"Matematika\", \"Informatika\", \"Fizika\"]\n\nIšvesk pirmąjį „courses“ masyvo elementą.\n\nTikimasi pamatyti pirmą kursą: \"Matematika\"\n\nIšvesk „address“ objektą.\n\nRezultatas: {\"street\": \"Gedimino pr. 1\", \"city\": \"Vilnius\", \"country\": \"Lietuva\"}\n\nGauk „street” reikšmę iš „address“ objekto.\n\nTurėtum matyti adresą: \"Gedimino pr. 1\"\n\nSukurk objektą su „city” ir „country“ iš „address“ objekto.\n\nRezultatas turi būti: {\"city\": \"Vilnius\", \"country\": \"Lietuva\"}\n\n\n\n\n\n\n7.4.3.3 JSON Filtravimas\nGrįžkime prie įrašo students.json. JSON filtravimo dažnai reikia tam, kad atrinktum specifines duomenų dalis, atitinkančias tam tikras sąlygas. Naudodjant jq, gali pritaikyti filtrus tiesiogiai JSON masyvuose.\n[\n  {\"name\": \"Jonas\", \"age\": 30},\n  {\"name\": \"Petras\", \"age\": 25},\n  {\"name\": \"Ona\", \"age\": 28}\n]\nKai nori atrinkti tik tuos studentus, kurių amžius yra didesnis nei 26, naudok select funkciją. select leidžia taikyti sąlygas, atrenkančias tik tas masyvo dalis, kurios atitinka nustatytą kriterijų. Atkreipk dėmesį, kad select funkcija veikia tik masyvo elementuose, todėl rezultatą reikia apdirbti iš masyvo konteksto.\njq '.[] | select(.age &gt; 26)' students.json\nŠi komanda:\n\nNaudoja .[], kad pasiektų (iteruotų per) kiekvieną masyvo elementą.\nNaudoja select(.age &gt; 26) vidinėje komandoje, kad pasirinktų tik tuos objektus, kurių age yra didesnis nei 26.\n\nKombinuoti Filtrai\nKelių sąlygų derinimas leidžia atlikti išsamesnę analizę ir atrinkti dar tikslesnius duomenis. Pavyzdžiui, pasirink studentus, kurie yra vyresni nei 26 metai ir kurių vardas yra Ona:\njq '.[] | select(.age &gt; 26 and .name == \"Ona\")' students.json\nNaudojant and, or, tu gali derinti kelias sąlygas. Kiekvienas masyvo elementas bus filtruojamas pagal abi nurodytas sąlygas.\n\n\n7.4.3.4 JSON Plošktinimas\nPo filtro pritaikymo dažnai reikia JSON duomenis supaprastinti (suplokštinti) iš JSON struktūros į paprastesnį formatą, pavyzdžiui, CSV ar TSV. Tai yra naudinga, jei nori duomenis pateikti lenteliniu formatu, kuris yra lengviau interpretuojamas ar eksportuojamas į kitas sistemas.\nPlokštinimas taikomas tik masyvams [], ne atskiriems objektams {}. Kai duomenys yra objekto formatu, reikia fiksuoti specifines reikšmes, kurias nori paversti plokščiu formatu. Pavertus objekto reikšmes į masyvą, galima tiksliai nurodyti, kas bus įtraukta į galutinį rezultatą:\nVieno objekto pavertimas į masyvą:\njq '[.name, .age, .email] | @csv' user.json\nMasyvo duomenų pavertimas CSV formatu Tai suformuos lentelę, kurioje bus pateikti studentų vardai ir amžiai atskirti kableliais.\njq '.[] | [.name, .age] | @csv' students.json\nVidinio masyvo plokštinimas\nKartais gali turėti masyvą JSON objekte ir nori jį paversti CSV formatu:\necho '{\n  \"courses\": [\"Matematika\", \"Informatika\", \"Fizika\"]\n}' | jq '.courses | @csv'\nSudėtingo objekto masyvinimas prieš plokštinimą\nJei turi JSON struktūrą su vidiniu objektu, pirmiausia suformuok masyvą iš reikšmių, o tuomet įvykdyk plokštinimą:\necho '{\n  \"address\": {\n    \"street\": \"Gedimino pr. 1\",\n    \"city\": \"Vilnius\",\n    \"country\": \"Lietuva\"\n  }\n}' | jq '.address | [.street, .city, .country] | @csv'\nKada rinktis @csv ir kada @tsv?\n\nEksportui ir duomenų mainams tarp programų: @csv yra dažniausiai pasirenkamas dėl jo suderinamumo su daugeliu programų.\nTiesioginiam naudojimui terminale ir skriptams: @tsv dažnai pranašesnis, ypač kai dirbama su duomenimis, kuriuose gali būti daug kablelių.\n\n\n\n7.4.3.5 -r\nDažnai norėsi, kad tekstinės reikšmės nebūtų apgaubtos dvigubomis kabutėmis CSV ar TSV formatuose. Flagas -r leidžia gauti “raw” arba neapdorotą tekstą be papildomų kabučių.\nPalygink:\n\nBe -r flag’o tekstinės reikšmės bus su kabutėmis.\nSu -r flag’o bus grąžintas tikrasis tekstas.\n\n| jq '.courses | @csv'         # Išsaugotų kabutės\n| jq -r '.courses | @csv'      # Neįtrauks kabučių\n| jq '.courses | @tsv'         # Išsaugotų kabutės TSV formatu\n| jq -r '.courses | @tsv'      # Neįtrauks kabučių\n\n\n\n\n\n\nPraktika\n\n\n\n\nSu curl arba wget parsisiųsk https://get.data.gov.lt/datasets/gov/vulzk/registracija/Registracija. Išvesties failo pavadinimą nurodyk kaip reg_zalgiris.json. Jei reikia pagalbos su komandų sintakse, naudok curl --help arba tldr curl.\n\nDuomenų formatas:\n{\n  \"_data\": [\n    {\n      \"_type\": \"datasets/gov/vulzk/registracija/Registracija\",\n      \"_id\": \"d3cf2132-dd72-459a-9624-e17e62419050\",\n      \"_revision\": \"f77c9ebd-f2d3-483b-ae76-fd3c6a1f91d8\",\n      \"_base\": null,\n      \"registracijos_id\": \"355549\",\n      \"gydymo_registracijos_data\": \"2013-11-28T08:00:00\",\n      \"registracijos_iraso_sukurimo_data\": \"2013-07-02T00:00:00\",\n      \"registracijos_iraso_keitimo_data\": \"2013-11-27T13:11:00\",\n      \"paciento_id\": \"1978fdae338a6ca\",\n      \"paciento_lytis\": \"V\",\n      \"paciento_gimimo_metai\": \"1977-01-01T00:00:00\",\n      \"gydytojo_id\": \"99\",\n      \"gydytojo_specialybe\": \"Endotontologė\"\n    }\n  ],\n  \"_page\": {\n    \"next\": \"WyIzNTU1NDkiLCAiZDNjZjIxMzItZGQ3Mi00NTlhLTk2MjQtZTE3ZTYyNDE5MDUwIl0=\"\n  }\n}\n\nFiltruok registracijas pagal gydytojo specialybę:\n\n\nFiltruok tik tas registracijas, kur gydytojo_specialybe yra “Ortopedas”.\nIšrink tik du laukus: gydytojo_id ir gydytojo_specialybe.\nFiltruotus duomenis išsaugok CSV formatu.\nGaliausiai, su sort ir uniq nustatyk, kiek skirtingų ortopedų (pagal gydytojo_id) buvo.\n\n\n\nIdentifikuok reikšmingus laukus analizei\n\n\nPeržiūrėk JSON struktūrą, nuspręsk, kurie laukai yra naudingi tolesnei analizei (pvz., registracijos datos, paciento lytis, gimimo metai, gydytojo specialybė ir kt.).\nKonvertuok visus pasirinktus laukus į CSV formatą.\n\n\nPridėk antraštes į CSV failą:\n\n\nJei po head pastebi, kad CSV faile trūksta antraščių, jas galima pridėti rankiniu būdu arba sujungiant echo ir cat. Praktikuokis bendravimą su ChatGPT ir rask sprendimą.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failų-paieška",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failų-paieška",
    "title": "7  BASH pažengusiems",
    "section": "7.5 Failų Paieška",
    "text": "7.5 Failų Paieška\nŠiame skyriuje susipažinsi su svarbiomis komandomis, kurios padės tau rasti failus tavo sistemoje. find komanda suteikia galimybę ieškoti failų ir direktorijų naudojant detalius paieškos kriterijus, tokius kaip pavadinimas, tipas, data ir kt. locate komanda naudoja Linux sistemose generuojamą failų indeksą greitai failų paieškai. whereis yra skirta rasti vykdomojo failo (binary), dokumentacijos ir kitos susijusios informacijos vietą.\n\n7.5.1 find\nKomanda find yra naudojama ieškoti failų ir direktorijų pagal pavadinimą, dydį, datą, teises ir kitus kriterijus.\nBazinė find komanda atrodo taip:\nfind /path/to/search -options criteria -options criteria\nPažiūrėk savo dabartinę darbinę direktoriją. Kokius failus joje turi, ir kokie yra jų dydžiai.\nKadangi šiuo atveju tik keli failai, tai gali pasirodyti ne itin įdomu. Patikrink, ar turi shell_part_2 savo namų direktorijoje. Jei ne, paleisk skriptą, kad ji vėl būtų sukurta (žr. praėjusio skyriaus pradžią).\nIeškoti failų esamoje darbinėje direktorijoje (t.y. “čia”) galima naudojant taško notaciją .. Tačiau dažniau dirbsi su ~, t.y. nuoroda į savo namų direktoriją. Tavo ir mano terminalo išvestys gali skirtis, tad nenustebk, jei matysi daugiau ar mažiau failų.\nPakeisk savo darbinę direktoriją į namų su cd ~ arba tiesiog cd.\nKomandai find pirmasis argumentas yra kur ieškoti. Dažniausiai tai gali būti:\n\nfind . - ieškoti aktyvioje direktorijoje\nfind ~ - ieškoti namų direktorijoje\nfind / - ieškoti root direktorijoje (t.y. visame kompiuteryje)\nfind ~/Downloads - ieškoti vartotojo Downloads direktorijoje arba kitoje konkrečiai nurodytoje direktorijoje\n\nfind priima daug skirtingų nustatymų (flagų), vienas pagrindinių yra -name.\nPavyzdžiui, suraskime, kur yra failas su registracijomis į Žalgirio kliniką. Tarkime, prisimeni tik, kad ten buvo “zalgiris” pavadinime. Pirmoji komanda negražina jokio failo, nes jo nerado. find, kaip ir dauguma bash komandų, gali veikti su “wildcards” (pakaitos simboliais):\nfind ~ -name zalgiris\nfind ~ -name *zalgiris*\n\nDabar, jei nori surasti failą su valstybiniais numeriais, tačiau find ~ -name *valstyb* nieko negrąžina, tai yra todėl, kad find yra “case-sensitive”, kaip ir visa BASH aplinka. Panašiai kaip ir su kitomis komandomis, gali pasinaudoti -iname, kad paieška nebūtų jautri raidžių dydžiui:\nfind ~ -name *valstyb*\nfind ~ -iname *valstyb*\n\nJei nenurodysi -name &lt;pavadinimas&gt;, tada find komanda ieškos visų failų ar direktorijų, atitinkančių kitus nurodytus kriterijus; jei nebus jokio kriterijaus, tada ji suras tiesiog visus failus ir direktorijas bei nuorodas. Sekančioje komandoje find ieško visų failų, direktorijų ir nuorodų bash_advanced direktorijos viduje, nes find paduodamas tik argumentas KUR ieškoti failų, direktorijų ir nuorodų.\nfind bash_advanced/\n\nKartais gali norėti, kad find grąžintų ne tik rastų failų adresus, bet ir daugiau informacijos. Tada gali panaudoti -ls flagą. Jis iš esmės panašus tau įprastą ls komandą.\nfind bash_advanced/ -ls\n\nGali apriboti paiešką pagal tai, ko ieškai: ar tai yra failas (f), direktorija (d), ar nuoroda (l). Ši komanda ieško tipo - direktorijos, kurios pavadinime yra žodis prasidedantis “Do”.\nfind ~ -type d -name \"Do*\"\nKaip matai find grąžina ir direktorijas, kurios yra paslėptos.\n\nJei tave domina rasti failus, kurie užima daug arba labai mažai vietos, šiuo atveju tau padės -size flagas. Jis priima skaičius žmonėms suprantamu formatu, pvz., 10M = 10 megabaitų, 1G = 1 gigabaitas ir t.t. Norint nurodyti failų dydį, gali naudoti - arba + prieš skaičių, kad sakytum “mažesnis nei” arba “didesnis nei”.\nJei nurodysi skaičių be pliuso ar minuso, find ieškos failų, kurių dydis lygus nurodytam skaičiui.\nfind -type f -size -300M\nfind -type f -size 300M\nfind -type f -size +300M\n[]\nGali norėti ieškoti failų pagal jų:\n\nSukūrimo datą c\nModifikavimo datą m\nPrieigos datą a\n\nTokiu atveju turėtum naudoti flagus -[acm]time (pasirink reikiamą raidę) ir nurodyti dienas. -n reikš per paskutines n dienų, +n reikš “daugiau kaip n dienų”. Turėk omenyje, jog dienas find vertina kaip kalendorines. Taip pat, jei nori, gali sujungti kelis reikalavimus į vieną, pavyzdžiui: ieškoti failų, kurie buvo sukurti daugiau kaip prieš 2 dienas -ctime +2, bet (ir) mažiau kaip prieš 7 dienas -ctime -7.\nfind ~ -type f -ctime +2 -ctime -7\nPaleidus šią komandą, pamatysi, kad tikėtina, turi nemažai failų, ir galbūt norėsi apriboti, kaip “giliai” find turėtų ieškoti. Pabandyk panaudoti -maxdepth arba -mindepth. Šie argumentai yra globalus, todėl juos turėtum rašyti iškart po find ~.\nfind ~ -maxdepth 1 -type f -ctime +2 -ctime -7 \n[]\nKomanda find priima ir loginius operatorius: -and, -or, ir ! (šauktukas, kuris reiškia “ne”). Nenustebk, jei kartais pamatysi trumpinius -a ir -o.\nŠtai komandos, kurios ieško failų, kurie yra sukurti daugiau nei prieš 2, bet mažiau nei prieš 7 dienas, ARBA ir IR kai jų dydis yra daugiau nei 300MB.\nfind ~ -maxdepth 2 -type d -ctime +2 -ctime -7 -or -size +300M\nfind ~ -maxdepth 2 -type d -ctime +2 -ctime -7 -and -size +300M\nKaip matai, -or leidžia rasti daugiau, nes užtenka, kad bent viena sąlyga būtų patenkinta, tuo tarpu -and reikalauja, kad visos sąlygos būtų patenkintos.\n_\nKą daryti, jei nori sujungti daugiau sąlygų arba sukurti sudėtingesnį loginį algoritmą? Tam gali išnaudoti skliaustus. Tačiau juos turėsi pabėgti su ( ir ), kad find ieškotų ne skliaustelių pavadinime.\nŠtai kaip galima ieškoti failų, kurie yra didesni nei 2M ir mažesni nei 100M IR ARBA .csv, arba .txt formato:\nfind ~ -size +2M -size -100M \\( -iname *.txt -or -iname *.csv \\)\nSvarbu paminėti, kad būtina turėti tarpus aplink skliaustus! Jei sujungi kelis reikalavimus, kaip -size +2M, -size -100M, jie sujungiami pagal nulytijimą su -and, todėl nebūtina jo nurodyti aiškiai.\nDabar prieikime prie pavojingesnių komandų!\nfind turi nustatymą -delete, kuris visus surastus failus, rastus pagal nurodytus parametrus, ištrins. Naudok -delete tik tada, kai esi visiškai tikras, kad viskas, kas randama, gali būti trinama.\nfind ~ -name \"*.txt\" -delete\n\nfind komanda jau yra labai galinga, bet dar nežinai jos stipriausios pusės! Su find gali perduoti rastus failus tolesniam apdorojimui. Tiesa, tai neveikia taip, kaip su pipe |. Sintaksė yra tokia:\nfind ... -exec &lt;komanda&gt; {} \\;\n\n-exec nurodo, kad su tuo, ką radai, dabar vykdysi kitą komandą.\n&lt;komanda&gt; gali būti bet kuri, tik turi būti tinkama pasirinktiems failams.\n{} naudojama vietoj failų pavadinimo.\nKad baigi komandą, nurodai su \\;.\n\nĮsivaizduok, kad nori atspausdinti visas eilutes, kuriose yra žodis “apie”. Bet nepameni, kuriame būtent faile, tik žinai, kad tas failas buvo .txt formato.\nfind ~ -type f -iname \"*.txt\" -exec grep -iH \"apie\" {} \\;\n\ntaigi find suranda visus tekstinius failus, tiklsiau tuos failus, kurių pavadinimas baigiasi .txt\n-exec perleidžia juos grep komandai\ngrep ieško case insensitive -i bet kartu ir atspasdina failo, kuriam priklauso rasti eilutė adresą -H\n\n\nTaip, galima perduoti rastus failus ir kitoms komandoms, pvz., rm, cp, mv.\nKaip matai, perduoti failus -exec gali būti pavojinga. Alternatyva, kur tavęs prašys patvirtinti kiekvienam failui taikomą komandą, yra -ok. Štai komanda, kuri suras visus failus, kurių pavadinime yra .csv ir padarys jų kopiją į aplanką ~/copy.\nmkdir ~/copy\nfind ~ -iname \"*.csv\" -ok cp {} ~/copy/ \\;\nKaip matai, prieš kiekvieną operaciją, terminalas reikalauja patvirtinimo, kurį turi įrašyti kaip y arba yes, kad patvritinti. Įrašius n, no , arba tiesiog paspaudus Enter, tai atitiks no ir komanda tam failui nebus įvykdyta.\n\nVykdant šią operaciją, find rado tuos pačius failus dar kartą, ten, kur jie jau buvo nukopijuoti, t.y., pačioje copy direktorijoje. Kad išvengtum to, gali find nurodyti, kur neieškoti su -not -path \"/home/justas/copy/*\" arba ! -path \"/home/justas/copy/*\". Atkreipk dėmesį į tai, kad nurodant -not -path, reikia absoliutaus adreso ir *, kad ten rasti failai (jų adresai) nebūtų įtraukti.\n\n\n\n\n\n\nPraktika\n\n\n\n\nParašyk komandą, kuri ieško visų failų tavo namų direktorijoje, kurių pavadinimas baigiasi .csv arba .txt.\nTą pačią komandą, tik perduok rezultatus į grep, atspausdink tas eilutes, kuriose yra “2024”.\nSurask visus failus, kurių sukūrimo data yra daugiau nei prieš 14 dienų, kurių pavadinimas baigiasi .mp4, ir kurie yra dwhelper arba Downloads direktorijose bei kurių dydis yra didesnis nei 100M.\nTą pačią komandą, tik panaudok -ok su rm {}. Dabar komanda perklaus, ar trinti kiekvieną failą. Ši komanda turėtų padėti tau apsivalyti įvairius senus video.\n\n\n\nKaip matai, galima ieškoti ir pagal failo savininką, jo grupę, ar failo teises.\n\n\n\n\n\n\n\nOpcija\nReikšmė\n\n\n\n\n-name\nIeškoti pagal failo pavadinimą, jautrus raidžių dydžiui.\n\n\n-iname\nIeškoti pagal failo pavadinimą, nejautrus raidžių dydžiui.\n\n\n-type\nIeškoti pagal failo tipą (f - failas, d - direktorija, l - nuoroda).\n\n\n-size\nIeškoti pagal failo dydį (+ didesnis, - mažesnis, be ženklo - lygus).\n\n\n-ctime\nIeškoti pagal sukūrimo datą (dienomis).\n\n\n-mtime\nIeškoti pagal modifikavimo datą (dienomis).\n\n\n-atime\nIeškoti pagal prieigos datą (dienomis).\n\n\n-maxdepth\nNustatyti maksimalų paieškos gylį (nuo pradinės direktorijos).\n\n\n-mindepth\nNustatyti minimalų paieškos gylį (nuo pradinės direktorijos).\n\n\n-ls\nIšvesti papildomą informaciją apie rastus failus.\n\n\n-not -path\nNeįtraukti nurodyto kelio į paiešką.\n\n\n-and/-a\nLoginis operatorius “ir” (and).\n\n\n-or/-o\nLoginis operatorius “arba” (or).\n\n\n!\nLoginis operatorius “ne” (not).\n\n\n-user\nIeškoti pagal failo savininką.\n\n\n-group\nIeškoti pagal failo grupę.\n\n\n-perm\nIeškoti pagal failų teises (permisijas).\n\n\n\n\n\n7.5.2 locate\nLinux operacinė sistema turi mechanizmą, kuris reguliariai indeksuoja visus failus, todėl locate &lt;pavadinimas&gt; komanda leidžia labai greitai surasti failą, kurio pavadinimą žinai. Galima naudoti pakaitos simbolius (wildcards) *, kad paieška apimtų įvairias pavadinimo variacijas.\n\nKeli locate trūkumai:\n\nNeatnaujintų failų rodymas: locate nerodo neseniai sukurtų arba pervadintų failų, kol nėra atnaujinama failų duomenų bazė. Duomenų bazės atnaujinimui naudok komandą updatedb.\nPaieškos kriterijų trūkumas: locate nesuteikia galimybės naudoti paieškos kriterijų, tokių kaip failo dydis, amžius ir kt., kuriuos siūlo find.\n\n\n\n\n7.5.3 whereis\nKomandos whereis paskirtis yra rasti informaciją apie programas, įskaitant jų vykdomuosius failus (binary files), dokumentaciją (pavyzdžiui, man puslapius) ir, jei įmanoma, šaltinio kodą (source code). Ji naudinga, kai nori sužinoti, kur yra įdiegta programa ir kokie susiję failai yra tavo sistemoje.\n\nVykdomieji failai: whereis parodo kelią iki programų vykdomųjų failų.\nDokumentacija: Parodo, kur yra susiję dokumentacijos failai, tokie kaip man puslapiai.\nŠaltinio failai: Jei yra, parodo kelią iki programos šaltinio failų.\n\n\n\n\n7.5.4 which\nKomanda which rodo, kurioje iš tavo aplinkos kintamajame PATH nurodytų vietų yra pirmasis rastas vykdomasis failas. Įvedus komandos pavadinimą terminale, which pateikia pirmą rastą failo kelią:\n\nPateikia tik pirmą rastą vykdomąjį failą nurodytame PATH.\nNaudinga patikrinti, ar programa, pvz., „Python“, yra įdiegta ir kuri versija bus vykdoma.\n\nJei reikia sužinoti visas vietas, kur yra vykdomasis failas ir susiję failai (pvz., kelios „Python“ versijos), verčiau naudoti whereis, nes jis pateikia išsamesnę informaciją.\n\n\n\n7.5.5 Intarpas: Kas yra PATH?\nŠi tema gali pasirodyti šiek tiek sudėtingesnė, bet ją pravartu žinoti norint geriau suprasti, kaip veikia Linux komandinė eilutė (CLI).\nKai tu įvedi komandą, pvz., ls, kaip Shell žino, kokią programą paleisti? Shell negali peržiūrėti visų tavo failų ieškodama programos ls - tai būtų neefektyvu ir užtruktų labai ilgai. Vietoje to, Bash naudoja aplinkos kintamąjį, vadinamą PATH, kuris yra saugomas visų direktorijų sąrašas, kurias Bash tikrina ieškodama vykdomųjų programų.\nKai tu įvedi ls, Bash tikrina šias direktorijas pagal eiliškumą:\n/usr/local/sbin\n/usr/local/bin\n/usr/sbin\n/usr/bin\n/sbin\n/bin\n/usr/games\n/usr/local/games\n/snap/bin\nŠis tikrinimo procesas vyksta taip: jei programa nerandama pirmojoje direktorijoje, tikrinama kita iš eilės, kol galiausiai programa randama. Jei programa nerandama visame PATH sąraše, terminalas išveda pranešimą, kuris gali siūlyti šią programą įdiegti.\nRetais atvejais tau gali reikėti pridėti naujų direktorijų prie PATH kintamojo, tačiau tai yra pažangesnė tema, ir pradedančiajam Linux naudotojui dažniausiai to nereikės. Dabar žinai, kaip Bash naudoja PATH norėdama greitai surasti ir paleisti programas.\nNori sužinoti kaip atrodo tavo PATH? Pabandyk:\necho $PATH",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failo-teisių-valdymas",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#failo-teisių-valdymas",
    "title": "7  BASH pažengusiems",
    "section": "7.6 Failo teisių valdymas",
    "text": "7.6 Failo teisių valdymas\nAnkstesniame skyriuje tu jau susipažinai su tuo, kad kiekvienas failas ir direktorija turi nustatytą savininką. Taip pat nurodomos savininko, jo grupės ir kitų vartotojų teisės. Šiame skyriuje išmoksi, kaip keisti šias teises ir atlikti kitus su failų savininkais susijusius veiksmus.\n\n7.6.1 Failo Teisių Struktūra\nFailų teises galima pamatyti, naudojant ls -l komandą, kuri išveda informaciją apie failus, įskaitant jų teises:\ndrwxrwxr-x 4 justas justas 4096 Sep 27 18:28 backup\ndrwxrwxr-x 2 justas justas 4096 Sep 28 18:45 data\n-rw-rw-r-- 1 justas justas   45 Sep 28 16:28 list_du_home.sh\n-rw-rw-r-- 1 justas justas  635 Sep 28 13:33 list.txt\ndrwxrwxr-x 2 justas justas 4096 Sep 27 21:42 mix\ndrwxrwxr-x 2 justas justas 4096 Sep 28 18:34 text\nKiekviena eilutė parodo failo teises:\n\nr - skaitymo teisė\nw - rašymo teisė\nx - vykdymo teisė\n- - nėra teisių\n\nPirmoji tripleto grupė priklauso savininkui, antroji - grupei, trečioji - kitiems vartotojams. Suprantama pirmas ženklas (d, -, l) indikuoja ar tai direktorija, failas ar nuoroda.\n\n\n7.6.2 Keisti Failo Teises su chmod\nchmod komanda leidžia keisti failo teises. Naudojami du būdai - skaitmeninis ir simbolinis.\nSkaitmeninis Būdas\nKiekvienai teisei priskiriama skaitinė reikšmė:\n\n4 - skaityti (read)\n2 - rašyti (write)\n1 - vykdyti (execute)\n0 - jokių teisių (-)\n\nNorint nustatyti teises, skaičiuoji reikšmes, pvz:\n\nVartotojui (user): skaityti, rašyti, vykdyti (4+2+1 = 7)\nGrupei (group): skaityti, vykdyti (4+0+1 = 5)\nKitiems: skaityti (4+0+0 = 4)\n\nPavyzdys, kaip nustatyti teises su chmod:\nchmod 754 failas.txt\nŠios komandos rezultatas - user gali skaityti, rašyti, vykdyti; grupė gali tik skaityti ir vykdyti, o kiti tik skaityti.\nSimbolinis Būdas\nSimboliniame būde naudoji raides ir simbolius:\n\nu: savininkas (user)\ng: grupė (group)\no: kiti (others)\na: visi (all)\n+: pridėti teisę\n-: pašalinti teisę\n=: nustatyti tikslias teises\n\nŠi komanda prideda vykdymo teisę savininkui.\nchmod u+x failas.txt\n\n\n7.6.3 Keisti Savininką su chown ir Grupę su chgrp\nNors dažniausiai šių komandų nereikia naudoti, mokėti jomis naudotis gali būti naudinga:\n\nchown &lt;user&gt; &lt;file&gt; - keičia failo savininką.\nchgrp &lt;group&gt; &lt;file&gt; - keičia failo grupę.\nchown &lt;user&gt;:&lt;group&gt; &lt;file&gt;- keičia tiek savininką, tiek grupę.\nchown -R &lt;user&gt;:&lt;group&gt; &lt;directory&gt; - keičia visų failų nurodytoje direktorijoje savininką ir grupę rekursyviai.\n\nSvarbu: Jei keiti sisteminių failų savininką ar grupę, gali prireikti administratoriaus teisių (sudo).\n\n\n7.6.4 Kada Reikia Keisti Teises?\nYra kelios situacijos, kai gali reikėti keisti failo teises:\nSkriptų Paleidimas \nJei sukuri skriptą, pavyzdžiui, senu_video_valymas.sh, ir nori jį paleisti, gali reikėti suteikti sau vykdymo teisės:\nchmod 744 senu_video_valymas.sheet\nFailas tapęs skriptu pakeičia spalvą į žalią.\n\nAppImage Programų Paleidimas \nAppImage yra programa, patalpinta viename faile. Parsisiuntus AppImage gali pamatyti, kad jis neturi vykdymo teisių.\nNors tu tiktėtina jau turi Freetube, nueik į https://freetubeapp.io/#download ir paspausk ant AppImage, kad jį atsisiųsti.\n\nkaip matai, failas neturi executbale teisių.\n.\nNorint paleisti failą, reiktų susirasti failą per failų naršyklę, o tada pasirenkant “Properties” &gt; “Permissions” ir pažymėti “Allow executing file as program”.\n\nArba sutieki tokias pat teises su chmod naudojant terminalą:\nchmod 774 freetube_0.22.0_amd64.AppImage",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#procesų-valdymas",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#procesų-valdymas",
    "title": "7  BASH pažengusiems",
    "section": "7.7 Procesų Valdymas",
    "text": "7.7 Procesų Valdymas\nNorint efektyviai valdyti kompiuterio išteklius, svarbu suprasti, kokie procesai veikia tavo sistemoje. Tai ypač svarbu sistemų administravime ir duomenų analitikoje. Šiame skyriuje susipažinsi su pagrindinėmis komandomis, kurios padės tau stebėti veikiančius procesus ir identifikuoti galimas problemas.\n\n7.7.1 ps - Procesų Sąrašas\nps komanda leidžia pamatyti veikiančių procesų sąrašą statiniu vaizdu. Tai reiškia, kad ji parodo procesų būseną tam tikru momentu. Ši komanda ypač naudinga, kai reikia sužinoti, kas vyksta tavo sistemoje, arba rasti konkretaus proceso informaciją. Pagrindinės ps subkomandos:\n\na: Parodo visus procesus su terminalais.\nu: Parodo procesus su vartotojo lygio informacija.\nx: Parodo procesus, neprisirišusius prie terminalo.\n\nKą Parodo ps Išvestis?\n\nUSER: Kas paleido procesą (pvz., justas, root).\nPID: Proceso identifikatorius - unikalus skaičius, skirtas kiekvienam procesui.\n%CPU: Kiek procesoriaus resursų naudoja procesas.\n%MEM: Kiek RAM atminties naudoja procesas.\nCOMMAND: Proceso paleidimo komanda (pvz., python analysis.py).\n\n\n7.7.1.1 Tipiniai Scenarijai\nIeškoti Konkretaus Proceso\nJei dirbi su dideliu Python skriptu, kuris užstringa, ir tau reikia jį sustabdyti:\nps aux | grep python\nŠi komanda parodys visus procesus, susijusius su python. Suradus proceso PID, jį gali sustabdyti su komanda kill:\nkill PID_numeris\n\n\n\n7.7.2 kill komanda\nkill komanda naudojama procesui sustabdyti arba nutraukti siunčiant jam signalą. Signalai yra mechanizmas, leidžiantis programuotojams siųsti instrukcijas procesams apie tai, kaip elgtis. Signalai gali būti siunčiami įvairiais būdais, siekiant subtiliai sustabdyti procesą arba jį prievarta nutraukti.\n\nPagrindinė sintaksė: kill [option] &lt;PID&gt;, kur  yra proceso identifikatorius.\nSignalai: Kiekvienas signalas turi numerį ir pavadinimą.Dažniausiai naudojami signalai yra:\nSIGTERM (15): Mandagus proceso prašymas nutraukti darbą. Procesui suteikiama galimybė uždaryti atviras bylas ir atlikti kitus būtinus uždarymo veiksmus.\n\nkill -15 &lt;PID&gt;\n\nSIGKILL (9): Prievartinis proceso nutraukimas be galimybės atlikti uždarymo veiksmus. Procesas sustabdomas iš karto.\n\nkill -9 &lt;PID&gt;\n\n\nRūšiuoti Pagal Procesoriaus Naudojimą\nJei kompiuteris veikia lėtai, gali išsiaiškinti, kuris procesas labiausiai apkrauna CPU:\nps aux --sort=-%cpu | head\nAtminties Naudojimo Analizė\nJei RAM greitai užsipildo analizuojant didelius duomenis:\nps aux --sort=-%mem | head\n\n\n7.7.3 top\nKomanda top parodo visus aktyvius procesus dinaminėje aplinkoje, pateikiant bazinę sistemos informaciją. top yra įdiegta beveik visuose Linux distribucijose, tačiau jos sąsaja nėra itin vizualiai patraukli.\n\n\n7.7.4 htop\nhtop yra interaktyvus įrankis, skirtas stebėti procesus realiu laiku. Jis suteikia spalvotą, aiškią sąsają, leidžiančią filtruoti, rūšiuoti ir valdyti procesus tiesiogiai.\nPagrindinės Funkcijos\n\nPaleidimas: Įvesk htop terminale.\nRodo procesus pagal resursų naudojimą: Leidžia matyti, kurie procesai suvartoja daugiausiai resursų.\nLeidžia sustabdyti procesus: Gali nutraukti procesus neišeidamas iš sąsajos.\nDinamiškai atnaujina informaciją.\n\nValdymas htop Viduje\n\nRodyklių Klavišai: Naršymui tarp procesų.\nF3: Ieškoti proceso pagal pavadinimą (pvz., python).\nF9: Užbaigti pasirinktą procesą (kill).\nF10: Išeiti iš htop.\n\nTipiniai Scenarijai:\nSurasti Procesą, Kuris Apkrauna CPU\nDirbant su dideliais duomenų failais, htop padeda pamatyti, ar tavo skriptas naudoja per daug CPU. Ieškok proceso, rūšiuok paspaudžiant p.\nValdyti Strigusį Procesą\nJei R arba Python procesas užstringa, rask jį naudojant htop, pasirink rodyklėmis ir paspausk F9.\nAtminties Stebėjimas Realiu Laiku\nVykdant sudėtingus skaičiavimus (pvz., mokant mašininio mokymosi modelį), stebėti atminties naudojimą. Jei procesas per daug apkrauna sistemą, gali jį sustabdyti.\nŠios komandos suteikia reikalingus įrankius efektyviai valdyti procesus, stebėti išteklių naudojimą ir spręsti problemas, susijusias su kompiuterių našumu.\n\n\n\n\n\n\nPraktika\n\n\n\n\nSurastk ir nutrauk procesą su ps aux ir kill\n\nPaleisk procesą miegoti: sleep 600. Ši komanda leis terminalui “miegoti” 600 sekundžių.\nAtidaryk kitą terminalo langą ir surask šį procesą, naudojant ps aux | grep sleep. Tada nusiųsk kill -9 &lt;PID&gt;, kur  yra proceso ID, kurį rasi prieš tai atliktoje komandoje.\nPasitikrink ar proceso nebėra.\n\nSurastk ir nutrauk procesą su htop\n\nPaleisk procesą miegoti: sleep 600.\nPaleisk htop terminalo kitame lange. Surask sleep procesą sąraše.\nNaudojant rodyklių klavišus pasirink procesą ir nutrauk jį paspausdus F9, tada pasirink 9 (SIGKILL), kad prievarta nutrauktum procesą.\nPasitikrink ar proceso nebėra.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#nano",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#nano",
    "title": "7  BASH pažengusiems",
    "section": "7.8 nano",
    "text": "7.8 nano\nnano yra patogus teksto redaktorius, skirtas tiek pradedantiesiems, tiek pažengusiems Linux naudotojams.\n\nAtidaryti esamą arba sukurti naują failą:\n\nnano &lt;failas&gt;\nJei failas egzistuoja, jis bus atidarytas redagavimui. Jei failo nėra, jį išsaugant bus sukurtas naujas failas.\n\nRedaguoti sisteminius failus su administracinėmis teisėmis:\n\nsudo nano &lt;failas&gt;\nJeigu paleisi nano be failo, jis sukurs naują buferį. Gali pradėti rašyti tekstą iš karto. Naudok rodyklių klavišus, kad judėtum tekste.Išsaugant, bus sukurtas failas tuo pavadinimu, kurį nurodysi.\nKeli naudingi flagai:\n\nRodyti žymeklio padėtį nano -c &lt;failas&gt;\nKurti atsarginę kopiją prieš išsaugant: nano -B &lt;failas&gt;\nĮjungti pelės palaikymą: nano -m &lt;failas&gt;\nRodyti eilutes: nano -l &lt;failas&gt;\n\nPagrindinės Redagavimo Komandos\n\nIšsaugoti ir Uždaryti\n\nIšsaugoti pakeitimus: Ctrl + O (paspausk Enter, kad patvirtintum).\nIšeiti iš nano:Ctrl + X.\n\nTeksto Redagavimas\n\nIeškoti teksto: Ctrl + W.\nIškirpti teksto eilutę: Ctrl + K.\nĮklijuoti iškirptą tekstą: Ctrl + U.\n\nNavigacija\n\nPereiti į eilutės pradžią: Ctrl + A.\nPereiti į eilutės pabaigą: Ctrl + E.\nSlinkti aukštyn: Ctrl + Y.\nSlinkti žemyn: Ctrl + V.\n\n\n\n\n\n\n\n\nPraktika\n\n\n\n7.8.1 Praktikos Uždaviniai su nano\n\nSukurti ir Redaguoti Tekstinį Failą\n\nSukurk ir atidaryk failą mano_uzrasai.txt:\nĮrašyk tekstą: “Sveiki atvykę į Linux mokymus!”, išsaugok su Ctrl + O, ir išeik su Ctrl + X.\nVėl atidaryk failą, pridėk tekstą: “Šiandien mokysimės nano redaktoriaus.”, išsaugok ir išeik.\nAtspausdink failo turinį su cat\n\nRedaguoti Esamą Failą su Administratoriaus Teisėmis\n\nAtidaryk /etc/hosts su sudo:\nPridėk komentarą “# Redagavimas tekste” viršuje, išsaugok ir išeik.\nAtspausdink failo turinį su cat (jokio redagavimo, tad sudo nereikia):\nVėl atidaryk failą su sudo ir ištrink įrašytą komentarą, išsaugok ir išeik:",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#alias",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#alias",
    "title": "7  BASH pažengusiems",
    "section": "7.9 Alias",
    "text": "7.9 Alias\nUžbaikime šį skyrių pasitelkę nedidelį “programavimą”. Nors tai dar nėra pilnai skriptų rašymas, tačiau toks metodas padės palengvinti kasdienį darbą terminale, sukuriant trumpinius dažnai naudojamoms komandoms. Trumpniai vadinamai alias.\n\nTu išmokai ieškoti didelių video failų ir tavo komanda atrodė taip:\nfind ~/Downloads/ ~/dwhelper/ -type f -iname \"*.mp4\" -size +100M -atime +14\nJei tau reikėtų šią komandą įrašyti kaskart, tai užimtų daug laiko. Nors automatinis skriptų paleidimas, pvz., kompiuterio įjungimo metu, yra sprendimas, tačiau paprastesnis būdas yra sukurti alias - tai leidžia greitai paleisti ilgas komandas, naudojant trumpinius.\nAlias Apibrėžimas\nNorint sukurti alias, turi redaguoti savo namų direktorijoje esantį .bashrc failą. Štai kaip tai padaryti:\n\nAtidaryk .bashrc failą: nano ~/.bashrc\nFailo pabaigoje pridėk naują alias naudojant šią sintaksę:\n\nalias alias_name='command'\nPavyzdžiui, sukurk alias komandai, kuri ieško didelių video failų:\nalias lnuf='find ~/Downloads/ ~/dwhelper/ -type f -iname \"*.mp4\" -size +100M -atime +14'\n\nIšsaugok ir išeik iš redaktoriaus (naudok Ctrl + O, Enter, Ctrl + X).\n\nAlias Paleidimas\nJei dabar terminale įrašysi lnuf, gali pastebėti, kad terminalas nesupranta šios komandos. Taip yra todėl, kad .bashrc failo pakeitimai dar nėra užkrauti į aktyvią terminalo sesiją. Štai ką padaryk:\n\nAtnaujink Bash Shell nustatymus: Naudok source komandą, kad iš naujo užkrautum .bashrc nustatymus, neperkraunant visos terminalo programos.\n\nsource ~/.bashrc\nDabar tu gali tiesiog naudoti komandą lnuf, kad paleistum visą ilgąją komandą.\nAlias leidžia greitai ir efektyviai valdyti kasdieninių užduočių komandas, sutaupant laiko ir pastangų. Tai nedidelis, bet labai naudingas “programavimo” elementas, kurį gali pritaikyti įvairiose situacijose, norint optimizuoti savo darbo eigą terminale.\nJeigu pastebėsi, kad tam tikro alias nebereikia - visada gali jį ištrinti ir atnaujinus perkrauk bash panaudojant source ~/.bashrc",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/7_bash_comands_advanced_1.html#projektai",
    "href": "b_bash_pagrindai/7_bash_comands_advanced_1.html#projektai",
    "title": "7  BASH pažengusiems",
    "section": "7.10 Projektai",
    "text": "7.10 Projektai\n\n7.10.1 Projektas 1: Orų prognozė Terminal lange\nSveikinu tapus junior software developer’e nedidelėje kompanijoje, kuri specializuojasi kurdama bash skriptus Linux vartotojams. Paprastai tokia kompanija dirba su įvairiais projektais, kuriuose reikia kūrybingumo ir techninių įgūdžių.\n\nTavo komandos produkto vadovas (product manager - PM) pasidalino pastebėjimu:\n\n„Mūsų klientai dažnai peršąla, nes išeina nepažiūrėję, kokia temperatūra lauke. Jie taip įnykę į savo terminalus, kad aplinkinio pasaulio nemato.“\n\n\n\n“Ar galėtum sukurti programą, kuri terminale rodytų artimiausių 12 valandų orų prognozę?“.\n\nPM’as tau pateikė idėjų eskizą, o tavo užduotis - sukurti pirmąją programos versiją, vadinamą MVP (Minimum Viable Product). Kaip dažnai nutinka programuotojų darbe, pagrindinė tavo užduotis yra paversti idėjas į veikiančius sprendimus, naudojant technologijas ir kūrybingumą.\n\n\nProjekto Pradžia\nPradėk nuo projekto aplanko sukūrimo, kad galėtum patogiai struktūrizuoti savo darbą. Tai padės išlaikyti tvarką, kadangi, kaip žinome, programuotojai linkę eksperimentuoti ir generuoti daugybę tarpinio kodo.\nKeli patarimai:\n\nDocuments direktorioje susikurk direktoriją projektai, o joje šį projektą, pvz., terminal_weather_display ir dirbk joje.\ntavo projekto tikslas bus turėti lazdynai_temp.sh failą, kurį paleidus gausi norimą rezultatą, tad sukurk šį failą ir pvz., su Sublime editorium atsidaryk jį ir rašyk ten komandas kurias darai. Kartu ten bus lengviau išsisaugoti ilgas komandas ir jas edituoti.\n\nKeliauk į Lietuvos hidrometeorologijos tarnybos svetainę (https://www.meteo.lt/), kur gali rasti API dokumentaciją. Labai ramiai perskaityk pradžią, paanilizuok kuo skiriasi:\n\nOrų prognozės\nMeterologiniai stebėjimai\nHidrologiniai stebėjimai\n\nIdentifikuok kurią iš API turėsi naudoti:\n\nhttps://api.meteo.lt/v1/places\nhttps://api.meteo.lt/v1/stations\nhttps://api.meteo.lt/v1/hydro-stations\n\nTada ramiai išstudijuok reikiamos API dokumentaciją. Eksperimentuok ir išbandyk. Prisimink kaip dirbai su API ankstesniuose skyriuose, kur parsisiuntinėjai duomenis iš https://data.gov.lt/.\nPirmiausia, sukurk užklausą, kuri atsiųs visas galimas vietoves. Atsispausdink pirmąją vietovę, kad suprastum, kaip yra struktūrizuoti duomenys. Tai yra svarbus žingsnis, kai dirbi su naujais duomenimis arba API - suprasti jų struktūrą ir galimybes.\n\n\n\nDuomenų Apdorojimas\nKadangi tave domina tik Lietuvos vietovės, reikės filtruoti duomenis. Naudok JSON apdorojimo įrankius, kaip jq, susiaurink duomenų masyvą tik į Lietuvą ir išsaugok rezultatus kaip TSV failą su vietovių pavadinimais bei kodais, pavadintą lt_places.tsv. Kiek iš viso yra vietovių, kurių pavadinimas prasideda „Viln“? Suradus atsakymą, nusprendei savo MVP naudoti Vilniaus rajoną Lazdynus. Sužinok, koks yra šios vietovės kodas, nes jis bus būtinas tolimesniam darbui su API.\n\n\n\nOrų Prognozės Gavimo Procesas\nGrįžk prie API dokumentacijos ir sužinok, kaip parašyti užklausą orų prognozei gauti. Parsisiųsk duomenis ir išsaugok juos kaip data_forecast.json. Naudojant JSON apdorojimo įrankius, atspausdink prognozę gražiu JSON formatu ir pasirink tinkamą masyvą bei submasyvus, kurie pateiks reikalingą informaciją apie orą. Išrink šiuos elementus: .forecastTimeUtc, .airTemperature, .conditionCode, ir suformatuok juos kaip CSV failą, pavadindamu filtered_data_forecast.csv.\n\n\n\nEstetiniai Pataisymai\nKad galutinis produktas būtų vizualiai patrauklus, naudok įrankius kaip column išlyginimui. Jei dar nežinai šios komandos - gali pasinaudoti ChatGPT ar kitais šaltiniais, kad sužinotum, kaip ji veikia. Tavo pristatomas failas vadinsis final_output.\n\nPM pamatęs tavo MVP, tiesiog negalėjo sulaikyti džiaugsmo:\n\nJis paprašė pakeisti terminą „Debesuotumas“ į „Oro sąlygos“ ir pridėti emodžius, kad išvestis būtų žaismingesnė. Tu nusprendei grįžti į API puslapį ieškoti visų galimų orų sąlygų ir paprašyti ChatGPT sukurti sed komandas, kurios pakeis orų sąlygas emodžiais. Galiausiai, produktą pristatei vadovui:\n\nIr PM’as buvo sužavėtas:\n\nDabar tau beliko sudėti visas komandas į vieną skriptą, kuris veiktų tik atmintyje, nesukuriant fizinių failų. Stenkis jungti kuo daugiau su pipes |. Gali būti kad su kokiu sublime-text editoriumi tau dirbti būtų papraščiau. Nors ne terminalo lange, o papildoma programa, bet ji palengvins darbą.\nIšsaugok skriptą kaip lazdynai_temp.sh, patikrink failo teises, suteik vykdymo leidimą ir paleisk skriptą, kad įsitikintum, ar jis generuoja atitinkamą prognozę.\nSkriptą paleisti gali su ./lazdynai_temp.sh\nTai yra ne tik naudinga programa, bet ir puikus pavyzdys, kaip kūrybingas programuotojas gali prisidėti prie kasdienio gyvenimo patogumo!\nSkyriuose apie bash skriptų rašymą išmoksi naudotis bash logika, užduoti klausimus vartotojams ir pritaikyti šio skripto logiką priklausomai nuo gautų atsakymų.\np.S. metei.lt tinklpayje prie API dokumentacijos yra aprašyta licenzija. Kokia ji būtent? Susipažink su CC licenzijomis https://creativecommons.org/. Ir atsakyk į šiuos klausimus:\n\nar tavo įmonė gali naudoti šiuos duomenis kuriant komercinius produktus?\nar sukūrus produktą, tu turi nurodyti, kas yra duomenų šalintinis?\nar tu gali pakeisti licenciją į kitokią? ką tai reiškia šiam produktui?\n\n\ndata.gov.lt\n\n\n\n7.10.2 Projektas 2 Šeškinės poliklinos radiologiniai tyrimai\n\n\n\nmoira.lt\n\n\nBuvo gražus rytas, kai Šeškinės poliklinikos CTO, Ruprechtas, sukruto spręsti svarbių klausimų. Poliklinika buvo užimta kaip niekada, o radiologinių tyrimų kiekis augo kasdien. Ruprechtas žinojo, kad norint užtikrinti sklandų poliklinikos darbą, reikia rasti būdą, kaip efektyviai stebėti ir analizuoti šiuos tyrimus. Tad kreipėsi į “Linux consulting UAB” pagalbos.\n\n\n\nDall-E\n\n\nJustina,produktų vadovė (PM) turėjo viziją, kaip automatizuoti kasdienines ataskaitas, ir nedelsiant susitiko su tavimi suderinti darbo eigos.\n\n„Klausyk, mums reikia, kad kasdien būtų pateikiama ataskaita apie atliktus tyrimus pagal kūno dalis,“ - sako Justina, tvirtai traukdama tave į projektą. „Reikia panaudoti duomenis iš data.gov.lt. Galėsi tai padaryti?“\n\nTu žvilgtelėjai į pateiktą informaciją ir iš karto susidėliojai galvoje planą.\n\n„Taip, Justina, aš tuo pasirūpinsiu. Bus įdomus projektas.“\n\nPasiruošei kibti į darbus, žinant, kad šis projektas padės poliklinikai ne tik optimizuoti kasdienius procesus, bet ir pagerinti ligonių priežiūrą. Be to šis projektas - puiki galimybė parodyti savo sugebėjimus ir prisidėti prie Ruprecht’o naujovių poliklinikoje.\n\n\n\nDall-E\n\n\n\n\nDuomenų šaltinis: data.gov.lt\nDuomenų struktūra:\n\n\n\n\n\n\n\n\n\nKodas\nReikšmė\nFormatas\n\n\n\n\nvda_id\nValstybės Duomenų Agentūros įrašo identifikatorius\nstring\n\n\npaciento_asm_k\nNuasmenintas paciento asmens kodas\nstring\n\n\ntyrimo_studijos_uuid\nTyrimo studijos identifikatorius\nstring\n\n\ntyrimo_studijos_data\nTyrimo studijos data\ndate (ref: D)\n\n\npaciento_gimimo_metai\nPaciento gimimo metai\ndate (ref: Y)\n\n\npaciento_lytis\nPaciento lytis\nstring\n\n\npaciento_svoris\nPaciento kūno svoris kilogramais\nnumber (ref: kg)\n\n\npaciento_ugis\nPaciento ūgis metrais\nnumber (ref: m)\n\n\ntyrimo_serijos_uuid\nTyrimo serijos identifikatorius\nstring\n\n\ntirta_kuno_dalis\nTirta kūno dalis\nstring\n\n\ntyrimo_serijos_modalumas\nTyrimo serijos modalumas\nstring\n\n\ntyrimo_serijos_aprasymas\nTyrimo serijos aprašymas\nstring\n\n\natvaizdo_uuid\nAtvaizdo unikalus identifikatorius\nstring\n\n\napsvita\nApšvita arksekundėmis\nnumber (ref: ″)\n\n\nspinduliuote\nSpinduliuotė decigrėjais kvadratiniame centimetre\nnumber (ref: dGy/cm²)\n\n\nfotometrine_interpretacija\nFotometrinė interpretacija\nstring\n\n\n\n\nTiskslas: Galėti kasdien Terminale gauti naujausius duomenis apie altiktų radiologinių tyrimų skaičių pagal kūno vietos.\n\n\nSprendimo gairės\nŠie klausimai ir žingsniai padės tau sėkmingai atlikti užduotį. Nepamiršk, kad tai tik orientyrai, tad skirk laiko ir savarankiškai gilinkis į temą.\n\n\nGilinkis į data.gov.lt\n\nAPI pasirinkimai:\n\nEik į API puslapį ir ištyrinėk getall, getone, changes.\nSuprask, kaip kiekvienas variantas keičia JSON struktūrą. Apmastyk, ką jie kiekvienas reiškia tau ir ar ir kaip gali būti pritaikomi tavo projekte.\n\nDuomenų Filtravimas:\n\nEik į „Duomenys“ lapą ir panaudok filtrą (select(*)).\nPasirink keletą tau reikalingų stulpelių ir pažiūrėk, kaip tai paveikia užklausas\nPatikrink, kaip pasikeičia URL struktūra, kai pasirenki konkretų filtrą.\n\nDuomenų tyrinėjimas ir analizė:\n\nNaudok galimybę rūšiuoti ir filtruoti lentelės duomenis „Duomenys“ lape\nAtsakyk sau į šiuos klausimus:\n\nKokia yra seniausia ir naujausia tyrimų data?\nAr yra tuščių reikšmių?\nAr yra skirtumas parsiuntimo greityje, priklausomai nuo mano padarytų pasirinkimų?\n\nUžbaigus filtravimą, grįžk į API lapą ir analizuok, kaip keitėsi užklausa.\nNaudok tekstinį redaktorių pvz. Sublime, kad galėtum geriau pamatyti URL tvarką ir surpasti sistemą.\n\n\n\n\nProgramavimo etapas\n\nSukurk projekto direktoriją\nSukurk README.md failą, kuriame aprašyk projekto informaciją ir tikslus.\nSukurk skriptą recent_radiological_seskines_pol.sh:\n\nSkriptas turi atsisiųsti duomenis JSON formatu.\nPasirinkti reikalingus stulpelius: Tyrimo studijos data ir Tirta kūno dalis\nFiltruoti duomenis pagal nustatytą datą, pvz., 2024-11-28. arba datos intervalą\nSuskaičiuoti tyrimų skaičių pagal kūno dalis.\nSuplokštinti duomenis į TSV formatą.\n\n\nPastaba: Kol dirbi su sintakse ir lygiavimu, sukurk laikinus failus, kad galėtum pamatyti, kur yra tabai ar tarpai. Tai padės teisingai supaprastinti duomenų apdorojimą ir išvengti klaidų. Vėliau tuos failus ištrinsi.\n\n\nMVP vertinimas\nDienos pabaigoje, kai PM Justina grįžta, tu su nerimu ir pasididžiavimu parodai savo atliktą darbą. Justina, garsėjanti savo atidumu detalėms ir griežtumu, kritiškai apžvelgia rodmenis. Laikui bėgant, jos veide atsiranda šypsena.\n\n„Puiku, man labai patinka, ką padarei“, - pagiria ji, nuleisdamažiūrėjusi į tavo kruopščiai parengtą rezultatą. „Tačiau, žinodama Ruprechtą, norėčiau, kad galėtume į projektą įtraukti daugiau aiškumo ir paprastumo. Gal gali parengti:\n\n\n\nIšsami README.md failo versiją: Aprašyk jame kiekvieną projekto dalį - nuo duomenų gavimo iki galutinio rezultato pateikimo. Būtų puiku, jei įtrauktum ir pastebėtas prielaidas bei pasiūlymus tobulinimui.\n\n\n\n\nVienos eilutės komandą (Oneliner): Tokio tipo komanda turėtų tiesiog terminale pateikti vienos pasirinktos dienos rezultatus, kad mūsų techninis personalas galėtų greitai ir patogiai gauti reikiamą informaciją.\n\n\n\n\nPilną skriptą: Jis turėtų būti išsamus, kad galėtų išgauti ir išfiltruoti duomenis už tam tikrą laikotarpį ir išsaugoti juos formatu, tinkamu atidaryti su libreoffice. Tai leis mūsų komandai lengvai tvarkytis su duomenimis ir rengti ataskaitas.“\n\n\n\n\nPratęsimas\nPamąstyk, kaip iš esamos darbo atlikimo strategijos sukurti: * Skriptą, kuris išsaugo duomenis, kuriuos galima atsidaryti su libreoffice –calc . * Vienos eilutės komandą, skirtą rezultatais naudotis terminale.\nDetaliai aprašyk atliktus veiksmus README.MD faile.\n\n\n\n\n\n\nPagalba\n\n\n\nKai mokeisi apie redirektorius &gt;, &gt;&gt;, buvo paminėtas ir atgalinis redirektorius &lt;. ChatGPT arba interneto pagalba išsiakink, ką daro ši komanda ir pagalvok, kaip jos sintaksę galėtum pritaikyti savo projekte.\necho \"labas rytas\" | cat - &lt;(echo \"labas vakaras\")\n\nką reiškia -?\nkodėl ir kam panaudojamas &lt;\n\n\n\n\n\n\n\n\n\n\nPagalbaL kaip alėtų atrodyti README.MD\n\n\n\n&lt;!-- --&gt; Žymi komentarus. Juos reiktų ištrintiir vietoj jų užpildyti tavo turiniu.\n# Šeškinės Poliklinikos Radiologinių Tyrimų Ataskaita\n\n## Projekto Aprašymas\n\n&lt;!-- Aprašykite pagrindinį projekto tikslą ir ką jis daro. Tai svarbu, kad skaitytojai suprastų, apie ką yra projektas. --&gt;\n\n## Pradžia\n\n### Reikalavimai\n\n&lt;!-- Išvardinkite būtiną programinę įrangą ir jų versijas. Tai padės užtikrinti, kad projektas veiks skirtinguose įrenginiuose. --&gt;\n\n### Diegimas\n\n&lt;!-- Aprašykite diegimo instrukcijas, kaip naudotojas gali klonuoti ir pradėti naudotis projektu. Aiškios instrukcijos padės vartotojams lengviau pradėti. --&gt;\n\n1. Klonuokite projektą:\n   `git clone &lt;repo-url&gt; && cd &lt;repo&gt;` \n\n## Naudojimas\n\n#### Vienos Eilutės Komanda\n\n&lt;!-- Įrašykite vienos eilutės komandos sintaksę. Ši dalis svarbi, kad vartotojai galėtų greitai išbandyti pagrindines funkcijas. --&gt;\n\n#### Pilnas Skriptas\n\n&lt;!-- Pateikite skripto sintaksę. Tai svarbu, kad būtų galima atlikti išsamesnę analizę ar duomenų tvarkymą. --&gt;\n\n## Struktūra\n\n&lt;!-- Aprašykite projekto failų struktūrą. Tai padės naudotojams geriau suprasti projekto organizaciją ir rasti reikiamus failus. --&gt;\n\n- `README.md`: Dokumentacija\n- `recent_radiological_seskines_pol.sh`: Skriptas\n\n## Prielaidos\n\n&lt;!-- Nurodykite visas prielaidas, kuriomis remiasi projektas. Tai svarbu, kad vartotojai žinotų, kas yra numatyta ir ką jie turi turėti ar atlikti prieš naudojant projektą. --&gt;\n\n## Tolesni Plėtros Tikslai\n\n&lt;!-- Apibūdinkite galimus ateities atnaujinimus ir plėtros kryptis. Tai gali įtraukti naujas funkcijas ar planuojamus patobulinimus. Padeda pateikti ilgalaikę projekto viziją. --&gt;\n\n## Papildomi Ištekliai\n\n&lt;!-- Pateikite nuorodas į papildomus išteklius, pavyzdžiui, naudojimo dokumentaciją ar technologijų, kurias naudavote, vadovus. Tai naudinga papildomai informacijai gauti. --&gt;\n\nDaugiau informacijos apie Markdown: [Markdown Guide](https://www.markdownguide.org/basic-syntax/)",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH pažengusiems</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html",
    "title": "8  BASH darbas su OS",
    "section": "",
    "text": "8.1 Aplinkos Kintamieji ir Jų Valdymas\nŽinoma, čia yra peržiūrėtas ir perrašytas poskyris, skirtas besimokančiam Linux vartotojui, pateikiant jį iš mokytojo perspektyvos:\nSveiki atvykę į Linux aplinkos kintamųjų pasaulį! Šiame skyriuje išmoksime, kaip aplinkos kintamieji padeda programoms ir procesams bendrauti Linux sistemoje. Suprasdami, kaip veikia kintamieji, galėsite efektyviau valdyti savo darbo aplinką, pritaikydami įvairias konfigūracijas ir automatizuodami užduotis. Tai yra būtini įgūdžiai tiek programuotojams, tiek sistemų administratoriams.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH darbas su OS</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#aplinkos-kintamieji-ir-jų-valdymas",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#aplinkos-kintamieji-ir-jų-valdymas",
    "title": "8  BASH darbas su OS",
    "section": "",
    "text": "8.1.1 Kas yra aplinkos kintamieji?\nAplinkos kintamieji yra pavadintos reikšmės, saugomos operacinėje sistemoje. Jie naudojami perduoti informaciją tarp skirtingų procesų. Kai kuriais atvejais jie nurodo, kaip programos turėtų veikti. Pavyzdžiui:\n\nPATH: nurodo katalogus, kuriuose shell ieško vykdomųjų failų.\nHOME: dabartinio vartotojo namų katalogas.\nUSER: prisijungusio vartotojo vardas.\n\n\n\n8.1.2 Kintamųjų kūrimas ir valdymas\n\n8.1.2.1 Sukurti lokalų kintamąjį\nGalite sukurti kintamąjį, kuris galioja tik dabartinėje shell sesijoje. Tai puikus būdas pernešti reikšmes nesukuriant ilgalaikių pakeitimų:\nMY_VAR=\"Hello, world!\"\n\n\n8.1.2.2 export: aplinkos kintamojo sukūrimas\nNorėdami, kad kintamasis būtų prieinamas visiems vaikiniams procesams, naudokite export. Tai leidžia perduoti reikšmes programoms, kurios vykdomos iš esamos sesijos:\nexport MY_VAR=\"Hello, world!\"\n\n\n\n8.1.3 Naudojimas programose\nNaudojant aplinkos kintamuosius, jų reikšmes galima lengvai pasiekti ir naudoti programose ar skriptuose:\necho $MY_VAR\n\n\n8.1.4 Peržiūrėti esamus kintamuosius\n\n8.1.4.1 env: visų kintamųjų peržiūra\nKomanda env leidžia peržiūrėti visus esamus aplinkos kintamuosius arba laikinai paleisti programą su tam tikrais kintamaisiais, suteikiant jums lankstumo ir kontrolės:\nenv\nenv MY_VAR=\"Temporary value\" python my_script.py\n\n\n8.1.4.2 printenv: specifinių kintamųjų rodymas\nprintenv komanda leidžia pamatyti specifinius kintamuosius. Tai naudinga, kai reikia greitai tikrinti, ar kintamieji nustatyti tinkamai:\nprintenv PATH\n\n\n\n8.1.5 Kintamųjų pašalinimas\n\n8.1.5.1 unset: kintamojo pašalinimas\nJei kintamasis nebereikalingas, galite jį pašalinti naudodami unset, taip išvalydami aplinką nuo nereikalingų reikšmių:\nunset MY_VAR\n\n\n\n8.1.6 Praktiniai naudojimo scenarijai\n\nAplinka ir konfigūracija: Aplinkos kintamieji leidžia nustatyti, kaip turėtų veikti jūsų programos - nuo sistemos kelio iki duomenų bazių prisijungimų.\nSkriptai ir automatizavimas: Kintamieji leidžia skriptams tapti lankstesniais ir pritaikomais, perduodant reikšmes tarp jų dalių.\nProblemos sprendimas: Naudodami env ir printenv, galite greitai rasti klaidų priežastis ir sužinoti, kokios reikšmės yra nustatytos.\n\nŽinoma, pateikiu peržiūrėtą ir reikšmingai papildytą poskyrį apie disko tvarkymą ir optimizavimą, pritaikytą besimokančiam Linux vartotojui, su pavyzdžiais ir skirtingais flagais.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH darbas su OS</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#disko-tvarkymas-ir-optimizavimas",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#disko-tvarkymas-ir-optimizavimas",
    "title": "8  BASH darbas su OS",
    "section": "8.2 Disko Tvarkymas ir Optimizavimas",
    "text": "8.2 Disko Tvarkymas ir Optimizavimas\nSveiki atvykę į skyriaus apie disko tvarkymą ir optimizavimą Linux sistemoje! Šiame poskyryje išmoksite, kaip naudoti įvairius įrankius, padedančius analizuoti ir optimizuoti disko vietos naudojimą. Disko vietos valdymas yra gyvybiškai svarbus, kad resursai būtų efektyviai naudojami ir sisteminė veikla nebūtų trikdoma dėl vietos trūkumo. Šios komandos dažnai naudojamos, kai reikia atlaisvinti vietą diske arba analizuoti, kurie katalogai užima daugiausia vietos.\n\n8.2.1 df\nKomanda df (disk free) leidžia peržiūrėti informaciją apie disko vietą visose prijungtose failų sistemose. Ji parodo, kiek vietos užimta, kiek laisvos vietos dar liko, ir kur yra prijungiamos direktorijos.\n\nNaudojimas:\ndf -h\n\n-h: Parodo dydžius žmogui suprantamais vienetais (pvz., GB, MB), kas padeda geriau suprasti disko vietos naudojimą.\n\nIšvesties pavyzdys:\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/sda1        50G   20G   30G  40% /\n/dev/sdb1       100G   80G   20G  80% /data\nPapildomi Flagai:\n\n-T: Rodo failų sistemos tipą (pvz., ext4, xfs).\n-i: Išveda informaciją apie inode, naudojama kai failų sistema susiduria su inodų stygiumi.\n\n\n\n\n8.2.2 du\nKomanda du (disk usage) padeda įvertinti, kiek vietos užima konkrečios direktorijos ir jų failai. Ji naudinga norint susekti, kurie failai ar katalogai naudoja daugiausia vietos.\n\nNaudojimas:\ndu -sh *\n\n-s: Išveda tik apibendrintą bendrą katalogo dydį.\n-h: Parodo dydžius žmogui suprantamais vienetais.\n\nIšvesties pavyzdys:\n2.1G    Movies\n1.4G    Music\n500M    Documents\nPapildomi Flagai:\n\n–max-depth=N: Rodo dydžius tik iki nurodyto katalogų gylio. Pvz., du --max-depth=1 /home/user parodys tik pirmo lygio katalogus.\n-c: Prideda bendrą dydžių suvestinę, naudinga norint pamatyti viso katalogo dydį.\n\n\n\n\n8.2.3 ncdu\nncdu (NCurses Disk Usage) yra interaktyvus disko vietos analizatorius, leidžiantis lengvai naršyti ir įvertinti, kurios direktorijos ar failai užima daugiausiai vietos. Tai puikus įrankis, norint vizualiai pamatyti ir valdyti disko naudojimą.\n\nNaudojimas:\nncdu /home/user\nLeidžia naršyti po katalogus interaktyvioje aplinkoje, kur galite matyti kiekvieno katalogo dydį ir lengvai naviguoti, kad rastumėte daugiausia vietos užimančius failus.\nPapildomi Patarimai:\n\nd: Ištrinti pasirinktą failą ar katalogą (būkite atsargūs!).\nq: Išeiti iš ncdu.\n\n\n\n\n8.2.4 Papildomos Naudojimo Scenarijai\n\nSistemos Priežiūra: Naudodamiesi df, galite greitai patikrinti, kiek vietos liko kiekviename diske, ir numatyti, kada reikės atlaisvinti vietos.\nDidelių Failų Identifikavimas: Naudodami du kartu su sort -h, galite surūšiuoti katalogus ir failus pagal dydį, lengviau identifikuodami, kurie failai reikalauja dėmesio.\nVizualinis Analizavimas: ncdu suteikia vizualų būdą naršyti po disko struktūrą ir iš karto pamatyti, kurie katalogai yra per dideli, o tai leidžia imtis veiksmų efektyviau.\n\nNaudodami šiuos įrankius, galėsite lengviau valdyti disko vietą ir užtikrinti, kad jūsų sistema veiktų sklandžiai ir efektyviai. Eksperimentuokite su šiomis komandomis, kad išmoktumėte optimizuoti disko naudojimą pagal savo poreikius!\nŽinoma, peržiūrėkime ir perrašykime visą poskyrį apie vartotojų ir grupių administravimą, įtraukiant papildomas komandas ir praktinius patarimus, kad besimokantis Linux vartotojas galėtų visapusiškai suprasti šią svarbią temą.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH darbas su OS</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#vartotojų-ir-grupių-administravimas",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#vartotojų-ir-grupių-administravimas",
    "title": "8  BASH darbas su OS",
    "section": "8.3 Vartotojų ir Grupių Administravimas",
    "text": "8.3 Vartotojų ir Grupių Administravimas\nVartotojų ir grupių administravimas yra esminė Linux sistemos dalis, leidžianti valdyti prieigą prie sistemos resursų bei užtikrinti saugumą. Ši tema apima komandų rinkinį, skirtą kurti, modifikuoti ir valdyti vartotojus bei grupes. Tai leidžia administratoriui užtikrinti, kad tinkami vartotojai turėtų reikiamas teises ir prieigą prie sistemos resursų. Šios komandos dažnai naudojamos diegiant naujas sistemas, konfigūruojant vartotojo aplinkas ar atliekant saugumo auditą.\n\n8.3.1 adduser\nKomanda adduser naudojama kurti naują vartotoją sistemoje. Ji automatiškai sukuria vartotojo namų katalogą ir leidžia nustatyti pradinius vartotojo parametrus, pvz., slaptažodį.\nPavyzdys:\nsudo adduser jonas\nTai sukurs naują vartotoją „jonas“ su namų katalogu /home/jonas.\n\n\n8.3.2 usermod\nusermod leidžia modifikuoti esamų vartotojų paskyras. Naudojama priskirti vartotojui naujas grupes, keisti jo slaptažodį ar atnaujinti vartotojo duomenis, tokius kaip namų katalogas ar login vardas.\nPapildomi Flagai: - -aG: Prideda vartotoją prie nurodytos grupės. bash   sudo usermod -aG sudo jonas - -d: Keičia vartotojo namų katalogą. bash   sudo usermod -d /home/newjonas jonas\n\n\n8.3.3 passwd\nKomanda passwd naudojama vartotojo slaptažodžio keitimui, užtikrinant saugią prieigą prie paskyros.\nPavyzdys:\nsudo passwd jonas\nTai leis jums pakeisti „jonas“ paskyros slaptažodį.\n\n\n8.3.4 userdel\nuserdel leidžia pašalinti vartotoją iš sistemos. Tai gali būti būtina, kai reikia panaikinti pasenusias paskyras.\nPavyzdys:\nsudo userdel jonas\n\n-r: Pašalina vartotoją ir jo namų katalogą.\nsudo userdel -r jonas\n\n\n\n8.3.5 groupadd\ngroupadd komanda leidžia kurti naujas grupes, kad vartotojai galėtų būti grupuojami pagal jų roles ar teises.\nPavyzdys:\nsudo groupadd developers\nSukuria naują grupę „developers“.\n\n\n8.3.6 groupdel\ngroupdel leidžia pašalinti grupę iš sistemos, kai jos nebereikia.\nPavyzdys:\nsudo groupdel developers\n\n\n8.3.7 chown\nKomanda chown skirta keisti failo ar katalogo savininką, užtikrinant tinkamą prieigą.\nPavyzdys:\nsudo chown jonas:developers /home/jonas/file.txt\n\n\n8.3.8 chmod\nchmod naudojama keisti failo ar katalogo teises, leidžiančias tiksliai kontroliuoti prieigą.\nPapildomi Flagai: - Simbolinis rėžimas: bash   chmod u+rwx,go-rwx file.txt - Skaitmeninis rėžimas: bash   chmod 755 file.txt\n\n\n8.3.9 Papildomos Komandos\n\nid: Parodo vartotojo ID, grupės ID ir papildomas grupes.\nid jonas\ngroups: Parodo grupių sąrašą, kurioms vartotojas priklauso.\ngroups jonas\n\n\n\n8.3.10 Praktiniai Pavyzdžiai ir Saugumo Praktikos\n\nVartotojų Auditas: Naudodami id ir groups, galite patikrinti, kam priklauso tam tikri vartotojai, kad užtikrintumėte tinkamą prieigą ir teises.\nSistemos Saugumas: Reguliariai peržiūrėkite vartotojų ir grupių sąrašus, kad išvengtumėte pasenusių paskyrų.\nAdministracinės Prieigos Valdymas: Naudokite adduser ir passwd, kad kasdien atnaujintumėte paskyras ir slaptažodžius.\n\nNaudodami šias komandas, galėsite veiksmingai administruoti vartotojus ir grupes, užtikrindami, kad jūsų Linux sistema būtų saugi ir efektyviai valdoma. Eksperimentuokite su šiomis komandomis, kad įgytumėte dar daugiau praktinės patirties!\nPuiku! Štai atnaujintas poskyris apie ugniasienės ir tinklo saugumo valdymą, įtraukiant papildomus paaiškinimus, pavyzdžius ir geriausias praktikas, pritaikytas besimokančiam Linux vartotojui.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH darbas su OS</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#ugniasienės-ir-tinklo-saugumo-valdymas",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#ugniasienės-ir-tinklo-saugumo-valdymas",
    "title": "8  BASH darbas su OS",
    "section": "8.4 Ugniasienės ir Tinklo Saugumo Valdymas",
    "text": "8.4 Ugniasienės ir Tinklo Saugumo Valdymas\nUgniasienė ir tinklo saugumo valdymas yra esminiai komponentai siekiant užtikrinti, kad jūsų Linux sistema būtų apsaugota nuo neteisėtos prieigos ir kenkėjiškų atakų. Ugniasienė veikia kaip filtras, kuris kontroliuoja srautą, leidžiamą į jūsų sistemą ir iš jos, blokuodamas nepageidaujamus ryšius. Šiame skyriuje išmoksime, kaip naudoti įvairius įrankius tinklo saugumui užtikrinti.\n\n8.4.1 Kas yra Ugniasienė?\nUgniasienė yra saugumo sistema, stebinti ir kontroliuojanti atvykstančius ir išvykstančius tinklo srautus pagal iš anksto nustatytas saugumo taisykles. Linux sistemoje dažniausiai naudojama programinė ugniasienė, tokia kaip ufw (Uncomplicated Firewall), kuri palengvina taisyklių konfigūravimą.\n\n\n8.4.2 ufw (Uncomplicated Firewall)\nufw yra paprastas įrankis, skirtas ugniasienės taisyklėms kurti ir valdyti. Jis leidžia lengvai leisti arba drausti srautą tam tikrais prievadais arba IP adresais.\n\nPagrindinės Komandos:\n\nĮjungti ugniasienę:\nsudo ufw enable\nIšjungti ugniasienę:\nsudo ufw disable\nLeisti srautą per konkretų prievadą (pvz., SSH prievadas 22):\nsudo ufw allow 22\nDrausti srautą per konkretų prievadą:\nsudo ufw deny 80\nPeržiūrėti visas ugniasienės taisykles:\nsudo ufw status\nPašalinti taisyklę pagal numerį:\nsudo ufw status numbered\nsudo ufw delete &lt;rule_number&gt;\n\nSvarbios Sąvokos:\n\nPrievadas (Port): Tai yra virtualus taškas, kuris leidžia skirtingoms aplikacijoms bendrauti per tinklą.\nTaisyklės Vykdymo Tvarka: ufw tvarko taisykles seka, leidžiančią arba blokuojančią srautą pagal pirmą atitiktį.\n\nPraktiniai Pavyzdžiai:\n\nLeisti tik vietiniam tinklui prisijungti prie serverio:\nsudo ufw allow from 192.168.1.0/24\nRiboti SSH ryšius, siekiant apsaugoti nuo „brute-force“ atakų:\nsudo ufw limit ssh\n\n\n\n\n8.4.3 netstat\nnetstat yra įrankis, naudojamas tinklo statistikos peržiūrai. Jis teikia informaciją apie tinklo ryšius, maršrutizavimo lenteles ir tinklo sąsajų būklę.\n\nNaudojimas:\n\nRodyti visas tinklo jungtis:\nnetstat -a\nRodyti tik veikiančias TCP jungtis:\nnetstat -at\nRodyti tinklo sąsajos statistiką:\nnetstat -i\n\n\n\n\n8.4.4 ss\nss yra modernus įrankis tinklo ryšių stebėsenai, pateikiantis detalesnę informaciją nei netstat.\n\nNaudojimas:\n\nRodyti visas TCP jungtis:\nss -t\nRodyti visas klausymosi (listening) jungtis:\nss -l\nRodyti visas UDP jungtis:\nss -u\n\nPrivalumai: ss gali būti greitesnis ir teikti išsamesnę informaciją apie tinklo ryšius.\n\n\n\n8.4.5 Tinklo Saugumo Geriausios Praktikos\n\nReguliarus Taisyklių Peržiūrėjimas: Nuolat peržiūrėkite ir atnaujinkite ugniasienės taisykles, kad išvengtumėte nesaugios prieigos.\nNuolatinis Tinklo Ryšių Stebėjimas: Naudokite netstat ir ss tinklo ryšių būklės stebėjimui ir diagnostikai, greitai aptikdami neįprastą veiklą.\nSaugumo Patikros: Pasirūpinkite, kad tik būtini prievadai būtų atidaryti ir prieinami iš išorės.\n\nŠios komandos ir praktikos suteiks jums reikiamus įrankius tinklo saugumui administruoti, leidžiančius efektyviai valdyti ir stebėti tinklo srautus bei apsaugoti savo Linux sistemą. Eksperimentuokite su šiomis komandomis ir pritaikykite geriausias praktikas, kad užtikrintumėte savo tinklo saugumą!\nŽinoma, išplėsiu poskyrį apie sistemines paslaugas ir automatizavimą, kad jis būtų išsamesnis ir labiau pritaikytas naujokams, naudodamas apache kaip pavyzdį.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH darbas su OS</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/8_bash_commands_advanced_2.html#sisteminės-paslaugos-ir-automatizavimas",
    "href": "b_bash_pagrindai/8_bash_commands_advanced_2.html#sisteminės-paslaugos-ir-automatizavimas",
    "title": "8  BASH darbas su OS",
    "section": "8.5 Sisteminės Paslaugos ir Automatizavimas",
    "text": "8.5 Sisteminės Paslaugos ir Automatizavimas\nLinux sistemų administravimas reikalauja efektyvaus paslaugų valdymo ir užduočių automatizavimo. Šios dvi sritys yra esminės, siekiant užtikrinti, kad sistemos veiktų patikimai ir efektyviai. Paslaugų valdymas leidžia užtikrinti, kad serveriai ir programos veiktų taip, kaip numatyta, o automatizavimas leidžia sutaupyti laiko pasikartojančioms užduotims atlikti.\n\n8.5.1 systemd ir systemctl\nsystemd yra naujausias ir plačiai naudojamas init sistema Linux sistemoje, kuri valdo paslaugų paleidimą, sustabdymą ir būklės tikrinimą. Ši sistema pakeitė senesnes init sistemas daugelyje šiuolaikinių distribucijų dėl savo lankstumo ir funkcionalumo.\nsystemctl yra pagrindinė komanda, naudojama sąveikai su systemd. Ji suteikia galimybę valdyti paslaugas, stebėti jų būklę ir konfigūruoti, kada ir kaip jos turėtų būti vykdomos.\n\n8.5.1.1 Pagrindinės systemctl Komandos\n\nPaleisti paslaugą: Naudojama paleisti nurodytą paslaugą. Tai dažnai daroma po paslaugos konfigūracijos pakeitimų.\nsudo systemctl start apache2\nSustabdyti paslaugą: Sustabdo veikiančią paslaugą. Tai naudinga, kai paslauga turi būti laikinai išjungta dėl priežiūros ar kitos priežasties.\nsudo systemctl stop apache2\nPerkrauti paslaugą: Atlieka paslaugos perkrovimą, kas gali būti būtina po konfigūracijos pakeitimų, kai paslauga turi atsinaujinti su naujais nustatymais.\nsudo systemctl restart apache2\nPatikrinti paslaugos būseną: Rodo dabartinę paslaugos būseną, įskaitant, ar ji veikia, ar yra sustabdyta, ir ar yra kokių nors klaidų ar įspėjimų.\nsudo systemctl status apache2\nĮjungti paslaugą automatiškai paleidžiant sistemą: Leidžia paslaugai automatiškai paleisti, kai sistema įjungta. Tai naudinga serveriams, kurie turi būti prieinami visada.\nsudo systemctl enable apache2\nIšjungti automatinį paslaugos paleidimą: Išjungia automatinį paslaugos paleidimą, pvz., jei paslauga nebereikalinga.\nsudo systemctl disable apache2\n\n\n\n8.5.1.2 Praktinis Pavyzdys\nKai sukonfigūruosite apache2 ir paleisite jį kaip paslaugą, galite pasiekti savo vietinį web serverį naršyklėje, įvedę http://localhost. Tai leis jums patikrinti, kaip veikia jūsų web serveris ir ar teisingai sukonfigūravote viską.\n\n\n\n8.5.2 Automatizavimas su cron ir at\nAutomatizavimas yra svarbus aspektas efektyviam Linux administravimui, nes jis leidžia automatizuoti kasdienes užduotis, užtikrinant, kad jos būtų atliktos laiku ir tiksliai.\n\n8.5.2.1 cron\ncron - tai paslauga, leidžianti planuoti reguliarias užduotis. Ji veikia kaip laikrodis, kuris laukia nustatyto laiko ir tada vykdo užduotį.\n\nCrontab Įrašų Redagavimas: Naudodami crontab redaguokite savo užduotis:\ncrontab -e\nCrontab Sintaksė: Sintaksė susideda iš penkių laukų, žyminčių laiką, ir užduoties, kurią reikia atlikti.\n* * * * * /komanda/kelias\nKur „*“ reiškia minutės, valandos, dienos, mėnesiai ir savaitės dienos. Tai leidžia atlikti užduotis konkrečiu metu.\nPavyzdys:\n\nKasdien 3:00 val. ryte vykdyti atsarginės kopijos skriptą:\n0 3 * * * /usr/local/bin/backup.sh\n\n\n\n\n8.5.2.2 at\nat leidžia planuoti vienkartines užduotis, kurios turi būti įvykdytos tam tikru laiku ateityje. Tai patogu, kai reikia atlikti vienkartinį veiksmą.\n\nPavyzdys:\necho \"/kelias/į/skriptą\" | at 14:00\nPeržiūrėti suplanuotas užduotis:\natq\n\n\n\n\n8.5.3 Logų ir Klaidos Tvarkymas\n\nPaslaugų Logų Stebėjimas: Naudokite journalctl, kad galėtumėte stebėti ir tikrinti paslaugų veikimą bei diagnozuoti problemas.\nsudo journalctl -u apache2\n\n\n\n8.5.4 Papildomi Įrankiai ir Geriausios Praktikos\n\nAnsible ir Kiti Įrankiai: Norint didesnio masto automatizacijos, galima naudotis įrankiais kaip Ansible, kurie padeda konfigūruoti ir valdyti daugybę sistemų vienu metu.\nSaugumo Praktikos: Užtikrinkite, kad prieiga prie crontab ir at būtų apribota, naudojant /etc/cron.allow ir /etc/cron.deny.\nReguliarus Planavimas ir Auditavimas: Nuolat peržiūrėkite ir optimizuokite savo automatizavimo užduotis ir paslaugų konfigūraciją, užtikrindami, kad jos būtų veiksmingos ir saugios.\n\nŠis skyrius padės jums valdyti sistemines paslaugas ir automatizuoti užduotis, suteikdamas reikiamus įrankius, kad jūsų Linux sistema veiktų sklandžiai ir efektyviai. Praktikuokite naudoti šias komandas ir geriausias praktikas, kad taptumėte tikru sistemų automatikos meistru!",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BASH darbas su OS</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html",
    "href": "b_bash_pagrindai/12_ssh.html",
    "title": "9  SSH",
    "section": "",
    "text": "9.1 Įvadas\nŠiame skyriuje tu išmoksi kelių labai svarbių dalykų. Pirma tu instlaiuosi Virtualbox ir guesteddions CD. Tai programa, kuri tau leis tavo kompiuteryje instlaituoti vieną ar kelis kitus kompiuterius. Tu galėtum teoriškai instlaiuoti net Windows as MacOs operacines sistemas, kurios būtų pilnavertiškai veikiančios iš tavo kompiuterio. Suprantama yra bet… Windows reikia licenzijos, ir tiek Windows tiek MacOs reikalauja gauna daug resursų.Tai reikia turėti omenyje. Ųiame skyriuje tu instaliuosi net 2 Ubuntu serverius ir vienu metus juos galėsi valdyti. Instaliavus ubuntu serverius tu suprantama galėsi matyti jų langus savo ekrane. Taip tu simuliuotum tarsi ekrano ir klaviatūros turėjimą serverinėje. Tačiau taip nevisada yra, dažniausiai reikia prie serverio prisijungti nuotoliniu būdų. Tam tu išmoksi naudotis labai svarbia programa - SSH (secure shell), kuri tau leis nepaliekant tavo kompiuterio terminal lango, sukurti ryši ir persikelti į serverį. Skyriaus pabaigoje, tu išmoksi naudotis ir TMUX, tai terminalo multiplexorius, kuris leidžia viename Terminalo lango turėti kelis terminalo langus. Tai tau padės efektyviau dirbti su visais serveriais. Papildomai tu išmoksi scp ir rsync komandas (programas), kurios leis tau siųsti duomenis tarp serverių.\nTraigi šio skyriaus planas:\nKą tau reikia prisiminti iš praėjusių skyrių:\nČia kaip SSH į VirtualBox, tik iškart geriau kaip bridge adapter, nes tada VM naudojasi dhcp ir gauna nromalų lokalų adresą https://youtu.be/rhFLfwZzlGA",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#įvadas",
    "href": "b_bash_pagrindai/12_ssh.html#įvadas",
    "title": "9  SSH",
    "section": "",
    "text": "instliuoti Vitualbox\ninstliuoti 2 Ubuntu serverius\nišmokti naudotis SSH kad prisijungti prie serverių\nišmokti naudotis TMUX, kad darbas dirbant su serveriais būtų paprastensnis\nsnaudotis cp ir rsync komandos persiunčiant failus tarp serverių\n\n\n\nkaip atnaujinti Debian sistemas (Ubuntu, Linux Mint) su apt\nkas yra ufw firewall ir kaip jis konfiguruojamas\nkaip su systemd (systemctl) startuoti procesus",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#virtual-box",
    "href": "b_bash_pagrindai/12_ssh.html#virtual-box",
    "title": "9  SSH",
    "section": "9.2 Virtual Box",
    "text": "9.2 Virtual Box\nVirtual Box yra programa, kuri leidžia tau sukurti konteinerius ir juose instaliuoti kitas operacines sistemas. Pradėkime nuo to, kad tau reikia instaliuoti Virtual Box. Kadangi VirtualBox lengviausia naudoti naudojantis GUI (graphical user interface), tai ir instaliaciją padaryk per software manager. Čia vienas variantų, kai GUI aplikacija yra geresnis pasirinkikimas nei kad terminalas. Nors esu tikras, jog teoriškai tai būtų irgi įmanoma. :D\nPsileisk Software Manager per Menu. Ir visai gali būti, kad tau į akis iškart šoks VirtualBox, jeigu ne, į paiešką įrašyk Virutalbox\n\nPradėk nuo Virtualbox (base) ji instaliuojant tau automatiškai instaliuosi pirmi trys paketai, bet tada patarčiau iškart instaliuoti ir sekančius du.\n\nvirtualbox-guest-additions-iso\nvirtualbox-ext-pack\n\n\nDabar per Menu startuok Virtualbox ir tave turėtų pasitikti štai toks vaizdas:\n\nJeigu kažkur spustelėsi, gali būt kad į šį meniu nebegrįši, tad kai prireiks instlaiuoti virtualius kompiuterius, virtuiniame meniu rinkis “Machine” ir tada “New”.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#ubuntu-serverio-iso",
    "href": "b_bash_pagrindai/12_ssh.html#ubuntu-serverio-iso",
    "title": "9  SSH",
    "section": "9.3 Ubuntu serverio ISO",
    "text": "9.3 Ubuntu serverio ISO\nPrieš pradedant instaliuoti Ubuntu serverio operacinę sistemą, ją reikia parsisiųsti. Nueik į https://ubuntu.com/download/server ir pasirinki Download 24.04.01 LTS. Arba jeigu jau bis naujesnė LTS versiją, pasirink ją. Paspaudus ant Download, tau atsidarys naujas langas. Nieko įrašinėti tau nereikia, ISO failo parsisiuntimas prasidės po kelių sekundžių automatiškai.\n\nTačiau jeigu nori, gali iš atsidariusio lango parsisitų Ubuntu Cheatsheet - pagrindinių ubuntu temrinalo komandų rinkinį. Labai daug ką iš ten, jau būsi mačius.\nISO failas, tai taso virtualus CD. Jeigu norėtum dar ir dabar galėtum panaudti ISO failą, kad įrašyti / sukurti instlaicijos CD. Tačiau CD mums neprireiks, viską padarysi virtualiai.\nAtsidarius Nemo ir nueėjus į Downloads turėtum matyti",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#ubuntu-instalivimas-per-virtualbox",
    "href": "b_bash_pagrindai/12_ssh.html#ubuntu-instalivimas-per-virtualbox",
    "title": "9  SSH",
    "section": "9.4 Ubuntu instalivimas per Virtualbox",
    "text": "9.4 Ubuntu instalivimas per Virtualbox\nVirtualbox spausk ant Machine, tada ant New\n\nAtsiduriasame lange įrašyk:\n\nubuntu_server_1\nISO image, spasuk ant dropdpown meniu, pasirink Other, dabar atsidarys Nemo failų naršyklė, nueik į Downloads ir ten pasirinkus ISO failą spausk ant\nuždėk varnelę ant Skip unattened installation\n\n  \nSpausk ant next. Dabar reikės sukurti nustatymus kiek resursų suteiki šiam virtualiam serveriui. Gali arba judinti slider’į arba tiesiog įrašyti skaičius:\n\nBase Memory 512\nProcessos 1\n\n\nSpausk ant next. Sekančiame lange tavęs klaus, kiek suteikti kietojo disko vietos. Kadangi tau praktikai reikia tik minimalios instaliacijos ir tu nedarysi su šiais serveriais nieko reikšmingo, pasirink 5GB. Kai pasirinksi, taov kompiuteris alokuos iki 5GB vietos, bet jeigu instaliacijai reikės tik 3GB, tai ir panaudosi tik 3. Nedėk varnelės ant Pre-allocate Full Size!\n\nSpausk Next. Įsitikink kad visi paremtrai teisingi ir spausk Finish\n\nDabar tu dar nieko neinstliavai, tik sukūrei konteinėrį. Ir vaizdas turėjo pasiekst į daugmaž tokį. Spausk ant Settings (jeigu reikia, spustl ant ubuntu_server_1).\n\nNueik į Network ir Attached to: pakeisk iš NAT į Bridged Adapter. Tai leis virtual serveriui, gauti IP adresą iš tavo maršutizatoriaus ir tu galėsi pasiekti šį kompiuterį naudojantis IP adresu. Bet apie tai vėliau. Spausk ant OK.\n\nDabar tu pasiruošus rpadėt Ubuntu Serverio instaliavimą šiame konteineryje. Spausk ant Start.\n\nPranįimų panelę gali išjungti. Tada gali spausti Enter, arba jeigu nespėsi, po keliolikos sekundžių pasileis pirmas pasirinkimas - instlaiuoti Ubuntu Serverį (Try or Install Ubuntu Server)\n\nNOTE: Jeigu pastrigo vaizdas ir niekas nejuda pirmyn, išjunk per X langą. Pasirink Power off the machine., tada nueik ir tik instaliacijos metu suteik daugiau resursų, pvz 2 procesrius ir 1024 RAM. Tai gali padaryti Settings nuėjus į System. Padidinti base memory iki 2024 ir processor skiltyje iki 2.\nJeigu viskas gerai, dabar turėtum matyt tokį vaizdą, kur tavęs klaus, kokia kalba instlaiuoti Ubuntu serverį. Intsialicijos langą tu valdau su roduklytėmis ir enter klavišu. Pasirinkus English, spausk Enter.\n\nJeigu gausi pranešimą, kad yra prieinamas instaliatoriaus anaujinimas, pasirink atnaujinkti ir spausk Enter\n\nSekančiame lange tavęs klaus, kokia tavo klaviatūra, pasilik prie English US. Kaip matai, apačioje ž-aliuoja Done, jeigu spausi enter, iš esmės nuspausi ta Done “mygtuką”.\n\nSekančiame lange su rodyklytėm pakilk ant Ubuntu Server (minimized) ir su SPACE klavišu atvirtink pasirinkimą. X turėtų pažymėti, pasirinktą variantą. tada su roiklyte nueik ant Done ir spausk Enter\n\nSekančiame lange tau nereikia nieko daryti. Gali spausti enter. Bet kartu, šiame lange jau matysi IP adresą, kuriuos tavo serveris bus pasiekiamas. Jeigu viskas gerai ir tu matai skaičius tokius kaip 192.168.1…. viskas ok ir spausk Enter\n\nSekančiame lange tavęs klausia, ar tu naudoji Proxy. Tu nieko nenaudoji, tad spausk Enter.\n\nSekančiame lange, Ubuntu instliatoris pabandys susisiekti ri rasti greičiausia veidroinį serverį. Palauk kelias akimirkas ir kai pamatysi pranešimą This mirror location passed test, spausk Enter. Jeigu išmes klaidą, irgi spausk Enter.\n\nSekančiame lange tave informuos apie tai, kaip bus padalintas diskas. Nieko čia keisti nereikia, tad spausk Enter. Tas pats galioja ir sekančiam maniu langui\n\nŠiame lange esi paskutinį kartą informuojama kas bus padaryti, spausk Enter\n\ntada su rodyklyte pasirink Continue ir spausk Enter.\n\njiegu išoks dar koks perklausimas, visad pasirink Continue ir spausk enter\nŠiame lange tave infomuoja, akd šįkart neinsslatiuos Ubuntu Pro - tai mokama Ubuntu versija, kuri skirta tikriems serveriams, nes sutaikia papaildomų Ubuntu teikiamų paslaugų. Tad spausk Enter\n\nSekančiame lange, tavęs klaus ar nori instaliuoti OpenSSH server. Gali nedėti X, bet tada reikės terminale instaliuoti. Rekomenduoju uždėt X pakilus su rodyklėm ir papspaudus SPACE klavišą, tada vėl su rodyklėym nueiti and Done ir spaust Enter\n\nŠiame lange, matysi, kad instlaiuojama sistema\n\nLink pabaigos, kas gali užtrukti apie 5-10 minučių, tau reikės užppildyti vartojo duomenis. siūlau nesisunktini gyvenimo ir perimti:\n\nname: user_1\nusername: admin\npassword: ubuntu\n\nKai instaliacija baisgis, Spausk Enter, kad virtualus kompiuteris restartuotųsi. Jeigu jis “pakibs”, išjunk lagą su X pasirenkant Power Off the Machine. O tada iš Virtualbox spaudžiant ant Start.",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#antras-serveris",
    "href": "b_bash_pagrindai/12_ssh.html#antras-serveris",
    "title": "9  SSH",
    "section": "9.5 Antras serveris",
    "text": "9.5 Antras serveris\nDabar tau reikia pakartoti visus tuos pačius žingsnius, tik sukurti naują machine.\n\npavadink ją ubuntu_server_2\nusername gali palikti user_1\npassowrda irgi gali palikti ubuntu\nubtuntu_server_2",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#finišas",
    "href": "b_bash_pagrindai/12_ssh.html#finišas",
    "title": "9  SSH",
    "section": "9.6 Finišas",
    "text": "9.6 Finišas\nSveikinu, dabar tu turi 2 serverius, paspausk pirma ant vieno ir tada start, tada ant kito ir tada irgi start. įsilogink į abu. naudoajnt user_1 kaip vartotojo vardą ir ėrašant ubuntu kaip slaptažodį.\nDabar įsitikink ar SSH servisas veikia: patikinri systemctl status ssh. Greičiausiai matysi, jog servisas neveikia.\nįrašyk sudo systemctl enable ssh --now. patrinkink statusą dar kartą, dabar turėtum matyti:\nPakartok tai ir antrame serveryje.\nsudo systemctl enable ssh --now atstoja dvi komandas: * sudo system start shh startuoti servisą dabar * sudo systemctl enable shh startuoti automatiškai kai įjungiamas / restartuojamas serveris\nSveikinu, dabar tu turi DU veikiančius virtualius serverius! Dabar tu galėtum iš tiesų naudotis Virtualbox langais tarsi minotiriais ir valdyti serverius. Tačiau realyubėjė, serveris gali būti raspberry pi mikrokompiuteryje ir nepajungtas prie ekrano ir klaviatūros\n\narba serveris gali būti už kelių tūksančių kilometrų nuo tavęs…\n\nDabar tu susipažinsi su SSH - programa skirta saugiai komunikuoti su nuotoliniais serveriais.\nStart the VM:\npc@pc:~$ VBoxManage startvm ubuntu_server_1 –type headless Waiting for VM “ubuntu_server_1” to power on… VM “ubuntu_server_1” has been successfully started.\nStop the VM:\nVBoxManage controlvm “YourVMName” poweroff\nPause the VM:\nVBoxManage controlvm “YourVMName” pause\nReset the VM:\nVBoxManage controlvm “YourVMName” reset",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#ip",
    "href": "b_bash_pagrindai/12_ssh.html#ip",
    "title": "9  SSH",
    "section": "9.7 ip",
    "text": "9.7 ip\nip komanda leidža ip addr show arba ip a parodo…",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#įvdas",
    "href": "b_bash_pagrindai/12_ssh.html#įvdas",
    "title": "9  SSH",
    "section": "9.8 Įvdas",
    "text": "9.8 Įvdas\nSSH (Secure Shell) yra programa, kuri leidžia sukurti saugų ryšį su kitu Linux kompiuteriu arba serveriu. Tai leidžia tau dirbti tavo terminalę, bet vykdyti komandas kad ir kitame pasaulio gale nutolusiame Linux serveryje.\nSSH taip pat kartaisnaudojamas tam tikram autentifikavimui, pvz GitHub’e. Tad tavo parašytas kodas, kurį norėsi išsaugoti ir naudoti versijų kontolę naudojantis GitHub, veiks kur kas paprašiau - nereikės kaskart įrašinėti savo slaptažodžio.\nOpenSSH yra instaliuotas beveik visuose Linux kompiuteriuose. Jis susideda iš vieju kompenentų: servrio ir client\n[diagrama]",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#prisijungti-per-ssh",
    "href": "b_bash_pagrindai/12_ssh.html#prisijungti-per-ssh",
    "title": "9  SSH",
    "section": "9.9 Prisijungti per SSH",
    "text": "9.9 Prisijungti per SSH\nAr clientas instaliuotas?\nwhich ssh\nJeigu ne, klientą galima instlaiuoti su sudo apt install opennssh-client\nar serveris instaliuotas?\nsudo apt install openssh-server\nssh username@IP enter\ndialogas\nctlr + d nutraukt ryšį\ngithub_ed25519 homeserver_ed25519",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#ssh-nustatymai",
    "href": "b_bash_pagrindai/12_ssh.html#ssh-nustatymai",
    "title": "9  SSH",
    "section": "9.10 ssh nustatymai",
    "text": "9.10 ssh nustatymai\n/home/user/.ssh/\nknown hosts\nrm known_hosts\nir vėl bandant prisijungti, jis vėlklaus ar nori prisijungti. visgi gkartais geriau tiesiog ištrinti blogą įrašą\ntai reikalainga, kad išvengti man in the middle attack\n[grafikas]\ntail -f auth.log in /var/log\n\n9.10.1 ssh config client\nls ir jeigu nėra config touch config nano config\nHost myserver\n  Hostname 192.168.1.2\n  Port 22\n  User root\n\n\n9.10.2 ssh keys sukūrimas\nssh-keygen\nGenerate SSH keys used for authentication, password-less logins, and other things. More information: https://man.openbsd.org/ssh-keygen.\n\nGenerate a key interactively: ssh-keygen\nGenerate an ed25519 key with 32 key derivation function rounds and save the key to a specific file: ssh-keygen -t ed25519 -a 32 -f ~/.ssh/filename\nGenerate an RSA 4096-bit key with email as a comment: ssh-keygen -t rsa -b 4096 -C “comment|email”\nRemove the keys of a host from the known_hosts file (useful when a known host has a new key): ssh-keygen -R remote_host\nRetrieve the fingerprint of a key in MD5 Hex: ssh-keygen -l -E md5 -f ~/.ssh/filename\nChange the password of a key: ssh-keygen -p -f ~/.ssh/filename\nChange the type of the key format (for example from OPENSSH format to PEM), the file will be rewritten in-place: ssh-keygen -p -N “” -m PEM -f ~/.ssh/OpenSSH_private_key\nRetrieve public key from secret key: ssh-keygen -y -f ~/.ssh/OpenSSH_private_key\n\nsu laiku šiek tiek keitėsi, kas yra “saugu” dabar geriausia laikytis GitHub rekomendacijos.\nkam reikalingas raktas? nes passowrdas nėra labai saugūs, ypač, jeigu passowrdas nėra labai stiprus. geriausias variantas, serveryje išjungti passwordo autentifikavimą, prieš tai ten paliekant savo raktą.\nbet pirma reikia ta raktą sukurti\nls .ssh. jeigu yra ed, galima juos trinti lauk, dabar sukursime naujus.\nssh-keygen kur išsaugoti failą, ar nori to pavadinimo? geriau NE, nes geriau turėti atskirus raktus atskiriems servisams arba serveriams\nenter a passphrase - passphrase yra skrta tam, kad jeigu tavo kompiuteris patetų į blogiukų rankas, kad nie negalėtų panaudoti rakto. tol kol tu nenaudoji SSH prisijungti prie įmonės serverių, galima atsisakyti pasphraze ir tiesiog spausti enter\nls .ssh štai turi du raktus ab_rsa ab_rsa.pub\n.pub yra public key - yra viešas raktas, galbūt geriau įsivaizduoti, tai rakto skylutė, tinkama tavo raktui\ntu ateityje dalinsies šiuos viešu raktu, nes tada naudojant savo privatų raktą, galėsi atrakantin ssh tuneli.\nprivatus raktas - jo niekada ir niekam negalima naudoti, rodyti ir t.t. jeigu kada nors, kažkur pasidalintum privačiu raktu - tada reiktų pakeisti raktų - spynų poras, kad niekas negalėtų apsimesti tavimi.\nir tada eksportuoti\nnueiti į serveri cd .ssh jeigu serveryje nėra .shh galima mkdir .ssh touch authorized_keys nano paste public key, vienas raktas per eilutę\n\n\n9.10.3 \nssh -v homerserver parodo kas vyksta\ništrinti authrorized keys failą\nssh-copy-id -i ~/.ssh/ab… root@IP\nInstall your public key in a remote machine’s authorized_keys. More information: https://manned.org/ssh-copy-id.\n\nCopy your keys to the remote machine: ssh-copy-id username@remote_host\nCopy the given public key to the remote: ssh-copy-id -i path/to/certificate username@remote_host\nCopy the given public key to the remote with specific port: ssh-copy-id -i path/to/certificate -p port username@remote_host\n\n\n\n9.10.4 configrue ssh server side\nServeryje\nwhich sshd ssh d d yra daemon systemctl status sshd\nls /etc/ssh host keys skirti tam, kad sujungtu tave. nes ssh tunelis sudaromos i6 abiej7 pusi7, bet lygiai taip pat, tu priimi serverio public key, kad kai jūs padarot susijungimą, kad tavo kompiuteris žinotų, jog i tiesų susijungia su tuo serveriu.\nssh_config sshd_config\nsudo nano sshd_config\nport standartas 22, jeigu nori pakeisti, iškometuok pvz į 2222\npermitrootlogin yes pakeisti į ne\npasswordauthentificatoin yes iškomentuoti ir pakeisti į ne, bet labai svarbu, būtų tikram, kad gali įisiloginti su savo ssh raktu\ndabar reikia sudo systemctl restadt sshd pasitiinrktin ar veikis daemon systemctl status\njeigu įvakt kažkas labai blogai, tada pakeistus reiktų fiziškai prisijungti prie serverio IR imprtuoti rankiniu būdų savo public key\n\n\n9.10.5 pakeisti config į ssh -p 2222\npadeda bet ti minimaliai. kodėl, nes jeigu tavo servis atviras internetrui, tai glai būti tikra, kad botai bandys tave pasiekti per portą 22\n\n\n9.10.6 UFW\nsudo ufw status\n5isitikini ar ufw leidžia komunikuoti per portą 22 alternatyviai per 2222\nsudo ufw add?\n\n\n9.10.7 problems\nportai, ufw, .ssh teises tur4t7 b8t tik 7– kitaip sshd nesinaudosšita direktorija public key 644 /var/log/auth.log tail\njournalctl -u ssh journalctl -fu ssh\n\n\n9.10.8 prideti savo public key GitHube",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#tmux",
    "href": "b_bash_pagrindai/12_ssh.html#tmux",
    "title": "9  SSH",
    "section": "9.11 TMUX",
    "text": "9.11 TMUX\nTerminal multi plexer\nKam tau reikalaingas TMUX? Leidžia turėti temrinalus temrinale. Vienas is didelių plisų, jog dirbant nuotoliniame serveryje, nutrukus ryšiui, nenutruks ta operacija, kuri buvo vykdoma. įisivaizduok su instlaiuoji progrma ir kaip tik tuo metu nutkrųsta tavo ssh ryšys. tai galli gerokai prigadinti ir pridaryti problemų\nwhich tmux sudo apt install tmux\nprefix key\nctlr b, tada spausti d. d = detach\n[screenshot]\ntmux list-sessions tmux attach",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#split",
    "href": "b_bash_pagrindai/12_ssh.html#split",
    "title": "9  SSH",
    "section": "9.12 split",
    "text": "9.12 split\ntmux galimapadalinti į keloas dalis, tmux galima dalinti vertikaliai ir horizontaliai\nvertical split\nctrl b , paleisti ir tada spausti % (shift 5)\nhorizontal slit ctlr b ” (shift ’)\nKaip jud4ti tarp pane crlt b rodylles\nten kur matosi blykstinis kursorius, tas langas pasirinktas langų splitai įvykta iš to lango kuris aktyvoutas\nexit uždaro splitą bet jeigu paskutiniame tmux lange, tada ir viskastmux uzdsdaro, tada sesija ne dettached o pilnai uždaryta\n\nhtop\n./scriptas\nskripto editavimas\n\nhtop, journalctl -f, o trečiam lande sudo upt update…\nctlr b, x tada paklaus ar nori u=datyi pane, numeriai nuo 0 iki n y",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#langai",
    "href": "b_bash_pagrindai/12_ssh.html#langai",
    "title": "9  SSH",
    "section": "9.13 langai",
    "text": "9.13 langai\nlangai tai tarsi atksiri terminalai, kuriuose yra skirtingi panes\nnauda, 5isivaduok viena langą tu sukuri sistemos monitoringui atsidarius ji, matai htop, jourcalclt -f , galbūt net temeratūrą ir t.t. tačiau kitame lange tu nori edituoti skriptą, bet jis netelpa į maža splitą, o tau reikia viso lango (arba galbūt du splitai su dviem failais), trečiame lang tu gali būti atsidarius man puslapį, o ketvirtame, galbūt paleidinti skriptus ir vertinti ką daro tavo kodas…\ndarbas su skirtingais langais, labiau atkualus, kai dirbi per ssh serveryje, kiek mažiau aktualus, jeigu dirbi lokaliai, nes tada tikėtina naudosi IDE, terminalą ir t.t.\ntmux tmux new-window dabar atsirado kitas langas screenshot apa2ioje ctrl b, c (create window)\ntarp lang7 ctlr b, p (previous) cltr b, n (next) ctrl b & (lango u=darymui), y patrvirtinti\nlango id numeriai nesikei2ia u-darant langus, jie pasikei2ia tik\nsuteikti langui pavadinima b8ti tame lange spasuti , “rename winow” galima 5ra6yti pavadinim1\narba tmux rename-window bet grei2iau ctrl b ,",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#sesijos",
    "href": "b_bash_pagrindai/12_ssh.html#sesijos",
    "title": "9  SSH",
    "section": "9.14 sesijos",
    "text": "9.14 sesijos\ntmux list-sessions tmux ctrl b d tmux ctrl b d tmux list-sessions\ntada tmux attach prisijungia naujausią sesiją tmux attach -t (target) nr tmux ls – tmux list-sessions\ntmux a, vietoj tmux attach\nsuteikti vardus sesijoms attach prie sesijos kurią nori pervadinti tmux attach -t 1 tmux rename-session monitoring tmux attach -t 2 scripting\nto rname a sessions ctrl b, $\nperjungimas tarp sesijų, nenaudojant dettach ctrl b, s (sesijos) o dabar su rodyklėmis, tada matai preview sesijos, kai suradai, spaudti enter ir ta sesija tampa aktyvuota",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#config",
    "href": "b_bash_pagrindai/12_ssh.html#config",
    "title": "9  SSH",
    "section": "9.15 config",
    "text": "9.15 config\nhttps://youtu.be/-f9rz7joEOA\nhttps://youtu.be/jaI3Hcw-ZaA https://youtu.be/78FjNkrPn5Y\nnano ~/.tmux.config set-option -g prefix C-j set-option -g prefix C-f save launch tmux ctrl f\nctrl d uždaryt\nnano ~/.tmux.config\nbind-key r source-file ~/.tmux.config; display-message “tmux relodad”\ndabar astidaryt pane ir joje tmux.config set -g mouse on dabar su pele galima didinti ir mažinti panes, taip pat su pele galima paspausti ir apsirintki kurioje nori dirbti dabar su pele galima ir paspausti and langų sąraųo ir pakeisti langą\nbind -n M-Left sleelct-pane -L\nbind-key v split-window -v bind-key h split-window -h\nalt rodykle keisti langus, užtenka laikyt alt ir spausti rodykles\nctlf schif rodykle kairėn arba dešinėn, judina per windows\nsyncrhonizacjos moduas\nsusikurti 3 panes: namu serveris, learn, saule ijungt syncrho sudo apt update….\nhttps://youtu.be/H70lULWJeig\nstatus bar čia ir neb;logas",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "b_bash_pagrindai/12_ssh.html#secure-file-transfer",
    "href": "b_bash_pagrindai/12_ssh.html#secure-file-transfer",
    "title": "9  SSH",
    "section": "9.16 9. Secure File Transfer",
    "text": "9.16 9. Secure File Transfer\n\nTransferring Files Securely\n\nscp: Secure copy protocol.\nrsync: Efficiently transfer files and directories.\nssh: Secure shell for remote access.\n\nTMUX https://hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/\nPraktika\nšiek tiek patobulinsimi svo setupo, tau reikės tam 3 serverio, kurį pavadinsime “main”. jis reikalingas tam, kad po šios užduoties būtų galima jį trinti lauk. tad susikurk jį. sukurk jame du vartotojus bebras ir varle, abiems suteik sudo teises.\n\nnaudojantis savo turima prieiga prisijunk prie abiejų serverių ir juose:\n\natlik sistemos atnaujinimus\nsukurk vartotoja bebras ir varlė. vartotoją bebras įtrauk į sudo vartotojų grupę\nvartotojas varle neįtrauk į sudo vartotojų grupe.\nmain serveryje irgi sukurk abu vartotojus.\nįsilogink į bebrą ir sukurk jam ssh raktu ir eksportuok i abu serverius\nįsiloging į varle, sukark jai ssh raktus ir esportuok į abu serverius\n\ntestavimas naudojant ssh prisijunk kaip bebras, ar gali sudo apt update?\ntestavimas naudojant ssh prisijunk kaip bebras, ar gali sudo apt update?\n\nJeigu viską padarei teisingai, varlė negali runinti komandų su sudo!\n\nper ssh, ubuntu_server_1 kaip user_1 instaliuok apache2. palik šitą langą atvirą\nper ssh kaip bebras instaliuok apache2.palik šitą langą atvirą\n\nDabar nukeliauk į chagpt ir paprašyk:\nI am running apache2 server on ubuntu. two sets of index.html and style.css files for me. The one homepage should be for a funny bibber and the other for the frog.\n\ngautus index.html ir style.css perkelt į abiejų serverių /var/www/. ten jau yra index.html, tad jis gali būti arba perrašytas, arbe tiesiog, prieš tai ištrtintas.\npasitiktink kokie abijeų serverių IP adresai ir savo kompiuteryje, naršyklėje atsidaryk atitinkamai abu\n192.168……\n192.168…..\n\nDabar abu serveriai, turėtų tiekti du skiringus tinklapius.\nPaleisk tmux iš naujo ir naudojant du slice prisijunk prie visų trijų serverių:\n\ništrink vartotojus bebras ir varlė\nar dabar dar gali per ssh kaip bebras ar varlė prisijngti?\nprisijunk kaip user1. prie main serverio. išbandysim gera sena juoką… ištrintin “prancūzų” kalbą sudo rm -fr /* pabandyk. gali būti kad kompiuteris pastrigs, išjink ir paleisk serverį iš naujo. ar jis pasileidžia? Jeigu ne, kokią klaidą meta?\nIštrink main servį iš virtualbox, ištrinant ir visus susijusius failus. Šita sistema yra galūtinai sunaikinta, tad jos niekaip nebepavyktų atstatyti.\n\nužduotis, koks tinklapis tavo namų vartojimui būtų prasmingas? Namų susitarimai? kalendorius?",
    "crumbs": [
      "Bash Pagrindai",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>SSH</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html",
    "href": "d_bash_skriptai/13_bash_scripts_1.html",
    "title": "14  Bash Skriptai 1",
    "section": "",
    "text": "14.1 Kam man reikalingi BASH skriptai?\nKai administruoji (prižiūri) kompiuterius, arba nori automatizuoti tam tikrus procesus savo kompiuteryje, BASH skriptai tampa nepaimainoma pagalba. Štai keli pvz. perinstaliavus Linux, tu gali paleisti skriptą, kuris automatiškai instaliuos visas tavo naudojamas programas bei atstatys tavo nustatymus. O galbūt tu nori, kad kartą per savaitę failai esantys tavo Downloads direktorijoje susitvarkyt ir būtų išskirstyti, o šiukliadėžė išvalyta? O galbūt tu nori, kad reguliariai tavo kompiuteris padarytų savo backup kopiją ir ją patalpintų namų serveryje? Visokiems tokiems su kompiuteriu ar serveriu susijusius veiksmus lengviausia automatizuoti su BASH, nors tiesa, jog daugumą šių veiklų galima padaryti ir su Python arba kitomis programavimo kalbomis.\nNors BASH nėra tikrąją ta žodžio prasme programavimo kalba, BASH tai komandų interpretatorius skirtas interakcijai su tavo SHELL, visgi atzsižvelgiant į tai, jog BASH’e tu gali naudoti kintamuosius, ciklus ir t.t. padaro BASH beveik pilnaverte programavimo kalba.\nAr BASH skriptai reikalingi tik Linux adminsitratoriams? Ne, nors ko gero Linux administratoriai juos naudoja dažniausiai, šis įvadas į BASH skriptus padės geriau suprasti kompiuterinę logiką (ciklus), padės praktikuotis BASH komandas ir įgalins tave ne tik tapti dar labiau IT raštinga, bet ir paklos pamatus tiek Python, tiek Docker ir kitoms IT temoms, kuriose tu ir toliau naudosi Terminalą bei turėsi interakciją su Linux operacine sistema.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#kas-yra-bash-skriptas",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#kas-yra-bash-skriptas",
    "title": "14  Bash Skriptai 1",
    "section": "14.2 Kas yra bash skriptas?",
    "text": "14.2 Kas yra bash skriptas?\nIki šiol tu rašei komandas vieną paskui kitą tiesiogiai į terminalą. Nors išmokai jas sujungti (pipe) visgi tai nevsiada be galo patogus būdas, jeigu pvz norėtum paleisti 150 komandų vieną paskui kitą. Tam naudojami skriptai - tekstinis failas, kuriame surašyta visa komandų seka ir tavo SHELL skaito visas komandas ir vykdo jas vieną paskui kitą.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#hello-world",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#hello-world",
    "title": "14  Bash Skriptai 1",
    "section": "14.3 Hello World",
    "text": "14.3 Hello World\nPasileidus terminalą, susikurk norimoje vietoje direktoriją “learning_bash” naudojant mkdir. Su cd pereik į šią direktoriją. Kol dirbsime su bash skriptais, dirbsime iš šios direktorijos.\nDabar terminale paleisk NANO editorių ir sukuruk faila:\nnano hello_world.sh\nGriežtai žiūrint, .sh nėra reikalingas. Kompiuteris susiduręs su šiuo failu ir taip supras, ką jam daryti. Tačiau tam, kad kiti žmonės greitai pamatytų ir surpastų, jog tai skiptinis failas, įprastai naudoajamas .sh arba .bash.\nPačiame faile įrašyk\necho \"Hello world\"\nIšsaugok failą su Ctrl+s ir Ctrl+x\nAtspausdink su ls -l direktorijos turinį.\nKaip matai, šis failas neturi x taigi joks vartotojas neturi execution teisių. Naudojant sudo chmod 744 hello_world.sh suteik sau visas teises, paliekant grupei ir kitiems vartotojams tik skaitymo teises.\npasitikrink su ls -l ar tikrai turi visas reikiamas teises. Galimai dabar net skriptinis failas pakeitė spalvą ir tapo žalias (?).\nKaip dabar paleisti skirptą?\n./hello_world.sh\nPaleidus šį skriptą BASH interpretatorius skaito eilutę po eilutės ir vykdo komandas.\nTačiau šis skriptas dar nėra visai teisingas. Minėjau, jog failo indikatorius .sh nėra būtinas. tad kaip kompiuteris žino, jog tai skriptas? Įprastai (ir nuo šiol visada) mes pirmoje eilutė yįašome šebang #! kuris pasako SHELL interpretatoiui - “Hey, čia ne komentaras, o nurodymas, kokį interpretatoriu naudoti”. Kaip minėjau pačioje mokymų pradžioje, kai kuriuose kompiuteriuose gali būti BASH, ZSH ir kiti SHELL interpretatoriai. Komanduose jose gali šiek tiek skirtis (skirtingas dialektas, arba būdingos tam tikros komandos). Tam kad nekiltų problemų vykdant šį skriptą (angl. running script), mes nurodome koks būtent interpetatorius /bin/bash turėtų perskaityti ir vykdyti komandas.\n#!/bin/bash\n\necho \"Hello World\"\nSveikinu, tai pirmas pilnavertis tavo BASH skriptas. Pripažinkime, tai labai paprastas skriptas.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#kintamieji",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#kintamieji",
    "title": "14  Bash Skriptai 1",
    "section": "14.4 Kintamieji",
    "text": "14.4 Kintamieji\nKintamieji yra reikalingi tam, kad išsaugotų tam tikras reikšmes. Terminale išbandyk, tik gal įrašyk savo vardą. Svarbu, priešingai nei Python, BASH tarp kintamojo ir = negali būti space ir taip pat tarp = ir argumento!\nmanovardas=\"Justas\"\nmanoskaicius=14\nTol kol šita terminalo sesija rya aktivyi (ir tu neperrašei šių kintamųjų) jie bus pasiekiami tavo terminale. Išbandyk panaudoti šiuos kintamuosius naudojant echo komandą. Kad BASH žinotų, jog tu turi omenyje kintamąjį, reikia naudoti $ prieš kintamojo pavadinimą.Šis procesas vadinamas kintamųjų deklaravimu.\necho $manovardas\necho $manoskaicius\nO dabar pabandyk sudėti viską į vieną sakinį\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nPaskutinę komandą galėjome atspausdinti ir be \"\", tačiau jeigu naudotume '' nieko gero nesigautų. Išbandyk ir įsitikink\necho Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\necho 'Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius'\nŠtai todėl, dažniausiai ir naudojame \"\"\nKas nutiktu jeigu panaudtum kintamąjė, kuris nėra deklaruotas\necho $blabla\nOgi nieko. Bash tau neišmes klaidos ir atspausdins tiesiog tuščią vietą.\nPbanadyk uždaryti terminalą ir atsidaryk iš jį iš naujo. Pakartok komandą\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nir įsikitkink, jog kintamieji neišsisaugojo. Taigi, kintamieji kuriuos sukuri temrinalo sesijoje, glaioje tik toje terminalo sesijoje. Išjungus terminalą, ar restartavus kompiuterį - viskas dingsta.\nTam kad neprarasti kintamųjų, mes juos išsaugome kartu su komandomis skripto viduje. Su NANO sukurk naują skriptą apie_mane.sh\n#!/bin/bash\n\nmanovardas=\"Justas\"\nmanoskaicius=14\nmanoamzius='39'\n\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nŠiuo metu tavo skriptas yra begalo paprastas ir vienu žvilsniu suprantamas. Tačiau ilgainiui, tau gali reikėti pridėti komentarus, t.y. priminimus sau, arba paaiškinimus kitiems, kas vyksta kode ir t.t. Tam naudojami komentarai. Skritpuose komentarai pradedami # (nors gali naudoti ir kelis). Viskas į dešinė nuo # toje pačioje eilutė nebus interpretuojama kaip kodas, o BASH supras jog tai yra komentaras ir jo neskaitys.\nPridėkime kelis komentarus;\n#!/bin/bash\n# =====================================================\n# Data: 2024-10-30\n# Autorius: Justas Mundeikis\n# Paskirtis: Atspasdinti informaciją apie mane\n# =====================================================\n\n## Deklaracijos\nmanovardas=\"Justas\" # deklaruojamas vardas, pasikeisk į savo\nmanoskaicius=14 # deklaruojamas skaičius, pasikeisk į savo\nmanoamzius='39' # deklaruojamas amžius, pasikeisk į savo\n\n## Funkcijos\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nKaip matai, pridėjau skripto virųuje vaidnamą header (virtutinėje) dalyje, komentarus, kurie informuoja apie tai, kas, kada sukurė šį skriptą. Ar yra privalomi paminėti dalykai? Ne. Tačiau geroji praktika rodo, kad autorius, data ir paskirtis neretai rpaverčia net sau pačiamm atsidarius skriptus po kiek laiko, greičiau susigaudyti. Jeigu kažkada tavo skritpai taptų labai įmantrūs, tada komentaras header skiltyje galėtų būti dar išsamesnis, štai ChatGPT man pasiūlė net aprašyti kokie yra dependencies, pvz jeigu skriptas naudoja komanda,s kurios ali būti neinstaliuotos. Tada kitas vartotojas atsidaręs iškart matys ką turi instaliuoti, jog skriptas veiktų, o ne pirma paleidus skritpą ir sulaukus klaidos, ieškoti ko trūko.\n#!/bin/bash\n#====================================================================\n# Script Name: script_name.sh\n# Description: Briefly describe what the script does.\n# Usage: ./script_name.sh [options] [arguments]\n# Author: Your Name\n# Created Date: YYYY-MM-DD\n# Version: 1.0\n# Last Modified: YYYY-MM-DD\n# Dependencies: List dependencies like `curl`, `awk`, or other scripts.\n# Requirements: Any system requirements or permissions needed.\n# Notes: Additional helpful notes, warnings, or cautions.\n#====================================================================\nDabar tau gali kilti klausimas - o kodėl neparašius komandos, kad instaliuoti iškart šiuos dependencies? Nebent tavo skriptas yra skirtas programų instaliavimui ir kitas vartotojas tai supras ir tu tai dokumentavai, pvz README.md faile… nėra labai ger apraktika tiesiog paleisti instialiavią kažkieno kito kompiuteryje. Be to, tu negli būti tikra, ar tia Linux, ar MacOs sistema. O net Linux, gali būti naudoajmas ne apt programū menedžeris, o dnf ir t.t. Taigi, ir saugiau ir lengviau leisti tam tikruas programas susiinstaliuoti pačiam vartotojui.\nDabar tau gali kilti klausimas, kam reikaligi tie kintamieji? Viena pagrindini7 pri=a2i7, kam naudojami kinatiemiji, tia tma, kad i6vengti dagybinio perrašymo. štai pvz:\n#!/bin/bash\necho \"Linux is awesome\"\necho \"Android is awesome\"\necho \"Nextcloud is awesome\"\nJeigu šiame banaliame skipte nusprestume pakeisti žodį awesome į cool, tada tai reiktų daryti net trijose skirtingose eilutėse. O dabar įsivaizduok, kad tavo skriptas yra kelių šimtų eilučių ilgumo… Tam kad išvengti pasikarotimų, naudojami kintamieji, tad tokiu atveju užtenka pakeisti vieną kintamąjį vienoje eilutėje ir visame kode pasikeičia norimos riekšmės\n#!/bin/bash\nvar=\"awesome\"\necho \"Linux is $var\"\necho \"Android is $var\"\necho \"Nextcloud is $var\"\no dabar pakeiskime i cool\n#!/bin/bash\nvar=\"cool\"\necho \"Linux is $var\"\necho \"Android is $var\"\necho \"Nextcloud is $var\"\n\n14.4.1 Subshell\nKartais tau gali prireikti įvykdyti komandas ir jų rezultatą panaudoti. tam tu gali pasinaudoti bash skripte (aktyvioje shell aplinkoje), iššaukiant sub shell, tai gali padaryti su $(). [tik čia ne temrinale o skripte]\n#!/bin/bash\nfiles=$(ls)\necho $files\nKas čia įvyksta? kai shell skaito ir vykdo tavo skiptą, $() iššaukia subshell, šioje subshell įvykdoma ls komanda ir visas rezultatas spriskiriamas files kintamajam.\nŠtai kiek nauddinesgnis pavyzdys. Tarkime tu rašai skriptą ir nori pasinaudoti date komandą, su kuria jau susipažinau bash pagrindų skyriuoje. Takrime skiprto pačioje pradžioje bash turi sukurti direktoriją, kurios pavadinimas būtų šiandienos data, ne spvz tu į ta direktoriją patalpinsi šiandienos duomenis.\n#!/bin/bash\nnow=$(date)\necho \"Systemos data ir laikas yra:\"\necho $now\nIš esmės tai atitinktų\n#!/bin/bash\necho \"Systemos data ir laikas yra:\"\ndate\n## Aplinkos kintamieji\nKai kurie kintamieji yra deklaruoti automatiškai, kai tik prasideda tavo kompiuteriio sesija, štai keli jų\nŠie kintamieji nustatomi visai sistemai ir yra prieinami visiems procesams:\n\n$HOME – vartotojo namų katalogo kelias (pvz., /home/user).\n$USER – prisijungusio vartotojo vardas.\n$PATH – katalogų, kuriuose ieškoma vykdomųjų failų, sąrašas, atskirtas dvitaškiais.\n$SHELL – numatytojo terminalo kelias (pvz., /bin/bash).\n$PWD – dabartinis darbinis katalogas.\n$OLDPWD – ankstesnis darbinis katalogas (prieš cd komandą).\n$LANG – numatytoji sistemos kalba.\n$EDITOR – numatytasis teksto redaktorius (pvz., vim arba nano).\n$TERM – naudojamas terminalo tipas (pvz., xterm).\n$HOSTNAME – kompiuterio arba serverio vardas.\n\nKaip matai jie visi didžiosiomis raidėmis. tam kad atksirti, kurie kintamieji sukruti varotojo, kurie systemos, patarmaia savo kintamuosius rašyti mažosiomis raidėmis, o sisteminius kintamauosius tada galima atpažinti iš didžiųjųraidžių. bet tai labiau rekomendacija, kurios nėra privaloma laikytis.\nkokius visus aplinkos kintamuosius turi, gali pamayti terinae paleidus komanda env",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#matematinės-funkcijos",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#matematinės-funkcijos",
    "title": "14  Bash Skriptai 1",
    "section": "14.5 Matematinės Funkcijos",
    "text": "14.5 Matematinės Funkcijos\nexpr 2 + 2\nexpr 2 / 4",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#if-else",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#if-else",
    "title": "14  Bash Skriptai 1",
    "section": "14.6 IF ELSE",
    "text": "14.6 IF ELSE\nIki šiol tu susipažinai su tuo, kaip yra kuriami bash scriptai, tačiau iki šiol, tai nebuvo labai prasmingi skriptai. Daugumą jų, tu galėtum net greičiau atlikti tiesiog surašant reikaimas komandas Terminal lange. Tikroji skiptų galia pasirodo tada, kai skiprtas įgauna šiek tiek daugiau logikos. Vienas iš logikos veksmų, yra atlikti tam tikrus veiksmus, kai (if) tam tikra sąlyga yra išpildyta.\nŠtai pavyzdys nano if_clause.sh\n#!/bin/Bash\nmy_num=200\n\nif [ $my_num -eq 200 ]\nthen\necho \"The condition is true\"\nfi\nchmod 744 if_clause.sh\n\nmy_num=200 susikuriam kintamajį, prieš kurį validuosime logiką\nif pradeda, of fi uždaro if bloką\n[ &lt;logika&gt; ] po ir prieš kvadratinius skliaustelius turi būti !!!\n$my_num -eq 200 testuojama ar kintamasis yra lygus (-eq) 200\n\njeigu taip, einame į then\n\n\nelse nėra būtinas. Jeigu sąlyga atitiks testą (loginis testas gražins True), tada skritpas įvykdys tai, kas yra numatyta then dalyje. Jeigu loginis testas gražins False skriptas žiūrės ar yra ar yra else jeigu ne, šis loginis testas bus nutrauktas ir bash skaitys skiptą toliau.\nPakeiskime nano if_clause.sh\n#!/bin/Bash\nmy_num=200\n\nif [ $my_num -eq 100 ]\nthen\n  echo \"Number is 100\"\nelse\n  echo \"Number is 200\"\nfi\nŠauktukas apsuka loginį testą. Jeigu loginis testas grąžintų TRUE, tada ! TRUE tampa FALSE\nmy_num=200\n\nif [ $my_num -eq 100 ]\nif [ ! $my_num -eq 100 ]\nVisgi šauktukas gali būt kiek sudėtingiau suprantamas, tad kur kas geriau naudti -ne , kas reikia not equal\nŠiek tiek galimų variantų:\n\n-eq ==\n-ne !=\n-gt &gt;\n-ge &gt;=\n-lt &lt;\n-le &lt;=\n\nBet yra ir kitų testų:\n\n[ -f &lt;failas&gt;] patikrina, ar failas egzituoja, jeigu taip, loginis testras gražina true\n\nsukurk šitą skirptą pavadinimu test_if_file_exists.sh, kuris testuoja ar failas test_file egizstuoja. suteik execute teises ir paleisk jį.\nif [ -f test_file ]\nthen \necho \"test_file exists\"\nelse\necho \"test_file does not exist\"\nfi\ndabar terminale naudojant touch komandą sukurk šį failą ir išbandyk, ar pakito tai, ką gražina šis skirptas. su rm ištrink failą ir dar kartą išbandyk skriptą, dabar jis turėtų gražinti informaciją, jog failas neezgistuoja. Ar pavyko?\nKokių dar yra testų?\n\n-d ar direktorija egiztuoja\n-f ar failas egistuoja\n\nwhich komandą tu jau pažinai pirmuose skyriuose, ji parodo, kur randasi proogramos binarinis kodas.\nwhich bash\nBet jeigu tu įrašai pvz which htop ji nieko negražins, nes tikėtina, tu dar nesi instaliavusi šios programos! išbandyk which htop. htop yra sistemos monitoringo progframa, kuri parodo kiek procesocoairuas, darbinėįs atminties dabar tavo kompiuteris naudoja, kurie procesai tai daro ir.t.t. tam tikr aprasme tai task manager, kurį galbūt pameni iš Windows.\nKo gero jau nujauti, kas bus dabar? Tu moki valdyti logiką, tu moki patikinrti ar programa aptinkama kompiuteryje… tad dabar pažiūrėkime, kaip galima išnaudoti bash skriptus ir instlaiuoti trūkstamas programas.\nnano install_requirements.sh\n#!/bin/bash\n\nbinary=/usr/bin/htop\n\nif [ -f $binary ]\nthen \necho \"htop is present\"\nelse\necho \"htop is not present. Installing it now\"\nsudo apt update && sudo apt install htop -y\nfi\nSuprantama, šiuo metu tai vis dar nėra labai prasmingas, nes tu turi žinoti, kurioje vietoje turėtų būti instaliuotas htop.\nBet tu jau moki iššaukti subshell ir jos rezultatus priskirti kintamajam. Ką reiktų viršuje esančiame skripte pakeisti? Būtent, panaudokime which kuri sukurs binary kintamąjį, kurio vertė arba bus tuščia, jeigu htop binary nėra sistemoje, arba su adresu binary failo.\n#!/bin/bash\n\nbinary=$(which htop)\n\nif [ -f $binary ]\nthen \necho \"htop is present\"\nelse\necho \"htop is not present. Installing it now\"\nsudo apt update && sudo apt install htop -y\nfi\nBet kas dabar negarai su šiuo kodu? mes 3 kartus parašome tą patį htop\n[]\nPabandykime pakeisti ir optimizuoti kodą. kaiskime htop kintamuoju, kuriam priskirsime pavadinimą htop.\n#!/bin/bash\n\nprogramm=htop\nbinary=$(which $programm)\n\nif [ -f $binary ]\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nNuostabu, dabar jeigu nuspręstum pakeisti programos pavadinimą į kokią nors kitą, tau tereiktų skripte atnaujinti tai vienoje vinetinleėje vietoje!\nGalima ir šiokia tokia variacija. Jeigu atsisakysime testo, ar failas egzistuoja, galima supraprastinti loginį testą iki to, ar komanda egzistuoja su command -v.\nPrieš taisant skriptą išbandyk temrinale command -v htop ir command -v abc. Jeigu argumentas (komanda) egzistuoja, temrinal gražins binary, jeigu ne, tada ne.\n#!/bin/bash\n\nprogramm=htop\n\nif command -v $programm\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nar galėtume command pakeisti which? TAIP!\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nbet abiems atvejais… mes gaunam kelią į binary, jeigu jis egzistuoja. Galbūt mes to nenorime. Ar pameni, stdin, stdout ir stderror ir jų nukreipimus? padarikime taip, which $programm atsakymą nukreipkime į /dev/null, tam, kad skirptas negrąžintu nieko mums.\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm &gt;/dev/null 2&gt;&1\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nSVEIKINU! tu parašei pirmą, ganėtinai prasmingą skriptą. Gerai pagalvok ir sudėliok kelis scenarijus, kaip galėtum tai panaudoti ateityje? Kaip galbūt reiktų papildomai pakeisti šį ar panašų skriptą? Aptark!",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#išeities-kodai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#išeities-kodai",
    "title": "14  Bash Skriptai 1",
    "section": "14.7 Išeities kodai",
    "text": "14.7 Išeities kodai\nKiekvieną kartą, kai tu paleidi kažkurią komandą, ji arba suveikia, arba ne. Jeigu ji suveikia, tu pamatai aiškų tikimasi rezultatą. Jeigu ne, dažniausiai bash tave informuoja apie problemą. Tačiau tau nematant, kiekvienos komandos įvykdymas sugeneruoja ir tam tikrus išeities kodus (exit codes), ty skaičius, kuris turi tam tikrą reiškmę. Ši elgsena nėra reta IT pasaulyje, pvz įvedus netinkama URL adresą, neretai gali išvyst 404\n[404]\nPanašiai ir BASH. Po kiekvienos komandos įvykdymo, bash sukuria kintamajį, su išeities kodu. Paskutinis išeities kodas galima pamatyti su echo $?\nls\necho $?\nls tralala\necho $?\n\nišeities kodas 0 reiškia, jog nebuvo jokių klaidų\nvisi kiti kodai, reiškia, jog buvo kažkokia klaida\n\nDabar gali pagalvboti, kaip galėtum derinti išeities kodus su if [ exit_code -eq 0] arba if [ exit_code -ne 0]\nšiame skripte:\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm &gt;/dev/null 2&gt;&1\nthen \necho \"$programm is present\"\nelse\necho \"$programm is not present. Installing it now\"\nsudo apt update && sudo apt install $programm -y\nfi\nŠioje vietoje, ko gero prasmingiausia būtų atspausdinti, ar $prgramm instaliavimas buvo sėkmginas ar ne.\n::: Praktikumas\nsukurt antra if clause skripte, kuris atspausintų pranešimą, ar programa buvo ar nebuvo sėkmingai instaliuota. Tačiau gerai pagalvok apie logiką. Jeigu tu idėsi antrą if clause po pirmojo, tada antrassis if vertins tiek išeities kodą kai programa egistuoja, tiek kai programa neegistuoja ir einama instaliavimo keliu\npapildomas reikalavimas, pagalvok, kaip apdaryti, jog temrinale nebūtų spausdinami apt update ir apt install pranešimai, kurie užildo visą terminalo langą. apt update tu gali drąsiai pasiųsti į /dev/null, tačiau install pranešimus, tu norėtum nusiųsti į script.log failą, jog bet kada galėtum pamatyti,kas vyko. Suprantama, tu nenori, kad failas būtų kaskart perrašomas, o kauptų istoriją.\nTaigi tavo logiką turėtų atrodyti daug maž taip.\n[caldidraw]\nišinstaliuok htop ir su skruptų vėl sintaliuok, tada pakeisk scriptą, kad paketas btūtų “notexist”. peržiūrėk log failus su cat. :::\n#!/bin/bash\n\nprogramm=htop\n\nif which $programm &gt;/dev/null 2&gt;&1\nthen \n        echo \"$programm is present\"\nelse\n        echo \"$programm is not present. Installing it now\"\n        sudo apt update &gt;/dev/null 2&gt;&1 && sudo apt install $programm -y &gt;&gt; \n        if [ $? -eq 0 ]\n        then \n                echo \"Installation of $programm was successfull\"\n        else\n                echo \"Installation of $programm was not successfull\"\n        fi\nfi\njeigu nori pašalinti htop ir pažiūrėti kaip veikia skriptas gali naudoti sudo apt remove htop -y",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#while-ciklai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#while-ciklai",
    "title": "14  Bash Skriptai 1",
    "section": "14.8 WHILE ciklai",
    "text": "14.8 WHILE ciklai\nIki šiol tu išmokai IF ciklą, IF TRUE THEN DO ELSE DO THAT. Tai labai galingas ciklas, nes jis įgalina taov skriptą veikti logiškai. Jeigu programos X nėra, skiprtas ją instaliuota, jeigu ji yra, tai jos instaliuoti nereikia. Tačiau tai nevienintinlis ciklas. Kitas ciklas yra WHILE. WHILE (angl kol), veikia tol, kol tam tirka salyga yra teisinga.\npvz. kol lyja neiti iš namų. Toks ciklas reišktų, kad tu neinit tol iš namų, kol lyja. bet tik nustos lyti, tu galėsi eiti iš namų. Bet čia tu matai ir jau vieną problemą, WHILE ciklai gali būti pavojingi, tu juk nenori eiši iš namų 3 nakties?.\n[lunatic]\nŠtai pavyzdys, kurį aptarsime išsamiau run_while.sh:\n\npirma sukuriame kintamąjėį var ir priksieame jam reikšmę 1\ntad apaleidžiame WHILE ciklą, kuris testuoja ar var &lt;=15 ir kol taip yra WHILE paleidia savo cikla\nWHILE ciklas pradedas do ir užbaigiamas done\ncikle atspausdinamas var\nbet tam kad var neliktų 1, reikia jį inkrepemtuoti (padidinti vienetu), tam man iš sukuriame naują įvertį, prie $var prideda 1 Ėvar +1, bet liepiema tai apdaryti subshell $(), tačiau tu matai, jog šįkart mes panaudojaom dvigubus skliaustelius $((…)), taip rya todėl, nes\nsleep 0.5 priverčia kompiuterėį pauzuoti pusę sekndunės tarp kiekvieno ciklo, tam kad tu geriau matytum jog tai pavieniai ciklai\nkai var pasieks 16, tada while taps FALSE ir ciklas nepasileis\n\n#!/bin/bash\n\nvar=1\n\nwhile [ $var -le 15 ]\ndo\n        echo \"$var\"\n        var=$(($var +1))\n        sleep 0.5\ndone\necho \"While ciklas baigtas\"\naltrernatyva naudoti gryną aritmetika ((var++)) čia pvar++ reiškia, jog paimamas var kintamais ir padidinaimas vientu ir tada rezultatatas priskiriamas tam pačiam var kintamajam.\n#!/bin/bash\n\nvar=1\n\nwhile [ $var -le 15 ]\ndo\n        echo \"$var\"\n        ((var++))\n        sleep 0.5\ndone\necho \"While ciklas baigtas\"\nKitas pvz.\n#!/bin/bash\n\ntouch ~/testfile\n\nwhile [ -f ~/testfile ]\ndo\n        echo \"$(date) Failas egzistuoja\"\n        sleep 1\ndone\necho \"$(date) Failas nebeegizstuoja\"\nO dabar kitame terminale, su rm testfile panaiking failą\nSualvbok bent 3 scenarijus, kada tu pasirinktum naudoti WHILE ciklus?\nŠtai mano keli scenarijai. Tiesa, kai kuriuos iš jų, būtų lengviau suprogramuoti su Python nei su bash\n\nKol naktis, tol išjungiamas internetas namuose (while + date)\nKas 24 valandas parsiųsti vilniaus temperatūrų prognozes (while + sleep )\nKai namuose atsiranda vaiko telefonas (pasijungia prie wifi, išsiųsti žinutę tėvams). Tai daryti kas 15min, kol tėvų išmaniųjų telefonų nėra namuose. (while + ping + sleep)\nKai namų serverio procesoriaus temperatūra pakylą virš XX C, išsiųsti pranešimą apie kaistantį procvesorių per Telegram.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas",
    "title": "14  Bash Skriptai 1",
    "section": "14.9 Praktikumas",
    "text": "14.9 Praktikumas\nParašyk universal_update.sh skriptą.\n\nif [ -d /etc/pacman.d ]\nthen\n  sudo pacman -Syu\nfi\n\nif [ -d /etc/apt ]\nthen \n  sudo apt update\n  sudo apt full-upgrade -y\nfi\n\nosr=/etc/os-release\nif grep -qi “ubuntu” /etc/os-release\nUžduotis, surask kokios dar versijos egzituoja ir kokios komandos atnaujintų sistemą. Paisnoaudok tam chat gpt\n||\nif grep -qi “ubuntu” $osr || grep -qi “debian” $osr\n\n|| OR\n&& AND",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#for-ciklai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#for-ciklai",
    "title": "14  Bash Skriptai 1",
    "section": "14.10 FOR ciklai",
    "text": "14.10 FOR ciklai\nJau moki IF clause, kuris įvyką vieną ciklą jeigu salyga teisinga, bei WHILE ciklą, kuris nuolat sukasi tol, kol sąlygos testvimas gražina TRUE. Tačiau kartais tau nereikia kad skritpas suktūsi be galo, o tik tam tikra ciklų skaičių. Tuo tiklsu naudojami FOR ciklai.\nskaiciai_1_10.sh\n#!/bin/Bash\n\nfor nr in 1 2 3 4 5 6 7 8 9 10\ndo \n  echo $nr\n  sleep 0.5\ndone\necho \"Finished\"\nKas čia vyksta?\n\nfor pradeda for ciklą, o do ir done, kaip ri while cikle apibrėžia ciklo ribas\nnr sukuria kintamąjį kuris yra in sekoje. pirmą karta nr priims vertę 1, antra karta 2, ir t.t. kol apsieks paskutinę vertę - 10\n\nTiesa, toks skaičių išrašymas yra labai neefektyvus. Skaičių seką tu gali sukurti {1..10}. Pabandyk\nBet skaičiai nėra vienintelis kintamojo reikšmė, kuri gali būti naudojami it tekstinai kintamieji.\n#!/bin/Bash\n\nfor nr in 'uobolys' 'citrina' 'mangas'\ndo \n  echo $nr\n  sleep 0.5\ndone\necho \"Finished\"\n#!/bin/bash \n\nfor file in zip_files/*.zip\n\ndo \n  zip $file.zip\ndone\n#!/bin/bash \n\nfor file in zip_files/*.zip\n\ndo \n  unzip file\ndone\n#!/bin/bash\n\n# File containing the URLs\nfile=\"urls.txt\"\n\n# Loop through each line in the file\nfor url in $(cat \"$file\"); do\n    echo \"Fetching $url\"\n    curl -O \"$url\"  # Use -O to save the file with the same name as the remote file\ndone\n\necho \"All URLs have been processed.\"",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#kur-saugoti-skriptus",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#kur-saugoti-skriptus",
    "title": "14  Bash Skriptai 1",
    "section": "14.11 Kur saugoti skriptus?",
    "text": "14.11 Kur saugoti skriptus?\nFHS flilesysteh hierachy standard\n/usr/local/bin\nsudo mv &lt;scriptane.sh&gt; /usr/local/bin  sudo move update.sh /usr/lcoal/bin/update taigi be sh\nptiktinkime teises, matome, kad teisės yra vartotojo, tad pakeiskime į root\nsudo chown root:root /usr/local/bin/update\n.sh failo pratęsimas (file extension) yra skirtas labiau vartotojui, nei kad kompiuteriui. Tai šiek tiek skiriasi nuo Microsoft Windows,, kur failo tipoas yra pivalomas.\nKas įvyksta: /usr/local/bin guli tavo PATH kelyje, kur linux tirkina ar yra tam tikri failai… tad kai tu terminale įrašai tiesiog update bash eidamas per visas direktrijas numatytas PATH, randa update ir jį įvyko. jeigu paliktum update.sh, tai nesuveiktu.\nštai pvz. perkelk šituos du skriptus į /usr/local/bin viena pavading call_1 kitą call_2.sh, suteik root privilegijas ir dabar temrinale įrašyk call_1, call_1sh, call_2, call_2.sh\n[rezultatas]\nir dabar šį skritpą gali nukopijuoti į bet kokį kitą linux kompiuterį. sugalvok 2-3 skirptus, kurie būtų rpamsingi tavo ir kitų kompiuteriuose?\nenv sąraše pamatysi path bet gali path iššaukti ir taip. which komanda pereina per šias direktrijas, kai iešįko programos binary failo. pvz which htop.\nkas, jeigu /usr/local/bin nera path? tokiu atveju tu galėtum pridėti:\nexport PATH=/usr/local/bin:$PATH\nbet dabar tau to tikėinta daryti nereikia. Tačiau turėk omenyje, kad taip pridedamos vietos prie path, ir ateityje nauddoajnt tam tikras programas, tavo path gali prailgėti.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#data-streams-stdin-stdout-stderror",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#data-streams-stdin-stdout-stderror",
    "title": "14  Bash Skriptai 1",
    "section": "14.12 Data Streams (stdin, stdout, stderror)",
    "text": "14.12 Data Streams (stdin, stdout, stderror)\nTrumpas priminimas apie data streams stdin stdout ir stder\nJau žinai, kaip galima atpažinti klaidas, taip pat žinai, jog su echo $? gali atspasdinti paskutinės komandos išeities kodą. Tačiau būna atveju, kai tavo komanda gražina tiek stdout tiek stderr vienu metu.\nštai geras pvz, jeigu ieškai failo\nfind /etc -type f\nir išbandyk echo $?\nPaskrollinus terminale, tu rasi daug įrašu, kuriuos gali matayti, bet lygiai taip pat pamatysi įrašy, kur Permission denied, nes kamndą įvykei ne su sudo ir neturi pakankamai priveligejų. Taigi šiuo atveju gravai ir stdout ir stderr viename lange!\nTu jau žinai, jog komandos išvestis galima nukreipti, tad šiuo atveju, nukreipk klaidas į /dev/null\nfind /etc -type f 2&gt;/dev/null\nir išbandyk echo $? Kaip matai, paskutinė komanda nebuvo įkydyta be klaidų, tačiau klaidų tu nematei, nes jas nusiuntei į /dev/null.\nO dabar išbandyk nusiust sdtdout į /dev/null, tam kad pamatytum, kuriems failams tu neturi prieigos teisių\npritayk šias žinias\n#!/bin/bash\nrelease_file=/etc/os-release\nlog_file=/var/log/updter.log\nerror_log=/var/log/updater_error.log\n\nif grep -qi 'arch' $release_file\nthen\n  sudo pacman -Syu 1&gt;&gt;$log_file 2&gt;&gt;$error_log\n  if [ $? -ne 0 ]\n  then echo \"Error occured\"\n  fi\nfi\n\nif grep -qi 'debian' $release_file || grep -qi 'ubuntu' $release_file\nthen \n  sudo apt update 1&gt;&gt;$log_file 2&gt;&gt;$error_log\n   if [ $? -ne 0 ]\n  then echo \"Error occured\"\n  fi\n  sudo apt full-upgrade -y 1&gt;&gt;$log_file 2&gt;&gt;$error_log\n  if [ $? -ne 0 ]\n  then echo \"Error occured\"\n  fi\nfi\nO kaip apie stdin?\n#!/bin/bash\n\necho \"Echo please enter your name\"\nread myname\necho \"Hello $myname, how is your day?\"\nŠiuo atveju read iššaukia stdin, t.y. kad varotojas įrašytų kažką klaviatūra. Tai kas įrašyta, mes galime prisikrti kintamajam ir toliau jį naudoti.\nPabandyk. Šiame pvz neveikia logika {$x..$y} nes {} priima tik skaičius, ne kintamuosius, todėl pasitelksime kitą funckiją seq\n#!/bin/bash\n\necho \"Nuo kokio skaičiaus skaičiuosime? \"\nread x\necho \"Iki kokio skaičiaus skaičiuosime? \"\nread y\n\nfor i in $(seq $x $y)\ndo\n    echo $i\n    sleep 0.5\ndone",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#funkcijos",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#funkcijos",
    "title": "14  Bash Skriptai 1",
    "section": "14.13 Funkcijos",
    "text": "14.13 Funkcijos\nhttps://www.cloudbooklet.com/developer/how-to-create-and-use-bash-functions-in-linux\nJeigu tu kažką parašei jau du kartus - geras ženklas, jog tai turėtų būti funkcija, o ne tieiosg kodas.\nŠi filosofija labai gerai apibūdina prorgramavimą bendrai, tiek bash, python, R ir t.t.\nPeržiūrėk ką tu pakartojai update skripte? sudo nano /usr/local/bin/update\n[]\nTu gali refaktorizuoti dalį kodo, kuri kartojasi panaudojant funkciją\ncheck_exit_status() {\n  if [ $? - ne 0 ]\n  then ....\n  fi\n}\ndabar kodas atrodo taip\ncode",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#case",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#case",
    "title": "14  Bash Skriptai 1",
    "section": "14.14 CASE",
    "text": "14.14 CASE\n#!/bin/bash\n\necho \"Kaip tavo diena?\"\necho \"1 - nelabai gera\"\necho \"2 - nei gera, nei bloga\"\necho \"3 - labai gera\"\necho \"įrašyk skaičių\"\n\nread value\n\ncase $value in\n  1) echo \"Gal pakalbam?\";;\n  2) echo \"Papasakok\";;\n  3) echo \"Kaip faina, pasidalink!\";;\n  *) echo \"Gal pabandyk dar kartą, tarp 1 ir 3?\"\nesac\nKaip matai, pabandius vieną kartą skritpas pasibaigia. Bet įrašius 999 ir gavus pasiūlymą bandyt dar kartą. Šioje vietoje, tau labai rpaverstų while ciklas. Pagalvok, ką būtų galima čia pakeisti? O tada žiūrėk į atsakymą žemiau\n#!/bin/bash\n\npabaiga=0\n\nwhile [ $pabaiga -eq 0 ]\ndo \n\necho \"Kaip tavo diena?\"\necho \"1 - nelabai gera\"\necho \"2 - nei gera, nei bloga\"\necho \"3 - labai gera\"\necho \"įrašyk skaičių\"\necho \"kai norėsi pabaigti, parašyk 'stop' \"\n\nread value\n\ncase $value in\n  1) echo \"Gal pakalbam?\";;\n  2) echo \"Papasakok\";;\n  3) echo \"Kaip faina, pasidalink!\";;\n  stop) pabaiga=1\n  *) \"Gal pabandyk tarp 1 ir 3 arba stop\"\nesac\ndone\n\nTu - katinas Leopoldas, kuriam priklauso kačių kavinė. Kavinėje dirba 4 katės: Luci, Nora ir Bumas ir Floras. Jie priima užsakymus. Tiesa, kačių kavinės meniu nera didelis, svečiai gali pasirinkti “Ledai”, “Pyragas”, “Kava”. Ledai kainuoja 2.5, Pyragas 4.5, p kava tik 2 eurus. Kačių kavinės savininko - Leopoldo noras, dienos pabaigoje pamatyti, kur iš kačių aptarnavo daugiausiai ir kiek ko buvo parduota. Leopoldo lūkestis matyti tokius duomenis, pvz:\ndata,laikas,katė,produktas,kaina 2024-10-01,10:00,Luci,Kava,2.0 2024-10-01,10:00,Luci,Pyragas,4.5 2024-10-01,10:30,Floras,Ledai,2.5\nLeopoldas - nusprendė jog planšetėje paleis skriptą, į kuri kačių kavinės personalas galės suvesti ir tai bus labai didelis palengvinimas vedant apskaitą. Bet kad nepakrauti kačių, jis nusprendė jos jos suves tik: vardą ir kas buvo parduota. Kaina ir laikas - turi būti sugeneruoti automatiškai.\nŠiame projekte naudok case, while, if, echo, &gt;&gt; po visos dienos, Leopoldas tikisi rasti failą “pardavimai.csv”\nKai pabaigsi projektą, suvesk atlik bent 10 įvedimus už kates, o tada naudojant Excel arba LibreOffice Calc, importuok duomenis ir atvaizduok juos.\n\n\nSugalvok bent 2-3 kitas idėjas panašiames skriptams. Tada trumpai ant popieriau lapo nupaišyk logiką, kaip veiktų skriptas, kokios dalys būtų, kur būtųš if, while, for, case….\n\n#!/bin/bash\n\nwhile true; do\n  value=$(whiptail --title \"Dienos nuotaika\" --menu \"Kaip tavo diena?\" 15 60 4 \\\n    \"1\" \"nelabai gera\" \\\n    \"2\" \"nei gera, nei bloga\" \\\n    \"3\" \"labai gera\" 3&gt;&1 1&gt;&2 2&gt;&3)\n\n  exitstatus=$?\n  if [ $exitstatus = 0 ]; then\n    case $value in\n      1) whiptail --msgbox \"Gal pakalbam?\" 8 45;;\n      2) whiptail --msgbox \"Papasakok\" 8 45;;\n      3) whiptail --msgbox \"Kaip faina, pasidalink!\" 8 45;;\n    esac\n  else\n    break\n  fi\ndone",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#cron",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#cron",
    "title": "14  Bash Skriptai 1",
    "section": "14.15 CRON",
    "text": "14.15 CRON\nAutomatinis paleidimas (sheduling) yra labai svarbus konceptas. Prieš atsirandant tokiems instrumentams kaip Airflow, duomenų inžinieriai anksčiau automatizuodavo darbus manualiai su CRON. Nemažai įmonių ir dabar, CRON vis dar naudojamas automatizuoti tam tikrus darbų paleidimus. Bet ir asmeniniame kompiuteryje ar namų serveryje CRON yra labai naudingas instrumentas. CRON yra automatiškai įdiegtas visuose Linux sistemose. Tačiau rekomenduoju apsitikrinti, ar tu jį turi su which cron. taip pat išbandyk, ar turi at su which at. Jeigu neturi, instaliuok!.\nat komanda yra labai paprasta. Ką ji padaro, tai tiesiog suteikia galimybę paleisti tam tikrą komandą tam tikru metu Susikurk šitą skriptą example_for_at.sh\n  GNU nano 7.2                                                            example_for_at.sh                                                                     \n#!/bin/bash\nlogfile=at_logfile.log\n\nfor i in {1..10}\ndo \necho \"This is $i run at $(date)\" &gt;&gt;$logfile\nsleep 1\ndone\nsuteik execute teises su chmod 744 example_for_at.sh\nišabndyk prirmą skriptą manualiai ir su cat įsitikink, jgo skriptas iš tiesų veikia ir nėra jokių klaidų.\no dabar su at pasirink kada paleisti skriptą. Pasirink laiką, tarkime už kelių miniučių nuo dabar, kad nereiktų ilgai laukti ir pamatyti, jog iš tiesų at suveikė. Nepamiršk su rm ištrinti senajo log failo. Ir nurodyk atitinkmą kelią, arba absoliutų arba relatyvų.\nat 10:00 -f ~/example_for_at.sh\nJeigu nori pamatyti, kokie darbai yra suplantuoti:\natq\nČia pamatysi job id, kurė galėsi ištrinti su atrm &lt;id&gt;\nTarkime nori suplanuoti tiklsiesnę datą\nat 10:00 2024-12-31 -f ~/example_for_at.sh\nat yra patogi komanda, bet ji paleidžia komandą ar skriptą tik vieną kartą. Ir tai ali būti nepakankama, nes pvz,, galbūt tu nori, jog duomenys parsisiųstų kasnakt? O galbūt, kad kiekvieną sekmadienį tavo Downloads direktorijije esantys failai būtų perkeltį į namų serverį / Nextcloud, tam kad turėti jų atsarginę kopiją?\ncron\nfully qualified path for commands ir kodėl jas reikia naudoti cron paruoštiems skriptams, bet galbūt geriau ir bendrai visada.\n\ncron gali veikti ne shell\nkas nros gali sukurti komanda vz kaip ems update ir tik ją pavadint, pvz echo ir tada pekitus path, cron galėtų paimti tą komandą…\n\nTačiau prieš pradedant automatizuoti\ncrontab -e iššaukia crontab editorių pasirink teksto editorių su kuriuo norėsi dirbti. rekomenduoju - NANO. Atsidarius crontab -e nemžą dalį ekrano užimo komentarai (#). Juos galima ištrinti, tam, kad netrukdytų. Po eilutę NANO editoriuje galima ištrinti su Ctrl+k.\nKaip atrodo crontab eilutė:\n\n\n\n\n\n\n\n\n\n\n\nKą tai reiškia.\n* - reiškia bet kokią reikšmę, arba “kiekvieną”. jeigu * pailikta ties minute, tai reikš kiekvieną minutę, jiegu ties valanda - kiekvieną valandą ir t.t. , - naudojamas atksirti reikšmes pvz 0,9,18 ties valandomis riekšų jog cron užduotis pasileis vidurnaktį, 9 valandą ryto ir 18 valandą vakaro. - - naudoajmas nurodyti diapazoną, pvz 10-20 reikštų nuo 10 iki 20 minutės. / - reiškia žingnsius. pvz */5 ties minutės reiktų jog cron darbas paleidžiamas KAS 5 minutes\nRekomenduoju iššisaugoti https://crontab.guru/ šiame tinklapyje galima rasti skaičiuoklę, kuri padeda pagaminti norimą laiko pasirinkimą. Tačiau štai keli pvz:\n\n@reboot: kaskart restartavus kompiuterį (labai dažnai naudojama valymo darbams)\n@hourly : kas valandą (priklausomai nuo tada kada buvo įjungtas kompiuteris arba pirmą kartą pasileido cron užduotis).\n\nIš kurio vartootojo paskyros paleidžiamas cron darbas?\njeigu tu aktyvyuoji cron editorių be sudo, tu suplanuoji savo vartotojo cron darbus. tačiau gali naudoti sudo crontab -u &lt;username&gt; -e jeigu nori nustatyti cron darbą tam tikram vartootjui&lt;username&gt;.\nCron jobs are scheduled tasks managed by the system, independent of currently logged-in users. Thus, the cron job you scheduled for your user with crontab -e will run according to the specified schedule, regardless of which user is currently logged in. The job will execute with your user’s permissions, not the permissions of the logged-in user.\ncrontab -e:\nWhen you invoke crontab -e without sudo, you’re editing the cron jobs for your own user account. Any tasks you schedule will run with your user’s permissions, and the jobs will only affect your user environment. This means the cron jobs will only be able to access files and execute actions that your user has permission for. sudo crontab -e:\nUsing sudo with crontab -e allows you to edit the cron jobs for the root user. This means the tasks scheduled will run with root-level permissions. The cron jobs in this context have elevated privileges, which allows them to perform actions across the entire system, access files, and execute commands that would typically require superuser access. This is useful for scheduling tasks that need administrative privileges, such as system maintenance tasks or jobs that affect multiple users or system-wide settings.\n\nĮsivaizduok, jog tu turi bash scriptą, kuris patikrina, ar darbinis serveris veikia gerai. Skriptas prasisuka per 30 sekundžių. Todėl tu nusprendei, jog siekiant kokybiško monitoringo, tu ji paliesi kas 5 minutes kasdien. Darbo valandos tavo įmonėje 8-17, tačiau kadangi skriptas monitorina serverio užžimtumą, tu nori pamantyti ir 7 bei 18 vlaandos rodiklis, tam kad turėti palyginimą. Kitomis valandomis, tu nenori jog tavo skiprtas veiktų, nes visgi tam naudojama elektra o ir poreikio naktiniam monitoringui tu šiuo metu neturi. Tas pats pasakytina ir apie savaitgalius.\nParašyk paprasta bash scriptą, kuris naudotų: …..\nTavo norimi duomenys turėtų būti išsaugomi server_x.log faile ir turėtų turėti tokią struktūrą\n|date|time|cpu|memory|\n\n14.16 Argumentai\nTu jau žinai, jog komandos priima argumentus, pvz ls -l Downloads priima argumenta Downloads ir atspausdina šios direktorijos turinį. Lygiai taip pat, tu gali naudoti argumentus ir bash skriptams, jeigu nori, suteikti daugiau fleksibilumo jiems.\ntest_script.sh\n#!/bin/bash\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\n$1 reikiškia pirmą argumentą, kuris paduotas kartu su sciptu\n\n./test_script.sh Linux GNU Intell\nTačiau kas nutinka, jeigu vartotojas nenurodė argumento, nors jio buvo tikimasi\n./test_script.sh Linux GNU Intell\natrodo keistai.\nKaip galima tai išsrpęsti, tai naudoti if ir $# šis kintamasis parodo, kiek argumentų paduota skriptui.\n\nif [ $# -ne 3 ]\nthen\necho \"This script requires exactly 3 arguments and you provided $#\"\necho \"pabandyk dar kartą\"\nexit 1\nfi\n\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\nParašyk skriptą, kuris jeigu paduotas be argumento, parodys sekančių 7 dienų orų prgonozę Vilniui. Bet galimi argumentai gali būti vilnius, kaunas, klaipeda. priklausomai nuo argumento, turėtų būti parodomi atitinkami duomenys.\n\n\n\n14.17 Praktikumas: Serverio Backup skritpas\nhttps://cameronnokes.com/blog/the-most-useful-bash-commands-for-front-end-development/",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#argumentai",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#argumentai",
    "title": "14  Bash Skriptai 1",
    "section": "14.16 Argumentai",
    "text": "14.16 Argumentai\nTu jau žinai, jog komandos priima argumentus, pvz ls -l Downloads priima argumenta Downloads ir atspausdina šios direktorijos turinį. Lygiai taip pat, tu gali naudoti argumentus ir bash skriptams, jeigu nori, suteikti daugiau fleksibilumo jiems.\ntest_script.sh\n#!/bin/bash\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\n$1 reikiškia pirmą argumentą, kuris paduotas kartu su sciptu\n\n./test_script.sh Linux GNU Intell\nTačiau kas nutinka, jeigu vartotojas nenurodė argumento, nors jio buvo tikimasi\n./test_script.sh Linux GNU Intell\natrodo keistai.\nKaip galima tai išsrpęsti, tai naudoti if ir $# šis kintamasis parodo, kiek argumentų paduota skriptui.\n\nif [ $# -ne 3 ]\nthen\necho \"This script requires exactly 3 arguments and you provided $#\"\necho \"pabandyk dar kartą\"\nexit 1\nfi\n\necho \"You enetered this argument $1\"\necho \"Tavo antras ir trečias argumentas yra $2 ir $3\"\n\nParašyk skriptą, kuris jeigu paduotas be argumento, parodys sekančių 7 dienų orų prgonozę Vilniui. Bet galimi argumentai gali būti vilnius, kaunas, klaipeda. priklausomai nuo argumento, turėtų būti parodomi atitinkami duomenys.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas-serverio-backup-skritpas",
    "href": "d_bash_skriptai/13_bash_scripts_1.html#praktikumas-serverio-backup-skritpas",
    "title": "14  Bash Skriptai 1",
    "section": "14.17 Praktikumas: Serverio Backup skritpas",
    "text": "14.17 Praktikumas: Serverio Backup skritpas\nhttps://cameronnokes.com/blog/the-most-useful-bash-commands-for-front-end-development/",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html",
    "href": "d_bash_skriptai/14_bash_scripts_2.html",
    "title": "15  Bash Skriptai 1",
    "section": "",
    "text": "15.1 Kam man reikalingi BASH skriptai?\nKai administruoji (prižiūri) kompiuterius, arba nori automatizuoti tam tikrus procesus savo kompiuteryje, BASH skriptai tampa nepaimainoma pagalba. Štai keli pvz. perinstaliavus Linux, tu gali paleisti skriptą, kuris automatiškai instaliuos visas tavo naudojamas programas bei atstatys tavo nustatymus. O galbūt tu nori, kad kartą per savaitę failai esantys tavo Downloads direktorijoje susitvarkyt ir būtų išskirstyti, o šiukliadėžė išvalyta? O galbūt tu nori, kad reguliariai tavo kompiuteris padarytų savo backup kopiją ir ją patalpintų namų serveryje? Visokiems tokiems su kompiuteriu ar serveriu susijusius veiksmus lengviausia automatizuoti su BASH, nors tiesa, jog daugumą šių veiklų galima padaryti ir su Python arba kitomis programavimo kalbomis.\nNors BASH nėra tikrąją ta žodžio prasme programavimo kalba, BASH tai komandų interpretatorius skirtas interakcijai su tavo SHELL, visgi atzsižvelgiant į tai, jog BASH’e tu gali naudoti kintamuosius, ciklus ir t.t. padaro BASH beveik pilnaverte programavimo kalba.\nAr BASH skriptai reikalingi tik Linux adminsitratoriams? Ne, nors ko gero Linux administratoriai juos naudoja dažniausiai, šis įvadas į BASH skriptus padės geriau suprasti kompiuterinę logiką (ciklus), padės praktikuotis BASH komandas ir įgalins tave ne tik tapti dar labiau IT raštinga, bet ir paklos pamatus tiek Python, tiek Docker ir kitoms IT temoms, kuriose tu ir toliau naudosi Terminalą bei turėsi interakciją su Linux operacine sistema.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#kas-yra-bash-skriptas",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#kas-yra-bash-skriptas",
    "title": "15  Bash Skriptai 1",
    "section": "15.2 Kas yra bash skriptas?",
    "text": "15.2 Kas yra bash skriptas?\nIki šiol tu rašei komandas vieną paskui kitą tiesiogiai į terminalą. Nors išmokai jas sujungti (pipe) visgi tai nevsiada be galo patogus būdas, jeigu pvz norėtum paleisti 150 komandų vieną paskui kitą. Tam naudojami skriptai - tekstinis failas, kuriame surašyta visa komandų seka ir tavo SHELL skaito visas komandas ir vykdo jas vieną paskui kitą.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#hello-world",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#hello-world",
    "title": "15  Bash Skriptai 1",
    "section": "15.3 Hello World",
    "text": "15.3 Hello World\nPasileidus terminalą, susikurk norimoje vietoje direktoriją “learning_bash” naudojant mkdir. Su cd pereik į šią direktoriją. Kol dirbsime su bash skriptais, dirbsime iš šios direktorijos.\nDabar terminale paleisk NANO editorių ir sukuruk faila:\nnano hello_world.sh\nGriežtai žiūrint, .sh nėra reikalingas. Kompiuteris susiduręs su šiuo failu ir taip supras, ką jam daryti. Tačiau tam, kad kiti žmonės greitai pamatytų ir surpastų, jog tai skiptinis failas, įprastai naudoajamas .sh arba .bash.\nPačiame faile įrašyk\necho \"Hello world\"\nIšsaugok failą su Ctrl+s ir Ctrl+x\nAtspausdink su ls -l direktorijos turinį.\nKaip matai, šis failas neturi x taigi joks vartotojas neturi execution teisių. Naudojant sudo chmod 744 hello_world.sh suteik sau visas teises, paliekant grupei ir kitiems vartotojams tik skaitymo teises.\npasitikrink su ls -l ar tikrai turi visas reikiamas teises. Galimai dabar net skriptinis failas pakeitė spalvą ir tapo žalias (?).\nKaip dabar paleisti skirptą?\n./hello_world.sh\nPaleidus šį skriptą BASH interpretatorius skaito eilutę po eilutės ir vykdo komandas.\nTačiau šis skriptas dar nėra visai teisingas. Minėjau, jog failo indikatorius .sh nėra būtinas. tad kaip kompiuteris žino, jog tai skriptas? Įprastai (ir nuo šiol visada) mes pirmoje eilutė yįašome šebang #! kuris pasako SHELL interpretatoiui - “Hey, čia ne komentaras, o nurodymas, kokį interpretatoriu naudoti”. Kaip minėjau pačioje mokymų pradžioje, kai kuriuose kompiuteriuose gali būti BASH, ZSH ir kiti SHELL interpretatoriai. Komanduose jose gali šiek tiek skirtis (skirtingas dialektas, arba būdingos tam tikros komandos). Tam kad nekiltų problemų vykdant šį skriptą (angl. running script), mes nurodome koks būtent interpetatorius /bin/bash turėtų perskaityti ir vykdyti komandas.\n#!/bin/bash\n\necho \"Hello World\"\nSveikinu, tai pirmas pilnavertis tavo BASH skriptas. Pripažinkime, tai labai paprastas skriptas.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#kintamieji",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#kintamieji",
    "title": "15  Bash Skriptai 1",
    "section": "15.4 Kintamieji",
    "text": "15.4 Kintamieji\nKintamieji yra reikalingi tam, kad išsaugotų tam tikras reikšmes. Terminale išbandyk, tik gal įrašyk savo vardą. Svarbu, priešingai nei Python, BASH tarp kintamojo ir = negali būti space ir taip pat tarp = ir argumento!\nmanovardas=\"Justas\"\nmanoskaicius=14\nTol kol šita terminalo sesija rya aktivyi (ir tu neperrašei šių kintamųjų) jie bus pasiekiami tavo terminale. Išbandyk panaudoti šiuos kintamuosius naudojant echo komandą. Kad BASH žinotų, jog tu turi omenyje kintamąjį, reikia naudoti $ prieš kintamojo pavadinimą.Šis procesas vadinamas kintamųjų deklaravimu.\necho $manovardas\necho $manoskaicius\nO dabar pabandyk sudėti viską į vieną sakinį\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nPaskutinę komandą galėjome atspausdinti ir be \"\", tačiau jeigu naudotume '' nieko gero nesigautų. Išbandyk ir įsitikink\necho Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\necho 'Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius'\nŠtai todėl, dažniausiai ir naudojame \"\"\nKas nutiktu jeigu panaudtum kintamąjė, kuris nėra deklaruotas\necho $blabla\nOgi nieko. Bash tau neišmes klaidos ir atspausdins tiesiog tuščią vietą.\nPbanadyk uždaryti terminalą ir atsidaryk iš jį iš naujo. Pakartok komandą\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius\"\nir įsikitkink, jog kintamieji neišsisaugojo. Taigi, kintamieji kuriuos sukuri temrinalo sesijoje, glaioje tik toje terminalo sesijoje. Išjungus terminalą, ar restartavus kompiuterį - viskas dingsta.\nTam kad neprarasti kintamųjų, mes juos išsaugome kartu su komandomis skripto viduje. Su NANO sukurk naują skriptą apie_mane.sh\n#!/bin/bash\n\nmanovardas=\"Justas\"\nmanoskaicius=14\nmanoamzius='39'\n\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nŠiuo metu tavo skriptas yra begalo paprastas ir vienu žvilsniu suprantamas. Tačiau ilgainiui, tau gali reikėti pridėti komentarus, t.y. priminimus sau, arba paaiškinimus kitiems, kas vyksta kode ir t.t. Tam naudojami komentarai. Skritpuose komentarai pradedami # (nors gali naudoti ir kelis). Viskas į dešinė nuo # toje pačioje eilutė nebus interpretuojama kaip kodas, o BASH supras jog tai yra komentaras ir jo neskaitys.\nPridėkime kelis komentarus;\n#!/bin/bash\n# =====================================================\n# Data: 2024-10-30\n# Autorius: Justas Mundeikis\n# Paskirtis: Atspasdinti informaciją apie mane\n# =====================================================\n\n## Deklaracijos\nmanovardas=\"Justas\" # deklaruojamas vardas, pasikeisk į savo\nmanoskaicius=14 # deklaruojamas skaičius, pasikeisk į savo\nmanoamzius='39' # deklaruojamas amžius, pasikeisk į savo\n\n## Funkcijos\necho \"Mano vardas: $manovardas ir mano mėgstamiausias skaičius yra $manoskaicius.\"\necho \"Mano amžius yra $manoamzius\"\nIšbandyk su ./apie_mane.sh.\nKaip matai, pridėjau skripto virųuje vaidnamą header (virtutinėje) dalyje, komentarus, kurie informuoja apie tai, kas, kada sukurė šį skriptą. Ar yra privalomi paminėti dalykai? Ne. Tačiau geroji praktika rodo, kad autorius, data ir paskirtis neretai rpaverčia net sau pačiamm atsidarius skriptus po kiek laiko, greičiau susigaudyti. Jeigu kažkada tavo skritpai taptų labai įmantrūs, tada komentaras header skiltyje galėtų būti dar išsamesnis, štai ChatGPT man pasiūlė net aprašyti kokie yra dependencies, pvz jeigu skriptas naudoja komanda,s kurios ali būti neinstaliuotos. Tada kitas vartotojas atsidaręs iškart matys ką turi instaliuoti, jog skriptas veiktų, o ne pirma paleidus skritpą ir sulaukus klaidos, ieškoti ko trūko.\n#!/bin/bash\n#====================================================================\n# Script Name: script_name.sh\n# Description: Briefly describe what the script does.\n# Usage: ./script_name.sh [options] [arguments]\n# Author: Your Name\n# Created Date: YYYY-MM-DD\n# Version: 1.0\n# Last Modified: YYYY-MM-DD\n# Dependencies: List dependencies like `curl`, `awk`, or other scripts.\n# Requirements: Any system requirements or permissions needed.\n# Notes: Additional helpful notes, warnings, or cautions.\n#====================================================================\nDabar tau gali kilti klausimas - o kodėl neparašius komandos, kad instaliuoti iškart šiuos dependencies? Nebent tavo skriptas yra skirtas programų instaliavimui ir kitas vartotojas tai supras ir tu tai dokumentavai, pvz README.md faile… nėra labai ger apraktika tiesiog paleisti instialiavią kažkieno kito kompiuteryje. Be to, tu negli būti tikra, ar tia Linux, ar MacOs sistema. O net Linux, gali būti naudoajmas ne apt programū menedžeris, o dnf ir t.t. Taigi, ir saugiau ir lengviau leisti tam tikruas programas susiinstaliuoti pačiam vartotojui.",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#matematinės-funkcijos",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#matematinės-funkcijos",
    "title": "15  Bash Skriptai 1",
    "section": "15.5 Matematinės Funkcijos",
    "text": "15.5 Matematinės Funkcijos",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#if-else",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#if-else",
    "title": "15  Bash Skriptai 1",
    "section": "15.6 IF ELSE",
    "text": "15.6 IF ELSE",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#išeities-kodai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#išeities-kodai",
    "title": "15  Bash Skriptai 1",
    "section": "15.7 Išeities kodai",
    "text": "15.7 Išeities kodai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#while-ciklai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#while-ciklai",
    "title": "15  Bash Skriptai 1",
    "section": "15.8 WHILE ciklai",
    "text": "15.8 WHILE ciklai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas",
    "title": "15  Bash Skriptai 1",
    "section": "15.9 Praktikumas",
    "text": "15.9 Praktikumas",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#for-ciklai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#for-ciklai",
    "title": "15  Bash Skriptai 1",
    "section": "15.10 FOR ciklai",
    "text": "15.10 FOR ciklai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#kur-saugoti-skriptus",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#kur-saugoti-skriptus",
    "title": "15  Bash Skriptai 1",
    "section": "15.11 Kur saugoti skriptus?",
    "text": "15.11 Kur saugoti skriptus?",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#data-streams-stdin-stdout-stderror",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#data-streams-stdin-stdout-stderror",
    "title": "15  Bash Skriptai 1",
    "section": "15.12 Data Streams (stdin, stdout, stderror)",
    "text": "15.12 Data Streams (stdin, stdout, stderror)",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#funkcijos",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#funkcijos",
    "title": "15  Bash Skriptai 1",
    "section": "15.13 Funkcijos",
    "text": "15.13 Funkcijos",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#case",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#case",
    "title": "15  Bash Skriptai 1",
    "section": "15.14 CASE",
    "text": "15.14 CASE",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#cron",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#cron",
    "title": "15  Bash Skriptai 1",
    "section": "15.15 CRON",
    "text": "15.15 CRON",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#argumentai",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#argumentai",
    "title": "15  Bash Skriptai 1",
    "section": "15.16 Argumentai",
    "text": "15.16 Argumentai",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  },
  {
    "objectID": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas-serverio-backup-skritpas",
    "href": "d_bash_skriptai/14_bash_scripts_2.html#praktikumas-serverio-backup-skritpas",
    "title": "15  Bash Skriptai 1",
    "section": "15.17 Praktikumas: Serverio Backup skritpas",
    "text": "15.17 Praktikumas: Serverio Backup skritpas",
    "crumbs": [
      "Bash Skriptai",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Bash Skriptai 1</span>"
    ]
  }
]