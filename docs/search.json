[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Linux vaikams ir pradedantiesiems",
    "section": "",
    "text": "Įvadas",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#operacinė-sistema",
    "href": "index.html#operacinė-sistema",
    "title": "Linux vaikams ir pradedantiesiems",
    "section": "Operacinė sistema",
    "text": "Operacinė sistema\nKai tu įjungi savo telefoną, kompiuterį ar mikrokompiuterį, jame pasileidžia programa - instrukcijų rinkinys, kuris nurodo, kaip tavo prietaisas turi veikti. Ši programa nurodo, pavyzdžiui, įjungus prietaisą pradėti šviesti ekranui, paspaudus klavišus abc suprasti, kad tu rašai, arba įjungus elektros kabelį pradėti krauti bateriją.\n\n\n\nKompiuteris. Autorius: Alessandro Oliverio\n\n\nŠis instrukcijų rinkinys dar nėra visavertė operacinė sistema. Tai yra vadinamasis branduolys (angl. - kernel), kuris nurodo, kaip turi veikti kompiuterinė įranga tarpusavyje.\nŠalia branduolio yra ir kita programinė įranga, kuri leidžia tau naudotis prietaisu - tai įvairiausios programos, pvz., skambinimo programėlė, kalkuliatorius, interneto naršyklė. Visa ši programinė įranga kartu su branduoliu sudaro operacinę sistemą (angl - operating system, arba - OS).\nTaigi operacinė sistema (OS) yra programinė įranga, kuri valdo kompiuterinės įrangos ir programų išteklius. Ji veikia kaip tarpininkė tarp vartotojo ir kompiuterio aparatūros. Pagrindinės populiarios operacinės sistemos yra Windows, UNIX šeimos OS - macOS, ir Linux.\n\nWindows: Microsoft korporacijos sukurta populiariausia operacinė sistema, naudojama tiek namų, tiek verslo kompiuteriuose. Ji žinoma dėl savo patogumo ir plataus programų pasirinkimo.\nmacOS: Apple korporacijos operacinė sistema, naudojama Mac kompiuteriuose. Ji žinoma dėl savo dizaino, stabilumo ir integracijos su Apple ekosistema.\nLinux: Atviro kodo operacinė sistema, kurią gali keisti ir dalintis visi norintys. Ją naudoja dauguma serverių ir technologijų entuziastų.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#ubuntu-skoniai",
    "href": "index.html#ubuntu-skoniai",
    "title": "Linux vaikams ir pradedantiesiems",
    "section": "Ubuntu skoniai",
    "text": "Ubuntu skoniai\nLinux yra atviro kodo operacinė sistema, todėl ją gali keisti ir dalintis visi norintys. Dėl to yra nemažai programuotojų, kurie nusprendžia pasidalinti savo pagamintais Linux variantais, vadinamais distribucijomis.\n\n\n\nLinux distribucijų medis\n\n\nKai tu įjungi telefoną arba kompiuterį, branduolys užtikrina, kad visi kompiuterio komponentai galėtų tarpusavyje bendrauti. Vis dar trūksta programų, kurios rodytų vaizdus ekrane, leistų įvesti tekstą ir pan. Tam yra reikalingos papildomos programos, dauguma jų buvo sukurtos GNU projekto metu. Tačiau tik branduolys ir GNU programos dar neleistų visavertiškai naudotis kompiuteriu, todėl papildomai diegiamos įvairios reikalingos programos, kurios padaro operacinę sistemą praktiška ir gražiai atrodančia.\nTaigi, pilną operacinę sistemą, dar kartais vadinamą Linux distribucija (distribution), sudaro:\n\nLinux branduolys (kernel)\nGNU programos\nPapildomos programos ir grafinis dizainas",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#kodėl-linux",
    "href": "index.html#kodėl-linux",
    "title": "Linux vaikams ir pradedantiesiems",
    "section": "Kodėl Linux",
    "text": "Kodėl Linux\nGrįžkime prie klausimo - “Kodėl Linux”?\n\nSaugumas: Linux dažnai laikoma saugesne operacine sistema dėl savo architektūros ir mažesnio virusų kiekio.\nServeriai: Linux arba jai giminingos UNIX sistemos veikia beveik visuose pasaulio serveriuose. Greičiausiai net tavo namuose yra ne vienas įrenginys, kuriame veikia Linux.\nUniversalumas: tiek iOS, tiek Android taip pat veikia UNIX pagrindu.\nLankstumas ir pritaikomumas: Linux leidžia tau būti labiau savarankiškam ir geriau suprasti, kaip veikia kompiuteriai. Tuo pačiu metu išmoksti dalykų, kurių nemoka kiti.\nProgramavimas: Linux yra gera pradžia kelionei į Python ir kitas programavimo kalbas, kurios naudojamos programuojant robotus, kuriant interneto svetaines ar atliekant skaičiavimus su dideliais duomenų kiekiais.\n\nŠiais laikais vis daugiau ir daugiau profesijų kasdienėje veikloje reikia programavimo. Buhelteriai naudojasi Python,kad greičiau apdorotų duomenis. Architektai ir inžinieriai, kad teisingai apskaičiuotų pastato konstrukcijas. Transporto srauto specialistai, kad planuotų ir valdytų automobilių srautus, o NASA darbuotojai, kad valdytų į kosmoosą kylančias raketas.\nTaigi Linux ir tam tikra prasme - programavimas, paruošia tave 21-ajam amžiui.\nNegana to, Linux veikia ant tokių paprastų mikrokompiuterių kaip Raspberry Pi Zero ir gali atgaivinti net 10-20 metų senumo nešiojamą kompiuterį. Taigi, tai padeda tausoti gamtą, nes savo technika gali naudotis ilgiau.\nBet yra ir kita medalio pusė. Ne visos tavo įprastos programos veikia Linux. Pavyzdžiui, Adobe produktai tiesiog neveikia Linux aplinkoje. Microsoft Excel ir Word taip pat nėra pritaikyti Linux. Jei tavo mokslui ar darbui yra būtinos tam tikros programos, Linux gali neatitikti tavo lūkesčių. Tačiau reikia žinoti, kad daugelis šių programų turi analogus Linux aplinkoje. Dažniausiai jie yra atviro kodo ir nemokami.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#linux-mint",
    "href": "index.html#linux-mint",
    "title": "Linux vaikams ir pradedantiesiems",
    "section": "Linux Mint",
    "text": "Linux Mint\nKaip jau minėjau, yra daug Linux distribucijų. Šiame vadovėlyje naudosime vieną iš paprasčiausių - Linux Mint distribuciją, kuri sukurta Ubuntu pagrindu.\nJą galima parsisiųsti iš linuxmint.com. Kaip ją instaliuoti, gali šiek tiek skirtis priklausomai nuo kompiuterio, tad geriausia šioje vietoje tiesiog paieškoti vaizdo įrašo Youtube svetainėje.",
    "crumbs": [
      "Įvadas"
    ]
  },
  {
    "objectID": "1_linux_configure.html",
    "href": "1_linux_configure.html",
    "title": "1  Linux konfiguracija",
    "section": "",
    "text": "1.1 Intro",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux konfiguracija</span>"
    ]
  },
  {
    "objectID": "2_linux_intro_terminal.html",
    "href": "2_linux_intro_terminal.html",
    "title": "2  Susipažinkime su Terminal",
    "section": "",
    "text": "3 Slapta žinutė\nLabas! Aš turiu tau slaptą žinutę:\nSmVpZ3UgdGF1IHBhdGlrbywgZ2FsIG5vcmkgdMSZc3RpIGlyIG1va3l0aXMgcHJvZ3JhbXVvdGkg bnVvIHJ1ZGVucz8K\nDabar tu galvoji, ką šis kodas gali reikšti? Tavo kompiuteris gali tau padėti dekoduoti šią žinutę!\nBet kad kopiuteris tau padėtų - pirma turi išmokti su juo kalbėtis. Ši pamoka ir bus apie tai kur ir kaip kalbėtis su kompiuteriu.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Susipažinkime su Terminal</span>"
    ]
  },
  {
    "objectID": "2_linux_intro_terminal.html#pažink-terminalą",
    "href": "2_linux_intro_terminal.html#pažink-terminalą",
    "title": "2  Susipažinkime su Terminal",
    "section": "4.1 Pažink Terminalą",
    "text": "4.1 Pažink Terminalą\nTau atsidarys toks baisus juodas langas. Bet tau jo visai nereikia bijoti. Čia tik langas, per kurį gali bendrauti su kompiuteriu, pasakant jam, ką tu nori, kad jis padarytų.\n\nTerminalas yra speciali programa tavo kompiuteryje, panaši į žaidimų platformas kaip Roblox ar YouTube. Tačiau vietoje to, kad žaidžiame ar žiūrėtume vaizdo įrašus, į ją rašome komandas - įsakymus kompiuteriui.\nKomandos yra būdas pasakyti kompiuteriui, ką jam daryti. Kadangi kompiuteris negali suprasti lietuviškai arba angliškai, jam reikia specialios kalbos. Viena iš tokių kalbų yra BASH.\nBASH (tariasi beeš) yra speciali kompiuterinė kalba, kurią naudojame bendraudami su terminalo programa. Ji leidžia mums rašyti ir vykdyti įsakymus arba komandas, kad galėtume valdyti kompiuterį. Panašiai kaip žmonės kalba skirtingomis kalbomis (pvz., lietuvių arba anglų), BASH yra mūsų būdas bendrauti su kompiuteriu, leidžiantis mums atlikti daug įvairių veiksmų - nuo paprastų failų valdymo iki sudėtingesnių komandų vykdymo.\nKitaip tariant, BASH yra kalba, kuri leidžia mums parašyti ir suprasti komandas, kurios padeda mums dirbti su kompiuteriu ir atlikti norimus veiksmus per terminalą.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Susipažinkime su Terminal</span>"
    ]
  },
  {
    "objectID": "2_linux_intro_terminal.html#pirma-komanda---echo",
    "href": "2_linux_intro_terminal.html#pirma-komanda---echo",
    "title": "2  Susipažinkime su Terminal",
    "section": "4.2 Pirma Komanda - echo",
    "text": "4.2 Pirma Komanda - echo\nPasiraitokime rankoves ir kibkime į darbą.\nPirmoji komanda (įsakymas kompiuteriui) bus - echo. Komanda echo atspausdina po jos sekantį tekstą.\nPabandykime pasisveikinti. Atkartok šią komandą terminale:\necho \"Labas rytas\"\nir tada nuspausk Enter klavišą. iš tiesų jų yra net 2! Ir kartais jie dar vadinami return, nes senovinėse spausdinimo mašinose jie gražindavo (angl. - return) eilutę į praždią.\n\n\nAr pastebėjai, kas nutiko? Kompiuteris tave išgirdo ir pakluso tavo komandai.\n\n\n4.2.1 Kas čia yra Kas?\n\nMatai šitą dolerio ženklą $? Jis angliškai vadinamas prompt ir reiškia, kad kompiuteris yra pasirengęs gauti iš tavęs komandą ir laukia jos.\n\n\n\necho yra komanda, kuri priima tekstą ir jį atspausdina. Ji gali atspausdinti čia, ekrane (terminale), bet gali ir atspausdinti kažkur kitur, pvz., nukreipiant tekstą į kokį nors failą. Kaip komanda žino, ką spausdinti? Ji priima argumentą. Argumentas – tai, ką tu pasirenki duoti tai komandai. Šiuo atveju argumentas yra tekstas tarp abiejų kabučių \"Labas rytas\".\n\n\n\nArgumentas – tarsi maisto produktas, kurį įdedi į maisto gaminimo įrenginį. O echo – tarsi maisto gaminimo įrenginys, kuris tą produktą apdoroja ir pagamina kažką skanaus.\n\n\nKaip matai, sekančioje eilutėje nėra $ ženklo. Nes toje eilutėje kompiuteris atsakė tau :)\n\nKai jis tai padarė, vėl pasiruošė tavęs klausyti, nes paruošė kitą eilutę, kurioje paliko prompt ženklą - $ ir laukia naujos tavo komandos.\n\n\n4.2.2 Challange:\nDabar visišai savarankiškai atspausdink žemiau pateiktą tekstą:\nLabas rytas suraitytas, meškos koja parašytas!\nPagalba:\n\nNaudok komandą echo.\nTekstas turi būti apsuptas kabutėmis \"......\".\nKad paleistum komandą – spausk Enter klavišą.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Susipažinkime su Terminal</span>"
    ]
  },
  {
    "objectID": "2_linux_intro_terminal.html#teksto-nukreipimas-į-failą--",
    "href": "2_linux_intro_terminal.html#teksto-nukreipimas-į-failą--",
    "title": "2  Susipažinkime su Terminal",
    "section": "4.3 Teksto nukreipimas į failą - >",
    "text": "4.3 Teksto nukreipimas į failą - &gt;\nŠaunu! Judam toliau… Dabar pabandysime tai, ką tau kompiuteris atspausdino į Terminal langą, nukreipti į failą. Ką tai reiškia? Tai reiškia, jog kompiuteris neatspaudins teksto Terminal lange, vietoj to, jis sukurs failą ir patalpins tavo norimą tekstą į jo vidų. Taip tavo tekstas gali būti išsaugotas. Išsaugoti angliškai - save.\nNukreipimas į failą įvyksta naudojant &gt; simbolį. Po šio simbolio seka failo pavadinimas, į kurį nurime nukreipti tekstą. Tačiau šis simbolis yra galingas bet ir pavojingas! Jis sukuria failą, jeigu to failo dar nėra, bet jeigu failas tokiu pat pavadinimu jau yra, jis jį perrašo.\nPabandyk:\necho \"Labas rytas, katine\" &gt; pasaka.txt\n\necho yra komanda.\n\"Labas rytas, katine\" yra argumentas skirtas echo komandai.\n&gt; nukreipia tai, kas įvyko prieš tai į failą\npasaka.txt yra failo pavadinimas, kurė sukuriame ir į kurį įrašome tekstą.\n\nJeigu viską padarei teisingai, tavo langas turėtų atrodyti taip:\n\nKompiuteris ir vėl laukia tavo komandos. Bet kur atsirado failas?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Susipažinkime su Terminal</span>"
    ]
  },
  {
    "objectID": "2_linux_intro_terminal.html#failų-naršyklė---files",
    "href": "2_linux_intro_terminal.html#failų-naršyklė---files",
    "title": "2  Susipažinkime su Terminal",
    "section": "4.4 Failų naršyklė - Files",
    "text": "4.4 Failų naršyklė - Files\nMatai, kompiuteris įvykdė komandą ir vėl tavęs klauso! Bet kur nuėjo tas “Labas rytas, katine!”? Juk jo nėra Terminal lange? Kad rasti, atsidaryk naują programą, šį kartą paieškoje įvesk „Files“.\n\nTau atsidarė failų naršyklė, angliškai dažnai vadinama „File Explorer“.\nPažiūrėkime, ką čia matome…\n\nMatome daug aplankų: Desktop, Documents, Downloads ir jie atsikaroja dešinėje pusėje\nBet štai ir failas pasaka.txt!\n\n\nPaspausk ant pasaka.txt du kartus su pele, jis tau atsidarys su teksto redagavimo programa.\n\nUždaryk visus visus ir pasiruošk nedideliam challange!\n\n4.4.1 Challange\n\nIš naujo atsidaryk Terminal langą\nNaudojantis echo ir &gt; išsaugok šį tekstą\n\nLietuva, Tėvyne mūsų Tu didvyrių žeme, Iš praeities Tavo sūnūs Te stiprybę semia.\n\nIšsaugok tekstą faile pavadinimu himnas.txt\nAtsidary Files programą, rask himnas.txt\nAtsidaryk failą ir patvirtink, jog iš tiesų išsaugojai Lietuvos himno pimąją eilutę.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Susipažinkime su Terminal</span>"
    ]
  },
  {
    "objectID": "2_linux_intro_terminal.html#komanda---cat",
    "href": "2_linux_intro_terminal.html#komanda---cat",
    "title": "2  Susipažinkime su Terminal",
    "section": "4.5 Komanda - cat",
    "text": "4.5 Komanda - cat\nDabar tau gali kilti klausimas, o kodėl reikėjo atsidaryti šitą failą taip komplikuotai. Negi nėra paprastesnio būdo?\nYRA!\nTerminale įrašyk komandą cat ir perleisk jai argumentą – failo pavadinimą, kurį cat komanda turi perskaityti! Paspausk Enter klavišą.\ncat pasaka.txt\nKą matai?\n\nNieko sau! cat komanda perskaitė tavo failą ir jį atspausdino Terminal lange. Tau nereikėjo eiti į Files susirasti ir atsidaryti failo. Tu viską gali padaryti Terminal lange.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Susipažinkime su Terminal</span>"
    ]
  },
  {
    "objectID": "2_linux_intro_terminal.html#teksto-nukreipimas-į-failą---1",
    "href": "2_linux_intro_terminal.html#teksto-nukreipimas-į-failą---1",
    "title": "2  Susipažinkime su Terminal",
    "section": "4.6 Teksto nukreipimas į failą - >>",
    "text": "4.6 Teksto nukreipimas į failą - &gt;&gt;\nPameni minėjau, jog &gt; sukuria failą, jeigu jo nėra, o jeigu jis jau yra, tada perrašo jį. Dėl to ši komanda yra gana pavojinga.\nPabandyk nusiųsti šį tekstą į pasaka.txt\necho \"Labas maužyle\" &gt; pasaka.txt\no tada atspausdinti pasaka.txt terminale:\ncat pasaka.txt\nO ne, dingo prieš tai buves tekstas :(\n\nTam kad neperrašyti failo, o tik pridėti naują eilutę failo apačioje, galima naudoti &gt;&gt; t.y. dvigubas &gt;.\n\n\n4.6.1 Challange\nPraėjusiam challange tu įrašei pirmą Lietuvos himno posmą. Tad dabar antrojo posmo eilė:\nTegul Tavo vaikai eina Vien takais dorybės Tegul dirba Tavo naudai Ir žmonių gėrybei.\n\nPirma pasitikrink su komanda cat ar tikrai turi failą himnas.txt ir ar jame tik pirmo posmo tekstas?\nNaudojant echo ir &gt;&gt; pridėk antro posmo tekstą\nSu komanda cat pasitikrink ar tikrai abu posmai išsisaugojo.\nJeigu eilutės neatrodo gražiai pasidink terminalo langą ir pakartok komandą",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Susipažinkime su Terminal</span>"
    ]
  },
  {
    "objectID": "2_linux_intro_terminal.html#naudingi-klavišų-trumpiniai-shortcuts",
    "href": "2_linux_intro_terminal.html#naudingi-klavišų-trumpiniai-shortcuts",
    "title": "2  Susipažinkime su Terminal",
    "section": "4.7 Naudingi klavišų trumpiniai (shortcuts):",
    "text": "4.7 Naudingi klavišų trumpiniai (shortcuts):\nDvi komandos, kurias turi išmokti čia ir dabar:\n\nPaspaudus du klavišus vienu metu CTRL ir L, Terminal langas išsivalo ir tu nebematai senų komandų.\nKartais tu gali įrašyti kažką neteisingai, padaryti klaidą ir kompiuteris gali nesuprasti. Tada geriausia nuspausti CTRL ir C klavišus. Tai įpareigoja kompiuterį nutraukti tavęs klausymąsi, ištrinti tai, ką dabar darai, ir pradėti klausytis vėl iš naujo.\n\nPabandyk:\nPirma įrašyk echo “Labas rytas bet neužbaik teksto įvedimo, nepadėk kabučių ir spausk Enter. Dabar vietoj atspausdinto teksto arba vietoj prompt $ matai šitą ženklą &gt;. Jis reiškia, kad kompiuteris laukia, kol tu pabaigsi įrašyt tekstą. Spaudžiant Enter – nieko nesigauna.\nNuspaudus CTRL + C nutrūksta komandos įrašymas.\nTaip pat, jeigu žinai ko trūksta, šiuo atveju užaryti tekstą kabutėmis, gali įrašyti ir spausti Enter.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Susipažinkime su Terminal</span>"
    ]
  },
  {
    "objectID": "2_linux_intro_terminal.html#slaptos-žinutės-dekodavimas",
    "href": "2_linux_intro_terminal.html#slaptos-žinutės-dekodavimas",
    "title": "2  Susipažinkime su Terminal",
    "section": "4.8 Slaptos Žinutės Dekodavimas:",
    "text": "4.8 Slaptos Žinutės Dekodavimas:\nNa štai, išmokai naudotis terminalu, žinai kas yra komanda, argumentas. Taip pat moki nukreipti tekstą į failą. Moki pakankamai, jog dekoduoti paslaptingą žinutę!\n\nPasinaudok komanda echo ir kaip jos argumentą įrašyk mano slaptą žinutę (su pele pažymėk visą kodą, paspausk dešinį pelės mygtuką ir spausk ant COPY). Tada terminale po echo ” su pele spausk ant terminalo, tada paspausk dešinį mygtuką ir spausk ant PASTE. Tačiau dar nespausk ENTER, nepamiršk, jog čia tekstas, kurį reikia uždaryti su “, kad jis niekur nepabėgtų :)\nIšsaugok visa tai pasinaudodama &gt; ir sukuriant failą pavadinimu kodas.txt.\nGali pasitikrinti, ar kodas.txt tikrai turi slaptą žinutę, pasinaudodama cat komanda ir perleisdama jai argumentą kodas.txt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Susipažinkime su Terminal</span>"
    ]
  },
  {
    "objectID": "2_linux_intro_terminal.html#šifravimo-komanda---base64",
    "href": "2_linux_intro_terminal.html#šifravimo-komanda---base64",
    "title": "2  Susipažinkime su Terminal",
    "section": "4.9 Šifravimo komanda - base64",
    "text": "4.9 Šifravimo komanda - base64\nNa, o dabar belieka pasinaudoti dar viena komanda:\nKomanda base64 moka koduoti ir dekoduoti. -d yra parametras ir reiškia dekoduoti. kodas.txt yra argumentas, tavo anksčiau sukurtas failas, kurio viduje yra kodas.\n\nParametras yra papildomas nustatymas komandai base64. Įsivaizduok komanda būtų kaip įsakymas “Kepti orkaitėje”, o paramtetras “nustačius 200 laispnių temperatūrą”.\n\nbase64 -d kodas.txt\nAr pavyko dekoduoti mano žinutę?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Susipažinkime su Terminal</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html",
    "href": "3_linux_update.html",
    "title": "2  Linux atnaujinimas",
    "section": "",
    "text": "2.1 Pradžia\nVisuose kompiuteriuose yra daugybė įvairių programų. Pavyzdžiui, jau susipažinome su Terminal ir Files programomis. Taip pat išmokome naudoti kai kurias įdiegtas komandas: echo, cat, ir base64. Šių programų kūrėjai dažnai atnaujina savo programas, tad norėdami pasinaudoti naujausiomis funkcijomis ir pataisymais, turime įdiegti šiuos atnaujinimus (angl. - update).\nŠioje pamokoje sužinosime:\nBe to, išmoksime:\nŠis skyrius padės išmokti, kaip efektyviai tvarkytis su programomis ir jų atnaujinimais, kad kompiuteris visada būtų naujausias ir veiktų be trikdžių.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#update-manager",
    "href": "3_linux_update.html#update-manager",
    "title": "2  Linux atnaujinimas",
    "section": "2.2 Update Manager",
    "text": "2.2 Update Manager\nUpdate Manager yra programa, kuri padeda atnaujinti kitas programas tavo kompiuteryje. Ji pati praneša, kai laikas atnaujinti programas. Kai internete yra prieinami atnaujinimai, dešiniame kampe atsiranda skydelio su raudonu tašku piktograma (raudonas taškas reiškia, kad yra naujų atnaujinimų).\n\n\nBet jei nematai šios piktogramos, gali paleisti “Update Manager” programą per Menu:\n.\nPirmą kartą paleidus šią programą, gali pamatyti tokį langą, kuris paaiškina, ką ji daro. Drąsiai spausk ant OK.\n\nJei pamatysi, kad pačiai programai reikia atnaujinimo, spausk ant “Apply the Update” (lt. - įdiegti atnaujinimą). Taip pat gali matyti užrašą switch to a local mirror, kol kas spausk No. Kas yra veidrodžiai (angl. - mirrors), pakalbėsime netrukus.\n\nJei paspaudus “Apply the Update” kompiuteris paprašys tavo slaptažodžio, įvesk jį. Taip kompiuteris įsitikina, kad tik tu ar kitas vartotojas, kuriam priklauso šis kompiuteris, gali atlikti pakeitimus. Drąsiai įvesk savo slaptažodį ir spausk Authenticate (lt. - patvirtinti tapatybę).\n\nNetrukus pamatysi vaizdą, kuris gali atrodyti panašiai - vienas ar keli, o gal net daugybė skirtingų programų atnaujinimų, kuriuos gali įdiegti savo kompiuteriui. Tačiau kol kas dar nieko nespauskime. Susipažinkime su tuo, ką čia matome:\n\n\n\nType - kokio tipo yra atnaujinimas? Jie gali būti:\n\nSecurity update - saugumo atnaujinimas. Jo simbolis yra skydelis. Tai svarbiausias atnaujinimas, kurį reikia kuo skubiau įdiegti, kad kompiuteris būtų saugus.\nKernel update - pagrindinės Linux sistemos atnaujinimas. Jo simbolis yra žaibas. Šie atnaujinimai pagerina, kaip veikia pats kompiuteris. Ar ekranas rodo gerai? Ar veikia pelė? Ir t.t.\nSoftware update - programų atnaujinimai. Tai atnaujinimai, kuriuos programų kūrėjai sukuria, kad jų programos veiktų geriau, turėtų daugiau funkcijų ir pan.\n\n\nŠiame lange taip pat gali paspausti ant:\n\n\nClear - išvalyti visus pasirinktus atnaujinimus\nSelect All - pasirinkti visus atnaujinimus\nRefresh - atnaujinti sąrašą atnaujinimų, kurie yra prieinami\nInstall Updates - įdiegti pasirinktus atnaujinimus\n\nBet kaip kompiuteris žino, kokias programas atnaujinti? Ir iš kur jis jas atsisiunčia?\n\n2.2.1 Mirrors ir Updates\nVeidrodėli, veidrodėli, kas pasaulyje gražiausia?\n\nPradėkime nuo pradžių…\nĮsivaizduok, kad programuotoja, kuri kuria programas, dirba iš namų, kaip ir tu. Po ilgos darbo savaitės, ji nusprendžia: “Viskas, programos atnaujinimas paruoštas. Ištaisyta klaida, įdiegti nauji patobulinimai”.\n\n(Nuotraukoje Jaime Gunther, kuri 38 metų nusprendė, kad mokysis savarankiškai programuoti ir tapo programuotoja)\nBet dabar įsivaizduok, kad keli milijonai žmonių bandytų parsisiųsti iš jos kompiuterio šiuos atnaujinimus. Jos kompiuteris negalėtų to atlaikyti, ir viskas strigtų bei vyktų labai lėtai.\nTodėl programuotoja naudoja serverius veidrodžius (angl. - mirrors).\n\nKas yra serveris? Serveris yra didelis kompiuteris, kuris pastatytas specialiose vietose ir gali aptarnauti milijonus žmonių vienu metu. (daugiau nuotraukų gali rasti čia)\n\n\n\nKodėl jie vadinami veidrodžiais (angl. - mirrors)? Nes jie atspindi tuos programinius pakeitimus, kuriuos programuotoja padarė savo namuose. Kai ji kažką atnaujina, šie serveriai iškart tai atspindi, ir tu gali parsisiųsti atnaujinimus neapkraudamas programuotojos namų kompiuterio!\n\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuris turi sąrašą, kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs, priklauso programų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitikrinti ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasties kartais tavo kompiuteris paklausia, ar nori prisijungti prie vietinių veidrodinių serverių - “Do you want to switch to a local mirror?”\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuriame yra sarašas kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs nutolęs, priklauso prgramų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitiktrinti, ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasies, kartais tavo kompiuteris paklausia, ar nori prisijngti prie lokalių veidrodžių.\nKaip tai padaryti?\n\nSpausk ant “Edit” (pakeitimai) ir tada ant “Software Sources” (programų šaltiniai).\nKompiuteris vėl paprašys tavo slaptažodžio, įvesk jį.\nAtsidariusiame naujame lange pamatysi Main ir Base veidrodžius. Jie gali būti nustatyti ne visai ten, kur gyveni tu.\nSpustelk pele prie Main. Atsidarys langas, kuriame bus serveriai, surūšiuoti pagal tai, kaip arti tavęs jie yra (pagal atsisiuntimo greitį). Tu pamatysi, kad po kelių sekundžių sąrašo viršus nebekinta. Tau nereikia laukti, kol kompiuteris parsisiųs visų serverių informaciją. Pasirink patį pirmą serverį\nPakartok tai su Base serveriu.\nSpustelk ant “Update the mirrors” (atnaujinti veidrodinius serverius). Tai gali truputį užtrukti.\nAtnaujinus, pamatysi, kad buvusius serverius pakeitė kiti, tavo pasirinkti serveriai.\nDabar gali uždaryti šį langą.\n\nVisas procesas šiame video:\nVideo\nDabar gali atnaujinti programas, paspaudus ant Install Updates. Gali atsirasti papildomi langai, kur paklaus, ar tikrai nori įdiegti atnaujinimus, gali paprašyti ir įvesti tavo slaptažodį dar kartą. Visur drąsiai sakyk “taip” ir įrašyk savo slaptažodį.\nTačiau yra ir kitas būdas! Naudojant Terminal.\nVeidrodinių serverių atnaujinimas yra būtinas net kai įdiegi atnaujinimus per Terminalą. Tad retkarčiais pasitikrink, ar pasirinkti vis dar sparčiausi veidroriniai serveriai.\n\n\n2.2.2 Atnaujinimų instalivimas per Terminal\nKodėl kartais geriau įdiegti atnaujinimus per Terminal programą? Visų pirma - tu praktikuojiesi BASH kalbos žinias! Visų antra, vėliau išmoksi, kaip vos kelių klavišų paspaudimu tai padaryti daug greičiau nei spaudant su pele ir naudojant Update Manager programą.\nŠtai taip atrodo kodas, kurį reikės įrašyti:\nsudo apt update && \nsudo apt full-upgrade -y && \nsudo apt autoremove -y && \nflatpak update\nDabar tavo galvoje gal atrodo taip:\n\nPradėkime nuo pradžių ir eikime per visas komandas, kad jas suprastume. Kai suprasi - pamatysi, kad viskas gana paprasta.\nMes galime visas komandas surašyti į vieną eilutę, bet paprastumo dėlei, terminale įrašyk komandą po komandos, kaip pateiktia žemiau.\n\nsudo apt update.\n\n\nčia iššaukiama komanda apt. Tai yra programa, kuri rūpinasi programų atnaujinimu.\nupdate yra argumentas, ką programa turi daryti. Priešingai nei atrodo, ji neatnaujina programų. Ką ji padaro, tai palygina tavo kompiuterio programas su tuo, kas yra veidrodiniuose serveriuose (mirror). Jeigu ji aptinka skirtumą, nes, pvz., serveryje programa yra naujesnė, apt tave informuos apie galimus atnaujinimus.\nO kas yra sudo? Atsimeni, kai Update Manager tavęs prašė įrašyti tavo slaptažodį? Kai tu jį įrašydavai, kompiuteris suprasdavo, jog tu turi kompiuterio administratoriaus teises. sudo padaro tą patį. Ši komanda pasako, kad po jo sekantis kodas būtų įvykdytas su kompiuterio administratoriaus teisėmis ir apsaugo, kad svetimi žmonės nieko negalėtų padaryti tavo kompiuteriui.\n\nSpausk Enter. Paleidus šią komandą, Terminal tavęs paprašys įrašyti savo slaptažodį. Jį rašant tu nieko nematysi (juk nenori, kad sėdint kavinėje, kas nors pamatytų tavo slaptažodį?). Įvesk ir spausk Enter dar kartą. Jeigu savo slaptažodį įvesi neteisingai - terminalas tau tai pasakys, tad galėsi bandyti dar kartą.\nJeigu tavo kompiuteriui yra pasiekiami atnaujinimai - tu pamatysi, kiek jų.\n\n\nsudo apt full-upgrade -y.\n\n\nŠi dalis pasako, kad sudo - elkis kaip administratorius\napt naudok programų atnaujinimų programą.\nfull-upgrade - atnaujink visas programas.\n-y yra nustatymas, panašus į ką jau matėme su base64 -d, tik šį kartą jis reiškia yes (lt - taip). Jeigu jo nepanaudotum, Terminal programa tavęs paklaustų, kokius atnaujinimus siūlo padaryti ir dar kartą klaustų, ar tikrai nori viską įdiegti. Tam kad išvengti šio papildomo klausimo, iš karto pasakome - yes.\n\nJeigu tu rašai šią komandą iškart po to, kai jau naudojai sudo apt update, Terminal programa tavęs gali ir nebeprašyti dar kartą įrašyti savo slaptažodį.\nPriklausomai nuo to, kiek yra atnaujinimų, šis procesas gali užtrukti kelioliką sekundžių, bet gali ir kelioliką minučių.\nVideo\n\nsudo apt autoremove -y.\n\n\nsudo ir apt jau žinome.\nauto-remove - šis nustatymas pasako apt komandai, kad jeigu yra kažkokių programų, kurios po atnaujinimo nebereikalingos, jas ištrintų. Nebijok, apt programa yra labai protinga ir atsargiai atsirenka, ką trinti ir ko ne.\n-y nustatymas pasako yes (taip), kad nereiktų patvirtinimo.\n\n\n\nflatpak update - kiek kita komanda. Čia mes iššaukiame programą flatpak, kuri, kaip ir programa apt, moka instaliuoti programas. Tačiau ją atnaujinti užtenka vos šių dviejų žodžių.\n\n\n\nO ką gi reiškia && toje ilgoje komandoje? Kai mes rašome komandas po vieną, kaip padarėme dabar, mes patys matome, ar nutiko kas nors netikėto, ar įvyko kokia nors klaida ir t.t. Tam, kad kompiuteris žinotų, jog tik padarius sudo apt update ir negavus jokių klaidų, jis eitų prie sekančios komandos sudo apt full-upgrade -y ir taip toliau, reikia šias komandas sujungti su &&. Jeigu prieš tai buvusi komanda nepavyktų, kompiuteris nutrauktų visas likusias komandas.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#sisteminių-paketų-instaliavimas",
    "href": "3_linux_update.html#sisteminių-paketų-instaliavimas",
    "title": "2  Linux programos ir atnaujinimai",
    "section": "3.1 Sisteminių paketų instaliavimas",
    "text": "3.1 Sisteminių paketų instaliavimas\nSisteminis paketas (angl. System Package) - tai programa, kurią Linux kūrėjai patikrino ir pritaikė tavo kompiuterio veikimui. Šios programos valdomos per apt programą.\nKita programų instaliavimo sistema yra Flatpak, su ja susipažinsime vėliau.\nĮdiekime “Bloboats” žaidimą.\nPaieškos viršuje įrašyk Bloboats ir paspausk ant programos piktogramos.\n\nKaip matai, sekantis langas parodo, jog tai System Package ir leidžia tau šią programą įdiegti. Spausk ant Install.\n\nSoftware Manager programa informuos tave, jei reikia įdiegti papildomas programas.\n\nJei taip nutiktų, spausk ant Continue, o tada įrašyk savo slaptažodį ir spausk ant Authenticate. Prisimeni, kai tu įrašai savo slaptažodį, kompiuteris komandas vykdo kaip sudo :)\n\nDabar gali spausti ant Launch (lt - paleisti), arba rasi šią programą tarp visų programų.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "href": "3_linux_update.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "title": "2  Linux programos ir atnaujinimai",
    "section": "3.2 Sisteminių paketų įdiegimas Terminal lange",
    "text": "3.2 Sisteminių paketų įdiegimas Terminal lange\nSusiraskime kitą programą - 3dchess. Kaip matai, jos pavadinimas kompiuteriui yra parašytas šio lango apačioje:\n\nAtsidaryk terminalą ir įrašyk šią komandą, daug kas jau tau bus matyta:\nsudo apt install 3dchess\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia įdiegti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\ninstall - komanda, pasakanti apt, ką turi daryti, šįkart įdiegti naują programą.\n3dchess - argumentas, pasakantis, kokią programą įdiegti.\n\nMes taip pat galėjome pridėti -y, bet šįkart to nepadarysime. Pažiūrėkime, kas nutinka. Ar pastebėjai kompiuterio reikalavimą patvirtinti, jog tikrai nori instaliuoti šią programą? Do you want to Continue [Y/n]\nVideo\nKaip matai, kompiuteris manęs klausė, ar tikrai noriu, ir teko įrašyti Y raidę ir spustelėti Enter. Tiesa, kai matai [Y/n] tai reiškia, kad jeigu tiesiog paspausi Enter - kompiuteris galvos, kad tu renkiesi Y (Yes trumpinys), tad rašyti Yes tau net nereikia. Kartais tu gali pamatyti [N/y]. Taigi tas pasirinkimas, kuris parašytas didžiąja raide - bus automatiškai pasirinktas jeigu nieko neįrašysi, bet pasupausi Enter klavišą.\nJeigu būčiau įrašęs komandą\nsudo apt install 3dchess -y\nTerminal programa manęs neprašytų patvirtinti mano pasirinkimo. Nes priejus šiam klausimui Do you want to Continue [Y/n], nustatymas -y pasakytų iškart Yes.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#flatpak",
    "href": "3_linux_update.html#flatpak",
    "title": "2  Linux programos ir atnaujinimai",
    "section": "3.3 Flatpak",
    "text": "3.3 Flatpak\nFlatpak yra kitoks būdas instaliuoti programas. Kai tu instaliuoji Flatpak programą, tu atsisiunti ne tik pačią programą, bet ir visas kitas programas, kurios reikalingos, kad pagrindinė programa veiktų. Pabandykime tai paaiškinti kitaip.\nĮsivaizduok, kad tavo kompiuteris yra kaip namas. Namai turi kambarius, virtuvę, vonią ir t.t. Dabar įsivaizduok, kad nori naujos spintos. Kai tu parsisiunti spintą kaip System Package (sisteminį paketą), tai tarsi parsiveži ją iš IKEA parduotuvės ir pastatai savo kambaryje.\nFlatpak programos veikia kitaip. Kai tu atsisiunti Flatpak programą, tai tarsi parsineštum visą didelę palapinę, kurioje yra ne tik tavo spinta, bet ir visa kita - virtuvė, vonia ir dar keli kambariai. Kodėl taip daroma?\nKartais programoms reikia kitų programų, kad jos veiktų gerai. Tavo kompiuteryje ne visada yra visos šios reikalingos programos. Todėl kai parsisiunti Flatpak programą, ji atsisiunčia viską, ko jai reikia, kad veiktų be problemų. Tai reiškia, kad gauni naujesnę ir geriau veikiančią programą. Tačiau ši didelė palapinė užima daugiau vietos tavo kompiuteryje, nes joje yra viskas, ko reikia programai.\nPavyzdžiui, susiraskime programą “hedgewars”. Pasirink bet kurią piktogramą.\n\nKaip matai, šalia “System Package” arba “Flatpak” yra nedidelis trikampiukas. Paspaudus ant jo, pamatysi, jog gali įdiegti šią programą ir kitu formatu.\nTaip atrodo System Package:\n\nO štai taip Flatpak. Atkreipk dėmesį į programos versijos skirtumus ir kiek vietos reikia kompiuteryje.\n\nKaip System Package ši programa užima 194 MB vietos tavo kompiuteryje, o kaip Flatpak - 3.7 GB. 3.7 GB atitinka 3700 MB. Taigi beveik 20 kartų daugiau vietos. Tai reiškia, kad Flatpak programai reikia daugiau vietos, nes ji atsisiunčia viską, ko jai reikia.\nGera žinia yra ta, kad kai instaliuosi kitą programą su Flatpak, labai tikėtina, kad kita programa jau galės naudotis kai kuriais dalykais iš pirmosios palapinės. Tada naujai programai reikės mažiau vietos.\nFlatpak programas taip pat galima instaliuoti per Terminal programą.\nTačiau tai šiek tiek skiriasi:\n\nnereikia naudoti sudo\nvietoj apt reikia naudoti flatpak\nnaudojame install\nprogramos pavadinimą galima pasiimti iš Software Manager, bet daugiau Flatpak programų galima rasti ir flathub.org tinklapyje.\n\nVideo",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#software-manager",
    "href": "3_linux_update.html#software-manager",
    "title": "2  Linux programos ir atnaujinimai",
    "section": "4.1 Software Manager",
    "text": "4.1 Software Manager\nPirmiausia pažiūrėkime, kaip ištrinti programas naudojant Software Manager.\n\nAtidaryk Software Manager.\nPaspaudus ant trijų brūkšnelių spausk ant “Show Installed Application” (lt. parodyk įdiegtas programas).\n\n\n\nSurask programą, kurią nori ištrinti, ir spausk ant jos pavadinimo ar piktogramos.\n\n\n\nAtsidariusiame lange spausk ant Remove (lt. pašalinti).\n\n\n\nSoftware Manager programa paprašys patvirtinimo. Spausk Continue, įvesk savo slaptažodį ir spausk Authenticate.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#menu",
    "href": "3_linux_update.html#menu",
    "title": "2  Linux programos ir atnaujinimai",
    "section": "4.2 Menu",
    "text": "4.2 Menu\nKitas būdas ištrinti programas yra per Menu.\n\nAtidaryk meniu, kur randi visas savo programas.\nDešiniu pelės klavišu spustelk ant programos, kurią nori ištrinti. Prasiskleis papildomas meniu.\nPasirink Uninstall (lt. pašalinti).\nPasirodys patvirtinimo langas. Pasirink OK, įvesk savo slaptažodį ir spausk Authenticate.\n\nVideo",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#terminalas",
    "href": "3_linux_update.html#terminalas",
    "title": "2  Linux programos ir atnaujinimai",
    "section": "4.3 Terminalas",
    "text": "4.3 Terminalas\nProgramas taip pat galima ištrinti per terminalą.\n\n4.3.1 Sisteminis paketas\nNorėdami ištrinti sisteminį paketą, naudokime apt programą. Pavyzdžiui, jei nori ištrinti programą “3dchess”:\n\nAtidaryk terminalą.\nĮrašyk šią komandą: sudo apt remove 3dchess\n\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia ištrinti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\nremove - komanda, pasakanti apt, kad reikia ištrinti programą.\n3dchess - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#flatpak-1",
    "href": "3_linux_update.html#flatpak-1",
    "title": "2  Linux programos ir atnaujinimai",
    "section": "4.4 Flatpak",
    "text": "4.4 Flatpak\nPer Terminal irgi galime ištrinti Flatpak programą. Pavyzdžiui, jei nori ištrinti programą org.hedgewars.Hedgewars:\nflatpak uninstall org.hedgewars.Hedgewars\nPaaiškinkime, kas čia yra kas:\n\nflatpak - programa, kuri įdiegia, atnaujina ir pašalina Flatpak programas.\nuninstall - komanda, pasakanti flatpak, kad reikia ištrinti programą.\norg.hedgewars.Hedgewars - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#kodėl-per-terminal",
    "href": "3_linux_update.html#kodėl-per-terminal",
    "title": "2  Linux programos ir atnaujinimai",
    "section": "4.5 Kodėl per Terminal?",
    "text": "4.5 Kodėl per Terminal?\nKo gero tau dabar kyla klausimas, kodėl verta mokėti atnaujinti, įdiegti ir ištrinti programas naudojant Terminal?\nNaudoti Terminal gali atrodyti sudėtingiau nei spustelėti pelę, tačiau jis turi daug privalumų.\n\nTerminal leidžia tau atlikti daugybę užduočių labai greitai. Užuot naršant per meniu ir ieškant reikiamų funkcijų, tu gali tiesiog įvesti kelias komandas ir tavo darbas bus atliktas.\nTerminal suteikia daugiau galimybių ir lankstumo. Kai kuriuos dalykus gali padaryti tik per Terminal. Be to, Terminal naudoti gali būti smagu! Tai tarsi magija – tu rašai komandas, o kompiuteris jas vykdo.\nTerminal naudojimas gali padėti tau geriau suprasti, kaip veikia tavo kompiuteris. Kai tu įrašai komandas ir matai, kaip jos veikia, tu pradedi suvokti, kas vyksta tavo kompiuterio viduje.\nTerminal naudojimas gali padėti tau tapti tikru kompiuterių ekspertu. Ir kas žino, galbūt ateityje tave sudomins programavimo, duomenų analitikos ar tiesiog inžinerijos mokslai? Labai daug profesijų pradeda nautodi programavimą kasdieniuose savo darbuose. Aplinkosaugininkai gali tyrinėti kaip keičiasi klimatas ir kaip kinta gamta, buhalteriai gali paspasrtinti ataskaitų ruošimą, architektai apskaičiuoti kaip statyti namą, jog jis nesugriųtų vykstant žemės drebėjimui, robotikos specialistai - kaip sukonstruoti robotoą, kuris važinėja ir tyrinėja Marso planeta…\n\nSkamba truputį sudėtingai, tiesa? Pateiksiu tau pavyzdį. Įsivaizduok, kad tu turi draugę vardu Pelenė. Pelenė irgi turi kompiuterį, bet nežino, kaip įdiegti programas. Tačiau jūs norite kartu žaisti tą patį žaidimą - lenktyniauti žaidžiant Super Tux Cart. Ką daryti?\nTu gali jai parašyti žinutę ir pasakyti, kad nukopijuotų ir paleistų štai tokį kodą:\nsudo apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update && flatpak install net.supertuxkart.SuperTuxKart -y\nNa štai, jeigu jūs turite paskyras Super Tux Cart, dabar galite nuotoliniu būdu lenktyniauti kartu.\nDar neturi paskyros ir elektroninio pašto adreso? Sekančioje pamokoje tai ir susikursime.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html",
    "href": "4_linux_software.html",
    "title": "3  Linux programos",
    "section": "",
    "text": "4 Programų instaliavimas\nProgramų instaliavimas Linux yra gana paprastas. Užtenka susirasti ir atsidaryti Software Manager.\nJam atsidarius, iškart matome daug programų pasiūlymų. Drąsiai panaršyk šiame lange. Ar matai ką nors tave dominančio?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html#update-manager",
    "href": "4_linux_software.html#update-manager",
    "title": "3  Linux programos ir atnaujinimai",
    "section": "3.2 Update Manager",
    "text": "3.2 Update Manager\nUpdate Manager yra programa, kuri padeda atnaujinti kitas programas tavo kompiuteryje. Ji pati praneša, kai laikas atnaujinti programas. Kai internete yra prieinami atnaujinimai, dešiniame kampe atsiranda skydelio su raudonu tašku piktograma (raudonas taškas reiškia, kad yra naujų atnaujinimų).\n\n\nBet jei nematai šios piktogramos, gali paleisti “Update Manager” programą per Menu:\n.\nPirmą kartą paleidus šią programą, gali pamatyti tokį langą, kuris paaiškina, ką ji daro. Drąsiai spausk ant OK.\n\nJei pamatysi, kad pačiai programai reikia atnaujinimo, spausk ant “Apply the Update” (lt. - įdiegti atnaujinimą). Taip pat gali matyti užrašą switch to a local mirror, kol kas spausk No. Kas yra veidrodžiai (angl. - mirrors), pakalbėsime netrukus.\n\nJei paspaudus “Apply the Update” kompiuteris paprašys tavo slaptažodžio, įvesk jį. Taip kompiuteris įsitikina, kad tik tu ar kitas vartotojas, kuriam priklauso šis kompiuteris, gali atlikti pakeitimus. Drąsiai įvesk savo slaptažodį ir spausk Authenticate (lt. - patvirtinti tapatybę).\n\nNetrukus pamatysi vaizdą, kuris gali atrodyti panašiai - vienas ar keli, o gal net daugybė skirtingų programų atnaujinimų, kuriuos gali įdiegti savo kompiuteriui. Tačiau kol kas dar nieko nespauskime. Susipažinkime su tuo, ką čia matome:\n\n\n\nType - kokio tipo yra atnaujinimas? Jie gali būti:\n\nSecurity update - saugumo atnaujinimas. Jo simbolis yra skydelis. Tai svarbiausias atnaujinimas, kurį reikia kuo skubiau įdiegti, kad kompiuteris būtų saugus.\nKernel update - pagrindinės Linux sistemos atnaujinimas. Jo simbolis yra žaibas. Šie atnaujinimai pagerina, kaip veikia pats kompiuteris. Ar ekranas rodo gerai? Ar veikia pelė? Ir t.t.\nSoftware update - programų atnaujinimai. Tai atnaujinimai, kuriuos programų kūrėjai sukuria, kad jų programos veiktų geriau, turėtų daugiau funkcijų ir pan.\n\n\nŠiame lange taip pat gali paspausti ant:\n\n\nClear - išvalyti visus pasirinktus atnaujinimus\nSelect All - pasirinkti visus atnaujinimus\nRefresh - atnaujinti sąrašą atnaujinimų, kurie yra prieinami\nInstall Updates - įdiegti pasirinktus atnaujinimus\n\nBet kaip kompiuteris žino, kokias programas atnaujinti? Ir iš kur jis jas atsisiunčia?\n\n3.2.1 Mirrors ir Updates\nVeidrodėli, veidrodėli, kas pasaulyje gražiausia?\n\nPradėkime nuo pradžių…\nĮsivaizduok, kad programuotoja, kuri kuria programas, dirba iš namų, kaip ir tu. Po ilgos darbo savaitės, ji nusprendžia: “Viskas, programos atnaujinimas paruoštas. Ištaisyta klaida, įdiegti nauji patobulinimai”.\n\n(Nuotraukoje Jaime Gunther, kuri 38 metų nusprendė, kad mokysis savarankiškai programuoti ir tapo programuotoja)\nBet dabar įsivaizduok, kad keli milijonai žmonių bandytų parsisiųsti iš jos kompiuterio šiuos atnaujinimus. Jos kompiuteris negalėtų to atlaikyti, ir viskas strigtų bei vyktų labai lėtai.\nTodėl programuotoja naudoja serverius veidrodžius (angl. - mirrors).\n\nKas yra serveris? Serveris yra didelis kompiuteris, kuris pastatytas specialiose vietose ir gali aptarnauti milijonus žmonių vienu metu. (daugiau nuotraukų gali rasti čia)\n\n\n\nKodėl jie vadinami veidrodžiais (angl. - mirrors)? Nes jie atspindi tuos programinius pakeitimus, kuriuos programuotoja padarė savo namuose. Kai ji kažką atnaujina, šie serveriai iškart tai atspindi, ir tu gali parsisiųsti atnaujinimus neapkraudamas programuotojos namų kompiuterio!\n\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuris turi sąrašą, kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs, priklauso programų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitikrinti ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasties kartais tavo kompiuteris paklausia, ar nori prisijungti prie vietinių veidrodinių serverių - “Do you want to switch to a local mirror?”\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuriame yra sarašas kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs nutolęs, priklauso prgramų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitiktrinti, ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasies, kartais tavo kompiuteris paklausia, ar nori prisijngti prie lokalių veidrodžių.\nKaip tai padaryti?\n\nSpausk ant “Edit” (pakeitimai) ir tada ant “Software Sources” (programų šaltiniai).\nKompiuteris vėl paprašys tavo slaptažodžio, įvesk jį.\nAtsidariusiame naujame lange pamatysi Main ir Base veidrodžius. Jie gali būti nustatyti ne visai ten, kur gyveni tu.\nSpustelk pele prie Main. Atsidarys langas, kuriame bus serveriai, surūšiuoti pagal tai, kaip arti tavęs jie yra (pagal atsisiuntimo greitį). Tu pamatysi, kad po kelių sekundžių sąrašo viršus nebekinta. Tau nereikia laukti, kol kompiuteris parsisiųs visų serverių informaciją. Pasirink patį pirmą serverį\nPakartok tai su Base serveriu.\nSpustelk ant “Update the mirrors” (atnaujinti veidrodinius serverius). Tai gali truputį užtrukti.\nAtnaujinus, pamatysi, kad buvusius serverius pakeitė kiti, tavo pasirinkti serveriai.\nDabar gali uždaryti šį langą.\n\nVisas procesas šiame video:\nVideo\nDabar gali atnaujinti programas, paspaudus ant Install Updates. Gali atsirasti papildomi langai, kur paklaus, ar tikrai nori įdiegti atnaujinimus, gali paprašyti ir įvesti tavo slaptažodį dar kartą. Visur drąsiai sakyk “taip” ir įrašyk savo slaptažodį.\nTačiau yra ir kitas būdas! Naudojant Terminal.\nVeidrodinių serverių atnaujinimas yra būtinas net kai įdiegi atnaujinimus per Terminalą. Tad retkarčiais pasitikrink, ar pasirinkti vis dar sparčiausi veidroriniai serveriai.\n\n\n3.2.2 Atnaujinimų instalivimas per Terminal\nKodėl kartais geriau įdiegti atnaujinimus per Terminal programą? Visų pirma - tu praktikuojiesi BASH kalbos žinias! Visų antra, vėliau išmoksi, kaip vos kelių klavišų paspaudimu tai padaryti daug greičiau nei spaudant su pele ir naudojant Update Manager programą.\nŠtai taip atrodo kodas, kurį reikės įrašyti:\nsudo apt update && \nsudo apt full-upgrade -y && \nsudo apt autoremove -y && \nflatpak update\nDabar tavo galvoje gal atrodo taip:\n\nPradėkime nuo pradžių ir eikime per visas komandas, kad jas suprastume. Kai suprasi - pamatysi, kad viskas gana paprasta.\nMes galime visas komandas surašyti į vieną eilutę, bet paprastumo dėlei, terminale įrašyk komandą po komandos, kaip pateiktia žemiau.\n\nsudo apt update.\n\n\nčia iššaukiama komanda apt. Tai yra programa, kuri rūpinasi programų atnaujinimu.\nupdate yra argumentas, ką programa turi daryti. Priešingai nei atrodo, ji neatnaujina programų. Ką ji padaro, tai palygina tavo kompiuterio programas su tuo, kas yra veidrodiniuose serveriuose (mirror). Jeigu ji aptinka skirtumą, nes, pvz., serveryje programa yra naujesnė, apt tave informuos apie galimus atnaujinimus.\nO kas yra sudo? Atsimeni, kai Update Manager tavęs prašė įrašyti tavo slaptažodį? Kai tu jį įrašydavai, kompiuteris suprasdavo, jog tu turi kompiuterio administratoriaus teises. sudo padaro tą patį. Ši komanda pasako, kad po jo sekantis kodas būtų įvykdytas su kompiuterio administratoriaus teisėmis ir apsaugo, kad svetimi žmonės nieko negalėtų padaryti tavo kompiuteriui.\n\nSpausk Enter. Paleidus šią komandą, Terminal tavęs paprašys įrašyti savo slaptažodį. Jį rašant tu nieko nematysi (juk nenori, kad sėdint kavinėje, kas nors pamatytų tavo slaptažodį?). Įvesk ir spausk Enter dar kartą. Jeigu savo slaptažodį įvesi neteisingai - terminalas tau tai pasakys, tad galėsi bandyti dar kartą.\nJeigu tavo kompiuteriui yra pasiekiami atnaujinimai - tu pamatysi, kiek jų.\n\n\nsudo apt full-upgrade -y.\n\n\nŠi dalis pasako, kad sudo - elkis kaip administratorius\napt naudok programų atnaujinimų programą.\nfull-upgrade - atnaujink visas programas.\n-y yra nustatymas, panašus į ką jau matėme su base64 -d, tik šį kartą jis reiškia yes (lt - taip). Jeigu jo nepanaudotum, Terminal programa tavęs paklaustų, kokius atnaujinimus siūlo padaryti ir dar kartą klaustų, ar tikrai nori viską įdiegti. Tam kad išvengti šio papildomo klausimo, iš karto pasakome - yes.\n\nJeigu tu rašai šią komandą iškart po to, kai jau naudojai sudo apt update, Terminal programa tavęs gali ir nebeprašyti dar kartą įrašyti savo slaptažodį.\nPriklausomai nuo to, kiek yra atnaujinimų, šis procesas gali užtrukti kelioliką sekundžių, bet gali ir kelioliką minučių.\nVideo\n\nsudo apt autoremove -y.\n\n\nsudo ir apt jau žinome.\nauto-remove - šis nustatymas pasako apt komandai, kad jeigu yra kažkokių programų, kurios po atnaujinimo nebereikalingos, jas ištrintų. Nebijok, apt programa yra labai protinga ir atsargiai atsirenka, ką trinti ir ko ne.\n-y nustatymas pasako yes (taip), kad nereiktų patvirtinimo.\n\n\n\nflatpak update - kiek kita komanda. Čia mes iššaukiame programą flatpak, kuri, kaip ir programa apt, moka instaliuoti programas. Tačiau ją atnaujinti užtenka vos šių dviejų žodžių.\n\n\n\nO ką gi reiškia && toje ilgoje komandoje? Kai mes rašome komandas po vieną, kaip padarėme dabar, mes patys matome, ar nutiko kas nors netikėto, ar įvyko kokia nors klaida ir t.t. Tam, kad kompiuteris žinotų, jog tik padarius sudo apt update ir negavus jokių klaidų, jis eitų prie sekančios komandos sudo apt full-upgrade -y ir taip toliau, reikia šias komandas sujungti su &&. Jeigu prieš tai buvusi komanda nepavyktų, kompiuteris nutrauktų visas likusias komandas.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html#sisteminių-paketų-instaliavimas",
    "href": "4_linux_software.html#sisteminių-paketų-instaliavimas",
    "title": "3  Linux programos",
    "section": "4.1 Sisteminių paketų instaliavimas",
    "text": "4.1 Sisteminių paketų instaliavimas\nSisteminis paketas (angl. System Package) - tai programa, kurią Linux kūrėjai patikrino ir pritaikė tavo kompiuterio veikimui. Šios programos valdomos per apt programą.\nKita programų instaliavimo sistema yra Flatpak, su ja susipažinsime vėliau.\nĮdiekime “Bloboats” žaidimą.\nPaieškos viršuje įrašyk Bloboats ir paspausk ant programos piktogramos.\n\nKaip matai, sekantis langas parodo, jog tai System Package ir leidžia tau šią programą įdiegti. Spausk ant Install.\n\nSoftware Manager programa informuos tave, jei reikia įdiegti papildomas programas.\n\nJei taip nutiktų, spausk ant Continue, o tada įrašyk savo slaptažodį ir spausk ant Authenticate. Prisimeni, kai tu įrašai savo slaptažodį, kompiuteris komandas vykdo kaip sudo :)\n\nDabar gali spausti ant Launch (lt - paleisti), arba rasi šią programą tarp visų programų.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "href": "4_linux_software.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "title": "3  Linux programos",
    "section": "4.2 Sisteminių paketų įdiegimas Terminal lange",
    "text": "4.2 Sisteminių paketų įdiegimas Terminal lange\nSusiraskime kitą programą - 3dchess. Kaip matai, jos pavadinimas kompiuteriui yra parašytas šio lango apačioje:\n\nAtsidaryk terminalą ir įrašyk šią komandą, daug kas jau tau bus matyta:\nsudo apt install 3dchess\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia įdiegti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\ninstall - komanda, pasakanti apt, ką turi daryti, šįkart įdiegti naują programą.\n3dchess - argumentas, pasakantis, kokią programą įdiegti.\n\nMes taip pat galėjome pridėti -y, bet šįkart to nepadarysime. Pažiūrėkime, kas nutinka. Ar pastebėjai kompiuterio reikalavimą patvirtinti, jog tikrai nori instaliuoti šią programą? Do you want to Continue [Y/n]\nVideo\nKaip matai, kompiuteris manęs klausė, ar tikrai noriu, ir teko įrašyti Y raidę ir spustelėti Enter. Tiesa, kai matai [Y/n] tai reiškia, kad jeigu tiesiog paspausi Enter - kompiuteris galvos, kad tu renkiesi Y (Yes trumpinys), tad rašyti Yes tau net nereikia. Kartais tu gali pamatyti [N/y]. Taigi tas pasirinkimas, kuris parašytas didžiąja raide - bus automatiškai pasirinktas jeigu nieko neįrašysi, bet pasupausi Enter klavišą.\nJeigu būčiau įrašęs komandą\nsudo apt install 3dchess -y\nTerminal programa manęs neprašytų patvirtinti mano pasirinkimo. Nes priejus šiam klausimui Do you want to Continue [Y/n], nustatymas -y pasakytų iškart Yes.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html#flatpak",
    "href": "4_linux_software.html#flatpak",
    "title": "3  Linux programos",
    "section": "4.3 Flatpak",
    "text": "4.3 Flatpak\nFlatpak yra kitoks būdas instaliuoti programas. Kai tu instaliuoji Flatpak programą, tu atsisiunti ne tik pačią programą, bet ir visas kitas programas, kurios reikalingos, kad pagrindinė programa veiktų. Pabandykime tai paaiškinti kitaip.\nĮsivaizduok, kad tavo kompiuteris yra kaip namas. Namai turi kambarius, virtuvę, vonią ir t.t. Dabar įsivaizduok, kad nori naujos spintos. Kai tu parsisiunti spintą kaip System Package (sisteminį paketą), tai tarsi parsiveži ją iš IKEA parduotuvės ir pastatai savo kambaryje.\nFlatpak programos veikia kitaip. Kai tu atsisiunti Flatpak programą, tai tarsi parsineštum visą didelę palapinę, kurioje yra ne tik tavo spinta, bet ir visa kita - virtuvė, vonia ir dar keli kambariai. Kodėl taip daroma?\nKartais programoms reikia kitų programų, kad jos veiktų gerai. Tavo kompiuteryje ne visada yra visos šios reikalingos programos. Todėl kai parsisiunti Flatpak programą, ji atsisiunčia viską, ko jai reikia, kad veiktų be problemų. Tai reiškia, kad gauni naujesnę ir geriau veikiančią programą. Tačiau ši didelė palapinė užima daugiau vietos tavo kompiuteryje, nes joje yra viskas, ko reikia programai.\nPavyzdžiui, susiraskime programą “hedgewars”. Pasirink bet kurią piktogramą.\n\nKaip matai, šalia “System Package” arba “Flatpak” yra nedidelis trikampiukas. Paspaudus ant jo, pamatysi, jog gali įdiegti šią programą ir kitu formatu.\nTaip atrodo System Package:\n\nO štai taip Flatpak. Atkreipk dėmesį į programos versijos skirtumus ir kiek vietos reikia kompiuteryje.\n\nKaip System Package ši programa užima 194 MB vietos tavo kompiuteryje, o kaip Flatpak - 3.7 GB. 3.7 GB atitinka 3700 MB. Taigi beveik 20 kartų daugiau vietos. Tai reiškia, kad Flatpak programai reikia daugiau vietos, nes ji atsisiunčia viską, ko jai reikia.\nGera žinia yra ta, kad kai instaliuosi kitą programą su Flatpak, labai tikėtina, kad kita programa jau galės naudotis kai kuriais dalykais iš pirmosios palapinės. Tada naujai programai reikės mažiau vietos.\nFlatpak programas taip pat galima instaliuoti per Terminal programą.\nTačiau tai šiek tiek skiriasi:\n\nnereikia naudoti sudo\nvietoj apt reikia naudoti flatpak\nnaudojame install\nprogramos pavadinimą galima pasiimti iš Software Manager, bet daugiau Flatpak programų galima rasti ir flathub.org tinklapyje.\n\nVideo",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html#software-manager",
    "href": "4_linux_software.html#software-manager",
    "title": "3  Linux programos",
    "section": "5.1 Software Manager",
    "text": "5.1 Software Manager\nPirmiausia pažiūrėkime, kaip ištrinti programas naudojant Software Manager.\n\nAtidaryk Software Manager.\nPaspaudus ant trijų brūkšnelių spausk ant “Show Installed Application” (lt. parodyk įdiegtas programas).\n\n\n\nSurask programą, kurią nori ištrinti, ir spausk ant jos pavadinimo ar piktogramos.\n\n\n\nAtsidariusiame lange spausk ant Remove (lt. pašalinti).\n\n\n\nSoftware Manager programa paprašys patvirtinimo. Spausk Continue, įvesk savo slaptažodį ir spausk Authenticate.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html#menu",
    "href": "4_linux_software.html#menu",
    "title": "3  Linux programos",
    "section": "5.2 Menu",
    "text": "5.2 Menu\nKitas būdas ištrinti programas yra per Menu.\n\nAtidaryk meniu, kur randi visas savo programas.\nDešiniu pelės klavišu spustelk ant programos, kurią nori ištrinti. Prasiskleis papildomas meniu.\nPasirink Uninstall (lt. pašalinti).\nPasirodys patvirtinimo langas. Pasirink OK, įvesk savo slaptažodį ir spausk Authenticate.\n\nVideo",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html#terminalas",
    "href": "4_linux_software.html#terminalas",
    "title": "3  Linux programos",
    "section": "5.3 Terminalas",
    "text": "5.3 Terminalas\nProgramas taip pat galima ištrinti per terminalą.\n\n5.3.1 Sisteminis paketas\nNorėdami ištrinti sisteminį paketą, naudokime apt programą. Pavyzdžiui, jei nori ištrinti programą “3dchess”:\n\nAtidaryk terminalą.\nĮrašyk šią komandą: sudo apt remove 3dchess\n\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia ištrinti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\nremove - komanda, pasakanti apt, kad reikia ištrinti programą.\n3dchess - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html#flatpak-1",
    "href": "4_linux_software.html#flatpak-1",
    "title": "3  Linux programos",
    "section": "5.4 Flatpak",
    "text": "5.4 Flatpak\nPer Terminal irgi galime ištrinti Flatpak programą. Pavyzdžiui, jei nori ištrinti programą org.hedgewars.Hedgewars:\nflatpak uninstall org.hedgewars.Hedgewars\nPaaiškinkime, kas čia yra kas:\n\nflatpak - programa, kuri įdiegia, atnaujina ir pašalina Flatpak programas.\nuninstall - komanda, pasakanti flatpak, kad reikia ištrinti programą.\norg.hedgewars.Hedgewars - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html#kodėl-per-terminal",
    "href": "4_linux_software.html#kodėl-per-terminal",
    "title": "3  Linux programos",
    "section": "5.5 Kodėl per Terminal?",
    "text": "5.5 Kodėl per Terminal?\nKo gero tau dabar kyla klausimas, kodėl verta mokėti atnaujinti, įdiegti ir ištrinti programas naudojant Terminal?\nNaudoti Terminal gali atrodyti sudėtingiau nei spustelėti pelę, tačiau jis turi daug privalumų.\n\nTerminal leidžia tau atlikti daugybę užduočių labai greitai. Užuot naršant per meniu ir ieškant reikiamų funkcijų, tu gali tiesiog įvesti kelias komandas ir tavo darbas bus atliktas.\nTerminal suteikia daugiau galimybių ir lankstumo. Kai kuriuos dalykus gali padaryti tik per Terminal. Be to, Terminal naudoti gali būti smagu! Tai tarsi magija – tu rašai komandas, o kompiuteris jas vykdo.\nTerminal naudojimas gali padėti tau geriau suprasti, kaip veikia tavo kompiuteris. Kai tu įrašai komandas ir matai, kaip jos veikia, tu pradedi suvokti, kas vyksta tavo kompiuterio viduje.\nTerminal naudojimas gali padėti tau tapti tikru kompiuterių ekspertu. Ir kas žino, galbūt ateityje tave sudomins programavimo, duomenų analitikos ar tiesiog inžinerijos mokslai? Labai daug profesijų pradeda nautodi programavimą kasdieniuose savo darbuose. Aplinkosaugininkai gali tyrinėti kaip keičiasi klimatas ir kaip kinta gamta, buhalteriai gali paspasrtinti ataskaitų ruošimą, architektai apskaičiuoti kaip statyti namą, jog jis nesugriųtų vykstant žemės drebėjimui, robotikos specialistai - kaip sukonstruoti robotoą, kuris važinėja ir tyrinėja Marso planeta…\n\nSkamba truputį sudėtingai, tiesa? Pateiksiu tau pavyzdį. Įsivaizduok, kad tu turi draugę vardu Pelenė. Pelenė irgi turi kompiuterį, bet nežino, kaip įdiegti programas. Tačiau jūs norite kartu žaisti tą patį žaidimą - lenktyniauti žaidžiant Super Tux Cart. Ką daryti?\nTu gali jai parašyti žinutę ir pasakyti, kad nukopijuotų ir paleistų štai tokį kodą:\nsudo apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update && flatpak install net.supertuxkart.SuperTuxKart -y\nNa štai, jeigu jūs turite paskyras Super Tux Cart, dabar galite nuotoliniu būdu lenktyniauti kartu.\nDar neturi paskyros ir elektroninio pašto adreso? Sekančioje pamokoje tai ir susikursime.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "5_passwords_online_accounts.html",
    "href": "5_passwords_online_accounts.html",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "",
    "text": "4.1 Intro\nAr žinai, kas kelia didžiausią riziką internete, tiek vaikams, tiek suaugusiems? Nesaugūs slaptažodžiai.\nTokie slaptažodžiai kaip:\nyra begalo pavojingi. Blogi pogramuotjai, dar vadinami “hakeriais”, nuolat bando nulaužti internetinas paskyras. Tam jie naudojasi teksto generatoriais, sukuria šimtus tūkstančių kombinacijų, pvz pelenė123 ir bando nulaužti internetinius slaptažodžius.\nkas gali nutikti blogiausia, jeigu tavo slaptažodį nulauš?\nScerijus:\nRetai, bet taip nutinka.\nŠioje pamokoje išmoksi kas yra saugus slaptažodis, kaip juos sukurti ir kaip juos saugoti. Taip tai ne visada yra patogu, bet deja, kaip visad gyvenime, reikia ieškoti kompromiso tarp saugumo ir patogumo.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "5_passwords_online_accounts.html#intro",
    "href": "5_passwords_online_accounts.html#intro",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "",
    "text": "12345\nslaptažodis\nvardaspavardė\nmamos vardas\naugintinio vardas\n\n\n\n\n\nHackeris “nulaužia” t.y. atspėja tavo slaptažodį pvz Google paskyros\nNueina į tavo banko paskyrą, ir pranša, kad pamiršo savo slaptažodį. Bankas atsiunčia nuorodą į elektronį paštą, kuriame prideda nuorodą, leidžiančia sukurti naują slaptažodį bankui.\nPrisijungęs prie tavo banko paskyros - hackeris ištuština tavo visas santaupas. Dabar tu turi eiti skolintis, vien tam, kad turėti pinigų maistui.\nBet hackeris buvo ypač blogas, apart visko, jis dar ištrynė ir visas kitas tavo paskyras, nuotraukų kopijas esančias internete ir prikėtė visokių kitų šunybių.\nNa prie to pačio, dar ir užrakino tavo telefoną, ištrynė kontaktus, tad net nebežinai, kaip paskambinti draugams ir paprašyti pagalbos.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "5_passwords_online_accounts.html#kas-yra-saugus-slaptažodis",
    "href": "5_passwords_online_accounts.html#kas-yra-saugus-slaptažodis",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "4.2 Kas yra saugus slaptažodis",
    "text": "4.2 Kas yra saugus slaptažodis\nPirmiausia, saugus slaptažodis yra toks, kurio tu nežinai! Jeigu tu nežinai savo slaptažodžio, tu negali jo užrašyti ant jokio popieriaus lapelio, tad niekas jo ir nepamatys.\nTai kaip prisijungti prie paskyrų internete, pvz, banke? prie elektroninio pašto?\nTam padeda slaptažodžių programos. Jų yra įvairių\n\ninternetinės programos tokios kaip Bitwarden, kurios sinchronizuoja, t.y. suvienodina informaciją per visus tavo įrenginius: kompiuterį, telefoną ir t.t.\nkompiuteryje instaliuotos programos, pvz keepassx, kuriose išsaugai slaptažodius ir kai reikia prisijungti, atsidarai jas ir iš jų nusikopijuoji slaptažodį, kurio reikia.\n\nKiti aspektai saugaus slaptažodžio:\n\nbent 16 simbolių (geriau naudoti daugiau, bet ne visur leidžiama)\nnaudoti tiek DIDŽIĄSIAS RAIDES, tiek mažąsas, tiek skaičius bet būtinai ir simpbolius tokius kaip !@#$%^&*()_\n\ntačiau pati svarbiausia taisyklė:\n\nnaudoti skirtingus slaptažodžius visur\n\nJeigu kam nors pavyktų nulaužti tavo vieną paskyrą, pvz kokios nors internetinės parduotuvės, tas hackeris negalėtų panaudoti išgauto slaptažožio norint prisijungti prie tavo elektroninio pašto.\nNaudojant tokias programėlės kaip Bitwarden, KeepassX ir kitas, su laiku tu pamatysi, kiek daug paskyrų turi ir kaip nelengva būtų visur turėti skirtingus slaptažodžius.\n\n4.2.1 KeepassX\nInstlaiuok keepassx savo kompiuteryje. Prisimink iš praėjusio skurio, kaip instaliuoti programas naudojantis Terminal Programos pavadinimas kurio reikės keepassx\nPagalba:\n\nsudo suteikia administratoriaus teises\napt programa kuri valdo programas\ninstall komanda kuri įdiegia programas\n&lt;argumentas&gt; programos pavadinimas, kurią norima įdiegti\n\n             Video Video\nTai dar kartą:\n\n16-20 simbolių slaptažodis\nsusidedantis iš įvairių raidžių, skaičių ir simbolių\nkiekvienam paskyrai skirtingas slaptažodis\nišsaugotas programėleje",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "5_passwords_online_accounts.html#elektroninis-pašto-adresas",
    "href": "5_passwords_online_accounts.html#elektroninis-pašto-adresas",
    "title": "4  Slaptažodžiai ir internetinės paskyros",
    "section": "4.3 Elektroninis pašto adresas",
    "text": "4.3 Elektroninis pašto adresas\nDauguma žmonių turi elektroninį paštro adresą sukuart Google svetainėje. Tai labai paprarsta ir patogu, juo labiau, nemokama.\nBet vėlgi, patogumas netolygu saugumui. Visų pirma Google naudojasi visais turimais duomenis, failais, laiškais ir t.t. tam, kad pagerintų reklamos rodymą. Ne Google yra produktas, kurį naudoji, o TU tampi produktu Google.\nTačiau yra ir saugumo problema, jeigu kas nors pamato tavo ekrano slaptžodį ir pavogia telefoną, o ten yra Gmail programėle, tai jau beveik ir nebereikia spėlioti tavo slaptažodžių. Tu gali nespėti užblokuoti savo telefono, o banko sąskaita jau gali būti tuščia. Kaip? Velgi, vagišius pasinaudos “pamiršau savo slaptažodį” funkcija. Jam atsius laišką į gmail su nuoroda kaip susikurti naują slaptažodį, o patvirtinimui, akd ten “tikrai tu”, bankas atsiųs SMS žinutę. Viskas viename įrenginyje…\nO jeigu tavo Gmail laiškuose dar ir tavo žinutės tavo slaptai meilei?\nKą daryti?\nGeriausia turėti elektroninį pašto adresą kuris nėra google. Gera alternatyva - Prononmail.\nTad dabar pažiūrėsime kaip susikurti Protonmail ir kaip galėsi atsidaryti emailus Thunderbird laiškų probramėlėje kompiuteryje.\nLaišku programėlės į telefoną - net nediegsime, juk vėl padidintume riziką.\n\n4.3.1 Protonmail\n\n\n4.3.2 Thunderbird",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Slaptažodžiai ir internetinės paskyros</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html",
    "href": "6_linux_comands_basic.html",
    "title": "5  Pagridinės BASH komandos",
    "section": "",
    "text": "5.1 Shell ir Terminalas\nShell (liet. apvalkalas) yra programinė įranga arba komandų interpretatorius, leidžiantis vartotojams bendrauti su operacine sistema naudojant teksto komandas. Kai įvedate komandą į Shell, jis ją paverčia į veiksmus, kuriuos supranta kompiuteris. Populiariausi Shell tipai, tokie kaip Bash (Bourne Again Shell), Zsh (Z Shell), ir ksh (Korn Shell), yra ypač naudingi, nes jie leidžia automatizuoti įvairias užduotis ir vykdyti sudėtingas komandas. Šalia to, Shell turi ir programavimo kalbos savybių, leidžiančių rašyti skriptus - failus su nuosekliomis komandomis, kurios vykdomos viena po kitos. Tai reiškia, kad Shell gali būti naudojamas ir programavimui, ypač sistemų administravimo ir automatizavimo darbams.\nCLI (Command Line Interface, liet. komandinės eilutės sąsaja) yra vartotojo sąsaja, kurioje komandos įvedamos (input) tekstu ir rezultatai rodomi kaip teksto išvestis (output). Skirtingai nuo grafinės vartotojo sąsajos (GUI), kurioje naudojami vizualiniai elementai, tokie kaip langai ir mygtukai, CLI leidžia tiesiogiai rašyti instrukcijas, kurias vykdo sistema.\nTerminalas yra CLI programa, kuri leidžia jums pasiekti Shell sąsają. Jį galima įsivaizduoti kaip langą kompiuteryje, per kurį galite įvesti komandas ir matyti jų rezultatus. Terminalo programos naudojamos įvairiose operacinėse sistemose, nes jos leidžia efektyviau valdyti sistemą nei daugelis grafinių vartotojo sąsajų. Naudodamiesi terminalu, galite atlikti įvairias užduotis greičiau ir tiksliau.\nAtidarykite Terminalą ir įrašykite šią komandą Terminalo lange:\nJos atsakymas (output) parodo vykdomojo Shell failo vietą – Shell programą, kuri šiuo metu yra naudojama jūsų terminale. Taip pat iš išvesties galima matyti, koks tai Shell. Šiuo atveju, tai Bash.\nŠiame skyriuje susipažinsime su šiomis komandomis:",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#pwd",
    "href": "6_linux_comands_basic.html#pwd",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.4 pwd",
    "text": "6.4 pwd\nKomanda pwd (angl. “print working directory”, liet. “parodyti darbinį katalogą”) parodo dabartinio darbinio katalogo pilną kelią (path). Tai naudinga komanda, jei norite sužinoti, kuriame kataloge šiuo metu dirbate.\npwd\n\nTaigi šiuo atveju darbinis katalogas yra /home/main-user",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#clear",
    "href": "6_linux_comands_basic.html#clear",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.8 clear",
    "text": "6.8 clear\nKomanda clear (liet. “valyti”) naudojama norint išvalyti terminalo ekraną, pašalinant visus anksčiau įvestus ir parodytus tekstinius duomenis. Tai palieka terminalą švarų ir patogesnį tolimesniam naudojimui. Ši komanda neištrina terminalo istorijos; ji tik paslenka visą tekstą į viršų, už dabartinio vaizdo ribų.\nclear",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#ls",
    "href": "6_linux_comands_basic.html#ls",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.7 ls",
    "text": "6.7 ls\nKomanda ls (angl. list, liet. “parodyti sąrašą”) naudojama norint peržiūrėti failų ir katalogų sąrašą dabartiniame arba nurodytame kataloge. Tai viena iš dažniausiai naudojamų komandų naviguojant failų sistemoje Linux ir Unix tipo operacinėse sistemose.\n\nParodyti dabartinio katalogo turinį:\n\nls\n\n\nParodyti konkretaus katalogo turinį:\n\nls /path/to/directory\n\n\nParodyti išsamų (ilgą) failų sąrašą su detalėmis, pvz., teisėmis,savininku, dydžiu ir paskutinio modifikavimo data:\n\nls -l\n\n\nParodyti visus failus, įskaitant paslėptus (failai, kurių pavadinimai prasideda tašku):\n\nls -a\n\n\nNaudoti ilgą sąrašą su žmogišku skaitymo formatu -h (dydžiai rodomi su B, K, M). Čia sukombinuojamas -l su -a ir -h\n\nls -lah\n\n\nParodyti katalogų turinį rekursyviai (parodyti failus ir katalogus visuose pakatalogiuose):\n\nls -R",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#section",
    "href": "6_linux_comands_basic.html#section",
    "title": "6  Manipulating files and directories",
    "section": "7.4 /",
    "text": "7.4 /\n\n/home",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#cd",
    "href": "6_linux_comands_basic.html#cd",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.6 cd",
    "text": "6.6 cd\nKomanda cd (angl. change directory, liet. “pakeisti katalogą”) naudojama pereiti iš vieno katalogo į kitą. Ši komanda leidžia keisti dabartinį darbinį katalogą.\n\nPereiti į konkretų katalogą pagal absoliutų kelią:\n\ncd /home/vartotojas/Documents\n\n\nPereiti į konkretų katalogą pagal relatyvų kelią:\n\ncd dokumentai/projektai\n\nPereiti į tėvinį katalogą (parent directory) (vienu lygiu aukščiau):\ncd ..\n\n\nPereiti į namų katalogą:\n\ncd\ncd ~\n\n\nPereiti į ankstesnį katalogą, kuriame buvote prieš pereidami į dabartinį katalogą:\n\ncd -",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#copy-with-cp",
    "href": "6_linux_comands_basic.html#copy-with-cp",
    "title": "6  Manipulating files and directories",
    "section": "7.6 Copy with cp",
    "text": "7.6 Copy with cp\nHow can I copy files?\nYou will often want to copy files, move them into other directories to organize them, or rename them. One command to do this is cp, which is short for “copy”. If original.txt is an existing file, then:\ncp original.txt duplicate.txt\ncreates a copy of original.txt called duplicate.txt. If there already was a file called duplicate.txt, it is overwritten. If the last parameter to cp is an existing directory, then a command like:\ncp seasonal/autumn.csv seasonal/winter.csv backup\ncopies all of the files into that directory. Instructions 1/2 50 XP\n1\n\nMake a copy of seasonal/summer.csv in the backup directory (which is also in /home/repl), calling the new file summer.bck.\n2\nCopy spring.csv and summer.csv from the seasonal directory into the backup directory without changing your current working directory (/home/repl).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#move-the-file-with-mw",
    "href": "6_linux_comands_basic.html#move-the-file-with-mw",
    "title": "6  Manipulating files and directories",
    "section": "7.7 Move the file with mw",
    "text": "7.7 Move the file with mw\nHow can I move a file?\nWhile cp copies a file, mv moves it from one directory to another, just as if you had dragged it in a graphical file browser. It handles its parameters the same way as cp, so the command:\nmv autumn.csv winter.csv ..\nmoves the files autumn.csv and winter.csv from the current working directory up one level to its parent directory (because .. always refers to the directory above your current location). Instructions 100 XP\nYou are in /home/repl, which has sub-directories seasonal and backup. Using a single command, move spring.csv and summer.csv from seasonal to backup.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#rename-files-with-mv",
    "href": "6_linux_comands_basic.html#rename-files-with-mv",
    "title": "6  Manipulating files and directories",
    "section": "7.8 rename files with mv",
    "text": "7.8 rename files with mv\nExercise Exercise How can I rename files?\nmv can also be used to rename files. If you run:\nmv course.txt old-course.txt\nthen the file course.txt in the current working directory is “moved” to the file old-course.txt. This is different from the way file browsers work, but is often handy.\nOne warning: just like cp, mv will overwrite existing files. If, for example, you already have a file called old-course.txt, then the command shown above will replace it with whatever is in course.txt. Instructions 1/3 35 XP\n1\n\nGo into the seasonal directory.\n2\nRename the file winter.csv to be winter.csv.bck. 3\nRun ls to check that everything has worked.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#remove-files-with-rm",
    "href": "6_linux_comands_basic.html#remove-files-with-rm",
    "title": "6  Manipulating files and directories",
    "section": "7.9 remove files with rm",
    "text": "7.9 remove files with rm\nExercise Exercise How can I delete files?\nWe can copy files and move them around; to delete them, we use rm, which stands for “remove”. As with cp and mv, you can give rm the names of as many files as you’d like, so:\nrm thesis.txt backup/thesis-2017-08.txt\nremoves both thesis.txt and backup/thesis-2017-08.txt\nrm does exactly what its name says, and it does it right away: unlike graphical file browsers, the shell doesn’t have a trash can, so when you type the command above, your thesis is gone for good. Instructions 1/4 25 XP\n1\n\nYou are in /home/repl. Go into the seasonal directory.\n2\nRemove autumn.csv. 3\nGo back to your home directory. 4\nRemove seasonal/summer.csv without changing directories again.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#create-and-remove-a-directory",
    "href": "6_linux_comands_basic.html#create-and-remove-a-directory",
    "title": "6  Manipulating files and directories",
    "section": "7.10 create and remove a directory",
    "text": "7.10 create and remove a directory\nExercise Exercise How can I create and delete directories?\nmv treats directories the same way it treats files: if you are in your home directory and run mv seasonal by-season, for example, mv changes the name of the seasonal directory to by-season. However, rm works differently.\nIf you try to rm a directory, the shell prints an error message telling you it can’t do that, primarily to stop you from accidentally deleting an entire directory full of work. Instead, you can use a separate command called rmdir. For added safety, it only works when the directory is empty, so you must delete the files in a directory before you delete the directory. (Experienced users can use the -r option to rm to get the same effect; we will discuss command options in the next chapter.) Instructions 1/4 25 XP\n1\n\nWithout changing directories, delete the file agarwal.txt in the people directory.\n2\nNow that the people directory is empty, use a single command to delete it. 3\nSince a directory is not a file, you must use the command mkdir directory_name to create a new (empty) directory. Use this command to create a new directory called yearly below your home directory. 4\nNow that yearly exists, create another directory called 2017 inside it without leaving your home directory.\nExercise Exercise Wrapping up\nYou will often create intermediate files when analyzing data. Rather than storing them in your home directory, you can put them in /tmp, which is where people and programs often keep files they only need briefly. (Note that /tmp is immediately below the root directory /, not below your home directory.) This wrap-up exercise will show you how to do that. Instructions 1/4 25 XP\n1\n\nUse cd to go into /tmp.\n2\nList the contents of /tmp without typing a directory name. 3\nMake a new directory inside /tmp called scratch. 4\nMove /home/repl/people/agarwal.txt into /tmp/scratch. We suggest you use the ~ shortcut for your home directory and a relative path for the second rather than the absolute path.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#viewing-file-contents-with-cat",
    "href": "6_linux_comands_basic.html#viewing-file-contents-with-cat",
    "title": "6  Manipulating files and directories",
    "section": "8.1 Viewing file contents with cat",
    "text": "8.1 Viewing file contents with cat\nExercise Exercise How can I view a file’s contents?\nBefore you rename or delete files, you may want to have a look at their contents. The simplest way to do this is with cat, which just prints the contents of files onto the screen. (Its name is short for “concatenate”, meaning “to link things together”, since it will print all the files whose names you give it, one after the other.)\ncat agarwal.txt\nname: Agarwal, Jasmine position: RCT2 start: 2017-04-01 benefits: full\nInstructions 100 XP\nPrint the contents of course.txt to the screen.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#mutliple-paged-files-with-less",
    "href": "6_linux_comands_basic.html#mutliple-paged-files-with-less",
    "title": "6  Manipulating files and directories",
    "section": "8.2 mutliple paged files with less",
    "text": "8.2 mutliple paged files with less\nHow can I view a file’s contents piece by piece?\nYou can use cat to print large files and then scroll through the output, but it is usually more convenient to page the output. The original command for doing this was called more, but it has been superseded by a more powerful command called less. (This kind of naming is what passes for humor in the Unix world.) When you less a file, one page is displayed at a time; you can press spacebar to page down or type q to quit.\nIf you give less the names of several files, you can type :n (colon and a lower-case ‘n’) to move to the next file, :p to go back to the previous one, or :q to quit.\nNote: If you view solutions to exercises that use less, you will see an extra command at the end that turns paging off so that we can test your solutions efficiently. Instructions 100 XP\nUse less seasonal/spring.csv seasonal/summer.csv to view those two files in that order. Press spacebar to page down, :n to go to the second file, and :q to quit.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#top-n-rows-with-head",
    "href": "6_linux_comands_basic.html#top-n-rows-with-head",
    "title": "6  Manipulating files and directories",
    "section": "8.3 top n rows with head",
    "text": "8.3 top n rows with head\nExercise How can I look at the start of a file?\nThe first thing most data scientists do when given a new dataset to analyze is figure out what fields it contains and what values those fields have. If the dataset has been exported from a database or spreadsheet, it will often be stored as comma-separated values (CSV). A quick way to figure out what it contains is to look at the first few rows.\nWe can do this in the shell using a command called head. As its name suggests, it prints the first few lines of a file (where “a few” means 10), so the command:\nhead seasonal/summer.csv\ndisplays:\nDate,Tooth 2017-01-11,canine 2017-01-18,wisdom 2017-01-21,bicuspid 2017-02-02,molar 2017-02-27,wisdom 2017-02-27,wisdom 2017-03-07,bicuspid 2017-03-15,wisdom 2017-03-20,canine\nWhat does head do if there aren’t 10 lines in the file? (To find out, use it to look at the top of people/agarwal.txt.) Instructions 50 XP Possible answers Print an error message because the file is too short. Display as many lines as there are. Display enough blank lines to bring the total to 10.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#autocompletion-with-tab",
    "href": "6_linux_comands_basic.html#autocompletion-with-tab",
    "title": "6  Manipulating files and directories",
    "section": "8.4 autocompletion with tab",
    "text": "8.4 autocompletion with tab\nExercise Exercise How can I type less?\nOne of the shell’s power tools is tab completion. If you start typing the name of a file and then press the tab key, the shell will do its best to auto-complete the path. For example, if you type sea and press tab, it will fill in the directory name seasonal/ (with a trailing slash). If you then type a and tab, it will complete the path as seasonal/autumn.csv.\nIf the path is ambiguous, such as seasonal/s, pressing tab a second time will display a list of possibilities. Typing another character or two to make your path more specific and then pressing tab will fill in the rest of the name. Instructions 1/2 50 XP\n1\n\nRun head seasonal/autumn.csv without typing the full filename.\n2\nRun head seasonal/spring.csv without typing the full filename.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#flags",
    "href": "6_linux_comands_basic.html#flags",
    "title": "6  Manipulating files and directories",
    "section": "8.5 flags",
    "text": "8.5 flags\nExercise Exercise How can I control what commands do?\nYou won’t always want to look at the first 10 lines of a file, so the shell lets you change head’s behavior by giving it a command-line flag (or just “flag” for short). If you run the command:\nhead -n 3 seasonal/summer.csv\nhead will only display the first three lines of the file. If you run head -n 100, it will display the first 100 (assuming there are that many), and so on.\nA flag’s name usually indicates its purpose (for example, -n is meant to signal “number of lines”). Command flags don’t have to be a - followed by a single letter, but it’s a widely-used convention.\nNote: it’s considered good style to put all flags before any filenames, so in this course, we only accept answers that do that. Instructions 100 XP\nDisplay the first 5 lines of winter.csv in the seasonal directory.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#ls-1",
    "href": "6_linux_comands_basic.html#ls-1",
    "title": "6  Manipulating files and directories",
    "section": "8.6 ls",
    "text": "8.6 ls\nExercise Exercise How can I list everything below a directory?\nIn order to see everything underneath a directory, no matter how deeply nested it is, you can give ls the flag -R (which means “recursive”). If you use ls -R in your home directory, you will see something like this:\nbackup course.txt people seasonal\n./backup:\n./people: agarwal.txt\n./seasonal: autumn.csv spring.csv summer.csv winter.csv\nThis shows every file and directory in the current level, then everything in each sub-directory, and so on. Instructions 100 XP\nTo help you know what is what, ls has another flag -F that prints a / after the name of every directory and a * after the name of every runnable program. Run ls with the two flags, -R and -F, and the absolute path to your home directory to see everything it contains. (The order of the flags doesn’t matter, but the directory name must come last.)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#see-manual-with-man",
    "href": "6_linux_comands_basic.html#see-manual-with-man",
    "title": "6  Manipulating files and directories",
    "section": "8.7 see manual with man",
    "text": "8.7 see manual with man\nExercise Exercise How can I get help for a command?\nTo find out what commands do, people used to use the man command (short for “manual”). For example, the command man head brings up this information:\nHEAD(1) BSD General Commands Manual HEAD(1)\nNAME head – display first lines of a file\nSYNOPSIS head [-n count | -c bytes] [file …]\nDESCRIPTION This filter displays the first count lines or bytes of each of the specified files, or of the standard input if no files are specified. If count is omitted it defaults to 10.\n If more than a single file is specified, each file is preceded by\n a header consisting of the string ``==&gt; XXX &lt;=='' where ``XXX''\n is the name of the file.\nSEE ALSO tail(1)\nman automatically invokes less, so you may need to press spacebar to page through the information and :q to quit.\nThe one-line description under NAME tells you briefly what the command does, and the summary under SYNOPSIS lists all the flags it understands. Anything that is optional is shown in square brackets […], either/or alternatives are separated by |, and things that can be repeated are shown by …, so head’s manual page is telling you that you can either give a line count with -n or a byte count with -c, and that you can give it any number of filenames.\nThe problem with the Unix manual is that you have to know what you’re looking for. If you don’t, you can search Stack Overflow, ask a question on DataCamp’s Slack channels, or look at the SEE ALSO sections of the commands you already know. Instructions 1/2 50 XP\n1\n\nRead the manual page for the tail command to find out what putting a + sign in front of the number used with the -n flag does. (Remember to press spacebar to page down and/or type q to quit.)\n2\nUse tail with the flag -n +7 to display all but the first six lines of seasonal/spring.csv.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#cut-command",
    "href": "6_linux_comands_basic.html#cut-command",
    "title": "6  Manipulating files and directories",
    "section": "8.8 cut command",
    "text": "8.8 cut command\nExercise Exercise How can I select columns from a file?\nhead and tail let you select rows from a text file. If you want to select columns, you can use the command cut. It has several options (use man cut to explore them), but the most common is something like:\ncut -f 2-5,8 -d , values.csv\nwhich means “select columns 2 through 5 and columns 8, using comma as the separator”. cut uses -f (meaning “fields”) to specify columns and -d (meaning “delimiter”) to specify the separator. You need to specify the latter because some files may use spaces, tabs, or colons to separate columns.\nWhat command will select the first column (containing dates) from the file spring.csv? Instructions 50 XP Possible answers cut -d , -f 1 seasonal/spring.csv cut -d, -f1 seasonal/spring.csv Either of the above. Neither of the above, because -f must come before -d.\nExercise Exercise What can’t cut do?\ncut is a simple-minded command. In particular, it doesn’t understand quoted strings. If, for example, your file is:\nName,Age “Johel,Ranjit”,28 “Sharma,Rupinder”,26\nthen:\ncut -f 2 -d , everyone.csv\nwill produce:\nAge Ranjit” Rupinder”\nrather than everyone’s age, because it will think the comma between last and first names is a column separator.\nWhat is the output of cut -d : -f 2-4 on the line:\nfirst:second:third:\n(Note the trailing colon.) Instructions 50 XP Possible answers second second:third second:third: None of the above, because there aren’t four fields.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#history",
    "href": "6_linux_comands_basic.html#history",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.9 history",
    "text": "6.9 history\nKomanda history (liet. “istorija”) naudojama norint parodyti visų anksčiau įvestų komandų sąrašą dabartinėje terminalo sesijoje. Tai suteikia patogų būdą sekti ir kartoti anksčiau vykdytas komandas.\nParodyti visą komandų istoriją:\nhistory\n\nJei norite parodyti tik paskutines n komandų, galite naudoti history n. Pvz., parodyti paskutines 10 komandų:\nhistory 10\n\nKartoti konkrečią komandą pagal numerį, galima įrašius ! ir komandos numerį\nhistory\n!51\n\nIštrinti komandų istoriją:\nhistory -c",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#grep",
    "href": "6_linux_comands_basic.html#grep",
    "title": "6  Manipulating files and directories",
    "section": "8.10 grep",
    "text": "8.10 grep\nHow can I select lines containing specific values?\nhead and tail select rows, cut selects columns, and grep selects lines according to what they contain. In its simplest form, grep takes a piece of text followed by one or more filenames and prints all of the lines in those files that contain that text. For example, grep bicuspid seasonal/winter.csv prints lines from winter.csv that contain “bicuspid”.\ngrep can search for patterns as well; we will explore those in the next course. What’s more important right now is some of grep’s more common flags:\n-c: print a count of matching lines rather than the lines themselves\n-h: do not print the names of files when searching multiple files\n-i: ignore case (e.g., treat \"Regression\" and \"regression\" as matches)\n-l: print the names of files that contain matches, not the matches\n-n: print line numbers for matching lines\n-v: invert the match, i.e., only show lines that don't match\nInstructions 1/3 35 XP\n1\n\nPrint the contents of all of the lines containing the word molar in seasonal/autumn.csv by running a single command while in your home directory. Don't use any flags.\n2\nInvert the match to find all of the lines that don’t contain the word molar in seasonal/spring.csv, and show their line numbers. Remember, it’s considered good style to put all of the flags before other values like filenames or the search term “molar”. 3\nCount how many lines contain the word incisor in autumn.csv and winter.csv combined. (Again, run a single command from your home directory.)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#redirection",
    "href": "6_linux_comands_basic.html#redirection",
    "title": "6  Manipulating files and directories",
    "section": "9.1 Redirection >",
    "text": "9.1 Redirection &gt;\nExercise Exercise How can I store a command’s output in a file?\nAll of the tools you have seen so far let you name input files. Most don’t have an option for naming an output file because they don’t need one. Instead, you can use redirection to save any command’s output anywhere you want. If you run this command:\nhead -n 5 seasonal/summer.csv\nit prints the first 5 lines of the summer data on the screen. If you run this command instead:\nhead -n 5 seasonal/summer.csv &gt; top.csv\nnothing appears on the screen. Instead, head’s output is put in a new file called top.csv. You can take a look at that file’s contents using cat:\ncat top.csv\nThe greater-than sign &gt; tells the shell to redirect head’s output to a file. It isn’t part of the head command; instead, it works with every shell command that produces output. Instructions 100 XP\nCombine tail with redirection to save the last 5 lines of seasonal/winter.csv in a file called last.csv.\nExercise Exercise How can I use a command’s output as an input?\nSuppose you want to get lines from the middle of a file. More specifically, suppose you want to get lines 3-5 from one of our data files. You can start by using head to get the first 5 lines and redirect that to a file, and then use tail to select the last 3:\nhead -n 5 seasonal/winter.csv &gt; top.csv tail -n 3 top.csv\nA quick check confirms that this is lines 3-5 of our original file, because it is the last 3 lines of the first 5. Instructions 1/2 50 XP\n1\n\nSelect the last two lines from seasonal/winter.csv and save them in a file called bottom.csv.\n2\nSelect the first line from bottom.csv in order to get the second-to-last line of the original file.\nWhat’s a better way to combine commands?\nUsing redirection to combine commands has two drawbacks:\nIt leaves a lot of intermediate files lying around (like top.csv).\nThe commands to produce your final result are scattered across several lines of history.\nThe shell provides another tool that solves both of these problems at once called a pipe. Once again, start by running head:\nhead -n 5 seasonal/summer.csv\nInstead of sending head’s output to a file, add a vertical bar and the tail command without a filename:\nhead -n 5 seasonal/summer.csv | tail -n 3\nThe pipe symbol tells the shell to use the output of the command on the left as the input to the command on the right. Instructions 100 XP\nUse cut to select all of the tooth names from column 2 of the comma delimited file seasonal/summer.csv, then pipe the result to grep, with an inverted match, to exclude the header line containing the word “Tooth”. cut and grep were covered in detail in Chapter 2, exercises 8 and 11 respectively.\nExercise Exercise How can I combine many commands?\nYou can chain any number of commands together. For example, this command:\ncut -d , -f 1 seasonal/spring.csv | grep -v Date | head -n 10\nwill:\nselect the first column from the spring data;\nremove the header line containing the word \"Date\"; and\nselect the first 10 lines of actual data.\nInstructions 100 XP\nIn the previous exercise, you used the following command to select all the tooth names from column 2 of seasonal/summer.csv:\ncut -d , -f 2 seasonal/summer.csv | grep -v Tooth\nExtend this pipeline with a head command to only select the very first tooth name.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#word-count-with-wc",
    "href": "6_linux_comands_basic.html#word-count-with-wc",
    "title": "6  Manipulating files and directories",
    "section": "9.2 word count with wc",
    "text": "9.2 word count with wc\nExercise Exercise How can I count the records in a file?\nThe command wc (short for “word count”) prints the number of characters, words, and lines in a file. You can make it print only one of these using -c, -w, or -l respectively. Instructions 100 XP\nCount how many records in seasonal/spring.csv have dates in July 2017 (2017-07).\nTo do this, use grep with a partial date to select the lines and pipe this result into wc with an appropriate flag to count the lines.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#wildcard",
    "href": "6_linux_comands_basic.html#wildcard",
    "title": "6  Manipulating files and directories",
    "section": "9.3 wildcard **",
    "text": "9.3 wildcard **\nHow can I specify many files at once?\nMost shell commands will work on multiple files if you give them multiple filenames. For example, you can get the first column from all of the seasonal data files at once like this:\ncut -d , -f 1 seasonal/winter.csv seasonal/spring.csv seasonal/summer.csv seasonal/autumn.csv\nBut typing the names of many files over and over is a bad idea: it wastes time, and sooner or later you will either leave a file out or repeat a file’s name. To make your life better, the shell allows you to use wildcards to specify a list of files with a single expression. The most common wildcard is *, which means “match zero or more characters”. Using it, we can shorten the cut command above to this:\ncut -d , -f 1 seasonal/*\nor:\ncut -d , -f 1 seasonal/*.csv\nInstructions 100 XP\nWrite a single command using head to get the first three lines from both seasonal/spring.csv and seasonal/summer.csv, a total of six lines of data, but not from the autumn or winter data files. Use a wildcard instead of spelling out the files’ names in full.\nWhat other wildcards can I use?\nThe shell has other wildcards as well, though they are less commonly used:\n? matches a single character, so 201?.txt will match 2017.txt or 2018.txt, but not 2017-01.txt.\n[...] matches any one of the characters inside the square brackets, so 201[78].txt matches 2017.txt or 2018.txt, but not 2016.txt.\n{...} matches any of the comma-separated patterns inside the curly brackets, so {*.txt, *.csv} matches any file whose name ends with .txt or .csv, but not files whose names end with .pdf.\nWhich expression would match singh.pdf and johel.txt but not sandhu.pdf or sandhu.txt?",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#sorting-with-sort",
    "href": "6_linux_comands_basic.html#sorting-with-sort",
    "title": "6  Manipulating files and directories",
    "section": "9.4 sorting with sort",
    "text": "9.4 sorting with sort\nHow can I sort lines of text?\nAs its name suggests, sort puts data in order. By default it does this in ascending alphabetical order, but the flags -n and -r can be used to sort numerically and reverse the order of its output, while -b tells it to ignore leading blanks and -f tells it to fold case (i.e., be case-insensitive). Pipelines often use grep to get rid of unwanted records and then sort to put the remaining records in order. Instructions 100 XP\nRemember the combination of cut and grep to select all the tooth names from column 2 of seasonal/summer.csv?\ncut -d , -f 2 seasonal/summer.csv | grep -v Tooth\nStarting from this recipe, sort the names of the teeth in seasonal/winter.csv (not summer.csv) in descending alphabetical order. To do this, extend the pipeline with a sort step.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#remove-adjesent-duplicates",
    "href": "6_linux_comands_basic.html#remove-adjesent-duplicates",
    "title": "6  Manipulating files and directories",
    "section": "9.5 remove adjesent duplicates",
    "text": "9.5 remove adjesent duplicates\nHow can I remove duplicate lines?\nAnother command that is often used with sort is uniq, whose job is to remove duplicated lines. More specifically, it removes adjacent duplicated lines. If a file contains:\n2017-07-03 2017-07-03 2017-08-03 2017-08-03\nthen uniq will produce:\n2017-07-03 2017-08-03\nbut if it contains:\n2017-07-03 2017-08-03 2017-07-03 2017-08-03\nthen uniq will print all four lines. The reason is that uniq is built to work with very large files. In order to remove non-adjacent lines from a file, it would have to keep the whole file in memory (or at least, all the unique lines seen so far). By only removing adjacent duplicates, it only has to keep the most recent unique line in memory. Instructions 100 XP\nWrite a pipeline to:\nget the second column from seasonal/winter.csv,\nremove the word \"Tooth\" from the output so that only tooth names are displayed,\nsort the output so that all occurrences of a particular tooth name are adjacent; and\ndisplay each tooth name once along with a count of how often it occurs.\nThe start of your pipeline is the same as the previous exercise:\ncut -d , -f 2 seasonal/winter.csv | grep -v Tooth\nExtend it with a sort command, and use uniq -c to display unique lines with a count of how often each occurs rather than using uniq and wc.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#redirecting",
    "href": "6_linux_comands_basic.html#redirecting",
    "title": "6  Manipulating files and directories",
    "section": "9.6 redirecting",
    "text": "9.6 redirecting\nExercise How can I save the output of a pipe?\nThe shell lets us redirect the output of a sequence of piped commands:\ncut -d , -f 2 seasonal/*.csv | grep -v Tooth &gt; teeth-only.txt\nHowever, &gt; must appear at the end of the pipeline: if we try to use it in the middle, like this:\ncut -d , -f 2 seasonal/*.csv &gt; teeth-only.txt | grep -v Tooth\nthen all of the output from cut is written to teeth-only.txt, so there is nothing left for grep and it waits forever for some input.\nWhat happens if we put redirection at the front of a pipeline as in:\n\nresult.txt head -n 3 seasonal/winter.csv\n\nInstructions 50 XP Possible answers The command’s output is redirected to the file as usual. The shell reports it as an error. The shell waits for input forever.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#break-out-with-ctrl-c",
    "href": "6_linux_comands_basic.html#break-out-with-ctrl-c",
    "title": "6  Manipulating files and directories",
    "section": "9.7 break out with ctrl + c",
    "text": "9.7 break out with ctrl + c\nExercise Exercise How can I stop a running program?\nThe commands and scripts that you have run so far have all executed quickly, but some tasks will take minutes, hours, or even days to complete. You may also mistakenly put redirection in the middle of a pipeline, causing it to hang up. If you decide that you don’t want a program to keep running, you can type Ctrl + C to end it. This is often written ^C in Unix documentation; note that the ‘c’ can be lower-case. Instructions 100 XP\nRun the command:\nhead\nwith no arguments (so that it waits for input that will never come) and then stop it by typing Ctrl + C.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#wrap-up-exercise",
    "href": "6_linux_comands_basic.html#wrap-up-exercise",
    "title": "6  Manipulating files and directories",
    "section": "9.8 wrap up exercise",
    "text": "9.8 wrap up exercise\nWrapping up\nTo wrap up, you will build a pipeline to find out how many records are in the shortest of the seasonal data files. Instructions 3/3 30 XP\nUse wc with appropriate parameters to list the number of lines in all of the seasonal data files. (Use a wildcard for the filenames instead of typing them all in by hand.)\nAdd another command to the previous one using a pipe to remove the line containing the word “total”. 3\nAdd two more stages to the pipeline that use sort -n and head -n 1 to find the file containing the fewest lines.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#shell-variable",
    "href": "6_linux_comands_basic.html#shell-variable",
    "title": "6  Manipulating files and directories",
    "section": "10.1 shell variable",
    "text": "10.1 shell variable\nHow else does the shell store information?\nThe other kind of variable is called a shell variable, which is like a local variable in a programming language.\nTo create a shell variable, you simply assign a value to a name:\ntraining=seasonal/summer.csv\nwithout any spaces before or after the = sign. Once you have done this, you can check the variable’s value with:\necho $training\nseasonal/summer.csv\nInstructions 1/2 50 XP\n1\n\nDefine a variable called testing with the value seasonal/winter.csv.\n2\nUse head -n 1 SOMETHING to get the first line from seasonal/winter.csv using the value of the variable testing instead of the name of the file.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#for",
    "href": "6_linux_comands_basic.html#for",
    "title": "6  Manipulating files and directories",
    "section": "10.2 for",
    "text": "10.2 for\nHow can I repeat a command many times?\nShell variables are also used in loops, which repeat commands many times. If we run this command:\nfor filetype in gif jpg png; do echo $filetype; done\nit produces:\ngif jpg png\nNotice these things about the loop:\nThe structure is for …variable… in …list… ; do …body… ; done\nThe list of things the loop is to process (in our case, the words gif, jpg, and png).\nThe variable that keeps track of which thing the loop is currently processing (in our case, filetype).\nThe body of the loop that does the processing (in our case, echo $filetype).\nNotice that the body uses $filetype to get the variable’s value instead of just filetype, just like it does with any other shell variable. Also notice where the semi-colons go: the first one comes between the list and the keyword do, and the second comes between the body and the keyword done. Instructions 100 XP\nModify the loop so that it prints:\ndocx odt pdf\nPlease use filetype as the name of the loop variable.\nHow can I repeat a command once for each file?\nYou can always type in the names of the files you want to process when writing the loop, but it’s usually better to use wildcards. Try running this loop in the console:\nfor filename in seasonal/*.csv; do echo $filename; done\nIt prints:\nseasonal/autumn.csv seasonal/spring.csv seasonal/summer.csv seasonal/winter.csv\nbecause the shell expands seasonal/*.csv to be a list of four filenames before it runs the loop. Instructions 100 XP\nModify the wildcard expression to people/* so that the loop prints the names of the files in the people directory regardless of what suffix they do or don’t have. Please use filename as the name of your loop variable.\nHow can I record the names of a set of files?\nPeople often set a variable using a wildcard expression to record a list of filenames. For example, if you define datasets like this:\ndatasets=seasonal/*.csv\nyou can display the files’ names later using:\nfor filename in $datasets; do echo $filename; done\nThis saves typing and makes errors less likely.\nIf you run these two commands in your home directory, how many lines of output will they print?\nfiles=seasonal/*.csv for f in $files; do echo $f; done\nInstructions 50 XP Possible answers None: since files is defined on a separate line, it has no value in the second line. One: the word “files”. Four: the names of all four seasonal data files.\nA variable’s name versus its value\nA common mistake is to forget to use $ before the name of a variable. When you do this, the shell uses the name you have typed rather than the value of that variable.\nA more common mistake for experienced users is to mis-type the variable’s name. For example, if you define datasets like this:\ndatasets=seasonal/*.csv\nand then type:\necho $datsets\nthe shell doesn’t print anything, because datsets (without the second “a”) isn’t defined.\nIf you were to run these two commands in your home directory, what output would be printed?\nfiles=seasonal/*.csv for f in files; do echo $f; done\n(Read the first part of the loop carefully before answering.) Answer the question 50XP Possible Answers Select one answer\nOne line: the word \"files\".\nPress\n1\nFour lines: the names of all four seasonal data files.\nPress\n2\nFour blank lines: the variable f isn't assigned a value.\nPress\n3\nHow can I run many commands in a single loop?\nPrinting filenames is useful for debugging, but the real purpose of loops is to do things with multiple files. This loop prints the second line of each data file:\nfor file in seasonal/*.csv; do head -n 2 $file | tail -n 1; done\nIt has the same structure as the other loops you have already seen: all that’s different is that its body is a pipeline of two commands instead of a single command. Instructions 100 XP\nWrite a loop that prints the last entry from July 2017 (2017-07) in every seasonal file. It should produce a similar output to:\ngrep 2017-07 seasonal/winter.csv | tail -n 1\nbut for each seasonal file separately. Please use file as the name of the loop variable, and remember to loop through the list of files seasonal/*.csv (instead of ‘seasonal/winter.csv’ as in the example).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#filenames",
    "href": "6_linux_comands_basic.html#filenames",
    "title": "6  Manipulating files and directories",
    "section": "10.3 filenames",
    "text": "10.3 filenames\nWhy shouldn’t I use spaces in filenames?\nIt’s easy and sensible to give files multi-word names like July 2017.csv when you are using a graphical file explorer. However, this causes problems when you are working in the shell. For example, suppose you wanted to rename July 2017.csv to be 2017 July data.csv. You cannot type:\nmv July 2017.csv 2017 July data.csv\nbecause it looks to the shell as though you are trying to move four files called July, 2017.csv, 2017, and July (again) into a directory called data.csv. Instead, you have to quote the files’ names so that the shell treats each one as a single parameter:\nmv ‘July 2017.csv’ ‘2017 July data.csv’\nIf you have two files called current.csv and last year.csv (with a space in its name) and you type:\nrm current.csv last year.csv\nwhat will happen: Answer the question 50XP Possible Answers Select one answer\nThe shell will print an error message because last and year.csv do not exist.\nPress\n1\nThe shell will delete current.csv.\nPress\n2\nBoth of the above.\nPress\n3\nNothing.\nPress\n4",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#section-1",
    "href": "6_linux_comands_basic.html#section-1",
    "title": "6  Manipulating files and directories",
    "section": "10.4 ",
    "text": "10.4 \nHow can I do many things in a single loop?\nThe loops you have seen so far all have a single command or pipeline in their body, but a loop can contain any number of commands. To tell the shell where one ends and the next begins, you must separate them with semi-colons:\nfor f in seasonal/*.csv; do echo $f; head -n 2 $f | tail -n 1; done\nseasonal/autumn.csv 2017-01-05,canine seasonal/spring.csv 2017-01-25,wisdom seasonal/summer.csv 2017-01-11,canine seasonal/winter.csv 2017-01-03,bicuspid\nSuppose you forget the semi-colon between the echo and head commands in the previous loop, so that you ask the shell to run:\nfor f in seasonal/*.csv; do echo $f head -n 2 $f | tail -n 1; done\nWhat will the shell do? Instructions 50 XP Possible answers Print an error message. Print one line for each of the four files. Print one line for autumn.csv (the first file). Print the last line of each file.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#nano",
    "href": "6_linux_comands_basic.html#nano",
    "title": "6  Manipulating files and directories",
    "section": "11.1 nano",
    "text": "11.1 nano\nHow can I edit a file?\nUnix has a bewildering variety of text editors. For this course, we will use a simple one called Nano. If you type nano filename, it will open filename for editing (or create it if it doesn’t already exist). You can move around with the arrow keys, delete characters using backspace, and do other operations with control-key combinations:\nCtrl + K: delete a line.\nCtrl + U: un-delete a line.\nCtrl + O: save the file ('O' stands for 'output'). You will also need to press Enter to confirm the filename!\nCtrl + X: exit the editor.\nInstructions 100 XP\nRun nano names.txt to edit a new file in your home directory and enter the following four lines:\nLovelace Hopper Johnson Wilson\nTo save what you have written, type Ctrl + O to write the file out, then Enter to confirm the filename, then Ctrl + X to exit the editor.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#history-1",
    "href": "6_linux_comands_basic.html#history-1",
    "title": "6  Manipulating files and directories",
    "section": "11.2 history",
    "text": "11.2 history\nWhen you are doing a complex analysis, you will often want to keep a record of the commands you used. You can do this with the tools you have already seen:\nRun history.\nPipe its output to tail -n 10 (or however many recent steps you want to save).\nRedirect that to a file called something like figure-5.history.\nThis is better than writing things down in a lab notebook because it is guaranteed not to miss any steps. It also illustrates the central idea of the shell: simple tools that produce and consume lines of text can be combined in a wide variety of ways to solve a broad range of problems. Instructions 2/3 35 XP\nCopy the files seasonal/spring.csv and seasonal/summer.csv to your home directory. 2\nUse grep with the -h flag (to stop it from printing filenames) and -v Tooth (to select lines that don’t match the header line) to select the data records from spring.csv and summer.csv in that order and redirect the output to temp.csv. 3\nPipe history into tail -n 3 and redirect the output to steps.txt to save the last three commands in a file. (You need to save three instead of just two because the history command itself will be in the list.)\nHow can I save commands to re-run later?\nYou have been using the shell interactively so far. But since the commands you type in are just text, you can store them in files for the shell to run over and over again. To start exploring this powerful capability, put the following command in a file called headers.sh:\nhead -n 1 seasonal/*.csv\nThis command selects the first row from each of the CSV files in the seasonal directory. Once you have created this file, you can run it by typing:\nbash headers.sh\nThis tells the shell (which is just a program called bash) to run the commands contained in the file headers.sh, which produces the same output as running the commands directly. Instructions 1/2 50 XP\n1\n\nUse nano dates.sh to create a file called dates.sh that contains this command:\n\ncut -d , -f 1 seasonal/*.csv\n\nto extract the first column from all of the CSV files in seasonal.\n2\nUse bash to run the file dates.sh.\nHow can I re-use pipes?\nA file full of shell commands is called a *shell script, or sometimes just a “script” for short. Scripts don’t have to have names ending in .sh, but this lesson will use that convention to help you keep track of which files are scripts.\nScripts can also contain pipes. For example, if all-dates.sh contains this line:\ncut -d , -f 1 seasonal/*.csv | grep -v Date | sort | uniq\nthen:\nbash all-dates.sh &gt; dates.out\nwill extract the unique dates from the seasonal data files and save them in dates.out. Instructions 1/3 35 XP\n1\n\nA file teeth.sh in your home directory has been prepared for you, but contains some blanks. Use Nano to edit the file and replace the two ____ placeholders with seasonal/*.csv and -c so that this script prints a count of the number of times each tooth name appears in the CSV files in the seasonal directory.\n2\nUse bash to run teeth.sh and &gt; to redirect its output to teeth.out. 3\nRun cat teeth.out to inspect your results.\nHow can I pass filenames to scripts?\nA script that processes specific files is useful as a record of what you did, but one that allows you to process any files you want is more useful. To support this, you can use the special expression $@ (dollar sign immediately followed by at-sign) to mean “all of the command-line parameters given to the script”.\nFor example, if unique-lines.sh contains sort $@ | uniq, when you run:\nbash unique-lines.sh seasonal/summer.csv\nthe shell replaces $@ with seasonal/summer.csv and processes one file. If you run this:\nbash unique-lines.sh seasonal/summer.csv seasonal/autumn.csv\nit processes two data files, and so on.\nAs a reminder, to save what you have written in Nano, type Ctrl + O to write the file out, then Enter to confirm the filename, then Ctrl + X to exit the editor. Instructions 1/2 50 XP\n1\n\nEdit the script count-records.sh with Nano and fill in the two ____ placeholders with $@ and -l (the letter) respectively so that it counts the number of lines in one or more files, excluding the first line of each.\n2\nRun count-records.sh on seasonal/*.csv and redirect the output to num-records.out using &gt;.\nHow can I process a single argument?\nAs well as $@, the shell lets you use $1, $2, and so on to refer to specific command-line parameters. You can use this to write commands that feel simpler or more natural than the shell’s. For example, you can create a script called column.sh that selects a single column from a CSV file when the user provides the filename as the first parameter and the column as the second:\ncut -d , -f $2 $1\nand then run it using:\nbash column.sh seasonal/autumn.csv 1\nNotice how the script uses the two parameters in reverse order.\nThe script get-field.sh is supposed to take a filename, the number of the row to select, the number of the column to select, and print just that field from a CSV file. For example:\nbash get-field.sh seasonal/summer.csv 4 2\nshould select the second field from line 4 of seasonal/summer.csv. Which of the following commands should be put in get-field.sh to do that? Answer the question 50XP Possible Answers Select one answer\nhead -n $1 $2 | tail -n 1 | cut -d , -f $3\nPress\n1\nhead -n $2 $1 | tail -n 1 | cut -d , -f $3\nPress\n2\nhead -n $3 $1 | tail -n 1 | cut -d , -f $2\nPress\n3\nhead -n $2 $3 | tail -n 1 | cut -d , -f $1\nPress\n4\nHow can one shell script do many things?\nOur shells scripts so far have had a single command or pipe, but a script can contain many lines of commands. For example, you can create one that tells you how many records are in the shortest and longest of your data files, i.e., the range of your datasets’ lengths.\nNote that in Nano, “copy and paste” is achieved by navigating to the line you want to copy, pressing CTRL + K to cut the line, then CTRL + U twice to paste two copies of it.\nAs a reminder, to save what you have written in Nano, type Ctrl + O to write the file out, then Enter to confirm the filename, then Ctrl + X to exit the editor. Instructions 1/4 25 XP\nUse Nano to edit the script range.sh and replace the two ____ placeholders with $@ and -v so that it lists the names and number of lines in all of the files given on the command line without showing the total number of lines in all files. (Do not try to subtract the column header lines from the files.)\nUse Nano again to add sort -n and head -n 1 in that order to the pipeline in range.sh to display the name and line count of the shortest file given to it.\nAgain using Nano, add a second line to range.sh to print the name and record count of the longest file in the directory as well as the shortest. This line should be a duplicate of the one you have already written, but with sort -n -r rather than sort -n.\nRun the script on the files in the seasonal directory using seasonal/*.csv to match all of the files and redirect the output using &gt; to a file called range.out in your home directory.\nHow can I write loops in a shell script?\nShell scripts can also contain loops. You can write them using semi-colons, or split them across lines without semi-colons to make them more readable:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#from-command-line-to-bash-script",
    "href": "6_linux_comands_basic.html#from-command-line-to-bash-script",
    "title": "6  Manipulating files and directories",
    "section": "13.1 From Command-Line to Bash Script",
    "text": "13.1 From Command-Line to Bash Script\nBASH = (Bourne Again Shell)\n\n(e)greo filters input based on regex pattern matching\ncat concatenates file content line-by-line\ntail / head give only the last -n lines\nwc does a character, word or line count (with flags -c, -w, -l)\nsed does pattern-matched string replacement\n“Regex” or reguler expressions are expressions helping to match a particlar string\nregex\n\n[] creates a set\n^[] inverts the set\n\n\nExtracting scores with shell\nThere is a file in either the start_dir/first_dir, start_dir/second_dir or start_dir/third_dir directory called soccer_scores.csv. It has columns Year,Winner,Winner Goals for outcomes of a soccer league.\ncd into the correct directory and use cat and grep to find who was the winner in 1959. You could also just ls from the top directory if you like! Instructions 50 XP Possible answers Winner Dunav Botev\nSearching a book with shell\nThere is a copy of Charles Dickens’s infamous ‘Tale of Two Cities’ in your home directory called two_cities.txt.\nUse command line arguments such as cat, grep and wc with the right flag to count the number of lines in the book that contain either the character ‘Sydney Carton’ or ‘Charles Darnay’. Use exactly these spellings and capitalizations. Instructions 50 XP Possible answers 77 32 45\ncat two_cities.txt | egrep ‘Sydney Carton|Charles Darnay’ | wc -l",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#first-bash-script",
    "href": "6_linux_comands_basic.html#first-bash-script",
    "title": "6  Manipulating files and directories",
    "section": "13.2 First bash script",
    "text": "13.2 First bash script\n\nfirst line #!/usr/bash\n\ncheck with which bash as the directory might be different\n\nmain code follows\nhas the file extension .sh which is not needed if the first line has the she-bang\ncan be run with bash script.sh or just by ./script.sh\n\nShell pipelines to Bash scripts\nIn this exercise, you are working as a sports analyst for a Bulgarian soccer league. You have received some data on the results of the grand final from 1932 in a csv file. The file is comma-delimited in the format Year,Winner,Winner Goals which lists the year of the match, the team that won and how many goals the winning team scored, such as 1932,Arda,4.\nYour job is to create a Bash script from a shell piped command which will aggregate to see how many times each team has won.\nDon’t worry about the tail -n +2 part, this just ensures we don’t aggregate the CSV headers! Ide Exercise Instruction 100XP\nCreate a single-line pipe to cat the soccer_scores.csv file, cut out the relevant field and aggregate (sort & uniq -c will help!) based on winning team.\nSave your script and run from the console.\ncat soccer_scores.csv | cut -d “,” -f 2 | tail -n +2 | sort | uniq -c\nExtract and edit using Bash scripts\nContinuing your work for the Bulgarian soccer league - you need to do some editing on the data you have. Several teams have changed their names so you need to do some replacements. The data is the same as the previous exercise.\nYou will need to create a Bash script that makes use of sed to change the required team names. Ide Exercise Instruction 100XP\nCreate a pipe using sed twice to change the team Cherno to Cherno City first, and then Arda to Arda United.\nPipe the output to a file called soccer_scores_edited.csv.\nSave your script and run from the console. Try opening soccer_scores_edited.csv using shell commands to confirm it worked (the first line should be changed)!\ncat soccer_scores.csv | sed ‘s/Cherno/Cherno City/g’ | sed ‘s/Arda/Arda United/g’ &gt; soccer_scores_edited.csv",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#standard-streans-and-arguments",
    "href": "6_linux_comands_basic.html#standard-streans-and-arguments",
    "title": "6  Manipulating files and directories",
    "section": "13.3 standard streans and arguments",
    "text": "13.3 standard streans and arguments\n\nSTDIN (stadnard input). A stream of data into the program\nSTDOUT (standard output) A stream of data out of the programm\nSTDERR (standard error) Errors in your program\n2&gt; /dev/null redirecting the STDERR to be deleted\n1&gt; /dev/null would be STDOUT\n\n\n\n\nalt text\n\n\n\nARGV is the array of all atguments given\neach argument can be acess via the $ notation: $1, $2\n$@ and $* give allt he arguments in ARGV\n$# gives the lentgh (number) of arguments\n\nUsing arguments in Bash scripts\nOften you will find that your Bash scripts are part of an overall analytics pipeline or process, so it’s very useful to be able to take in arguments (ARGV) from the command line and use these inside your scripts.\nYour job is to create a Bash script that will return the arguments inputted as well as utilize some of the special properties of ARGV elements in Bash scripts.\nSince we are using arguments, you must run your script from the terminal pane, not using the ‘run this file’ button. Ide Exercise Instruction 100XP\nEcho the first and second ARGV arguments.\nEcho out the entire ARGV array in one command (not each element).\nEcho out the size of ARGV (how many arguments fed in).\nSave your script and run from the terminal pane using the arguments Bird Fish Rabbit. Don't use the ./script.sh method.\n#!/usr/bash\n# Echo the first and second ARGV arguments\necho $1 \necho $2\n# Echo out the entire ARGV array\necho $@\n# Echo out the size of ARGV\necho $#\n`bash script.sh Bird Fish Rabbit\nBird\nFish\nBird Fish Rabbit\n3\nUsing arguments with HR data\nIn this exercise, you are working as a data scientist in the HR department of a large IT company. You need to extract salary figures for recent hires, however, the HR IT system simply spits out hundreds of files into the folder /hire_data.\nEach file is comma-delimited in the format COUNTRY,CITY,JOBTITLE,SALARY such as Estonia,Tallinn,Javascript Developer,118286\nYour job is to create a Bash script to extract the information needed. Depending on the task at hand, you may need to go back and extract data for a different city. Therefore, your script will need to take in a city (an argument) as a variable, filter all the files by this city and output to a new CSV with the city name. This file can then form part of your analytics work. Ide Exercise Instruction 100XP\nEcho the first ARGV argument so you can confirm it is being read in.\ncat all the files in the directory /hire_data and pipe to grep to filter using the city name (your first ARGV argument).\nOn the same line, pipe out the filtered data to a new CSV called cityname.csv where cityname is taken from the first ARGV argument.\nSave your script and run from the console twice (do not use the ./script.sh method). Once with the argument Seoul. Then once with the argument Tallinn.\n# Echo the first ARGV argument\necho $1 \n\n# Cat all the files\n# Then pipe to grep using the first ARGV argument\n# Then write out to a named csv using the first ARGV argument\ncat hire_data/*.csv | grep \"$1\" &gt; \"$1\".csv\nbash script.sh Seoul bash script.sh Tallinn",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#variables-in-bash-scripting",
    "href": "6_linux_comands_basic.html#variables-in-bash-scripting",
    "title": "6  Manipulating files and directories",
    "section": "13.4 Variables in Bash Scripting",
    "text": "13.4 Variables in Bash Scripting\n\n13.4.1 Basic variables in Bash\nvar1=“Moon” $var1\nfirstname=“John” lastname=“Wick” echo “Hello” $firstname $lastnname\nNote, there can be no spaces around = else bash will not work\nvar1 = “Moon” $var1\n\nsingle quotes '...' shell interprets what is between literally\nsouble quotes \"...\" shell interpres literally expcept using $ and backticks backtiks ... shell runs the command and captures STDOUT back into a variable\n\nnow_var='NOW'\nnow_var_singlequote='$now_var'\necho $now_var_singlequote\nnow_var_doublequote=\"$now_var\"\necho $now_var_doublequote\n\ndate\n\nrightnow_doubleuote=\"The date is `date`.\"\necho $rightnow_doubleuote\nalternative usge $() which is more stardard way in bash\nrightnow_doubleuote=\"The date is `$(date)`.\"\necho $rightnow_doubleuote\nUsing variables in Bash\nYou have just joined a data analytics team at a new company after someone left very quickly to pursue a new job (lucky them!). Unfortunately they left so fast they did not have time to finish the Bash script they were working on as part of a new chatbot project.\nThere is an error with this script - it is printing out the words yourname rather than the person’s name. You know this has something to do with variable assignment - can you help fix this script? Add the necessary components to ensure this script runs correctly. Ide Exercise Instruction 100XP\nCreate a variable, yourname that contains the name of the user. Let's use the test name 'Sam' for this.\nFix the echo statement so it prints the variable and not the word yourname.\nRun your script.\n# Create the required variable\n____=\"____\"\n\n# Print out the assigned name (Help fix this error!)\necho \"Hi there yourname, welcome to the website!\"\nShell within a shell\nWhich of the following correctly uses a ‘shell within a shell’ to print out the date? We do not want to select the option that will just print out the string ‘date’.\nYou could try these in the console yourself! Instructions 50 XP Possible answers echo “Right now it is”date”” echo “Right now it is date” echo “Right now it is $date”",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#numeric-variables-in-bash",
    "href": "6_linux_comands_basic.html#numeric-variables-in-bash",
    "title": "6  Manipulating files and directories",
    "section": "13.5 Numeric variables in Bash",
    "text": "13.5 Numeric variables in Bash\n\nexpr is a useful utility programm (just like cat or grep)\nexpr 1+4\nit cannot handle decimal places expr 1 + 2.5\nbc\n1 + 2.5\nquit or\necho “1+2.5”| bc\nscale number of decimal places for returned valre\necho “10/3”| bc\necho “scale=3; 10/3”| bc\n\ndog_name='Roger'\ndog_age=6\necho \"... $dog_name...$dog_age\"\n\nexpr 5+7\necho $((5 +7)) &lt;- still uses expr not bc, so no decimals\n\nmodel_1=87.65\nmodel_2=89.20\necho \"The total score is $(echo \"model_1 + model_2\" |bc)\"\necho \"The avergae score is $(echo \"(model_1 + model_2) / 2\" |bc)\"\nConverting Fahrenheit to Celsius\nYou work in the analytics department for an Australian company that recently purchased an American company. The files and data from the US company are in the imperial system and need to be converted to metric. This sounds like a great opportunity to use your Bash skills to create a program which will assist.\nYour task is to write a program that takes in a single number (a temperature in Fahrenheit) as an ARGV argument, converts it to Celsius and returns the new value. There may be decimal places so you will need to undertake calculations using the bc program.\nAt all times use 2 decimal places using the scale command for bc.\nThe formula for Fahrenheit to Celsius is:\nC = (F - 32) x (5/9)\nRemember, since we are using arguments, you will need to run your script from the terminal pane rather than ‘run this file’ button. Ide Exercise Instruction 100XP\nCreate a variable temp_f from the first ARGV argument.\nCall a shell-within-a-shell to subtract 32 from temp_f and assign to variable temp_f2.\nUsing the same method, multiply temp_f2 by 5 and divide by 9, assigning to a new variable temp_c then print out temp_c.\nSave and run your script (in the terminal) using 108 Fahrenheit (the forecast temperature in Parramatta, Sydney this Saturday!).\n# Get first ARGV into variable\ntemp_f=____\n\n# Subtract 32\ntemp_f2=$(echo \"scale=2; $temp_f - ____\" | bc)\n\n# Multiply by 5/9\ntemp_c=$(echo \"scale=2; $temp_f2 * ____ / 9\" | bc)\n\n# Print the celsius temp\necho ____\nExtracting data from files\nYou are a data scientist for a climate research organization. To update some models, you need to extract temperature data for 3 regions you are monitoring. Unfortunately the temperature reading devices are quite old and can only be configured to dump data each day into a folder called temps on your server. Each file contains the daily temperature for each region.\nYour task is to extract the data from each file (by concatenating) into the relevant variable and print it out. The temperature in the file region_A needs to be assigned to the variable temp_a and so on.\nYou will later do some more advanced calculations on these variables. Ide Exercise Instruction 100XP\nCreate three variables from the data in the three files within temps by concatenating the content into a variable using a shell-within-a-shell.\nPrint out the variables to ensure it worked.\nSave your script and run from the command line.\n# Create three variables from the temp data files' contents\ntemp_a=$(____ temps/____)\ntemp_b=$(____ temps/____)\ntemp_c=$(____ temps/____)\n\n# Print out the three variables\necho \"The three temperatures were ____, $temp_b, and $temp_c\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#arrays-in-bash",
    "href": "6_linux_comands_basic.html#arrays-in-bash",
    "title": "6  Manipulating files and directories",
    "section": "13.6 Arrays in Bash",
    "text": "13.6 Arrays in Bash\n\nnumerical-indexed array\ndeclare -a my_first_array\nmy_dirst_array=(1 2 3)\nmy_dirst_array=(1,2,3) this is not correct, bash uses spaces not commas\nall array elements can be returned using array[@]. Bash requires curly {} brackes around the array name when you want to access these properties\naccessing array elements using quare brackes. note index starts at 0. so the thrid element is [2] (like in Python)\nset array elements usingf the index notation\nslicing a subset of array\n\narray[@]:N:M\n:N start index\n:M number of elements\n\nappending arrays\n\narray+=(elements)\nif missing () then 10 will be added to the first element\n\n\nmy_array=(1 3 5 2)\necho ${my_array[@]}\necho ${#my_array[@]}\necho ${my_array[2]}\nmy_array[0]=999\necho ${my_array[@]}\necho ${my_array[@]:1:2}\nmy_array+=(111)\necho ${my_array[@]}\nmy_array+=111\necho ${my_array[@]}\n\nassociative array\n\ndeclare -A city_details # declare first\ncity_details=([city_name]=\"New York\" [population]=14000000) # add eleemtens\necho ${city_details[city_name]} # index using key to return a value\necho ${city_details[population]} # index using key to return a value\ncity_details=([city_name]=\"New York\" [population]=14000000) # directly add elements\necho ${city_details[city_name]} # index using key to return a value\necho ${city_details[population]} # index using key to return a value\n\n! returns all the keys\n\necho ${!city_details[@]}\nCreating an array\nIn this exercise, you will practice building and accessing key properties of an array. Understanding what key properties are built in to Bash is important for fully utilizing arrays. For example, when iterating through arrays, knowing their length is very handy. Similarly, knowing how to easily return all array elements is also important for looping and also for checking your work and printing.\nIn this exercise, you will firstly build an array using two different methods and then access the length of the array. You will then return the entire array using a different special property. Instructions 1/3 35 XP\n1\n2\n3\n\nCreate a normal array called capital_cities which contains the cities Sydney, Albany and Paris. Do not use the declare method; fill the array as you create it. Be sure to put double quotation marks around each element!\n# Create a normal array with the mentioned elements\ncapital_cities=____",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#for-loops-while-statements",
    "href": "6_linux_comands_basic.html#for-loops-while-statements",
    "title": "6  Manipulating files and directories",
    "section": "43.1 FOR loops & WHILE statements",
    "text": "43.1 FOR loops & WHILE statements\nfor x in 1 2 3 \ndo\n    echo $x\ndone\nfor x in {1..5..2}\ndo\n    echo $x\ndone\nfor x in ((x=2;x&lt;=4;x+=2))\ndo\n    echo $x\ndone\nfor book in books/*\ndo\n    echo $book\ndone\nfor book in $(ls books/ |grep -i 'air')\ndo\n    echo $book\ndone\nx=1\nwhile [ $x -le 3 ];\ndo\n    echo $x\n    ((x+=1))\ndone\nA simple FOR loop\nYou are working as a data scientist in an organization. Due to a recent merge of departments, you have inherited a folder with many files inside. You know that the .R scripts may be useful for your work but you aren’t sure what they contain.\nWrite a simple Bash script to loop through all the files in the directory inherited_folder/ that end in .R and print out their names so you can get a quick look at what sort of scripts you have. Hopefully the file names are useful! Ide Exercise Instruction 100XP\nUse a FOR statement to loop through files that end in .R in inherited_folder/ using a glob expansion.\necho out each file name into the console.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#case-statements",
    "href": "6_linux_comands_basic.html#case-statements",
    "title": "6  Manipulating files and directories",
    "section": "46.1 CASE statements",
    "text": "46.1 CASE statements\ncase 'STRINGVAR' in\n    PATTERN1)\n    COMMAND1;;\n    PATTERN2)\n    COMMAND2;;\n    *)\n    DEFAUL COMMAND;;\nesac\n\n\n\nalt text\n\n\nDays of the week with CASE\nIn your role as a Data Scientist, it is sometimes useful to associate dates with a ‘working day’ (Monday, Tuesday, Wednesday, Thursday, Friday) or a ‘weekend’ (Saturday & Sunday).\nYour task is to build a small Bash script that will be useful to call in many areas of your data pipeline. It must take in a single argument (string of a day) into ARGV and use a CASE statement to print out whether the argument was a weekday or a weekend. You only need to account for the capitalized case for now.\nYou also don’t need to worry about words or letters before and after. Just use exact matching for this example.\nRemember the basic structure of a case statement is:\ncase MATCHVAR in PATTERN1) COMMAND1;; PATTERN2) COMMAND2;; *) DEFAULT COMMAND;; esac\nIde Exercise Instruction 100XP\nBuild a CASE statement that matches on the first ARGV element.\nCreate a match on each weekday such as Monday, Tuesday etc. using OR syntax on a single line, then a match on each weekend day (Saturday and Sunday) etc. using OR syntax on a single line.\nCreate a default match that prints out Not a day! if none of the above patterns are matched.\nSave your script and run in the terminal window with Wednesday and Saturday to test.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#basic-functions-in-bash",
    "href": "6_linux_comands_basic.html#basic-functions-in-bash",
    "title": "6  Manipulating files and directories",
    "section": "51.1 Basic functions in Bash",
    "text": "51.1 Basic functions in Bash\nfunction_name () {\n\n    ##function_code\n    return #something\n}\nfunction function_name {\n    ##function_code\n    return #something\n}\nUploading model results to the cloud\nYou are working as a data scientist on building part of your machine learning cloud infrastructure. Your team has many machine learning experiments running all the time. When an experiment is finished, it will output the results file and a configuration file into a folder called output_dir/.\nThese results need to be uploaded to your cloud storage environment for analysis. Your task is to write a Bash script that contains a function which will loop through all the files in output_dir/ and upload the result files to your cloud storage.\nFor technical reasons, no files will be uploaded; we will simply echo out the file name. Though you could easily replace this section with code to upload to Amazon S3, Google Cloud or Microsoft Azure! Ide Exercise Instruction 100XP\nSet up a function using the 'function-word' method called upload_to_cloud.\nUse a FOR statement to loop through (using glob expansion) files whose names contain results in output_dir/ and echo that the filename is being uploaded to the cloud.\nCall the function just below the function definition using its name.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#arguments-return-values-and-scope",
    "href": "6_linux_comands_basic.html#arguments-return-values-and-scope",
    "title": "6  Manipulating files and directories",
    "section": "59.1 Arguments, return values, and scope",
    "text": "59.1 Arguments, return values, and scope\n\n$1, $2 $@ $* $# \nscope\n\nglobal\nlocal\n\n\nin bash all variables are global scope\nto restrict, one can use local\n\nfunction print_filename{\n    local first_filename=$1\n}\nprint_filename 'abc.txt' 'cde.txt'\necho $first_filename\n\nreturn values\n$? if successful (0) failure (1-255)\n\nA percentage calculator\nIn your work as a data scientist, you often find yourself needing to calculate percentages within Bash scripts. This would be a great opportunity to create a nice modular function to be called from different places in your code.\nYour task is to create a Bash function that will calculate a percentage of two numbers that are given as arguments and return the value.\nA test example you can think of to use in this script is a model that you just ran where there were 456 correct predictions out of 632 on the test set.\nRemember that the shell can’t natively handle decimal places, so it will be safer to employ the use of bc. Ide Exercise Instruction 100XP\nCreate a function called return_percentage using the function-word method.\nCreate a variable inside the function called percent that divides the first argument fed into the function by the second argument.\nReturn the calculated value by echoing it back.\nCall the function with the mentioned test values of 456 (the first argument) and 632 (the second argument) and echo the result.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#scheduling-your-scripts-with-cron",
    "href": "6_linux_comands_basic.html#scheduling-your-scripts-with-cron",
    "title": "6  Manipulating files and directories",
    "section": "67.1 Scheduling your scripts with Cron",
    "text": "67.1 Scheduling your scripts with Cron\ncron name comes from chronos greek word for time its a service that runs on comuter and executes user predefined commands (cronjobs) crontab is a file tat cotnains cronjob\ncrontab -l\n\n\n\nalt text\n\n\nexaples 5 1 * * * bash myscript.sh runs at 01:05 every day 15 14 * * 7 bash myscript.sh runs at 14:15 every sunday 15,30,45 * * * * bash myscript.sh every day on 15, 30, 45 minute mark /15  * * * bash myscript.sh runs every 15 minutes\ncrontab -e you might need to select an editor nano: ctrl+s ctrl+x crontab -l\nhttps://crontab.guru/\nCreating cronjobs\nYou are working as a data scientist managing an end-to-end machine learning environment in the cloud. You have created some great Bash scripts but it is becoming tedious to have to run these scripts every morning and afternoon. You recently learned about cron which you think can greatly assist here!\nAn example file has been placed in your directory where you can create some crontab jobs.\nRemember that a crontab schedule has 5 stars relation to the time periods minute, hour, day-of-month, month-of-year, day-of-week. For this task, assume Sunday is the 0th day rather than the 7th day (as in some unix systems).\nNote that where all time periods are not specified in the instructions below, you can assume those time periods are ‘every’ (*).\nDon’t try to run the scripts or use crontab. Neither will work.\nA useful tool for constructing crontabs is https://crontab.guru/. Instructions 100 XP\nCreate a crontab schedule that runs script1.sh at 30 minutes past 2am every day.\nCreate a crontab schedule that runs script2.sh every 15, 30 and 45 minutes past every hour.\nCreate a crontab schedule that runs script3.sh at 11.30pm on Sunday evening, every week. For this task, assume Sunday is the 0th day rather than the 7th day (as in some unix systems).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Manipulating files and directories</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#shell-ir-terminalas",
    "href": "6_linux_comands_basic.html#shell-ir-terminalas",
    "title": "5  Pagridinės BASH komandos",
    "section": "",
    "text": "which $SHELL\n\n\n\nLinux Komandos/\n├── Navigacija ir informacijos gavimas/\n│   ├── cd/\n│   ├── pwd/\n│   ├── ls/\n│   ├── clear/\n│   ├── history/\n│   ├── whoami/\n│   └── which/\n├── Failų ir katalogų valdymas/\n│   ├── touch/\n│   ├── mkdir/\n│   ├── mv/\n│   ├── rm/\n│   ├── cp/\n│   ├── cat/\n│   ├── echo/\n│   ├── &gt; ir &gt;&gt;/\n│   ├── head/\n│   └── tail/\n├── Teksto paieška/\n│   └── grep/\n├── Failų ir katalogų paieška/\n│   └── find/\n├── Teisių ir savininkų keitimas/\n│   ├── chmod/\n│   └── chown/\n└── Procesų valdymas/\n    ├── ps/\n    └── top/",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#kas-aš-esu-ir-kur-aš-randuosi",
    "href": "6_linux_comands_basic.html#kas-aš-esu-ir-kur-aš-randuosi",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.2 Kas aš esu ir kur aš randuosi?",
    "text": "6.2 Kas aš esu ir kur aš randuosi?\nKomanda whoami parodo dabartinio vartotojo (user) vardą, su kuriuo esate prisijungę prie sistemos. Tai paprastas ir naudingas būdas patikrinti, kokį vartotojo prisijungimą naudojate, ypač kai dirbate su keliais vartotojais toje pačioje sistemoje.\nwhoami\nŠiuo atveju, vartotojo vardas yra main-user\n\n\n6.2.1 user vs root\nPaprastas vartotojas (user) ir root (šakninis vartotojas) Linux sistemoje turi skirtingas teises ir privilegijas.\nuser:\n\nTeisės: Turi ribotas teises, gali atlikti veiksmus tik savo namų kataloge (home directory) ir kataloguose (directories), kuriuose turi suteiktas teises.\nPriėjimas: Negali atlikti sisteminės administracijos užduočių, pvz., negali įdiegti ar pašalinti programinės įrangos, keisti sisteminių failų ar vykdyti daugumos konfigūracijos pakeitimų.\n\nroot (šakninis vartotojas)\n\nTeisės: Turi pilną administracinę prieigą prie visos sistemos. Gali atlikti bet kokias užduotis, įskaitant sisteminių failų modifikavimą, vartotojų administravimą, programinės įrangos įdiegimą ir pašalinimą.\nPriėjimas: Gali atlikti bet kokias operacijas be apribojimų\n\nPerėjimas iš paprasto vartotojo į root:\nPriklausomai nuo konteksto, norint pereiti iš paprasto vartotojo į root, naudojamos komandos:\n\nVienkartinė komanda su root teisėmis: Naudokite sudo norint vykdyti vienkartinę komandą su root teisėmis. Pvz., programos įdiegimui:\n\nsudo apt install &lt;programa&gt;\n\nPilna root sesija: Norint keisti sisteminius failus ar atlikti daugiau administracinių užduočių, naudokite sudo -i:\n\nsudo -i",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#šakninis-katalogas-ir-svarbiausi-linux-failų-sistemos-katalogai",
    "href": "6_linux_comands_basic.html#šakninis-katalogas-ir-svarbiausi-linux-failų-sistemos-katalogai",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.3 Šakninis katalogas ir svarbiausi Linux failų sistemos katalogai",
    "text": "6.3 Šakninis katalogas ir svarbiausi Linux failų sistemos katalogai\nŠakninis katalogas (angl. root directory) yra katalogas, kuris yra failų sistemos viršūnėje. Jį žymi /. Visi kiti failai ir katalogai yra šakninio katalogo pavaldiniai. Windows sistemoje tai atitiktų C:\\ katalogą.\n\nroot dircetory rasite yra daug subkatalogų (subdirectories). Pagrindiniai subkatalogai apie kuriuos reiktų žinoti:\n\n/root: Visagalio root vartotojo namų katalogas. Tai root vartotojo aplinka, kurioje jis gali dirbti, kai prisijungia kaip root.\n/etc: Čia paprastai laikomi Linux konfigūracijos failai. Šie failai kontroliuoja įvairių programų paleidimo laiką ir būdą.\n/home: Paprastų vartotojų namų katalogai. Kiekvienas vartotojas turi savo subkatalogą, pvz., /home/vartotojas, kuriame laikomi jo asmeniniai failai ir nustatymai.\n/mnt: Katalogas, kuriame yra prijungiamos (pridėjamos) kitos failų sistemos. Tai laikina vieta prijungtoms laikmenoms, tokioms kaip kietieji diskai ar tinklo diskai.\n/media: Katalogas, kuriame paprastai pritvirtinami (mounted) CD, DVD ir USB įrenginiai. Kai prijungiate USB atmintinę ar DVD, jie atsiranda šiame kataloge.\n/bin: Katalogas, kuriame yra saugomi sisteminiai vykdomieji failai (binaries), tai yra programos arba komandos, kurios yra būtinos pagrindiniam sistemos veikimui, pvz., ls, cp, mv.\n/lib: Čia rasite bibliotekas, kurios yra bendrai naudojamos programos. Tai analogiška Windows DLL failams. Šios bibliotekos būtinos daugeliui sisteminių programų ir komandų, veikiančių /bin kataloge.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#absoliutus-ir-relatyvus-kelias-path",
    "href": "6_linux_comands_basic.html#absoliutus-ir-relatyvus-kelias-path",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.5 Absoliutus ir relatyvus kelias (path)",
    "text": "6.5 Absoliutus ir relatyvus kelias (path)\nŠioje vietoje reiktų susipažinti su absoliutaus ir relatyvaus kelio samprata.\n\n6.5.1 Absoliutus kelias\nAbsoliutus kelias (angl. absolute path) yra pilnas kelias nuo šaknies katalogo (/) iki konkretaus failo ar katalogo. Jis visada nurodo tą pačią vietą, nepriklausomai nuo to, kur yra dabartinis darbinis katalogas (working directory).\nPavyzdžiai:\n/home/main-user/Documents/ataskaita.txt\n/home/main-user/Downloads/duomenys.csv\nKartais tam kad sutrumpinti kelią ir pritaikyti skriptus prie galimai kitokio vartojo vardo (ir kartu jo subkatalogo), naudoajmas ~ ženklas. Kai Shell aptinka ~, jis iškart supranta, kad turimas omenyje dabartinio vartojojo /home/vartotojas adresas.\nTaigi šie adresai yra įdentiški\n/home/main-user/Documents/ataskaita.txt\n~/Documents/ataskaita.txt\n\n\n6.5.2 Relatyvus kelias\nRelatyvus kelias (angl. relative path) yra kelias, kuris yra nurodomas atsižvelgiant į dabartinį darbinį katalogą. Relatyvus kelias neturi pradinio /, jis pradeda nurodymą nuo jūsų dabartinio katalogo.\nPavyzdžiai:\nJei esate kataloge /home/vartotojas, relatyvus kelias\nDocuments/ataskaita.txt\nnurodys failą\n/home/vartotojas/dokumentai/ataskaita`.txt\nKada naudojama kas?\n\nAbosliutus kelias dažniausiai naudojamas skriptuose, konfigūracijos failuose, dokumentacijoje ir sisteminių failų veikloje.\nRelatyvus kelias naudojamas kasdieniniame darbe su failais, vartotojo scenarijuose, bendrame naudojime ir navigacijoje bei skriptuose.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#touch",
    "href": "6_linux_comands_basic.html#touch",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.10 touch",
    "text": "6.10 touch\nKomanda touch naudojama norint sukurti tuščią failą arba pakeisti esamo failo datą ir laiką (modifikavimo ir prieigos laikus). Tai yra universali ir dažnai naudojama komanda, ypač kai reikia greitai sukurti failą arba atnaujinti failo metaduomenis.\nJei failas dar neegzistuoja, ši komanda jį sukurs. Jei failas jau yra, ji pakeis failo “paskutinio keitimo laiką” į dabartinį laiką, nekeičiant paties failo turinio.\n\nSukurti tuščią failą:\n\ntouch failas0.txt\n\n\nSukurti keletą tuščių failų vienu metu:\n\ntouch failas1.txt failas2.txt failas3.txt\n\n\nSukurti tuščią faila kitame kataloge nurodant absoliutų arba relatyvų kelią:\n\ntouch /home/user/Documents/failas4.txt\ntouch ~/Documents/failas5.txt\n\n\nPakeisti esamo failo paskutinio keitimo laiką -m abra prieigos laiką -a, arba nustatyti konkretų datą ir laiką -t:\n\ntouch -m failas.txt\ntouch -a failas.txt\ntouch -t YYYYMMDDHHMM.SS failas.txt",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#mkdir",
    "href": "6_linux_comands_basic.html#mkdir",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.11 mkdir",
    "text": "6.11 mkdir\nKomanda mkdir (angl. make directory, liet. “kurti katalogą”) naudojama norint sukurti naujus katalogus. Tai yra pagrindinė komanda, kai reikia sukurti naujus katalogus failų sistemoje.\n\nSukurti naują katalogą:\n\nmdkir projektas0\n\n\nSukurti keletą naujų katalogų vienu metu\n\nmkdir projektas1 projektas2 projektas3\n\n\nSukurti katalogų medį (hierarchiją), jei tarpiniai katalogai neegzistuoja:\n\nmkdir -p projektas0/duomenys\n\nNemo failų naršyklėje taip pat matomas rezultatas",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#rm",
    "href": "6_linux_comands_basic.html#rm",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.13 rm",
    "text": "6.13 rm\nKomanda rm (angl. remove, liet. “pašalinti”) naudojama pašalinti failus ir katalogus. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar katalogai nėra perkeliami į šiukšlinę ir jų atkurti nebebus galima.\n\nPašalinti failą:\n\nrm failas.txt\n\nPašalinti kelis failus:\n\nrm failas1.txt failas2.txt failas3.txt\n\nPašalinti tuščią katalogą:\n\nrm -d tuščias_katalogas\n\nPašalinti katalogą ir jo turinį rekursyviai:\n\nrm -r katalogas\n\nPriverstinai pašalinti failą ar katalogą:\n\nrm -rf katalogas",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#mv",
    "href": "6_linux_comands_basic.html#mv",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.12 mv",
    "text": "6.12 mv\nKomanda mv (angl. move, liet. “perkelti” arba “pervadinti”) naudojama perkelti arba pervadinti failus ir katalogus. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\n\nPervadinti failą arba katalogą:\n\nŠi komanda pervadina failą ar katalogą iš senas_pavadinimas į naujas_pavadinimas.\nmv senas_pavadinimas naujas_pavadinimas\n\nPerkelti failą į kitą katalogą:\n\nŠi komanda perkelia failą failas.txt į katalogą /naujas/kelias/.\nmv failas.txt /naujas/kelias/\n\nPerkelti kelis failus į kitą katalogą:\n\nŠi komanda perkelia failus failas1.txt ir failas2.txt į katalogą /naujas/kelias/.\nmv failas1.txt failas2.txt /naujas/kelias/\n\nPerkelti katalogą ir jo turinį į kitą vietą: Ši komanda perkelia katalogą katalogas ir visą jo turinį į katalogą /naujas/kelias/.\n\nmv katalogas /naujas/kelias/",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#echo",
    "href": "6_linux_comands_basic.html#echo",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.14 echo",
    "text": "6.14 echo\nKomanda echo naudojama norint išvesti tekstą ar kintamuojo vertę į terminalą. Tai paprasta, bet galinga komanda, kuri dažnai naudojama skriptuose, kad būtų rodomi pranešimai arba tikrinamos kintamųjų vertės.\nPagrindiniai naudojimo būdai: Išvesti paprastą tekstą:\nbash Copy code echo “Sveiki, pasauli!” Išvesti kintamuojo vertę: Pirmiausia priskirkite vertę kintamajam:\nbash Copy code vardas=“Jonas” Tada naudokite echo norint išvesti kintamojo vertę:\nbash Copy code echo “Labas, $vardas” Naudoti specialius simbolius su -e: Naudokite -e vėliavą, norint naudoti specialius simbolius, kaip (nauja eilutė) arba tabuliacija):\nbash Copy code echo -e “Labas,!” Išspausdinti sisteminius kintamuosius: Pavyzdžiui, naudokite HOME arba USER:\nbash Copy code echo “Namų katalogas: $HOME” echo “Vartotojo vardas: $USER”",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#cat",
    "href": "6_linux_comands_basic.html#cat",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.15 cat",
    "text": "6.15 cat\nKomanda cat (angl. concatenate, liet. “sujungti”) naudojama Linux ir Unix tipo operacinėse sistemose norint peržiūrėti, sujungti ir kurti failus. Tai viena iš dažniausiai naudojamų komandų, nes ji leidžia greitai peržiūrėti failų turinį, įvesti turinį į kitus failus arba sujungti kelis failus į vieną.\nPagrindiniai naudojimo būdai: Peržiūrėti failo turinį:\nbash Copy code cat failas.txt Ši komanda išveda failo failas.txt turinį į terminalą.\nSujungti kelių failų turinį ir išvesti į terminalą:\nbash Copy code cat failas1.txt failas2.txt Ši komanda išveda failų failas1.txt ir failas2.txt sujungtą turinį į terminalą.\nSukurti naują failą arba perrašyti esamą failą tekstu:\nbash Copy code cat &gt; naujas_failas.txt Įveskite tekstą ir užbaikite įvedimą paspaudę Ctrl+D.\nPridėti naują tekstą prie esamo failo:\nbash Copy code cat &gt;&gt; esamas_failas.txt Įveskite tekstą ir užbaikite įvedimą paspaudę Ctrl+D. Naujas tekstas bus pridėtas prie failo esamas_failas.txt galo.\nNukopijuoti failo turinį į kitą failą:\nbash Copy code cat failas1.txt &gt; kopija.txt Ši komanda nukopijuoja failo failas1.txt turinį į failą kopija.txt.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#ir-operatoriai",
    "href": "6_linux_comands_basic.html#ir-operatoriai",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.16 > ir >> operatoriai",
    "text": "6.16 &gt; ir &gt;&gt; operatoriai\nLinux ir Unix tipo operacinėse sistemose &gt; ir &gt;&gt; operatoriai naudojami išvesties nukreipimui (angl. output redirection). Jie nukreipia komandos išvestį į failą, o ne į terminalą. Šie operatoriai yra esminiai dirbant su failais ir automatizuojant užduotis skriptuose.\n\noperatorius Veikimas: Nukreipia komandos išvestį į failą, perrašo šio failo turinį, jei failas jau egzistuoja. Jei failas neegzistuoja, jis bus sukurtas.\n\nPavyzdžiai:\nPaprasta komanda:\nbash Copy code echo “Sveiki, pasauli!” &gt; failas.txt Ši komanda sukuria (arba perrašo) failą failas.txt su tekstu “Sveiki, pasauli!”.\nNukreipia kitos komandos išvestį:\nbash Copy code ls &gt; katalogo_turinys.txt Ši komanda nukreipia ls komandos išvestį į failą katalogo_turinys.txt, perrašydama failo turinį, jei failas jau egzistuoja.\n\n\noperatorius Veikimas: Nukreipia komandos išvestį į failą, pridedant (append) prie failo turinio. Jei failas neegzistuoja, jis bus sukurtas.\n\n\nPavyzdžiai:\nPaprasta komanda:\nbash Copy code echo “Papildomas tekstas” &gt;&gt; failas.txt Ši komanda prideda “Papildomas tekstas” prie failo failas.txt galo, neperrašydama esamo turinio.\nNukreipia kitos komandos išvestį:\nbash Copy code ls &gt;&gt; katalogo_turinys_log.txt Ši komanda prideda ls komandos išvestį prie failo katalogo_turinys_log.txt galo, išlaikydama esamą turinį.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#praktika",
    "href": "6_linux_comands_basic.html#praktika",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.7 Praktika",
    "text": "6.7 Praktika",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#navigacija-ir-darbas-su-failų-sistema",
    "href": "6_linux_comands_basic.html#navigacija-ir-darbas-su-failų-sistema",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.2 Navigacija ir darbas su failų sistema:",
    "text": "6.2 Navigacija ir darbas su failų sistema:\nKomanda whoami parodo dabartinio vartotojo (user) vardą, su kuriuo esate prisijungę prie sistemos. Tai paprastas ir naudingas būdas patikrinti, kokį vartotojo prisijungimą naudojate, ypač kai dirbate su keliais vartotojais toje pačioje sistemoje.\nwhoami\nŠiuo atveju, vartotojo vardas yra main-user\n\n\n6.2.1 user vs root\nPaprastas vartotojas (user) ir root (šakninis vartotojas) Linux sistemoje turi skirtingas teises ir privilegijas.\nuser:\n\nTeisės: Turi ribotas teises, gali atlikti veiksmus tik savo namų kataloge (home directory) ir kataloguose (directories), kuriuose turi suteiktas teises.\nPriėjimas: Negali atlikti sisteminės administracijos užduočių, pvz., negali įdiegti ar pašalinti programinės įrangos, keisti sisteminių failų ar vykdyti daugumos konfigūracijos pakeitimų.\n\nroot (šakninis vartotojas)\n\nTeisės: Turi pilną administracinę prieigą prie visos sistemos. Gali atlikti bet kokias užduotis, įskaitant sisteminių failų modifikavimą, vartotojų administravimą, programinės įrangos įdiegimą ir pašalinimą.\nPriėjimas: Gali atlikti bet kokias operacijas be apribojimų\n\nPerėjimas iš paprasto vartotojo į root:\nPriklausomai nuo konteksto, norint pereiti iš paprasto vartotojo į root, naudojamos komandos:\n\nVienkartinė komanda su root teisėmis: Naudokite sudo norint vykdyti vienkartinę komandą su root teisėmis. Pvz., programos įdiegimui:\n\nsudo apt install &lt;programa&gt;\n\nPilna root sesija: Norint keisti sisteminius failus ar atlikti daugiau administracinių užduočių, naudokite sudo -i:\n\nsudo -i",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#ekrano-valdymas-ir-komandų-istorija",
    "href": "6_linux_comands_basic.html#ekrano-valdymas-ir-komandų-istorija",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.4 Ekrano valdymas ir komandų istorija:",
    "text": "6.4 Ekrano valdymas ir komandų istorija:\n\n6.4.1 clear\nKomanda clear (liet. “valyti”) naudojama norint išvalyti terminalo ekraną, pašalinant visus anksčiau įvestus ir parodytus tekstinius duomenis. Tai palieka terminalą švarų ir patogesnį tolimesniam naudojimui. Ši komanda neištrina terminalo istorijos; ji tik paslenka visą tekstą į viršų, už dabartinio vaizdo ribų.\nclear\n\n\n6.4.2 history\nKomanda history (liet. “istorija”) naudojama norint parodyti visų anksčiau įvestų komandų sąrašą dabartinėje terminalo sesijoje. Tai suteikia patogų būdą sekti ir kartoti anksčiau vykdytas komandas.\nParodyti visą komandų istoriją:\nhistory\n\nJei norite parodyti tik paskutines n komandų, galite naudoti history n. Pvz., parodyti paskutines 10 komandų:\nhistory 10\n\nKartoti konkrečią komandą pagal numerį, galima įrašius ! ir komandos numerį\nhistory\n!51\n\nIštrinti komandų istoriją:\nhistory -c",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#failų-ir-katalogų-manipulacija",
    "href": "6_linux_comands_basic.html#failų-ir-katalogų-manipulacija",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.9 Failų ir katalogų manipulacija:",
    "text": "6.9 Failų ir katalogų manipulacija:\n\n6.9.1 touch\nKomanda touch naudojama norint sukurti tuščią failą arba pakeisti esamo failo datą ir laiką (modifikavimo ir prieigos laikus). Tai yra universali ir dažnai naudojama komanda, ypač kai reikia greitai sukurti failą arba atnaujinti failo metaduomenis.\nJei failas dar neegzistuoja, ši komanda jį sukurs. Jei failas jau yra, ji pakeis failo “paskutinio keitimo laiką” į dabartinį laiką, nekeičiant paties failo turinio.\n\nSukurti tuščią failą:\n\ntouch failas0.txt\n\n\nSukurti keletą tuščių failų vienu metu:\n\ntouch failas1.txt failas2.txt failas3.txt\n\n\nSukurti tuščią faila kitame kataloge nurodant absoliutų arba relatyvų kelią:\n\ntouch /home/user/Documents/failas4.txt\ntouch ~/Documents/failas5.txt\n\n\nPakeisti esamo failo paskutinio keitimo laiką -m abra prieigos laiką -a, arba nustatyti konkretų datą ir laiką -t:\n\ntouch -m failas.txt\ntouch -a failas.txt\ntouch -t YYYYMMDDHHMM.SS failas.txt\n\n\n6.9.2 mkdir\nKomanda mkdir (angl. make directory, liet. “kurti katalogą”) naudojama norint sukurti naujus katalogus. Tai yra pagrindinė komanda, kai reikia sukurti naujus katalogus failų sistemoje.\n\nSukurti naują katalogą:\n\nmdkir projektas0\n\n\nSukurti keletą naujų katalogų vienu metu\n\nmkdir projektas1 projektas2 projektas3\n\n\nSukurti katalogų medį (hierarchiją), jei tarpiniai katalogai neegzistuoja:\n\nmkdir -p projektas0/duomenys\n\nNemo failų naršyklėje taip pat matomas rezultatas\n\n\n\n6.9.3 mv\nKomanda mv (angl. move, liet. “perkelti” arba “pervadinti”) naudojama perkelti arba pervadinti failus ir katalogus. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\n\nPervadinti failą arba katalogą:\n\nŠi komanda pervadina failą ar katalogą iš senas_pavadinimas į naujas_pavadinimas.\nmv senas_pavadinimas naujas_pavadinimas\n\nPerkelti failą į kitą katalogą:\n\nŠi komanda perkelia failą failas.txt į katalogą /naujas/kelias/.\nmv failas.txt /naujas/kelias/\n\nPerkelti kelis failus į kitą katalogą:\n\nŠi komanda perkelia failus failas1.txt ir failas2.txt į katalogą /naujas/kelias/.\nmv failas1.txt failas2.txt /naujas/kelias/\n\nPerkelti katalogą ir jo turinį į kitą vietą: Ši komanda perkelia katalogą katalogas ir visą jo turinį į katalogą /naujas/kelias/.\n\nmv katalogas /naujas/kelias/\n\n\n6.9.4 rm\nKomanda rm (angl. remove, liet. “pašalinti”) naudojama pašalinti failus ir katalogus. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar katalogai nėra perkeliami į šiukšlinę ir jų atkurti nebebus galima.\n\nPašalinti failą:\n\nrm failas.txt\n\nPašalinti kelis failus:\n\nrm failas1.txt failas2.txt failas3.txt\n\nPašalinti tuščią katalogą:\n\nrm -d tuščias_katalogas\n\nPašalinti katalogą ir jo turinį rekursyviai:\n\nrm -r katalogas\n\nPriverstinai pašalinti failą ar katalogą:\n\nrm -rf katalogas",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#teksto-išvedimas-ir-redirekcija",
    "href": "6_linux_comands_basic.html#teksto-išvedimas-ir-redirekcija",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.5 Teksto išvedimas ir redirekcija:",
    "text": "6.5 Teksto išvedimas ir redirekcija:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#papildoma",
    "href": "6_linux_comands_basic.html#papildoma",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.6 papildoma",
    "text": "6.6 papildoma\nPapildomos svarbios komandos: cp Komanda cp (angl. copy, liet. “kopijuoti”) naudojama kopijuoti failus ir katalogus.\nPagrindiniai naudojimo būdai: Kopijuoti failą:\nbash Copy code cp šaltinis.txt tikslas.txt Ši komanda kopijuoja failą šaltinis.txt į failą tikslas.txt.\nKopijuoti katalogą rekursyviai:\nbash Copy code cp -r šaltinis_katalogas tikslas_katalogas Ši komanda kopijuoja katalogą šaltinis_katalogas ir visą jo turinį į tikslas_katalogas.\nhead ir tail Komandos head ir tail yra naudojamos peržiūrėti pirmąsias arba paskutines failo eilutes.\nPagrindiniai naudojimo būdai: Peržiūrėti pirmąsias 10 failo eilučių:\nbash Copy code head failas.txt Peržiūrėti paskutines 10 failo eilučių:\nbash Copy code tail failas.txt Peržiūrėti pirmąsias n eilučių:\nbash Copy code head -n 20 failas.txt Peržiūrėti paskutines n eilučių:\nbash Copy code tail -n 20 failas.txt grep Komanda grep (angl. global regular expression print, liet. “globalus reguliariųjų išraiškų paieškos spausdinimas”) naudojama tekstui paieškai pagal šabloną failuose arba išvestyje.\nPagrindiniai naudojimo būdai: Ieškoti teksto failuose:\nbash Copy code grep “paieškos_tikslas” failas.txt Ši komanda ieško “paieškos_tikslas” ir parodo atitinkančias eilutes iš failo failas.txt.\nIeškoti rekursyviai kataloge:\nbash Copy code grep -r “paieškos_tikslas” /path/to/directory Ši komanda ieško “paieškos_tikslas” visame katalogo ir jo pakatalogių medyje.\nfind Komanda find naudojama ieškoti failų ir katalogų pagal įvairius kriterijus.\nPagrindiniai naudojimo būdai: Ieškoti failų dabartiniame kataloge pagal pavadinimą:\nbash Copy code find . -name “failas.txt” Ieškoti failų visoje sistemoje pagal pavadinimą:\nbash Copy code find / -name “failas.txt” chmod Komanda chmod (angl. change mode, liet. “keisti režimą”) naudojama keisti failų ir katalogų teises.\nPagrindiniai naudojimo būdai: Suteikti vykdymo teisę failui:\nbash Copy code chmod +x failas.sh Nustatyti konkrečias teises:\nbash Copy code chmod 755 failas.txt chown Komanda chown (angl. change owner, liet. “keisti savininką”) naudojama keisti failų ir katalogų savininką.\nPagrindiniai naudojimo būdai: Keisti failo savininką:\nbash Copy code sudo chown naujas_savininkas failas.txt Keisti failo savininką ir grupę:\nbash Copy code sudo chown naujas_savininkas:nauja_grupė failas.txt ps ir top Komandos ps ir `top naudojamos valdyti ir stebėti procesus sistemoje.\nPagrindiniai naudojimo būdai: Parodyti veikiančius procesus su ps:\nbash Copy code ps aux Realiu laiku sekti procesus su top:\nbash Copy code top",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#navigacija-ir-informacijos-gavimas",
    "href": "6_linux_comands_basic.html#navigacija-ir-informacijos-gavimas",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.3 Navigacija ir informacijos gavimas",
    "text": "5.3 Navigacija ir informacijos gavimas\n\n5.3.1 whoami\nKomanda whoami parodo dabartinio vartotojo (user) vardą, su kuriuo esate prisijungę prie sistemos. Tai paprastas ir naudingas būdas patikrinti, kokį vartotojo prisijungimą naudojate, ypač kai dirbate su keliais vartotojais toje pačioje sistemoje.\nwhoami\nŠiuo atveju, vartotojo vardas yra main-user\n\n\n\n5.3.2 direktorija, katalogas ir aplankas\nTerminai direktorija, katalogas ir aplankas dažnai vartojami kaip sinonimai ir paprastai reiškia tą patį – vietą failų sistemoje, kur gali būti saugomi failai ir kiti subkatalogai. Tačiau yra keletas kultūrinių ir kontekstinių niuansų:\n\nDirektorija (angl. directory): Tai techninis terminas, dažniausiai vartojamas Unix/Linux bendruomenėje ir kitose techninėse aplinkose. Jis pabrėžia hierarchinę failų sistemos struktūrą.\nKatalogas: Tai dar vienas techninis terminas, dažnai vartojamas kaip sinonimas direktorijai. Šis terminas yra paplitęs tiek techninėje, tiek kasdieninėje kalboje.\nAplankas (angl. folder): Tai terminas, dažniausiai naudojamas grafinėse vartotojo sąsajose (GUI), pavyzdžiui, Windows ir Mac OS. Nors jis iš esmės reiškia tą patį kaip direktorija ar katalogas, jis dažniau sutinkamas GUI kontekste.\n\n\n\n5.3.3 sudo\nPaprastas vartotojas (user) ir šakninis vartotojas (root) Linux sistemoje turi skirtingas teises ir privilegijas.\nuser:\n\nTeisės: Turi ribotas teises, gali atlikti veiksmus tik savo namų kataloge (home directory) ir kataloguose (directories), kuriuose turi suteiktas teises.\nPriėjimas: Negali atlikti sisteminės administracijos užduočių, pvz., negali įdiegti ar pašalinti programinės įrangos, keisti sisteminių failų ar vykdyti daugumos konfigūracijos pakeitimų.\n\nroot (šakninis vartotojas)\n\nTeisės: Turi pilną administracinę prieigą prie visos sistemos. Gali atlikti bet kokias užduotis, įskaitant sisteminių failų modifikavimą, vartotojų administravimą, programinės įrangos įdiegimą ir pašalinimą.\nPriėjimas: Gali atlikti bet kokias operacijas be apribojimų\n\nPerėjimas iš paprasto vartotojo į root:\nPriklausomai nuo konteksto, norint pereiti iš paprasto vartotojo į root, naudojamos komandos:\n\nVienkartinė komanda su root teisėmis: Naudokite sudo norint vykdyti vienkartinę komandą su root teisėmis. Pvz., programos įdiegimui:\n\nsudo apt install &lt;programa&gt;\n\nPilna root sesija: Norint keisti sisteminius failus ar atlikti daugiau administracinių užduočių, naudokite sudo -i:\n\nsudo -i\n\n\n5.3.4 Šakninis katalogas ir svarbiausi Linux failų sistemos katalogai\nŠakninis katalogas (angl. root directory) yra katalogas, kuris yra failų sistemos viršūnėje. Jį žymi /. Visi kiti failai ir katalogai yra šakninio katalogo pavaldiniai. Windows sistemoje tai atitiktų C:\\ katalogą.\n\nroot dircetory rasite yra daug subkatalogų (subdirectories). Pagrindiniai subkatalogai apie kuriuos reiktų žinoti:\n\n/root: Visagalio root vartotojo namų katalogas. Tai root vartotojo aplinka, kurioje jis gali dirbti, kai prisijungia kaip root.\n/etc: Čia paprastai laikomi Linux konfigūracijos failai. Šie failai kontroliuoja įvairių programų paleidimo laiką ir būdą.\n/home: Paprastų vartotojų namų katalogai. Kiekvienas vartotojas turi savo subkatalogą, pvz., /home/vartotojas, kuriame laikomi jo asmeniniai failai ir nustatymai.\n/mnt: Katalogas, kuriame yra prijungiamos (pridėjamos) kitos failų sistemos. Tai laikina vieta prijungtoms laikmenoms, tokioms kaip kietieji diskai ar tinklo diskai.\n/media: Katalogas, kuriame paprastai pritvirtinami (mounted) CD, DVD ir USB įrenginiai. Kai prijungiate USB atmintinę ar DVD, jie atsiranda šiame kataloge.\n/bin: Katalogas, kuriame yra saugomi sisteminiai vykdomieji failai (binaries), tai yra programos arba komandos, kurios yra būtinos pagrindiniam sistemos veikimui, pvz., ls, cp, mv.\n/lib: Čia rasite bibliotekas, kurios yra bendrai naudojamos programos. Tai analogiška Windows DLL failams. Šios bibliotekos būtinos daugeliui sisteminių programų ir komandų, veikiančių /bin kataloge.\n\n\n\n5.3.5 pwd\nKomanda pwd (angl. “print working directory”, liet. “parodyti darbinį katalogą”) parodo dabartinio darbinio katalogo pilną kelią (path). Tai naudinga komanda, jei norite sužinoti, kuriame kataloge šiuo metu dirbate.\npwd\n\nTaigi šiuo atveju darbinis katalogas yra /home/main-user\n\n5.3.5.1 Absoliutus ir relatyvus kelias (path)\nŠioje vietoje reiktų susipažinti su absoliutaus ir relatyvaus kelio samprata.\n\n5.3.5.1.1 Absoliutus kelias\nAbsoliutus kelias (angl. absolute path) yra pilnas kelias nuo šaknies katalogo (/) iki konkretaus failo ar katalogo. Jis visada nurodo tą pačią vietą, nepriklausomai nuo to, kur yra dabartinis darbinis katalogas (working directory).\nPavyzdžiai:\n/home/main-user/Documents/ataskaita.txt\n/home/main-user/Downloads/duomenys.csv\nKartais tam kad sutrumpinti kelią ir pritaikyti skriptus prie galimai kitokio vartojo vardo (ir kartu jo subkatalogo), naudoajmas ~ ženklas. Kai Shell aptinka ~, jis iškart supranta, kad turimas omenyje dabartinio vartojojo /home/vartotojas adresas.\nTaigi šie adresai yra įdentiški\n/home/main-user/Documents/ataskaita.txt\n~/Documents/ataskaita.txt\n\n\n5.3.5.1.2 Relatyvus kelias\nRelatyvus kelias (angl. relative path) yra kelias, kuris yra nurodomas atsižvelgiant į dabartinį darbinį katalogą. Relatyvus kelias neturi pradinio /, jis pradeda nurodymą nuo jūsų dabartinio katalogo.\nPavyzdžiai:\nJei esate kataloge /home/vartotojas, relatyvus kelias\nDocuments/ataskaita.txt\nnurodys failą\n/home/vartotojas/dokumentai/ataskaita`.txt\nKada naudojama kas?\n\nAbosliutus kelias dažniausiai naudojamas skriptuose, konfigūracijos failuose, dokumentacijoje ir sisteminių failų veikloje.\nRelatyvus kelias naudojamas kasdieniniame darbe su failais, vartotojo scenarijuose, bendrame naudojime ir navigacijoje bei skriptuose.\n\n\n\n\n\n5.3.6 cd\nKomanda cd (angl. change directory, liet. “pakeisti katalogą”) naudojama pereiti iš vieno katalogo į kitą. Ši komanda leidžia keisti dabartinį darbinį katalogą.\n\nPereiti į konkretų katalogą pagal absoliutų kelią:\n\ncd /home/vartotojas/Documents\n\n\nPereiti į konkretų katalogą pagal relatyvų kelią:\n\ncd dokumentai/projektai\n\nPereiti į tėvinį katalogą (parent directory) (vienu lygiu aukščiau):\ncd ..\n\nTiesa, galite pereiti ir kiek įmantriau, štai iš Downloads, pakylama į tėvinį katalogą (..), o tada einama į /Documents:\ncd ../Documents\n\nPereiti į namų katalogą:\n\ncd\ncd ~\n\n\nPereiti į ankstesnį katalogą, kuriame buvote prieš pereidami į dabartinį katalogą:\n\ncd -\n\n\n5.3.7 ls\nKomanda ls (angl. list, liet. “parodyti sąrašą”) naudojama norint peržiūrėti failų ir katalogų sąrašą dabartiniame arba nurodytame kataloge. Tai viena iš dažniausiai naudojamų komandų naviguojant failų sistemoje Linux ir Unix tipo operacinėse sistemose.\n\nParodyti dabartinio katalogo turinį:\n\nls\n\n\nParodyti konkretaus katalogo turinį:\n\nls /path/to/directory\n\n\nParodyti išsamų (ilgą) failų sąrašą su detalėmis, pvz., teisėmis,savininku, dydžiu ir paskutinio modifikavimo data:\n\nls -l\n\n\nParodyti visus failus, įskaitant paslėptus (failai, kurių pavadinimai prasideda tašku):\n\nls -a\n\n\nNaudoti ilgą sąrašą su žmogišku skaitymo formatu -h (dydžiai rodomi su B, K, M). Čia sukombinuojamas -l su -a ir -h\n\nls -lah\n\n\nParodyti katalogų turinį rekursyviai (parodyti failus ir katalogus visuose pakatalogiuose):\n\nls -R\n\n\n\n5.3.8 clear\nKomanda clear (liet. “valyti”) naudojama norint išvalyti terminalo ekraną, pašalinant visus anksčiau įvestus ir parodytus tekstinius duomenis. Tai palieka terminalą švarų ir patogesnį tolimesniam naudojimui. Ši komanda neištrina terminalo istorijos; ji tik paslenka visą tekstą į viršų, už dabartinio vaizdo ribų.\nclear\n\n\n5.3.9 history\nKomanda history (liet. “istorija”) naudojama norint parodyti visų anksčiau įvestų komandų sąrašą dabartinėje terminalo sesijoje. Tai suteikia patogų būdą sekti ir kartoti anksčiau vykdytas komandas.\nParodyti visą komandų istoriją:\nhistory\n\nJei norite parodyti tik paskutines n komandų, galite naudoti history n. Pvz., parodyti paskutines 10 komandų:\nhistory 10\n\nKartoti konkrečią komandą pagal numerį, galima įrašius ! ir komandos numerį\nhistory\n!51\n\nIštrinti komandų istoriją:\nhistory -c\n\n\n\n5.3.10 Intarpas: kaip naviguoti CLI\nKartais rašant ilgas komandas, mes visi padarome klaidų. Pvz parašome “Hello World” ir nuspaudžiame Enter, tik tada supratę, kad turėjome parašyti echo prieš “Hello World”.\nTokiu atveju galime su rodyklyte aukštyn pakilti, ir rodyklyte į kairę pareiti į eilutės pradžią ir prirašyti echo.\nVideo\nkartais eilutės visgi būna gana ilgos\nsud apt update & sudo apt full-upgrade -y && sudo autoremove -y && flatpak update\ndeja šįkart neįarėme sudo. Kad nereikėtų su rodyklyte tipenti ilgai… galime naudotis tam tikrais trumpiniais:\n\nCtrl-A: nušoka į eilutės pradžia\nCtrl-E nusoka į eilutės pabaigą\nCtrl-U ištrina viską į dešinė nuo kursoriaus\n\nVideo\n\n\n5.3.11 which\nKomanda which naudojama norint sužinoti, kurioje vietoje (path) yra esanti tam tikra vykdomoji programa. Ji parodo visą vykdomojo failo kelią, nurodydama, kurioje direktorijoje sistema pirmiausiai ieškos šios programos pagal PATH aplinkos kintamąjį.\nKartu ši komanda naudojama norint sužinoti, ar norima komanda yra įdiegta.\nparodo kurioje vietoje yra ls programa\nwhich ls\nTaip pat galima pamatyti, ar pvz neovim programa yra instaliuota\nwhich neovim\nKadangi Terminal negrąžino jokio kelio (path), tai pasako, jog šios programos nėra.\n\n\n\n5.3.12 Praktika\n\nSuraskite savo vartotojo pavadinimą. Ar jis atitinka tai, kas nurodoma užklausoje (prompt) prieš @?\nKai startuojate terminalą, kurioje direktorijoje randatės? Pakeiskite direktoriją, pereidami į Downloads. Uždarykite terminalo langą ir paleiskite terminalą iš naujo. Kur randatės?\nIš /home/user/ direktorijos pereikite į Downloads. Atspausdinkite direktorijos turinį naudojant komandą ls, bet nustatykite, kad:\n\n\nFailų dydis būtų suprantamas žmonėms.\nSąrašas būtų pateikiamas viename stulpelyje.\n\n\nIš /home/user/ direktorijos pereikite į Documents. Būdami joje, atspausdinkite tokį pat sąrašą failų, bet Downloads direktorijos. Pirmu atvejuy naudokite abosliutų kelią, antru, relatyvų.\n\nPagalbai:\nHome Directory/\n├── Desktop/\n├── Documents/\n├── Downloads/\n├── Music/\n├── Pictures/\n├── Public/\n├── Templates/\n└── Videos/\n\nPasinaudoję clear, išvalykite terminalo ekraną, tada naudodamiesi history suraskite komandą, naudotą 1. uždavinyje, ir pakartokite ją naudodami !n.\nPaleiskite šią komandą terminale (CTRL + SHIFT + V):\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/e61bb3ab5cf28686f74a50e436b06fe6/raw | bash\nŠi komanda parsisiųs ir įvykdys skriptą, kuris sukurs test direktoriją (kartu su pakatalogiais) jūsų namų kataloge (/home/username/).\nŠi komanda parsius ir įvykdys skriptą, kurio metu sukurs direktoriją test ~/test\n6.1. Pereikite į test direktoriją: 6.2. Pasinaudodami ls su atitinkama parinktimi atspausdinkite visus failus, net esančius po kitomis direktorijomis: 6.3. Atsakykite į šiuos klausimus: * Kiek yra aplankų (directories)? * Kiek iš viso suskaičiuojate failų? Suskaičiuokite visus failus, esančius visose direktorijose. * Kokio tipo failų (pvz., .txt, .csv) yra daugiausia? Kurioje direktorijoje?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#failų-ir-katalogų-valdymas",
    "href": "6_linux_comands_basic.html#failų-ir-katalogų-valdymas",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.4 Failų ir katalogų valdymas",
    "text": "5.4 Failų ir katalogų valdymas\n\n5.4.1 echo\nKomanda echo naudojama norint atspausdinti tekstą arba kintamojo vertę į terminalą (dar vadinamą standartine išvestimi, angl - standard output). Tai paprasta, bet galinga komanda, kuri dažnai naudojama skriptuose, kad būtų rodomi pranešimai arba tikrinamos kintamųjų vertės.\nNors nėra būtina apskliausti tekstą kabutėmis, dėl geresnio matomumo ir skaitomumo, patartina tai padaryti.\necho Hello World!\necho \"Hello World!\"\necho 'Hello World!'\nReikėtų atkreipti dėmesį į tai, jog dvivietės kabutės (““) ir vienvietės kabutės (’‘) šiek tiek skiriasi. Tekstas, kuris yra’’ viduje, atspausdinamas paraidžiui, nepaisant esančių kintamųjų ar specialiųjų simbolių. Tuo tarpu tekstas, esantis”” viduje, yra interpretuojamas, ir Shell leidžia išvesti kintamųjų vertes bei specialiuosius simbolius.\nSukurkime kintamąjį vardas='Lora'. Sukuriant kintamuosius, svarbu nepalikti laisvų vietų aplink =. Pvz., vardas = 'Lora' Bash Shell netinka, nors tai kuo puikiausiai veiktų Python kalboje.\nvardas='Lora'\necho  Hello $vardas\necho 'Hello $vardas'\necho \"Hello $vardas\"\n\nPasipraktikuok!\nSukurkite kintamuosius ME, HD ir RNR, kuriems priskirkite atitinkamai $USER, $HOME ir $RANDOM. Tada atspausdinkite jų vertes naudodami echo komandą.\nME=$USER\nHD=$HOME\nRNR=$RANDOM\n\necho \"My username on this computer is $ME and my home directory is $HD. The random number is $RNR\"\nPatvirtinkite, kad ankstesnė išvestis yra tapati šiai:\necho \"My username on this computer is $USER and my home directory is $HOME. The random number is $RANDOM\"\n\n\n5.4.2 Intarpas: Ctrl-C\nNaudojant komandinę eilutę, kartais terminalas gali „pakibti“ ir tolesnis komandų įvedimas tampa sudėtingas ar neįmanomas. Štai keletas tokių situacijų pavyzdžių:\n$ echo \"hello\n$ grep foobar\n$ yes\n$ tail\n$ cat\nSprendimas: Paspauskite Ctrl-C (laikykite Ctrl ir paspauskite C). Tai siunčia kontrolės kodą terminalui ir nutraukia vykdomą procesą.\nKartais pamatysite ^C terminale, kuris rodo, kad Ctrl-C buvo paspausta:\nPastaba: Jei Ctrl-C neveikia, pabandykite paspausti ESC (escape) klavišą. Tai padeda daugeliu atvejų.\n\n\n\n5.4.3 &gt; ir &gt;&gt; operatoriai\n&gt; ir &gt;&gt; operatoriai naudojami išvesties nukreipimui (angl. output redirection). Jie nukreipia komandos išvestį į failą, o ne į terminalą. Šie operatoriai yra esminiai dirbant su failais ir automatizuojant užduotis skriptuose.\n&gt; operatorius nukreipia komandos išvestį į failą, perrašo šio failo turinį, jei failas jau egzistuoja. Jei failas neegzistuoja, jis bus sukurtas.\necho \"Hello World!\" &gt; failas.txt\nŠi komanda sukuria (arba perrašo) failą failas.txt su tekstu “Hello World!”.\nls &gt; katalogo_turinys.txt\nŠi komanda nukreipia ls komandos išvestį į failą katalogo_turinys.txt, perrašydama failo turinį, jei failas jau egzistuoja.\n&gt;&gt; operatorius nukreipia komandos išvestį į failą, pridedant (append) prie failo turinio. Jei failas neegzistuoja, jis bus sukurtas.\necho \"What a beatiful day\" &gt;&gt; failas.txt\nŠi komanda prideda “What a beatiful day” prie failo failas.txt galo, neperrašydama esamo turinio.\nNukreipia kitos komandos išvestį:\nls -l ~/Downloads &gt;&gt; katalogo_turinys_log.txt\nls -l ~/Documents &gt;&gt; katalogo_turinys_log.txt\nŠi komanda prideda ls komandos išvestį prie failo katalogo_turinys_log.txt galo, išlaikydama esamą turinį.\n\n\n5.4.4 cat\nKomanda cat (angl. concatenate, liet. “sujungti”) naudojama norint peržiūrėti, sujungti ir kurti failus. Tai viena iš dažniausiai naudojamų komandų, nes ji leidžia greitai peržiūrėti failų turinį, įvesti turinį į kitus failus arba sujungti kelis failus į vieną.\nPagrindiniai naudojimo būdai:\n\nPeržiūrėti failo turinį:\n\ncat failas.txt\nŠi komanda išveda failo failas.txt turinį į terminalą.\n\nSujungti kelių failų turinį ir išvesti į terminalą:\n\ncat failas1.txt failas2.txt\nŠi komanda išveda failų failas1.txt ir failas2.txt sujungtą turinį į terminalą.\n\nSukurti naują failą arba perrašyti esamą failą tekstu. Įveskite tekstą ir užbaikite įvedimą paspaudę Ctrl+D.\n\ncat &gt; naujas_failas.txt\nHello world!\nWhat a nice day \\n\ncat naujas_failas.txt\nNukopijuoti failo turinį į kitą failą:\ncat failas1.txt &gt; kopija.txt\nŠi komanda nukopijuoja failo failas1.txt turinį į failą kopija.txt.\n\n\n5.4.5 Intarpas: Standartinė įvestis, išvestis ir klaidos\nLinux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenų įvestį ir išvestį programose bei komandose. Šie srautai dažnai vadinami standartine įvestimi (standard input), standartine išvestimi (standard output) ir standartine klaida (standard error). Kiekvienas jų turi specifinį paskirtį ir failo aprašymo numerį.\n\n5.4.5.1 Standartinė įvestis (stdin)\n\nFailo aprašymo numeris: 0\nAprašymas: Standartinė įvestis, sutrumpinta kaip stdin, yra srautas, iš kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, stdin yra prijungta prie klaviatūros įvesties, tačiau gali būti nukreipta iš failo ar kito srauto.\nNaudojimas:\n\n# Nuskaito duomenis iš klaviatūros\ncat\nTaip pat gali būti nukreipiama iš failo:\ncat &lt; failas.txt\n\n\n5.4.5.2 Standartinė išvestis (stdout)\n\nFailo aprašymo numeris: 1\nAprašymas: Standartinė išvestis, sutrumpinta kaip stdout, yra srautas, į kurį komanda ar programa rašo išvestį. Pagal numatytuosius nustatymus, stdout yra prijungta prie terminalo ekrano.\nNaudojimas:\n\n# Spausdina į terminalą\necho \"Hello World\"\nTaip pat gali būti nukreipiama į failą:\necho \"Hello World!\" &gt; išvestis.txt\n\n\n5.4.5.3 Standartinė klaida (stderr)\n\nFailo aprašymo numeris: 2\nAprašymas: Standartinė klaida, sutrumpinta kaip stderr, yra srautas, į kurį komanda ar programa rašo klaidų pranešimus. Pagal numatytuosius nustatymus, stderr yra prijungta prie terminalo ekrano, bet gali būti nukreipta į failą ar kitą srautą.\nNaudojimas:\n\n# Nukreipia klaidų pranešimus į failą\nls non_existing_file 2&gt; klaida.log\n\n\n5.4.5.4 Praktika:\n\nPabandykite atspausdinti (nukipijuoti) su cat neegsistuojantį failą abracadabra.txt į failą, o klaidą nukreipti į failą error_logs.txt\nSu cat atspausdinkite error_logs.txt\nSu echo bei &gt; sukurkite failą abracadabra.txt pvz\n\necho \"Abracadabra is a magic word, historically used as an apotropaic incantation on amulets and common today in stage magic. It is of unknown origin.\" &gt; 'abracadabra.txt'\n\npakartokite 1 ir 2 žingsnius.\n\n\n\n\n5.4.6 touch\nKomanda touch naudojama norint sukurti tuščią failą arba pakeisti esamo failo datą ir laiką (modifikavimo ir prieigos laikus). Tai yra universali ir dažnai naudojama komanda, ypač kai reikia greitai sukurti failą arba atnaujinti failo metaduomenis.\nJei failas dar neegzistuoja, ši komanda jį sukurs. Jei failas jau yra, ji pakeis failo “paskutinio keitimo laiką” į dabartinį laiką, nekeičiant paties failo turinio.\n\nSukurti tuščią failą:\n\ntouch failas0.txt\n\n\nSukurti keletą tuščių failų vienu metu:\n\ntouch failas1.txt failas2.txt failas3.txt\n\n\nSukurti tuščią faila kitame kataloge nurodant absoliutų arba relatyvų kelią:\n\ntouch /home/user/Documents/failas4.txt\ntouch ~/Documents/failas5.txt\n\n\nPakeisti esamo failo paskutinio keitimo laiką -m abra prieigos laiką -a, arba nustatyti konkretų datą ir laiką -t:\n\ntouch -m failas.txt\ntouch -a failas.txt\ntouch -t YYYYMMDDHHMM.SS failas.txt\n\n\n5.4.7 mkdir\nKomanda mkdir (angl. make directory, liet. “kurti katalogą”) naudojama norint sukurti naujus katalogus. Tai yra pagrindinė komanda, kai reikia sukurti naujus katalogus failų sistemoje.\n\nSukurti naują katalogą:\n\nmdkir projektas0\n\n\nSukurti keletą naujų katalogų vienu metu\n\nmkdir projektas1 projektas2 projektas3\n\n\nSukurti katalogų medį (hierarchiją), jei tarpiniai katalogai neegzistuoja:\n\nmkdir -p projektas0/duomenys\n\nNemo failų naršyklėje taip pat matomas rezultatas\n\n\n\n5.4.8 mv\nKomanda mv (angl. move, liet. “perkelti” arba “pervadinti”) naudojama perkelti arba pervadinti failus ir katalogus. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\n\nPervadinti failą arba katalogą:\n\nŠi komanda pervadina failą ar katalogą iš senas_pavadinimas į naujas_pavadinimas.\nmv senas_pavadinimas naujas_pavadinimas\n\nPerkelti failą į kitą katalogą:\n\nŠi komanda perkelia failą failas.txt į katalogą /naujas/kelias/.\nmv failas.txt /naujas/kelias/\n\nPerkelti kelis failus į kitą katalogą:\n\nŠi komanda perkelia failus failas1.txt ir failas2.txt į katalogą /naujas/kelias/.\nmv failas1.txt failas2.txt /naujas/kelias/\n\nPerkelti katalogą ir jo turinį į kitą vietą: Ši komanda perkelia katalogą katalogas ir visą jo turinį į katalogą /naujas/kelias/.\n\nmv katalogas /naujas/kelias/\n\n\n5.4.9 rm\nKomanda rm (angl. remove, liet. “pašalinti”) naudojama pašalinti failus ir katalogus. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar katalogai nėra perkeliami į šiukšlinę ir jų atkurti nebebus galima.\n\nPašalinti failą:\n\nrm failas.txt\n\nPašalinti kelis failus:\n\nrm failas1.txt failas2.txt failas3.txt\n\nPašalinti tuščią katalogą:\n\nrm -d tuščias_katalogas\n\nPašalinti katalogą ir jo turinį rekursyviai:\n\nrm -r katalogas\n\nPriverstinai pašalinti failą ar katalogą:\n\nrm -rf katalogas\n\n\n5.4.10 cp\nKomanda cp (angl. copy, liet. “kopijuoti”) naudojama kopijuoti failus ir direktorijas.\n\nKopijuoti failą:\n\ncp šaltinis.txt tikslas.txt\nŠi komanda kopijuoja failą šaltinis.txt į failą tikslas.txt.\n\nKopijuoti direktorija rekursyviai (su visu esančiu turiniu):\n\ncp -r šaltinis_katalogas tikslas_katalogas\nŠi komanda kopijuoja direktoriją šaltinis_katalogas ir visą jo turinį į tikslas_katalogas.\n\n\n5.4.11 head ir tail\nKomandos head ir tail yra naudojamos peržiūrėti pirmąsias arba paskutines failo eilutes.\n\nPeržiūrėti pirmąsias 10 failo eilučių:\n\nhead failas.txt\n\nPeržiūrėti paskutines 10 failo eilučių:\n\ntail failas.txt\n\nPeržiūrėti pirmąsias n eilučių:\n\nhead -n 20 failas.txt\n\nPeržiūrėti paskutines n eilučių:\n\ntail -n 20 failas.txt\n\n\n5.4.12 grep\nKomanda grep (angl. global regular expression print, liet. “globalus reguliariųjų išraiškų paieškos spausdinimas”) naudojama tekstui paieškai pagal šabloną failuose arba išvestyje.\n\nIeškoti teksto failuose:\n\ngrep \"paieškos_tikslas\" failas.txt\nŠi komanda ieško “paieškos_tikslas” ir parodo atitinkančias eilutes iš failo failas.txt.\n\nIeškoti rekursyviai kataloge:\n\ngrep -r \"paieškos_tikslas\" /path/to/directory\nŠi komanda ieško “paieškos_tikslas” visame katalogo ir jo pakatalogių medyje.\n\n\n5.4.13 find\nKomanda find naudojama ieškoti failų ir katalogų pagal įvairius kriterijus.\n\nIeškoti failų dabartiniame kataloge pagal pavadinimą:\n\nfind . -name \"failas.txt\"\n\nIeškoti failų visoje sistemoje pagal pavadinimą:\n\nfind / -name \"failas.txt\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#cli-komanda",
    "href": "6_linux_comands_basic.html#cli-komanda",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.2 CLI komanda",
    "text": "6.2 CLI komanda\nKomandinės eilutės sąsaja (CLI – Command Line Interface) yra sąsaja, kurioje komandos įvedamos tekstu ir rezultatai rodomi kaip teksto išvestis. Dirbant su CLI, yra keletas pagrindinių elementų, kurie padės suprasti ir efektyviai naudotis šia sąsaja.\n\n6.2.1 Prompt (užklausa)\nUžklausa (angl. prompt) yra teksto eilutė, kuri rodoma terminale ir nurodo, kad sistema yra pasirengusi priimti komandą. Užklausa dažniausiai rodo informaciją apie dabartinį darbinį katalogą, vartotojo vardą ar kitus naudingus duomenis. Pavyzdžiui:\nmain-user@linux-mint:~$\nParodo vartojo vardą @ kompiuterio vardą. ~ nurodo dabar naudojamą aktyvią darbinę direktoriją, o $ reiškia, kad kompiuteris laukia įvesties. Kas yra darbinė direktorija, susipažinsime vėliau.\n\n\n\n6.2.2 Komanda (command)\nKomanda (angl. command) yra specifinis nurodymas, kurį vartotojas įveda, kad būtų atliktas tam tikras veiksmas sistemoje. Komandos gali būti naudojamos įvairiems veiksmams atlikti, pvz., failų kopijavimui, katalogų kūrimui ar informacijos rodymui. Pavyzdžiui, komanda ls rodo dabartinio katalogo turinį\nls\nKartais komandos turi subkomandas, pvz apt yra komanda kuri valdo programą, atsakingą už programinės įrangos instaliavimą. Tačiau ji nuadojama su subkomandomis:\n\napt update:: Atnaujina paketų sąrašą.\napt install: Diegia nurodytą paketą.\napt remove: Pašalina nurodytą paketą.\napt upgrade: Atnaujina visus diegtus paketus į naujausias versijas\n\nTam kad bet kas neinstaliuotų programų, šią komandą reikia iššaukti su administratoriaus teisėmis, tam pasitelkiama komanda sudo. Taigi kartais išaukiamos kelios komandos vienu ypu.\nsudo apt update\nsudo apt install cowsay\n\n\n6.2.3 Pasirinkimas (option) ir Argumentas (argument)\nPasirinkimas (angl. option) ir argumentas (angl. argument) yra papildomi parametrai, kurie gali būti pridėti prie komandos, siekiant tiksliau nurodyti, kaip komanda turėtų būti vykdoma.\nPasirinkimas (option): Pasirinkimas modifikuoja komandos elgesį. Jis dažnai pridedamas prie komandos su brūkšneliu (-) arba dvigubu brūkšneliu (–). Pavyzdžiui, naudojant ls -l, -l yra pasirinkimas, kuris rodo failų sąrašą ilgąja forma. Kai options nurodomos sutrumpinta forma, naudoajams vienas brūkšnelis, kai išrašomas visas žodis, tada dvigubas brūkšnelis.\nArgumentas (argument): Argumentas yra papildoma informacija, kurią komanda naudoja veikimui. Pvz., ls Documents nurodo, kad komanda ls turėtų parodyti katalogo Documents turinį. Šiuo atveju Documents yra argumentas:\n\n\n6.2.4 Žymeklis (cursor)\nŽymeklis (cursor): Mirksintis žymeklis rodo, kad terminalas pasirengęs priimti kitą įvestį.\n\n\n\n6.2.5 Praktika\n\nIdentifikuok prompt, komandą, pasirinkimą ir argumentus. Nepergyvenk, jog nepažįsti pačių komandų.\n\nmain-user@linux-mint:~$ sudo apt install cowsay -y\nmain-user@linux-mint:~$ cd Downloads\nmain-user@linux-mint:~$ rm -rf test/\nmain-user@linux-mint:~$ ls -alh /home/user/Downloads\nmain-user@linux-mint:~$ mkdir -p /project/data\n\nSurask būdą kaip sukurti tabs terminale. Kartais yra labai patogu turėti kelis skritingus langus Temrinal lange. Pvz viename aktyviai stebėti kompiuterio temperatūrą, iš kito valdyti paleisti tam tikras prorgamas, o trečiame - stebėti ar kompiutueris nefiksuoja kokių nors klaidų. Bet kaip atsidaryti skirtingus tabs? Ir koks klaviatūros trumpinys tai padaro?\n\nO jeigu norėtum paleisti ne tab o atskirą langą? koks trumpinys tai padarytų?\n\n\nSusirask Terminal grafinius nustatymus ir pakeist foną, raidžių spalvą ir t.t. Rask tau patinkantį atrodymą.\n\n\n\nNors dažniausiai cursor yra blyksintis kvadratėlis, surask, kaip jį pakeisti į |.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#praktika-1",
    "href": "6_linux_comands_basic.html#praktika-1",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.8 Praktika",
    "text": "6.8 Praktika",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#cli-komandos",
    "href": "6_linux_comands_basic.html#cli-komandos",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.2 CLI komandos",
    "text": "5.2 CLI komandos\nKomandinės eilutės sąsaja (CLI – Command Line Interface) yra sąsaja, kurioje komandos įvedamos tekstu ir rezultatai rodomi kaip teksto išvestis. Dirbant su CLI, yra keletas pagrindinių elementų, kurie padės suprasti ir efektyviai naudotis šia sąsaja.\n\n5.2.1 Prompt (užklausa)\nUžklausa (angl. prompt) yra teksto eilutė, kuri rodoma terminale ir nurodo, kad sistema yra pasirengusi priimti komandą. Užklausa dažniausiai rodo informaciją apie dabartinį darbinį katalogą, vartotojo vardą ar kitus naudingus duomenis. Pavyzdžiui:\nmain-user@linux-mint:~$\nParodo vartojo vardą @ kompiuterio vardą. ~ nurodo dabar naudojamą aktyvią darbinę direktoriją, o $ reiškia, kad kompiuteris laukia įvesties. Kas yra darbinis katalogas, susipažinsime vėliau.\n\n\n\n5.2.2 Komanda (command)\nKomanda (angl. command) yra specifinis nurodymas, kurį vartotojas įveda, kad būtų atliktas tam tikras veiksmas sistemoje. Komandos gali būti naudojamos įvairiems veiksmams atlikti, pvz., failų kopijavimui, katalogų kūrimui ar informacijos rodymui. Pavyzdžiui, komanda ls rodo dabartinio katalogo turinį:\nls\nKartais komandos turi subkomandas. Pavyzdžiui, apt yra komanda, kuri valdo programą, atsakingą už programinės įrangos instaliavimą. Tačiau ji naudojama su subkomandomis:\n\napt update:: Atnaujina paketų sąrašą.\napt install: Diegia nurodytą paketą.\napt remove: Pašalina nurodytą paketą.\napt upgrade: Atnaujina visus diegtus paketus į naujausias versijas\n\nKad bet kas negalėtų instaliuoti programų, šią komandą reikia vykdyti su administratoriaus teisėmis, pasitelkiant komandą sudo. Tai reiškia, kad kartais vykdomos kelios komandos vienu metu:\nsudo apt update\nsudo apt install cowsay\n\n\n5.2.3 Pasirinkimas (option) ir Argumentas (argument)\nPasirinkimas (angl. option) ir argumentas (angl. argument) yra papildomi parametrai, kurie gali būti pridėti prie komandos, siekiant tiksliau nurodyti, kaip komanda turėtų būti vykdoma.\nPasirinkimas (option): Pasirinkimas modifikuoja komandos elgesį. Jis dažnai pridedamas prie komandos su brūkšneliu (-) arba dvigubu brūkšneliu (--). Pavyzdžiui, naudojant ls -l, -l yra pasirinkimas, kuris rodo failų sąrašą ilgąja forma. Kai pasirinkimai nurodomi sutrumpinta forma, naudojamas vienas - brūkšnelis, kai išrašomas visas žodis, tada -- dvigubas brūkšnelis.\nArgumentas (argument): Argumentas yra papildoma informacija, kurią komanda naudoja veikimui. Pvz., ls Documents nurodo, kad komanda ls turėtų parodyti katalogo Documents turinį. Šiuo atveju Documents yra argumentas:\n\n\n5.2.4 Žymeklis (cursor)\nŽymeklis (cursor): Mirksintis žymeklis rodo, kad terminalas pasirengęs priimti kitą įvestį.\n\n\n\n5.2.5 Praktika\n\nIdentifikuokite užklausą (prompt), komandą (command), pasirinkimą (option) ir argumentą (argumentą). Nepanikuokite, jei nepažįstate pačių komandų.\n\nmain-user@linux-mint:~$ sudo apt install -y cowsay\nmain-user@linux-mint:~$ cd Downloads\nmain-user@linux-mint:~$ rm -rf test/\nmain-user@linux-mint:~$ ls -alh /home/user/Downloads\nmain-user@linux-mint:~$ mkdir -p /project/data\n\nSuraskite būdą, kaip sukurti skirtukus (tabs) terminale. Kartais yra labai patogu turėti kelis skirtingus langus terminale. Pvz., viename aktyviai stebėti kompiuterio temperatūrą, iš kito valdyti ir paleisti tam tikras programas, o trečiame – stebėti, ar kompiuteris nefiksuoja kokių nors klaidų. Bet kaip atidaryti skirtukus? Ir koks klaviatūros trumpinys tai padarytų?\n\nJei norėtumėte paleisti ne skirtuką, o atskirą langą, koks trumpinys tai padarytų?\n\n\nSusiraskite terminalo grafinius nustatymus ir pakeiskite foną, raidžių spalvą ir t.t. Raskite jums patinkantį stilių.\n\n\n\nNors dažniausiai žymeklis yra blyksintis kvadratėlis, suraskite, kaip jį pakeisti į |?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#praktika-2",
    "href": "6_linux_comands_basic.html#praktika-2",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.7 Praktika",
    "text": "6.7 Praktika",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_linux_comands_basic.html#praktika-3",
    "href": "6_linux_comands_basic.html#praktika-3",
    "title": "6  Pagridinės BASH komandos",
    "section": "6.7 Praktika",
    "text": "6.7 Praktika",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html",
    "href": "7_linux_comands_advanced.html",
    "title": "7  BASH advanced",
    "section": "",
    "text": "7.0.1 help",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#pradžia",
    "href": "3_linux_update.html#pradžia",
    "title": "2  Linux atnaujinimas",
    "section": "",
    "text": "Kas yra veidrodiniai serveriai (angl. - mirrors).\nKaip atnaujinti programas naudojant Update Manager programą.\nKaip atlikti programų atnaujinimus naudojant terminalą.\n\n\n\nKaip įdiegti (angl. - install) programas naudojant Software Manager ir terminalą.\nKuo skiriasi System Package nuo Flatpak programų.\nKaip pašalinti (angl. - uninstall) nebereikalingas programas, kad kompiuteris būtų švaresnis ir veiktų sklandžiau.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "4_linux_software.html#pradžia",
    "href": "4_linux_software.html#pradžia",
    "title": "3  Linux programos ir atnaujinimai",
    "section": "",
    "text": "Kas yra veidrodiniai serveriai (angl. - mirrors).\nKaip atnaujinti programas naudojant Update Manager programą.\nKaip atlikti programų atnaujinimus naudojant terminalą.\n\n\n\nKaip įdiegti (angl. - install) programas naudojant Software Manager ir terminalą.\nKuo skiriasi System Package nuo Flatpak programų.\nKaip pašalinti (angl. - uninstall) nebereikalingas programas, kad kompiuteris būtų švaresnis ir veiktų sklandžiau.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#themes",
    "href": "1_linux_configure.html#themes",
    "title": "1  Linux konfiguracija",
    "section": "1.2 Themes",
    "text": "1.2 Themes",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux konfiguracija</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#backgrounds",
    "href": "1_linux_configure.html#backgrounds",
    "title": "1  Linux konfiguracija",
    "section": "1.3 Backgrounds",
    "text": "1.3 Backgrounds",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux konfiguracija</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#menu",
    "href": "1_linux_configure.html#menu",
    "title": "1  Linux konfiguracija",
    "section": "1.4 Menu",
    "text": "1.4 Menu",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux konfiguracija</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#panel",
    "href": "1_linux_configure.html#panel",
    "title": "1  Linux konfiguracija",
    "section": "1.5 Panel",
    "text": "1.5 Panel",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux konfiguracija</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#firewall",
    "href": "1_linux_configure.html#firewall",
    "title": "1  Linux konfiguracija",
    "section": "1.6 Firewall",
    "text": "1.6 Firewall",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux konfiguracija</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#languages",
    "href": "1_linux_configure.html#languages",
    "title": "1  Linux konfiguracija",
    "section": "1.7 Languages",
    "text": "1.7 Languages",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux konfiguracija</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#keyboard",
    "href": "1_linux_configure.html#keyboard",
    "title": "1  Linux konfiguracija",
    "section": "1.8 Keyboard",
    "text": "1.8 Keyboard",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux konfiguracija</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#time",
    "href": "1_linux_configure.html#time",
    "title": "1  Linux konfiguracija",
    "section": "1.9 Time",
    "text": "1.9 Time",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux konfiguracija</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#tips-tricks",
    "href": "1_linux_configure.html#tips-tricks",
    "title": "1  Linux konfiguracija",
    "section": "1.10 Tips & Tricks",
    "text": "1.10 Tips & Tricks",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux konfiguracija</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#programų-instaliavimas",
    "href": "3_linux_update.html#programų-instaliavimas",
    "title": "2  Linux programos ir atnaujinimai",
    "section": "2.3 Programų instaliavimas",
    "text": "2.3 Programų instaliavimas\nProgramų instaliavimas Linux yra gana paprastas. Užtenka susirasti ir atsidaryti Software Manager.\n\nJam atsidarius, iškart matome daug programų pasiūlymų. Drąsiai panaršyk šiame lange. Ar matai ką nors tave dominančio?\n\n\n2.3.1 Sisteminių paketų instaliavimas\nSisteminis paketas (angl. System Package) - tai programa, kurią Linux kūrėjai patikrino ir pritaikė tavo kompiuterio veikimui. Šios programos valdomos per apt programą.\nKita programų instaliavimo sistema yra Flatpak, su ja susipažinsime vėliau.\nĮdiekime “Bloboats” žaidimą.\nPaieškos viršuje įrašyk Bloboats ir paspausk ant programos piktogramos.\n\nKaip matai, sekantis langas parodo, jog tai System Package ir leidžia tau šią programą įdiegti. Spausk ant Install.\n\nSoftware Manager programa informuos tave, jei reikia įdiegti papildomas programas.\n\nJei taip nutiktų, spausk ant Continue, o tada įrašyk savo slaptažodį ir spausk ant Authenticate. Prisimeni, kai tu įrašai savo slaptažodį, kompiuteris komandas vykdo kaip sudo :)\n\nDabar gali spausti ant Launch (lt - paleisti), arba rasi šią programą tarp visų programų.\n\n\n2.3.2 Sisteminių paketų įdiegimas Terminal lange\nSusiraskime kitą programą - 3dchess. Kaip matai, jos pavadinimas kompiuteriui yra parašytas šio lango apačioje:\n\nAtsidaryk terminalą ir įrašyk šią komandą, daug kas jau tau bus matyta:\nsudo apt install 3dchess\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia įdiegti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\ninstall - komanda, pasakanti apt, ką turi daryti, šįkart įdiegti naują programą.\n3dchess - argumentas, pasakantis, kokią programą įdiegti.\n\nMes taip pat galėjome pridėti -y, bet šįkart to nepadarysime. Pažiūrėkime, kas nutinka. Ar pastebėjai kompiuterio reikalavimą patvirtinti, jog tikrai nori instaliuoti šią programą? Do you want to Continue [Y/n]\nVideo\nKaip matai, kompiuteris manęs klausė, ar tikrai noriu, ir teko įrašyti Y raidę ir spustelėti Enter. Tiesa, kai matai [Y/n] tai reiškia, kad jeigu tiesiog paspausi Enter - kompiuteris galvos, kad tu renkiesi Y (Yes trumpinys), tad rašyti Yes tau net nereikia. Kartais tu gali pamatyti [N/y]. Taigi tas pasirinkimas, kuris parašytas didžiąja raide - bus automatiškai pasirinktas jeigu nieko neįrašysi, bet pasupausi Enter klavišą.\nJeigu būčiau įrašęs komandą\nsudo apt install 3dchess -y\nTerminal programa manęs neprašytų patvirtinti mano pasirinkimo. Nes priejus šiam klausimui Do you want to Continue [Y/n], nustatymas -y pasakytų iškart Yes.\n\n\n2.3.3 Flatpak\nFlatpak yra kitoks būdas instaliuoti programas. Kai tu instaliuoji Flatpak programą, tu atsisiunti ne tik pačią programą, bet ir visas kitas programas, kurios reikalingos, kad pagrindinė programa veiktų. Pabandykime tai paaiškinti kitaip.\nĮsivaizduok, kad tavo kompiuteris yra kaip namas. Namai turi kambarius, virtuvę, vonią ir t.t. Dabar įsivaizduok, kad nori naujos spintos. Kai tu parsisiunti spintą kaip System Package (sisteminį paketą), tai tarsi parsiveži ją iš IKEA parduotuvės ir pastatai savo kambaryje.\nFlatpak programos veikia kitaip. Kai tu atsisiunti Flatpak programą, tai tarsi parsineštum visą didelę palapinę, kurioje yra ne tik tavo spinta, bet ir visa kita - virtuvė, vonia ir dar keli kambariai. Kodėl taip daroma?\nKartais programoms reikia kitų programų, kad jos veiktų gerai. Tavo kompiuteryje ne visada yra visos šios reikalingos programos. Todėl kai parsisiunti Flatpak programą, ji atsisiunčia viską, ko jai reikia, kad veiktų be problemų. Tai reiškia, kad gauni naujesnę ir geriau veikiančią programą. Tačiau ši didelė palapinė užima daugiau vietos tavo kompiuteryje, nes joje yra viskas, ko reikia programai.\nPavyzdžiui, susiraskime programą “hedgewars”. Pasirink bet kurią piktogramą.\n\nKaip matai, šalia “System Package” arba “Flatpak” yra nedidelis trikampiukas. Paspaudus ant jo, pamatysi, jog gali įdiegti šią programą ir kitu formatu.\nTaip atrodo System Package:\n\nO štai taip Flatpak. Atkreipk dėmesį į programos versijos skirtumus ir kiek vietos reikia kompiuteryje.\n\nKaip System Package ši programa užima 194 MB vietos tavo kompiuteryje, o kaip Flatpak - 3.7 GB. 3.7 GB atitinka 3700 MB. Taigi beveik 20 kartų daugiau vietos. Tai reiškia, kad Flatpak programai reikia daugiau vietos, nes ji atsisiunčia viską, ko jai reikia.\nGera žinia yra ta, kad kai instaliuosi kitą programą su Flatpak, labai tikėtina, kad kita programa jau galės naudotis kai kuriais dalykais iš pirmosios palapinės. Tada naujai programai reikės mažiau vietos.\nFlatpak programas taip pat galima instaliuoti per Terminal programą.\nTačiau tai šiek tiek skiriasi:\n\nnereikia naudoti sudo\nvietoj apt reikia naudoti flatpak\nnaudojame install\nprogramos pavadinimą galima pasiimti iš Software Manager, bet daugiau Flatpak programų galima rasti ir flathub.org tinklapyje.\n\nVideo",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#programų-ištrynimas",
    "href": "3_linux_update.html#programų-ištrynimas",
    "title": "2  Linux programos ir atnaujinimai",
    "section": "2.4 Programų ištrynimas",
    "text": "2.4 Programų ištrynimas\nKaip ir programų įdiegimas, programų ištrynimas Linux yra gana paprastas. Tai galima padaryti keliais būdais. Šiame skyriuje išmoksi ištrinti programas per Software Manager bet ir per Menu. Taip pat atlikti abu veiksmus naudojant Terminal programą.\n\n2.4.1 Software Manager\nPirmiausia pažiūrėkime, kaip ištrinti programas naudojant Software Manager.\n\nAtidaryk Software Manager.\nPaspaudus ant trijų brūkšnelių spausk ant “Show Installed Application” (lt. parodyk įdiegtas programas).\n\n\n\nSurask programą, kurią nori ištrinti, ir spausk ant jos pavadinimo ar piktogramos.\n\n\n\nAtsidariusiame lange spausk ant Remove (lt. pašalinti).\n\n\n\nSoftware Manager programa paprašys patvirtinimo. Spausk Continue, įvesk savo slaptažodį ir spausk Authenticate.\n\n\n\n2.4.2 Menu\nKitas būdas ištrinti programas yra per Menu.\n\nAtidaryk meniu, kur randi visas savo programas.\nDešiniu pelės klavišu spustelk ant programos, kurią nori ištrinti. Prasiskleis papildomas meniu.\nPasirink Uninstall (lt. pašalinti).\nPasirodys patvirtinimo langas. Pasirink OK, įvesk savo slaptažodį ir spausk Authenticate.\n\nVideo\n\n\n2.4.3 Terminalas\nProgramas taip pat galima ištrinti per terminalą.\n\n2.4.3.1 Sisteminis paketas\nNorėdami ištrinti sisteminį paketą, naudokime apt programą. Pavyzdžiui, jei nori ištrinti programą “3dchess”:\n\nAtidaryk terminalą.\nĮrašyk šią komandą: sudo apt remove 3dchess\n\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia ištrinti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\nremove - komanda, pasakanti apt, kad reikia ištrinti programą.\n3dchess - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.\n\n\n\n2.4.4 Flatpak\nPer Terminal irgi galime ištrinti Flatpak programą. Pavyzdžiui, jei nori ištrinti programą org.hedgewars.Hedgewars:\nflatpak uninstall org.hedgewars.Hedgewars\nPaaiškinkime, kas čia yra kas:\n\nflatpak - programa, kuri įdiegia, atnaujina ir pašalina Flatpak programas.\nuninstall - komanda, pasakanti flatpak, kad reikia ištrinti programą.\norg.hedgewars.Hedgewars - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.\n\n\n2.4.5 Kodėl per Terminal?\nKo gero tau dabar kyla klausimas, kodėl verta mokėti atnaujinti, įdiegti ir ištrinti programas naudojant Terminal?\nNaudoti Terminal gali atrodyti sudėtingiau nei spustelėti pelę, tačiau jis turi daug privalumų.\n\nTerminal leidžia tau atlikti daugybę užduočių labai greitai. Užuot naršant per meniu ir ieškant reikiamų funkcijų, tu gali tiesiog įvesti kelias komandas ir tavo darbas bus atliktas.\nTerminal suteikia daugiau galimybių ir lankstumo. Kai kuriuos dalykus gali padaryti tik per Terminal. Be to, Terminal naudoti gali būti smagu! Tai tarsi magija – tu rašai komandas, o kompiuteris jas vykdo.\nTerminal naudojimas gali padėti tau geriau suprasti, kaip veikia tavo kompiuteris. Kai tu įrašai komandas ir matai, kaip jos veikia, tu pradedi suvokti, kas vyksta tavo kompiuterio viduje.\nTerminal naudojimas gali padėti tau tapti tikru kompiuterių ekspertu. Ir kas žino, galbūt ateityje tave sudomins programavimo, duomenų analitikos ar tiesiog inžinerijos mokslai? Labai daug profesijų pradeda nautodi programavimą kasdieniuose savo darbuose. Aplinkosaugininkai gali tyrinėti kaip keičiasi klimatas ir kaip kinta gamta, buhalteriai gali paspasrtinti ataskaitų ruošimą, architektai apskaičiuoti kaip statyti namą, jog jis nesugriųtų vykstant žemės drebėjimui, robotikos specialistai - kaip sukonstruoti robotoą, kuris važinėja ir tyrinėja Marso planeta…\n\nSkamba truputį sudėtingai, tiesa? Pateiksiu tau pavyzdį. Įsivaizduok, kad tu turi draugę vardu Pelenė. Pelenė irgi turi kompiuterį, bet nežino, kaip įdiegti programas. Tačiau jūs norite kartu žaisti tą patį žaidimą - lenktyniauti žaidžiant Super Tux Cart. Ką daryti?\nTu gali jai parašyti žinutę ir pasakyti, kad nukopijuotų ir paleistų štai tokį kodą:\nsudo apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update && flatpak install net.supertuxkart.SuperTuxKart -y\nNa štai, jeigu jūs turite paskyras Super Tux Cart, dabar galite nuotoliniu būdu lenktyniauti kartu.\nDar neturi paskyros ir elektroninio pašto adreso? Sekančioje pamokoje tai ir susikursime.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux programos ir atnaujinimai</span>"
    ]
  },
  {
    "objectID": "3_linux_update.html#žodynėlis",
    "href": "3_linux_update.html#žodynėlis",
    "title": "2  Linux atnaujinimas",
    "section": "2.3 Žodynėlis",
    "text": "2.3 Žodynėlis\n\n\n\n\n\n\n\n\nKomanda\nApibrėžimas\nPavyzdys\n\n\n\n\nsudo apt update\nKomanda, kuri atnaujina paketų sąrašą iš visų saugyklų, kad būtų galima gauti informaciją apie naujausias programinės įrangos versijas.\nPaleidus sudo apt update, sistema patikrina, ar yra naujų programinės įrangos paketų atnaujinimų.\n\n\nsudo apt full-upgrade\nKomanda, kuri atnaujina visus įdiegtus paketus į naujausias galimas versijas, automatiškai pašalindama arba įdiegdama paketus, kai reikia.\nNaudojant sudo apt full-upgrade, jūsų sistema bus atnaujinta į naujausias programinės įrangos versijas.\n\n\nsudo autoremove\nKomanda, kuri pašalina nereikalingus paketus, kurie buvo įdiegti kaip priklausomybės, bet dabar nebėra reikalingi.\nPaleidus sudo autoremove, bus pašalinti nereikalingi bibliotekų paketai, siekiant atlaisvinti vietos diske.\n\n\nflatpak update\nKomanda, kuri atnaujina visus įdiegtus Flatpak programas į naujausias versijas.\nNaudojant flatpak update, jūsų Flatpak programos bus atnaujintos į naujausias versijas.\n\n\nsudo apt install &lt;name&gt;\nKomanda, kuri įdiegia nurodytą programinės įrangos paketą iš saugyklos.\nPaleidus sudo apt install vim, bus įdiegta vim redaktoriaus programa.\n\n\nsudo apt remove &lt;name&gt;\nKomanda, kuri pašalina nurodytą programinės įrangos paketą iš sistemos.\nNaudojant sudo apt remove vim, bus pašalinta vim redaktoriaus programa.\n\n\nflatpak install &lt;name&gt;\nKomanda, kuri įdiegia nurodytą Flatpak programą iš Flatpak saugyklos.\nPaleidus flatpak install flathub org.gimp.GIMP, bus įdiegta GIMP programa.\n\n\nflatpak remove &lt;name&gt;\nKomanda, kuri pašalina nurodytą Flatpak programą iš sistemos.\nNaudojant flatpak remove org.gimp.GIMP, bus pašalinta GIMP programa.\n\n\n-y\nParametras, kuris automatiškai atsako “taip” į visus klausimus, kuriuos komanda gali užduoti, taip palengvinant automatizuotą diegimą ar pašalinimą.\nKomandoje sudo apt install -y vim, parametras -y užtikrina, kad diegimo procesas vyks be vartotojo įsikišimo.\n\n\n&&\nLoginis operatorius, naudojamas sujungti kelias komandas taip, kad antroji komanda būtų vykdoma tik tuo atveju, jei pirmoji komanda baigiasi sėkmingai.\nKomandoje sudo apt update && sudo apt upgrade, sudo apt upgrade bus vykdoma tik tada, jei sudo apt update sėkmingai baigiasi.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html",
    "href": "6a_linux_comands_basic.html",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "",
    "text": "5.1 Shell ir Terminalas\nŠiek tiek istorijos… Senais laikais kompiuteriai buvo milžiniški. Kad būtų patogiau (santykinai) su jais dirbti, žmonės prisėsdavo prie ekrano su klaviatūra, kuris buvo sujungtas su kompiuteriu. Ši instaliacija – ekranas su klaviatūra – buvo vadinama terminalu. Darbuotojai rašydavo komandas, o kompiuteris jas vykdydavo ir grąžindavo rezultatus. Tais laikais buvo rašomos komandos, nes kompiuteriai dar nebuvo tokie galingi ir neturėjo GUI (graphical user interface, lt - grafinės vartotojo sąsajos). Taigi, terminalas buvo CLI (command line interface, lt- komandų eilutės sąsaja), nes priimdavo komandas. Tai yra vartotojo sąsaja, kurioje komandos įvedamos (input) tekstu, o rezultatai rodomi kaip teksto išvestis (output). Skirtingai nuo GUI, kur naudojami vizualiniai elementai, tokie kaip langai ir mygtukai, CLI leidžia tiesiogiai rašyti instrukcijas, kurias vykdo sistema.\nKiek vėliau, atsiradus ekranams…\nŠiais laikais, kai norime, kad kompiuteris vykdytų komandas, taip pat naudojamės terminalu, tik jau ne fiziniu, o program, kuri emuliuoja fizinį terminalą.\nPrograma, kuri priima ir vykdo komandas, bendrai vadinama Shell. Ji priima komandas, išverčia jas į kompiuterio suprantamą kalbą ir liepia kompiuteriui jas įvykdyti. Po to, gavusi rezultatus, ji juos parodo terminale. Yra keletas skirtingų Shell “kalbų” arba tipų. Populiariausi Shell tipai, tokie kaip Bash (Bourne Again Shell), yra standartinė kiekvienos Linux sistemos dalis. Zsh (Z Shell) yra standartinis Shell MacOS sistemose, tačiau jis vis labiau populiarėja ir tarp Linux vartotojų.\nShell programos leidžia automatizuoti įvairias užduotis ir vykdyti sudėtingas komandas. Be to, Shell turi programavimo kalbos savybių, leidžiančių rašyti skriptus – failus su komandomis, kurios vykdomos viena po kitos.\nTaigi terminalas yra CLI programa, kuri leidžia pasiekti Shell sąsają. Jį galima įsivaizduoti kaip langą kompiuteryje, per kurį įvedi komandas ir matai jų rezultatus. Terminalo programos naudojamos įvairiose operacinėse sistemose, nes jos leidžia efektyviau valdyti sistemą nei daugelis grafinių vartotojo sąsajų. Naudodajantis terminalu, gali atlikti įvairias užduotis greičiau ir tiksliau.\nAtidaryk terminalo programą ir įrašyk šią komandą. Ji parodys, kur yra Shell ir koks būtent Shell tipas naudojamas.\nAtsakymas (output) parodo vykdomojo Shell failo vietą – Shell programą, kuri šiuo metu naudojama tavo terminale. Iš output taip pat gali matyti, koks tai Shell tipas. Šiuo atveju, tai Bash.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#shell-ir-terminalas",
    "href": "6a_linux_comands_basic.html#shell-ir-terminalas",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "",
    "text": "The IBM 2741 Terminal IBM\n\n\n\n\n\n\n22.0 IBM Modell 360 / 370 IBM\n\n\n\n\n\n\n\nwhich $SHELL",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#cli-komanda",
    "href": "6a_linux_comands_basic.html#cli-komanda",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.2 CLI komanda",
    "text": "5.2 CLI komanda\nKomandinės eilutės sąsaja (CLI – Command Line Interface) yra sąsaja, kurioje komandos įvedamos tekstu ir rezultatai rodomi kaip teksto išvestis. Dirbant su CLI, yra keletas pagrindinių elementų, kurie padės suprasti ir efektyviai naudotis šia sąsaja.\n\nPrompt\n\nUžklausa (angl. prompt) yra teksto eilutė, kuri rodoma terminale ir nurodo, kad sistema yra pasirengusi priimti komandą. Užklausa dažniausiai rodo informaciją apie dabartinį darbinį katalogą, vartotojo vardą ar kitus naudingus duomenis. Pavyzdžiui:\nmain-user@linux-mint:~$\nParodo vartojo vardą @ kompiuterio vardą. ~ nurodo dabar naudojamą aktyvią darbinę direktoriją, o $ reiškia, kad kompiuteris laukia įvesties. Kas yra darbinis katalogas, susipažinsime vėliau.\n\n\ncommand\n\nKomanda (angl. command) yra specifinis nurodymas, kurį vartotojas įveda, kad būtų atliktas tam tikras veiksmas sistemoje. Komandos gali būti naudojamos įvairiems veiksmams atlikti, pvz., failų kopijavimui, katalogų kūrimui ar informacijos rodymui. Pavyzdžiui, komanda ls rodo dabartinio katalogo turinį:\nls\nKartais komandos turi subkomandas. Pavyzdžiui, apt yra komanda, kuri valdo programą, atsakingą už programinės įrangos instaliavimą. Tačiau ji naudojama su subkomandomis:\n\napt update:: Atnaujina paketų sąrašą.\napt install: Diegia nurodytą paketą.\napt remove: Pašalina nurodytą paketą.\napt upgrade: Atnaujina visus diegtus paketus į naujausias versijas\n\nKad bet kas negalėtų instaliuoti programų, šią komandą reikia vykdyti su administratoriaus teisėmis, pasitelkiant komandą sudo. Tai reiškia, kad kartais vykdomos kelios komandos vienu metu:\nsudo apt update\nsudo apt install cowsay\n\nOption, Argument\n\nPasirinkimas (angl. option) ir argumentas (angl. argument) yra papildomi parametrai, kurie gali būti pridėti prie komandos, siekiant tiksliau nurodyti, kaip komanda turėtų būti vykdoma.\nPasirinkimas (option): Pasirinkimas modifikuoja komandos elgesį. Jis dažnai pridedamas prie komandos su brūkšneliu (-) arba dvigubu brūkšneliu (--). Pavyzdžiui, naudojant ls -l, -l yra pasirinkimas, kuris rodo failų sąrašą ilgąja forma. Kai pasirinkimai nurodomi sutrumpinta forma, naudojamas vienas - brūkšnelis, kai išrašomas visas žodis, tada -- dvigubas brūkšnelis.\nArgumentas (argument): Argumentas yra papildoma informacija, kurią komanda naudoja veikimui. Pvz., ls Documents nurodo, kad komanda ls turėtų parodyti katalogo Documents turinį. Šiuo atveju Documents yra argumentas:\n\nCursor Žymeklis (cursor): Mirksintis žymeklis rodo, kad terminalas pasirengęs priimti kitą įvestį.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#man",
    "href": "6a_linux_comands_basic.html#man",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.7 man",
    "text": "5.7 man",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#help",
    "href": "6a_linux_comands_basic.html#help",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.8 –help",
    "text": "5.8 –help",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#tldr",
    "href": "6a_linux_comands_basic.html#tldr",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.9 tldr",
    "text": "5.9 tldr\nman puslapiai yra begalo išsamūs, tačiau jie ir ganėtinai ilgi. &lt;command&gt; --help arba &lt;command&gt; -h kartais būna gani trumpi ir aiškūs pagalbos puslpiai, tačiau jeigu komanda turi daug nustatymų ir argumentų, net --help puslapiai gali būti perdaug sudėtingi, ypač pačioje pradžioje naudojantis Linux.\nInstaliuok programa yt-dlp ir paleisk jos --help puslapį. Gana ilgas tiesa?\nKita programa, kuri stengiasi padėti CLI naudotojams, yra tldr (akronimias reiškiantis “too long;didn’t read it” = santrauka)\ninstaliuok programa tldr ir paleisk ją su argumentu yt-dlp\ntldr yt-dlp\nŠi programa pateikia dažniausius komandos naudjimo scenarijus ir labai trumpą paaiškinimą apie komandą. Tad tai dar vienas instrumentas tavo arsenale, primiršus prismint kaip veikia komanda, ką ji daro ir kokie nustatymai ir argumentai yra galimi. 5. Pabandyk tldr tldr\n\n5.9.1 Praktika\n\nSuraskite savo vartotojo pavadinimą. Ar jis atitinka tai, kas nurodoma užklausoje (prompt) prieš @?\nKai startuojate terminalą, kurioje direktorijoje randatės? Pakeiskite direktoriją, pereidami į Downloads. Uždarykite terminalo langą ir paleiskite terminalą iš naujo. Kur randatės?\nIš /home/user/ direktorijos pereikite į Downloads. Atspausdinkite direktorijos turinį naudojant komandą ls, bet nustatykite, kad:\n\n\nFailų dydis būtų suprantamas žmonėms.\nSąrašas būtų pateikiamas viename stulpelyje.\n\n\nIš /home/user/ direktorijos pereikite į Documents. Būdami joje, atspausdinkite tokį pat sąrašą failų, bet Downloads direktorijos. Pirmu atvejuy naudokite abosliutų kelią, antru, relatyvų.\n\nPagalbai:\nHome Directory/\n├── Desktop/\n├── Documents/\n├── Downloads/\n├── Music/\n├── Pictures/\n├── Public/\n├── Templates/\n└── Videos/\n\nPasinaudoję clear, išvalykite terminalo ekraną, tada naudodamiesi history suraskite komandą, naudotą 1. uždavinyje, ir pakartokite ją naudodami !n.\nNukopijuokite ir paleiskite šią komandą terminale:\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/e61bb3ab5cf28686f74a50e436b06fe6/raw | bash\nŠi komanda parsisiųs ir įvykdys skriptą, kuris sukurs test direktoriją (kartu su pakatalogiais) jūsų namų kataloge (/home/username/).\nŠi komanda parsius ir įvykdys skriptą, kurio metu sukurs direktoriją test ~/test\n6.1. Pereikite į test direktoriją: 6.2. Pasinaudodami ls su atitinkama parinktimi atspausdinkite visus failus, net esančius po kitomis direktorijomis: 6.3. Atsakykite į šiuos klausimus: * Kiek yra aplankų (directories)? * Kiek iš viso suskaičiuojate failų? Suskaičiuokite visus failus, esančius visose direktorijose. * Kokio tipo failų (pvz., .txt, .csv) yra daugiausia? Kurioje direktorijoje?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#navigacija-ir-informacijos-gavimas",
    "href": "6a_linux_comands_basic.html#navigacija-ir-informacijos-gavimas",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.6 Navigacija ir informacijos gavimas",
    "text": "5.6 Navigacija ir informacijos gavimas\n\n5.6.1 whoami\nKomanda whoami parodo dabartinio vartotojo (user) vardą, su kuriuo esate prisijungę prie sistemos. Tai paprastas ir naudingas būdas patikrinti, kokį vartotojo prisijungimą naudojate, ypač kai dirbate su keliais vartotojais toje pačioje sistemoje.\nwhoami\nŠiuo atveju, vartotojo vardas yra main-user\n\n\n\n5.6.2 direktorija, katalogas ir aplankas\nTerminai direktorija, katalogas ir aplankas dažnai vartojami kaip sinonimai ir paprastai reiškia tą patį – vietą failų sistemoje, kur gali būti saugomi failai ir kiti subkatalogai. Tačiau yra keletas kultūrinių ir kontekstinių niuansų:\n\nDirektorija (angl. directory): Tai techninis terminas, dažniausiai vartojamas Unix/Linux bendruomenėje ir kitose techninėse aplinkose. Jis pabrėžia hierarchinę failų sistemos struktūrą.\nKatalogas: Tai dar vienas techninis terminas, dažnai vartojamas kaip sinonimas direktorijai. Šis terminas yra paplitęs tiek techninėje, tiek kasdieninėje kalboje.\nAplankas (angl. folder): Tai terminas, dažniausiai naudojamas grafinėse vartotojo sąsajose (GUI), pavyzdžiui, Windows ir Mac OS. Nors jis iš esmės reiškia tą patį kaip direktorija ar katalogas, jis dažniau sutinkamas GUI kontekste.\n\n\n\n5.6.3 sudo\nPaprastas vartotojas (user) ir šakninis vartotojas (root) Linux sistemoje turi skirtingas teises ir privilegijas.\nuser:\n\nTeisės: Turi ribotas teises, gali atlikti veiksmus tik savo namų kataloge (home directory) ir kataloguose (directories), kuriuose turi suteiktas teises.\nPriėjimas: Negali atlikti sisteminės administracijos užduočių, pvz., negali įdiegti ar pašalinti programinės įrangos, keisti sisteminių failų ar vykdyti daugumos konfigūracijos pakeitimų.\n\nroot (šakninis vartotojas)\n\nTeisės: Turi pilną administracinę prieigą prie visos sistemos. Gali atlikti bet kokias užduotis, įskaitant sisteminių failų modifikavimą, vartotojų administravimą, programinės įrangos įdiegimą ir pašalinimą.\nPriėjimas: Gali atlikti bet kokias operacijas be apribojimų\n\nPerėjimas iš paprasto vartotojo į root:\nPriklausomai nuo konteksto, norint pereiti iš paprasto vartotojo į root, naudojamos komandos:\n\nVienkartinė komanda su root teisėmis: Naudokite sudo norint vykdyti vienkartinę komandą su root teisėmis. Pvz., programos įdiegimui:\n\nsudo apt install &lt;programa&gt;\n\nPilna root sesija: Norint keisti sisteminius failus ar atlikti daugiau administracinių užduočių, naudokite sudo -i:\n\nsudo -i\n\n\n5.6.4 Šakninis katalogas ir svarbiausi Linux failų sistemos katalogai\nŠakninis katalogas (angl. root directory) yra katalogas, kuris yra failų sistemos viršūnėje. Jį žymi /. Visi kiti failai ir katalogai yra šakninio katalogo pavaldiniai. Windows sistemoje tai atitiktų C:\\ katalogą.\n\nroot dircetory rasite yra daug subkatalogų (subdirectories). Pagrindiniai subkatalogai apie kuriuos reiktų žinoti:\n\n/root: Visagalio root vartotojo namų katalogas. Tai root vartotojo aplinka, kurioje jis gali dirbti, kai prisijungia kaip root.\n/etc: Čia paprastai laikomi Linux konfigūracijos failai. Šie failai kontroliuoja įvairių programų paleidimo laiką ir būdą.\n/home: Paprastų vartotojų namų katalogai. Kiekvienas vartotojas turi savo subkatalogą, pvz., /home/vartotojas, kuriame laikomi jo asmeniniai failai ir nustatymai.\n/mnt: Katalogas, kuriame yra prijungiamos (pridėjamos) kitos failų sistemos. Tai laikina vieta prijungtoms laikmenoms, tokioms kaip kietieji diskai ar tinklo diskai.\n/media: Katalogas, kuriame paprastai pritvirtinami (mounted) CD, DVD ir USB įrenginiai. Kai prijungiate USB atmintinę ar DVD, jie atsiranda šiame kataloge.\n/bin: Katalogas, kuriame yra saugomi sisteminiai vykdomieji failai (binaries), tai yra programos arba komandos, kurios yra būtinos pagrindiniam sistemos veikimui, pvz., ls, cp, mv.\n/lib: Čia rasite bibliotekas, kurios yra bendrai naudojamos programos. Tai analogiška Windows DLL failams. Šios bibliotekos būtinos daugeliui sisteminių programų ir komandų, veikiančių /bin kataloge.\n\n\n\n5.6.5 pwd\nKomanda pwd (angl. “print working directory”, liet. “parodyti darbinį katalogą”) parodo dabartinio darbinio katalogo pilną kelią (path). Tai naudinga komanda, jei norite sužinoti, kuriame kataloge šiuo metu dirbate.\npwd\n\nTaigi šiuo atveju darbinis katalogas yra /home/main-user\n\n5.6.5.1 Absoliutus ir relatyvus kelias (path)\nŠioje vietoje reiktų susipažinti su absoliutaus ir relatyvaus kelio samprata.\n\n5.6.5.1.1 Absoliutus kelias\nAbsoliutus kelias (angl. absolute path) yra pilnas kelias nuo šaknies katalogo (/) iki konkretaus failo ar katalogo. Jis visada nurodo tą pačią vietą, nepriklausomai nuo to, kur yra dabartinis darbinis katalogas (working directory).\nPavyzdžiai:\n/home/main-user/Documents/ataskaita.txt\n/home/main-user/Downloads/duomenys.csv\nKartais tam kad sutrumpinti kelią ir pritaikyti skriptus prie galimai kitokio vartojo vardo (ir kartu jo subkatalogo), naudoajmas ~ ženklas. Kai Shell aptinka ~, jis iškart supranta, kad turimas omenyje dabartinio vartojojo /home/vartotojas adresas.\nTaigi šie adresai yra įdentiški\n/home/main-user/Documents/ataskaita.txt\n~/Documents/ataskaita.txt\n\n\n5.6.5.1.2 Relatyvus kelias\nRelatyvus kelias (angl. relative path) yra kelias, kuris yra nurodomas atsižvelgiant į dabartinį darbinį katalogą. Relatyvus kelias neturi pradinio /, jis pradeda nurodymą nuo jūsų dabartinio katalogo.\nPavyzdžiai:\nJei esate kataloge /home/vartotojas, relatyvus kelias\nDocuments/ataskaita.txt\nnurodys failą\n/home/vartotojas/dokumentai/ataskaita`.txt\nKada naudojama kas?\n\nAbosliutus kelias dažniausiai naudojamas skriptuose, konfigūracijos failuose, dokumentacijoje ir sisteminių failų veikloje.\nRelatyvus kelias naudojamas kasdieniniame darbe su failais, vartotojo scenarijuose, bendrame naudojime ir navigacijoje bei skriptuose.\n\n\n\n\n\n5.6.6 cd\nKomanda cd (angl. change directory, liet. “pakeisti katalogą”) naudojama pereiti iš vieno katalogo į kitą. Ši komanda leidžia keisti dabartinį darbinį katalogą.\n\nPereiti į konkretų katalogą pagal absoliutų kelią:\n\ncd /home/vartotojas/Documents\n\n\nPereiti į konkretų katalogą pagal relatyvų kelią:\n\ncd dokumentai/projektai\n\nPereiti į tėvinį katalogą (parent directory) (vienu lygiu aukščiau):\ncd ..\n\nTiesa, galite pereiti ir kiek įmantriau, štai iš Downloads, pakylama į tėvinį katalogą (..), o tada einama į /Documents:\ncd ../Documents\n\nPereiti į namų katalogą:\n\ncd\ncd ~\n\n\nPereiti į ankstesnį katalogą, kuriame buvote prieš pereidami į dabartinį katalogą:\n\ncd -\n\n\n5.6.7 ls\nKomanda ls (angl. list, liet. “parodyti sąrašą”) naudojama norint peržiūrėti failų ir katalogų sąrašą dabartiniame arba nurodytame kataloge. Tai viena iš dažniausiai naudojamų komandų naviguojant failų sistemoje Linux ir Unix tipo operacinėse sistemose.\n\nParodyti dabartinio katalogo turinį:\n\nls\n\n\nParodyti konkretaus katalogo turinį:\n\nls /path/to/directory\n\n\nParodyti išsamų (ilgą) failų sąrašą su detalėmis, pvz., teisėmis,savininku, dydžiu ir paskutinio modifikavimo data:\n\nls -l\n\n\nParodyti visus failus, įskaitant paslėptus (failai, kurių pavadinimai prasideda tašku):\n\nls -a\n\n\nNaudoti ilgą sąrašą su žmogišku skaitymo formatu -h (dydžiai rodomi su B, K, M). Čia sukombinuojamas -l su -a ir -h\n\nls -lah\n\n\nParodyti katalogų turinį rekursyviai (parodyti failus ir katalogus visuose pakatalogiuose):\n\nls -R\n\n\n\n5.6.8 clear\nKomanda clear (liet. “valyti”) naudojama norint išvalyti terminalo ekraną, pašalinant visus anksčiau įvestus ir parodytus tekstinius duomenis. Tai palieka terminalą švarų ir patogesnį tolimesniam naudojimui. Ši komanda neištrina terminalo istorijos; ji tik paslenka visą tekstą į viršų, už dabartinio vaizdo ribų.\nclear\n\n\n5.6.9 history\nKomanda history (liet. “istorija”) naudojama norint parodyti visų anksčiau įvestų komandų sąrašą dabartinėje terminalo sesijoje. Tai suteikia patogų būdą sekti ir kartoti anksčiau vykdytas komandas.\nParodyti visą komandų istoriją:\nhistory\n\nJei norite parodyti tik paskutines n komandų, galite naudoti history n. Pvz., parodyti paskutines 10 komandų:\nhistory 10\n\nKartoti konkrečią komandą pagal numerį, galima įrašius ! ir komandos numerį\nhistory\n!51\n\nIštrinti komandų istoriją:\nhistory -c\n\n\n\nIntarpas: kaip naviguoti CLI\nKartais rašant ilgas komandas, mes visi padarome klaidų. Pvz parašome “Hello World” ir nuspaudžiame Enter, tik tada supratę, kad turėjome parašyti echo prieš “Hello World”.\nTokiu atveju galime su rodyklyte aukštyn pakilti, ir rodyklyte į kairę pareiti į eilutės pradžią ir prirašyti echo.\nVideo\nkartais eilutės visgi būna gana ilgos\nsud apt update & sudo apt full-upgrade -y && sudo autoremove -y && flatpak update\ndeja šįkart neįarėme sudo. Kad nereikėtų su rodyklyte tipenti ilgai… galime naudotis tam tikrais trumpiniais:\n\nCtrl-A: nušoka į eilutės pradžia\nCtrl-E nusoka į eilutės pabaigą\nCtrl-U ištrina viską į dešinė nuo kursoriaus\n\nVideo\nJeigu dar nepastebėjote, Ctrl-C ir Ctrl-V klavišų kombinacijos neveikia. Terminal nustatymuose raskite nustatyas klavišų kombinacijas, kurios atitinka įprastines Ctrl-C ir Ctrl-V kombinacijas.\nNaudojant komandinę eilutę, kartais terminalas gali „pakibti“ ir tolesnis komandų įvedimas tampa sudėtingas ar neįmanomas. Štai keletas tokių situacijų pavyzdžiųm kai parašote echo padedate kabutes, prašot pirmą žodį ir paspaudžiat enter… kadangi neudarėte kabučių, CLI laukia įvesties, t.y. kabučių. Tokiu ir panašiais atvejais, kai nebaigiate įvesti komandos, ar padarote klaidą, terminal gali pasirodyti kaip “pakibęs”.\nPabykite šias komandas po vieną:\n$ echo \"hello\n$ grep foobar\n$ yes\n$ tail\n$ cat\nNorint nutraukti “pakibusią” komanda galite su Ctrl-C (laikykite Ctrl ir paspauskite C). Tai siunčia kontrolės kodą terminalui ir nutraukia vykdomą procesą. Taigi Ctrl-C nekopijuoja, o nutraukia, šioje komandoje C=Cancel.\nKartais pamatysite ^C terminale, kuris rodo, kad Ctrl-C buvo paspausta.\nPastaba: Jei Ctrl-C neveikia, pabandykite paspausti ESC (escape) klavišą. Tai padeda daugeliu atvejų.\n\nVerta žinoti, kartais vietoj Ctrl- notacijos, jūs galite sutikti ^ notaciją, pvz ^C ^O ^X\n\n\n5.6.10 $PATH\n!Atsargiai ši tema kiek sudėtingesnė, bet ją pravartu žinoti.\nKaip Shell žino, kokią programą startuoti, kai pvz tu įrašai ls? Juk negali Shell eiti epr visus tavo failus ir ieškoti, ar yra tokia programa ls? Tai užtruktų labai ilgai ir būtų neefektyvu. Tavo Bash programa yra išsaugojusi visų direktorijų sąrašą, kurias ji tikrina.\nmain-user@linux-mint:~$ $PATH\nbash: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin: No such file or directory\nKą visa tai reiškia? Kai vartotojas įrašo komanda ls Bah pirma tikrina /usr/local/sbin/ jeigu ten neranda, eina į sekandią direktoriją /usr/local/bin ir t.t. Jeigu visame sąraše šios programos nebūtų, įrašius ls nieko neįvyktų, o terminale išvystum pranešimą, su siūlymų galbūt šią programą instaliuoti (jeigu apt programa apie šią komandą kažką žino).\nsu komanda which galime pamayti, o tai kur būtent ls randasi\nmain-user@linux-mint:~$ which ls\n/usr/bin/ls\nTaigi įrašius ls bash keliavo\n\n/usr/local/sbin &lt;- nerado ls\n/usr/local/bin &lt;- nerado ls\n/usr/sbin &lt;- nerado ls\n/usr/bin &lt;- čia rado ls\n\nRetais atvejais, tau gali reikėti pridėti direktorijas prie $PATH, bet labai tikėtina, jog tik pradedant naudotis Linux CLI, tau to dar nereikės. Tačiau jeigu kada prireiks, tu žinosi, apie ką čia kalbama.\n\n\n5.6.11 which\nKomanda which naudojama norint sužinoti, kurioje vietoje (path) yra esanti tam tikra vykdomoji programa. Ji parodo visą vykdomojo failo kelią, nurodydama, kurioje direktorijoje sistema pirmiausiai ieškos šios programos pagal PATH aplinkos kintamąjį.\nKartu ši komanda naudojama norint sužinoti, ar norima komanda yra įdiegta.\nparodo kurioje vietoje yra ls programa\nwhich ls\nTaip pat galima pamatyti, ar pvz neovim programa yra instaliuota\nwhich neovim\nKadangi Terminal negrąžino jokio kelio (path), tai pasako, jog šios programos nėra.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#locate",
    "href": "6a_linux_comands_basic.html#locate",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.4 locate",
    "text": "5.4 locate",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#whereis",
    "href": "6a_linux_comands_basic.html#whereis",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.5 whereis",
    "text": "5.5 whereis",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#path-1",
    "href": "6a_linux_comands_basic.html#path-1",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.6 path",
    "text": "5.6 path",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html",
    "href": "6b_linux_comands_basic.html",
    "title": "6  BASH komandos",
    "section": "",
    "text": "6.1 Failų ir direktorijų valdymas\nPraėjusiame skyriuje išmokai naviguoti terminale naudojant komandas pwd ir cd. Sužinojai apie Linux failų sistemą: kaip matyti visų failų ir katalogų sąrašą naudojant ls komandą, bei tai, kad Linux sistemoje vartotojai turi skirtingas teises, priklauso grupėms, ir kiekvienas failas turi savininko, grupės, bei kitų vartotojų teises naudotis tuo failu ar katalogu. Taip pat išmokai svarbių klaviatūros trumpinių, kaip peršokti į komandinės eilutės pradžią (Ctrl-A), pabaigą (Ctrl-E), nutrinti dalį (Ctrl-U), kaip kopijuoti ir įklijuoti į terminalą naudojant Ctrl-Shift-C ir Ctrl-Shift-V. Išmokai dirbti su terminalo istorija naudojant history ir kartoti komandas su !n.\nŠiame skyriuje skirsi dėmesį darbui su failais ir direktorijomis. Tu išmoksi kurti failus ir direktorijas, juos kopijuoti, perkelti, ištrinti. Taip pat išmoksi sujungti kelias komandas. Ir šio skyriaus pabaigoje pamatysi, kad tavo BASH įgūdžiai tampa dar stipresni!\nPrieš pradedant, įsitikink, kad turi keletą svarbių programų: jq ir curl. Kaip ir praėjusiame skyriuje, kai ieškojaiwhich $SHELL, komanda tau parodė, kur yra binary failas (programa). Dabar padaryk tą patį:\nJei tavo kompiuteris aptinka šias programas, terminalas atspausdins vietą, kur jos yra įdiegtos. Jei terminalas jų neranda, įdiek curl ir jq kaip sisteminius paketus naudojant apt. Jei pamiršai, kaip tai daryti, pakartok ankstesnę medžiagą.\nKai tai atliksi, nukopijuok ir paleisk šią komandą savo terminale - ji sukurs direktoriją shell_2_dalis tavo namų direktorijoje kartu su visais šiam skyriui reikalingais failais:\nJeigu viskas gerai, turėtum pamatyti:\nSu ls komanda atspausdink long formatu savo home directory turinį. Paaiškink visas šios eilutės reikšmes.\nPakeisk savo darbinę direktoriją į ~/shell_2_dalis. Kaip pasikeitė tavo prompt? Paaiškink, kas čia yra kas.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#failų-ir-katalogų-valdymas",
    "href": "6b_linux_comands_basic.html#failų-ir-katalogų-valdymas",
    "title": "6  BASH komandos",
    "section": "",
    "text": "By J. Howard Miller - U.S. National Archives and Records Administration\n\n\n\n\nPatikrink, ar turi curl, su which curl.\nPatikrink, ar turi jq, su which jq.\n\n\n\ncurl -s ... | bash\n\n\n\n\n\n\nTip\n\n\n\nPasikartok komandas cd, prisimink absoliutų ir reliatyvų kelią, bei ką reiškia ~, . ir ... Šiame skyriuje taip pat dažnai reikės naudoti ls, tad pasikartok šią komandą ir jos nustatymus dabar.\n\n\n\n\n\n\n\n6.1.1 echo\nKomanda echo naudojama norint atspausdinti vartotojo įvestį (input) terminale (dar vadinamą standartine išvestimi, angl. standard output). Tai paprasta, bet galinga komanda, dažnai naudojama skriptuose pranešimams rodyti arba kintamųjų reikšmėms tikrinti.\nNors nėra būtina tekstą apskliausti kabutėmis, dėl geresnio aiškumo ir įskaitomumo patartina tai daryti.\necho Hello World!\necho 'Hello World!'\necho \"Hello World!\"\nReikėtų atkreipti dėmesį, jog dvigubos kabutės (\" \") ir viengubos kabutės (' '’) šiek tiek skiriasi. Tekstas, esantis viengubose kabutėse (' '), atspausdinamas paraidžiui, nepaisant ten esančių kintamųjų. Tuo tarpu tekstas, esantis dvigubose kabutėse (\" \"), yra interpretuojamas, ir Shell leidžia naudoti kintamųjų vertes.\nPabandyk šias komandas, kurios naudoja kintamąjį $USER, atspausdinantį shell sesijos vartotojo vardą:\necho My username is $USER\necho 'My username is $USER'\necho \"My username is $USER\"\nAr pastebi, kuo skiriasi išvestis?\n\n\n\n6.1.2 &gt; ir &gt;&gt; operatoriai\n&gt; ir &gt;&gt; operatoriai naudojami išvesties nukreipimui (angl. output redirection). Jie nukreipia komandos išvestį (angl. output) į failą, o ne į terminalą. Šie operatoriai yra esminiai dirbant su failais ir automatizuojant užduotis skriptuose.\n&gt; operatorius nukreipia komandos išvestį į failą, perrašydamas jo turinį, jei failas jau egzistuoja. Jei failas neegzistuoja, jis bus sukurtas.\nŠi komanda sukuria (arba perrašo) failą hello_world.txt su tekstu “Hello World!”.\necho \"Hello World!\" &gt; hello_world.txt\nKaip echo komanda ir jos argumentas “Hello World!” buvo nukreipti į tekstinį failą, taip galime nukreipti ir kitų komandų išvestis į failus. Operatoriaus &gt; argumentas nebūtinai turi būti tik failo pavadinimas, tai gali būti ir failo pavadinimas su absoliučiu ar reliatyviu adresu.\nls &gt; mix/katalogo_turinys.txt\nŠi komanda nukreipia ls komandos išvestį į failą direktorijos_turinys.txt, kuris yra mix subdirektorijoje. Atsidaryk šį failą ir patikrink, ar jis susikūrė teisingai. Turėtum matyti kažką panašaus į šį vaizdą:\n\n\n\n\n\n\n\nPraktika\n\n\n\nLiekant shell_part_2 direktorijoje, atspausdink namų direktorijos (angl. home directory) turinį su visais paslėptais failais, ilguoju formatu ir žmonėms geriau suprantamais failų ir direktorijų dydžiais, ir nukreipk išvestį į mix subdirektorijoje esantį failą direktorijos_turinys.txt, jį perrašant.\n\n\nIntarpas\nHey, ką tik gavai užduotį. Ateityje gausi panašias ir dar sudėtingesnes užduotis. Todėl šioje vietoje padarykime intarpą. Pakalbėkime apie vieną svarbiausių darbo būdų programavime (ir ne tik!) – darbų skaidymą (angl. break down).\nKartais gali gauti labai sudėtingą užduotį, kuri iš pradžių atrodys neįveikiama ar nesuprantama. Tai visiškai normalu. Nestresuok – giliai įkvėpk, iškvėpk, jei reikia, pasiimk popierių ir pieštuką ir pradėk skaidyti darbus į logines sekas. Pvz., prieš tai buvusią užduotį galima suskaidyti į dvi dideles dalis:\n\nDabar galima skaidyti ar toliau detalizuoti kiekvieną iš šių dalių.\n\nSkaidydama užduotį į mažesnes dalis, vis labiau suprasi, ką reikia padaryti. Turėdama daugiau patirties, geriau žinosi, kiek laiko gali prireikti kiekvienam žingsniui.\nPvz., duomenų analitikas gali gauti užduotį: suprognozuoti sekančių metų ledų pardavimus. Analitikas, žinodamas, kad ledų pardavimai priklauso nuo lauko temperatūros, gali suskaidyti darbus taip:\n\nImportuoti istorinius tam tikros vietos temperatūros duomenis\nPrognozuoti sekančių metų kiekvienos dienos temperatūras\nApskaičiuoti kiekvienos dienos pardavimus\nAprašyti duomenis ir pateikti juos užsakovui suprantamu formatu\n\n\n\n\nPhoto by Kamaji Ogino\n\n\nKiekvieną iš šių žingsnių analitikas gali suskaidyti į dar daugiau mažesnių užduočių.\nKodėl tai svarbu? Visų pirma, tai padeda geriau suprasti, ką reikia padaryti, ir kiek tai gali užtrukti. Kiekvienas žingsnis tampa atskiru procesu, ir jei nepavyksta vienas metodas, gali bandyti kitą.\nDarbų skaidymas yra intuityvus procesas kasdieniame darbe ir tu jau ir taip taikai, bet kai gauname sudėtingas užduotis, vis tiek verta prisiminti šią strategiją, nes kartais mes pamirštame, kaip ji padeda išvengti pasimetimo.\n&gt;&gt; operatorius nukreipia komandos išvestį į failą, pridedant (angl. append) prie failo turinio. Jei failas neegzistuoja, jis bus sukurtas.\necho \"What a beatiful morning\" &gt;&gt; day.txt\necho \"What a beatiful day\" &gt;&gt; day.txt\necho \"What a beatiful evening\" &gt;&gt; day.txt\nŠios komandos prideda tekstą “What a beautiful morning”, “What a beautiful day” ir “What a beautiful evening” prie failo day.txt galo, neperrašydamos esamo turinio. Jei tokio failo nėra, jis bus sukurtas.\n\n\n\n\n\n\nPraktika\n\n\n\n\nSusirask tau patinkančios dainos tekstą internete.\nNaudojant komandą echo ir operatorių &gt;, sukurk failą favorite_song.txt, mix subdirektorijoje. Failo turinys turėtų būti panašus į “My favorite song is ”.\nPirmas keturias dainos eilutes atspausdink į failą song_text.txt, mix subdirektorijoje naudojant echo ir &gt;&gt;. Nepamiršk, kokie klaviatūros trumpiniai naudojami kopijuojant ir įkeliant tekstą į terminalą!\n\n\n\n\n\n6.1.3 cat\nKomanda cat (angl. concatenate, liet. „sujungti“) naudojama peržiūrėti, sujungti ir atspausdinti failus. Tai viena iš pagrindinių Linux komandų, nes leidžia greitai peržiūrėti failų turinį, įvesti turinį į kitus failus arba sujungti kelis failus į vieną.\nPraeitame skyriuje sukūrei du failus favorite_song.txt ir song_text.txt. Dabar juos ir naudosime.\nAtspausdink failo favorite_song.txt turinį į terminalą:\ncat favorite_song.txt\nPas mane tai atrodo taip:\n\ncat leidžia sujungti kelių failų turinį ir atspausdinti rezultatą terminale:\ncat favorite_song.txt song_text.txt\n\nKaip praeitame skyriuje išmokai, komandos išvestį (nesvarbu, ar tai būtų echo, ar ls) galima nukreipti į failą. Lygiai taip pat gali nukopijuoti failą naudojant cat ir &gt; arba &gt;&gt;:\ncat favorite_song.txt &gt; favorite_song_2.txt\nŠi komanda nukopijuoja failo favorite_song.txt turinį į naują failą megstamiausia_daina.txt, perrašydama jo turinį, jei toks failas jau egzistuoja.\n\n\n\n\n\n\nPraktika\n\n\n\n\nNaudojant echo ir &gt;&gt;, įrašyk dar 4 eilutes mėgstamiausios dainos teksto į failą song_text_2.txt.\nSujunk failus song_text.txt ir song_text_2.txt, nukreipiant rezultatą į song_text_full.txt:\nPagalvok, kaip naudojant visas iki šiol žinomas komandas, būtų galima gauti song_text.txt failą, kuriame būtų pirmas ketvertas eilučių ir antras ketvertas eilučių teksto?\n\n\n\n\n\n6.1.4 head ir tail\nKomandos head (galva) ir tail (uodega) naudojamos peržiūrėti pirmąsias arba paskutines failo eilutes. Įprastai jos atspausdina 10 eilučių teksto.\n\n\n\n\n\n\nNote\n\n\n\nDabar tavo failas song_text.txt turėtų turėti 8 eilutes teksto. Todėl tokiu pat būdu, kaip prieš tai, pridėk dar 4 eilutes teksto, kad turėtum bent 12.\n\n\nPeržiūrėk pirmas 10 eilučių song_text.txt su head:\nhead song_text.txt\nPeržiūrėk paskutines 10 failo eilučių:\ntail song_text.txt\nTiek head, tiek tail priima nustatymą (option) -n su argumentu, nurodančiu, kiek eilučių atspausdinti:\n\nNorint peržiūrėti pirmas 3 eilutes, naudok komandą: head -n 3 song_text.txt\nNorint peržiūrėti paskutines 5 eilutes, naudok komandą: tail -n 5 song_text.txt.\n\n\n\n\n\n\n\nPraktika\n\n\n\nKas nutiktų, jei panaudotum head arba tail su failu, kuriame nėra 10 eilučių? Pabandyk su favorite_song.txt\n\n\n\n\n\n\n\n\nPraktika\n\n\n\nDabar dirbsi su failu data/temp_vilnius.txt.\n\nNaudojant cat, atspausdink visą failą terminale\nPirmosios dienos prognozės gali turėti mažiau nei 24 valandas (pvz., likusios 6 valandos). Naudojant head, atspausdink tik šiandienos orų prognozes\nKadangi šiandienos oras jau aiškus, tavo draugei Amelijai reikia rytojaus orų prognozės. Derinant head ir tail, išfiltruok eilutes taip ir sukurk tarpinius failus, kad būtų nusiųstos tik rytojaus 24 valandų temperatūros prognozės. Rezultatą išsaugok į failą amelija_vilnius_temp.txt subdirektorijoje data\n\n\n\n\n\n6.1.5 less\nPraėjusiame skyriuje jau turėjai atvejį, kai viso failo vilnius_temp.txt turinys netilpo į terminalo langą. Tikėtina, reikėjo pakeisti terminalo lango dydį arba slinkti su pele. Dabar tau galbūt kyla klausimas, kaip būtų galima matyti failo turinį gabaliukais?\nNors gali naudoti cat dideliems failams atspausdinti ir tada slinkti išvestį, paprastai patogiau failą rodyti puslapiais. Tam pirminė komanda buvo more, bet ją pakeitė galingesnė komanda less.\nNaudojant less &lt;failas&gt;, vienu metu matysi tik vieną failo puslapį. Spaudžiant ␣ (space) klavišą, pereisi į kitą puslapį; gali taip pat naudoti ↓ ir ↑ klavišus, kad judėtum po vieną eilutę žemyn arba aukštyn. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk vilnius_temp.txt su less, išbandyk judėjimą tekste žemyn, aukštyn ir uždaryk programą su q.\n\n\nJei less komandai nurodysi kelis failus, gali naudoti :n (next) pereiti prie kito failo, o :p (previous) sugrįžti prie ankstesnio failo. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk failus favorite_song.txt, data/vilnius_temp.txt ir text/seneles_pasaka.txt su less. Išbandyk judėjimą tekste žemyn, aukštyn, pereik tarp failų naudojant :n ir :p bei pabaigoje uždaryk less su q\n\n\n\n\n6.1.6 wc\nKomanda wc (angl. word count) naudojama atspausdinti naujų eilučių, žodžių ir baitų skaičių faile.\n\n\n\n\n\n\n\nNustatymas\nReikšmė\n\n\n\n\n-c\nAtspausdina baitų skaičių (angl. byte count), kiek vietos užima failas\n\n\n-m\nAtspausdina simbolių skaičių (angl. character count)\n\n\n-w\nAtspausdina žodžių skaičių (angl. word count)\n\n\n-l\nAtspausdina eilučių skaičių (angl. line count)\n\n\n\nPastaba: -c ir -m gali atspausdinti skirtingus rezultatus priklausomai nuo failo koduotės, nes simbolis gali užimti daugiau nei vieną baitą (pvz., specialūs lietuviški simboliai).\n\n\n\n\n\n\nPraktika\n\n\n\n\nKKiek žodžių ir kiek eilučių yra text/seneles_pasaka.txt?\nKiek eilučių yra data/temp_vilnius.txt ir kiek data/temp_kaunas.txt?\n\n\n\n\n\n6.1.7 touch\nKomanda touch naudojama kuriant tuščią failą arba keičiant esamo failo metaduomenis, pvz., modifikavimo ar prieigos laiką. Ji yra universali ir ypač naudinga tais atvejais, kai reikia greitai sukurti failą arba atnaujinti failo laikus be jo turinio keitimo.\nJei failas neegzistuoja, touch jį sukurs. Jei failas jau yra, komanda tiesiog pakeis failo “paskutinio keitimo laiką” (modification time) į dabartinį laiką, nesikeičiant turinio.\nSukurk tuščią failą:\ntouch empty_1.txt\n\nJei nurodysi kelis failų pavadinimus, touch sukurs visus iš karto:\ntouch empty_2.txt empty_3.txt empty_4.txt\n\nJeigu failo pavadinimas yra nurodytas su absoliučiu ar reliatyviu keliu, failas bus sukurtas atitinkamoje direktorijoje, jei tokia direktorija egzistuoja. Jei direktorija neegzistuoja, bus pranešta apie klaidą, ir failas nebus sukurtas.\ntouch mix/empty_5.txt\ntouch tralala/empty_6.txt\n\ntouch taip pat leidžia atnaujinti failo prieigos arba modifikavimo laiką. Štai keli pavyzdžiai:\n\nAtnaujinti tiek prieigos, tiek modifikavimo laikus į dabartinį laiką:\n\ntouch empty_1.txt\n\nAtnaujinti tik prieigos laiką:\n\ntouch -a empty_1.txt\n\nAtnaujinti tik modifikavimo laiką:\n\ntouch -m empty_1.txt\n\nNustatyti tiek prieigos, tiek modifikavimo laikus į konkrečią datą, pvz., 2022 m. sausio 1 d., 12:00 val.:\n\ntouch -t 202201011200 empty_1.txt\n\nNaudoti -d parinktį, norint lankstesnio laiko nustatymo:\n\ntouch -d \"2023-07-04 15:45\" empty_1.txt\nDabar gali kilti klausimas - kam tai naudinga? Iš tiesų, failų laikų keitimas gali atrodyti nišinis, tačiau tai naudinga tam tikrais atvejais:\n\nJei nori išbandyti skriptą, kuris rūšiuoja ar archyvuoja failus pagal jų prieigos ar modifikavimo laiką, gali generuoti tuščius failus su netikrais laikais ir patikrinti, ar skriptas veikia teisingai.\nJei atstatai failus iš atsarginės kopijos, gali norėti atkurti ir jų originalius prieigos bei modifikavimo laikus, kad išsaugotum failų istoriją tiksliai tokia, kokia buvo prieš atsargines kopijas.\n\n\n\n6.1.8 mkdir\nKomanda mkdir (angl. make directory) naudojama naujų direktorijų kūrimui.\nNaują direktoriją gali sukurti taip:\nmdkir projektas1\nKaip ir su komanda touch, gali sukurti kelias direktorijas vienu metu, nurodant pavadinimus arba kelius į jas:\nmkdir projektas2 mix/projektas3\nKartais reikia sukurti direktorijų medį (hierarchiją). Jei tarpinės direktorijos dar neegzistuoja, gali naudoti -p argumentą, kuris automatiškai sukurs ir tarpines direktorijas. Pavyzdžiui:\nmkdir -p projektas0/duomenys\n\n\n\n\n\n\nPraktika\n\n\n\nNetrukus norėsime sukurti tam tikrų failų atsargines kopijas. Kaip pasiruošimą, užtikrink, kad shell_part_2 direktorijoje būtų:\n\nbackup/data\nbackup/text\n\nSukurk jas naudojant -p, nurodant abi direktorijas kaip du argumentus vienoje komandoje (vienoje eilutėje).\n\n\n\n\n6.1.9 cp\nPripažink, kopijuoti failą su cat failas.txt &gt; kopija.txt nėra labai intuityvu. O ką daryti, jei nori nukopijuoti ne tik failą, bet ir visą direktoriją?\nKomanda cp (angl. copy) naudojama failams ir direktorijoms kopijuoti.\nPaprasčiausiu atveju, kai nori sukurti failo kopiją, komandai cp nurodai originalaus failo pavadinimą ir kokiu pavadinimu turėtų būti sukurta kopija.\ncp song_text.txt song_text_copy.txt\nJei failas song_text_copy.txt jau egzistuotų, jis būtų perrašytas. Taigi cp veikia panašiai kaip &gt;.\nKaip ir su visomis BASH komandomis, gali naudoti tiek reliatyvius, tiek absoliučius kelius (angl. path). Pavyzdžiui, kopiją gali perkelti į kitą direktoriją:\ncp ./song_text.txt mix/song_text_copy.txt\nJeigu kaip antrąjį argumentą nurodysi egzistuojančios direktorijos pavadinimą, cp sukurs kopiją tokiu pačiu pavadinimu kaip originalas ir patalpins ją į nurodytą direktoriją:\ncp ~/song_text.txt ./mix\ncp gali kopijuoti ir direktorijas, tačiau tam, kad visa direktorija būtų nukopijuota rekursyviai (su visu turiniu), reikia naudoti nustatymą -r (recursive):\ncp -r mix mix_copy\nKada naudoti cp -a?\nNustatymas -a (arba archive) naudojamas, kai reikia nukopijuoti failus ir direktorijas kartu su jų metaduomenimis (pvz., failo leidimais, nuosavybe, laikais). Tai naudinga, kai nori išsaugoti visas originalaus failo ar katalogo savybes. -a iš esmės yra kombinuotas cp -r (rekursija) ir kitų nustatymų rinkinys, kuris užtikrina, kad išsaugomi visi atributai.\ncp -a mix mix_copy_2\nDabar palyging metaduominis su ls -l\n\n\n\n\n\n\nPraktika\n\n\n\n\nPadaryk vilnius_temp.txt kopiją pavadinimu vilnius_temp_copy.txt, bet kaip argumentą nurodyk direktoriją ir failo pavadinimą. Patalpink kopiją į backup/data.\nPadaryk kaunas_temp.txt kopiją su originaliu pavadinimu, kaip antrą argumentą cp paduodant tik backup/data direktoriją.\nPadaryk data/text kopiją su visu jos turinu į backup direktoriją. Išsaugok visus metaduomenis.\n\n\n\n\n\n6.1.10 mv\nKomanda mv (angl. move) naudojama perkelti arba pervadinti failus ir direktorijas. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\nPvz., naudojant mv, gali pervadinti failą vilnius_temp.txt į alytus_temp.txt:\nmv data/vilnius_temp.txt data/alytus_temp.txt\nTaip pat su mv gali perkelti failus iš vienos direktorijos į kitą. Ši komanda perkelia failą kaunas_temp.txt į mix:\nmv data/kaunas_temp.txt mix\nmv komandai galima paduoti daugiau nei du argumentus. Pavyzdžiui, ši komanda perkelia failus alytus_temp.txt ir seneles_pasaka.txt į direktoriją mix. Čia svarbu, kad paskutinis argumentas būtų egzistuojanti direktorija:\nmv data/alytus_temp.txt text/seneles_pasaka.txt mix\nmv taip pat gali būti naudojama perkelti direktoriją ir visą jos turinį. Pavyzdžiui, ši komanda perkelia katalogą ~/test į ~/shell_part_2:\nmv ~/test ~/shell_part_2\nSvarbu: kaip ir naudojant &gt; ar cp, jeigu tikslinis failas jau egzistuoja, jis bus perrašytas, nebent pridėsi -i (interaktyvų režimą), kad būtų paprašyta patvirtinimo prieš perrašant.\n\n\n\n\n\n\nPraktika\n\n\n\n\nTeorinis klausimas: Kas nutiktų, jei įvykdytum šią komandą?\n\nmv vilnius_temp.txt kaunas_temp.txt ~/Documents ~/Downloads\n\nUžduotis: Perkelk Aytaus, Kauno ir Klaipėdos temperatūrų failus atgal iš mix į data naudojant mv. Naudojant cp, padaryk kopiją pavadinimu data_cp (nepamiršk rekursyvaus nustatymo!). Įsitikink, ar kopijoje yra visi failai, kaip ir data direktorijoje? Sukurk tuščią direktoriją pavadinimu empty, o tada pabandyk ją pervadinti į data_cp. Ar mv perrašė data_cp, ar visgi failai vis dar yra viduje?\n\n\n\n\n\n6.1.11 rm\nTavo shell_part_2 direktorijoje dabar tikrai daug failų ir subdirektorijų, kurių nebereikia. Laikas įvesti šiek tiek tvarkos!\nKomanda rm (angl. remove) naudojama pašalinti failus ir direktorijas. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar direktorijos nėra perkeliami į šiukšliadėžę ir jų atkurti nebebus galima.\nNorint pašalinti failą rm komandai paduodamas argumentas failo pavadinimas, arba absoiulutus arba reliatyvus kelias į failą.\nrm failas.txt\nrm mix/failas.txt\nKomandai rm galima paduoti ir kelis failus\nrm failas1.txt failas2.txt failas3.txt\nTuščia direktoriją (kai joje nėra jokių kitų failų ar subridektorijų) galima pašalinti arba naudojant rmdir, kuri yra priešinkybe mkdir, arba su rm nurodant nustatymą -d.\nrm -d tuščias_direktorija\nTiesiog pašlainti direktrijos, kurioje yra kažkas, su rm arba rm -d nepavyks, nes BASH bando apsaugoti vartotoja nuo rizikos negrįžtamai ištrinti per daug failų.\nIMG\nVisgi ne retai reikia ištrinti visą direktoriją su visu jos turinu. Tokiu atveju naudojamas option -r (recursive).\nrm -r katalogas\nKartais gali nutikti,jog rm -r negalės ištrinti direktorijos, pvz nes… tada pridedamas nustymas -f (force) - priverstinai ištrinti.\nrm -rf katalogas\nintarpas: wildcard *\nKartais BASH komandose norisi pažymėti ar pasirinkti daugiau nei vieną failą. Kaip jau matei, tiek cat ,cp, mv rm, less komandos kuo puikiausiai dirba su keliais failais. Tad kyla klausimas, kaip tai padaryti.\npvz tu galėtum rašyti:\nrm empty_1.txt empty_2.txt\nir yra akivaizdy, jog šiuose failų pavaidinimuose yra tam tikras dėsningumas jie prasideda empty_ ir baigiasi .txt.\nBASH kaip ir daugumoje kitų programavimo kalbų yra vadinaamsi wildcard - simbolis, kuris leiždia užpildyti vieną ar daugiau ženklų.\n\n\n\n\n\n\nPraktika\n\n\n\nPasakyk kas nutiktų visiais šiais atvejais:\n\nrm song*.txt\nrm emtpy_*.txt\nrm *song*.txt\nrm *.txt\nrm *.*\nrm ./*\n\n\n\nyra keli wildcard, kuriais gali pasinaudoti\n\n* reikšia vieną arba daugiau simbolių\n? reiškia lygiai vieną simbolį, pvz 201?.txt galėtų būti tik 2017.txt, 2018.txt bet negatėtų būti 2017-01.txt\n[...] reiškia vieną iš pateiktų simbolių, pvz 201[78].txt atiitktų 2017.txt ir arba 2018.txt, bet ne 2016.txt.\n{...} atitinka bet kurį iš kableliu atrkirtų variantų pvz {*.txt, *.csv} atitiks bet kurį failą kurio pabaiga bus .csv arba .txt, bet kurio pabaiga nebus .pdf\n\n\n\n\n\n\n\nPraktika\n\n\n\nNaudojantis wildcard ištrink iš shell_part_2 visus failus kuriuorese yra\n\nžodis empty\nžodis song\nviska kas yra mix subdirektorijoje, bet neištrinant jos pačios\nvisus failus esansius data subdirektorijoje, kurie baigiasi _bak\n\n\n\n\n\n6.1.12 grep\nKartais tau gali reikėti nuskaityti tik tam tikras failo eilutes, kuriose yra tam tikras tekstas. Komanda grep (angl. global regular expression print, liet. “globalus reguliariųjų išraiškų paieškos spausdinimas”) naudojama tekstui paieškai pagal šabloną failuose arba išvestyje.\nPavyzdžiui ši komanda surastų visas eilutes senės pasakoje, kurioje yra žodis “Apie”.\ngrep Apie text/seneles_pasaka.text\n\nSuprantama tu gali pateikti kelis failus vienu metu\ngrep 14:00:00 data/temp_vilnius.txt data/temp_kaunas.txt \n\ngrep prima ir tam tikrus nustatymus, kurie palengvina\n\n-c: print a count of matching lines rather than the lines themselves\n-h: do not print the names of files when searching multiple files\n-i: ignore case (e.g., treat “Regression” and “regression” as matches)\n-l: print the names of files that contain matches, not the matches\n-n: print line numbers for matching lines\n-v: invert the match, i.e., only show lines that don’t match\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nKurios eilutės turi paminėtą žodį Pasaka (su P didžiaja)?\nKurios eilutės turi paminėtą žodį Pasaka (nesvarbu ar P didžioji ar mažoji)?\nKiek eilučių (ieškome skaičiaus) turi paminėtą žodi “apie” neprikllausomai nuo rašybos?\nKiek eilučių (ieškome skaičiaus) nepamini žodžio “apie” nepriklausomai nuo rašybos?\n\n\n\n\n\n6.1.13 cut\nKartais vietoj eilučių, tau gali riekėti išsifiltruoti stuleplius. pvz head data/temp_vilnius.txt tau atspasdina:\nIMG\nKomandai cut reikės tam tikru nustatymų, pagrindiai:\n\n-d (delimiter), skirtukas, kuri skiria stlpelius,po jo seka apibrėžimas, pvz -d \" \" reiktų jog skirtukas yra viena tuščia vieta (space), kitas pvz -d \",\" identifikuotų stulpelius, jeigu jie atskirti kableliu\n-f (fields) pasako, kuriuos laukius tu nori pasirinkti, pvz -f 2 pasirinktų antrą stulpelį, -f 2-5 nuo antro iki penkto stulpelio, o -f 2-5,8 nuo antro iki penkto ir aštuntą stulpelius.\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nPasinaudodama tau žinomis komandomis investiguok failą data/customer.csv.\n\nkiek jame eilučių?\nkoks skirtukas naudojamas?\n\natspausdink terminale tik customer_id stulpelį\nkai tai pavyksta, išsaugok rezultata kaip customers_id.csv\ndabar nuskaityk customers_id.csv ir naujame faile customers_lt_id.csv išsaugok tik tas eilutes, kuriose yra “-lt-” kodas.\n\n\n\n\n\n\n\n\n\nPraktika\n\n\n\n\ninvestiguok faila data/temp_vilnius.txt. kokie skirtukai naudojami šiame faile?\ntu dar nemoki perrašyti teksto turinio, bet pabandyk išsikirtpti tik datas ir išsagok data/temp_vilnius_dates.txt\n\n\n\n\n\n6.1.14 Intarpas: Standartinė įvestis, išvestis ir klaidos\nLinux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenų įvestį ir išvestį programose bei komandose. Šie srautai dažnai vadinami standartine įvestimi (standard input), standartine išvestimi (standard output) ir standartine klaida (standard error). Kiekvienas jų turi specifinį paskirtį ir failo aprašymo numerį.\n\n6.1.14.1 Standartinė įvestis (stdin)\nStandartinė įvestis, sutrumpinta kaip stdin, yra srautas, iš kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, stdin yra prijungta prie klaviatūros įvesties, tačiau gali būti nukreipta iš failo ar kito srauto.\npabandyk įrašyti cat, paspausti enter ir tada įrašius kelis žodžius vis paspausti enter. Terminale tu matysi tekstą kurį įrašai, o paspaudus enter jis bus traktuojamas kaip įvestis cat komandai, kuri šį tekstą atspaudins. Todėl matysi 2x to ką įvedei.\n# Nuskaito duomenis iš klaviatūros\ncat\nĮvestis gali būti ir iš failo į komanda. Štai mes komandai cat nukreipiam kaip argumentą failą failas.txt\ncat &lt; failas.txt\nStandarintės įviesties aprašymo numeris: 0. Netrukus sužinosi, kam tie skaičiai reikalingi…\nnutraukti cat įvestį gali su Ctrl-D arba Ctrl-C.\n\n\n6.1.14.2 Standartinė išvestis (stdout)\nStandartinė išvestis, sutrumpinta kaip stdout, yra srautas, į kurį komanda ar programa rašo išvestį. Dirbant terminale stdout yra prijungta prie terminalo ekrano. Todėl įračius sekančia komandą, terminale yra atspausdinamas dar kartą Hello World. (atitinkmai prieš tai pavyzdyje cat atspausdindavo viską irgi terminale)\necho \"Hello World\"\nTačiau kaip tu jau moki, galima standartinę išvestį nukriepti ne į terminalo langą, o į failą. Tai jau ne kartą darei. pvz:\necho \"Hello World!\" &gt; išvestis.txt\nStandartinė išvestis turi numerį 1. todėl ši komanda iš esmės, ko tu nerašai, bet kas atitinka šiai komandai yra\necho \"Hello World!\" 1&gt; išvestis.txt\ntai reiškia, kad tas srautas kurį sugeneruoja echo komanda nusiunčimas į failą išvestis.txt\n\n\n6.1.14.3 Standartinė klaida (stderr)\nKartais kai komanda negali atlikti tam tikro veiksmo, ji sugeneruoja klaidos pranešimą. Šis klaidos prenešimas yra išsiunčiamas į standartinės klaidos, sutrumpinta kaip stderr. Standarinės klaidos srauto numeris yra 2. Ir jo srautą galima nukreipti į failą.\npabandyk ls komandą jai kaip argumentą perduodant neegzistuojančia dirketorija abc , tiagi ls abc\n\n\n\nalt\n\n\ndabar, nukreipkime specifiškai klaidos srautą į failą klaidos.log\nls abc 2&gt; klaidos.log\nTavo temrinale neberodo klaidos, bet pasinauok head arba cat ir pažiūrėk, ką rando klaidos.log faile!\nKaip visą tai taikyti praktikoje?\nįsivaizduok tu turi komanda ls bet kartais ji gali sugeneruoti sarašą, tu ji nori nukreipti į ok.txt, o jeigu sugeneruojama klaida, data į error.log, tada tu atitinkamai taikytum\nls &lt;direktorija&gt; 1&gt; ok.txt 2&gt;error.log\nišbandyk šią komandąsu egzistuojančia ir neesgistuojačia direktorija.\nKartais tu gali norėti, jog kompiuteris abu srautus nukreiptų į ta patį failą. Pvztu kas 10 minučių pamatuoji kompiuterio temperatūrą. tada tu gali nukreipti abu srautus nukreipiant stdout į failą temp.log, o klaidos srautą nukreipiant į stndout srautą.\nkomanda 1&gt;temp.log  2&gt;&1\narba klaidos srautą nukreipiant į temp.log, o stnd out srautą, į klaidos.\nkomanda 2&gt;temp.log  1&gt;&2\n\n\n\n\n\n\nPraktika\n\n\n\n\nPabandykite atspausdinti (nukipijuoti) su cat neegsistuojantį failą abracadabra.txt į failą, o klaidą nukreipti į failą error_logs.txt\nSu cat atspausdinkite error_logs.txt\nSu echo bei &gt; sukurkite failą abracadabra.txt pvz\n\necho \"Abracadabra is a magic word, historically used as an apotropaic incantation on amulets and common today in stage magic. It is of unknown origin.\" &gt; 'abracadabra.txt'\n\npakartokite 1 ir 2 žingsnius.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#iš-ko-susideda-cli-komanda",
    "href": "6a_linux_comands_basic.html#iš-ko-susideda-cli-komanda",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.2 Iš ko susideda CLI komanda?",
    "text": "5.2 Iš ko susideda CLI komanda?\nAtsidaryk terminalo programą. Štai ką turėtum pamatyti:\n\n\n\nTerminal su matomu prompt\n\n\n\nPrompt\n\nTerminale iškart matai prompt – tai teksto eilutė, kuri nurodo, kad sistema yra pasirengusi priimti komandą. Ši eilutė dažniausiai rodo informaciją apie dabartinę direktoriją, vartotojo vardą ar kitus naudingus duomenis. Pavyzdžiui:\njustas@linux-pc:~$\nČia rodoma: vartotojo vardas @ kompiuterio pavadinimas. Simbolis ~ nurodo aktyvią darbinę direktoriją (namų direktoriją), o $ reiškia, kad sistema laukia įvesties (todėl ir vadinama prompt – iššaukimas). Kas yra darbinė direktorija, sužinosime vėliau.\nŠtai pavyzdys, kai Shell yra užsiėmęs ir nėra pasirengęs priimti tavo komandos:\n\n\n\nTerminal vykdo užduotį\n\n\n\nŽymeklis (Cursor)\n\nMirksintis žymeklis (cursor) rodo, kad terminalas pasirengęs priimti kitą įvestį ir nurodo, kurioje vietoje eilutėje bus įrašas.\n\nKomanda (command)\n\nKomanda (angl. command) yra specifinis nurodymas, kurį vartotojas įveda, kad būtų atliktas tam tikras veiksmas sistemoje. Komandos gali būti naudojamos įvairiems veiksmams atlikti, pvz., failų kopijavimui, direktorijų kūrimui ar informacijos rodymui. Pavyzdžiui, komanda ls rodo dabartinės direktorijos failus ir subdirektorijas:\nls\nKai kurios komandos turi subkomandas. Pavyzdžiui, apt yra komanda, atsakinga už programinės įrangos (angl. software) valdymą, tačiau ji naudojama su subkomandomis:\n\napt update:: Atnaujina prieinamų programų sąrašą.\napt install: Instaliuoja nurodytą paketą.\napt remove: Pašalina nurodytą paketą.\napt upgrade: Atnaujina visus diegtus paketus į naujausias versijas\n\nKad bet kas negalėtų instaliuoti programų, ši komanda turi būti vykdoma su administratoriaus teisėmis, pasitelkiant komandą sudo. Todėl kartais naudojamos kelios komandos iš eilės:\nsudo apt update\nsudo apt install cowsay\n\nPasirinkimai ir argumentai (Option, Argument)\n\nPasirinkimas (angl. option) ir argumentas (angl. argument) yra papildomi parametrai, kurie gali būti pridėti prie komandos, siekiant tiksliau nurodyti, kaip komanda turėtų būti vykdoma.\nPasirinkimas (option): Pasirinkimas modifikuoja komandos elgesį. Jis dažnai pridedamas prie komandos su brūkšneliu (-) arba dvigubu brūkšneliu (--). Pavyzdžiui, naudojant ls -l, -l yra pasirinkimas, kuris rodo failų sąrašą ilgąja forma. Naudojant sutrumpintus pasirinkimus, naudojamas vienas brūkšnys -, o išrašant pilną pavadinimą – dvigubas brūkšnys --.\nArgumentas (argument): Argumentas yra papildoma informacija, kurią komanda naudoja veikimui. Pvz., ls Documents nurodo, kad komanda ls turėtų parodyti direktorijos Documents turinį. Šiuo atveju Documents yra argumentas.\n\n\n5.2.1 Praktika\n\nIdentifikuok užklausą (prompt), komandą (command), pasirinkimą (option) ir argumentą (argumentą). Nepanikuok, jei nepažįsti pačių komandų.\n\nmain-user@linux-mint:~$ sudo apt install -y cowsay\nmain-user@linux-mint:~$ cd Downloads\nmain-user@linux-mint:~$ rm -rf test/\nmain-user@linux-mint:~$ ls -alh /home/user/Downloads\nmain-user@linux-mint:~$ mkdir -p /project/data\n\nSurask būdą, kaip sukurti skirtukus (tabs) terminalo lange. Kartais yra labai patogu turėti kelis skirtingus terminalo skirtukus. Pavyzdžiui, viename galite stebėti kompiuterio temperatūrą, kitame valdyti ir paleisti programas, o trečiame - stebėti, ar sistema nefiksuoja kokių nors klaidų. Bet kaip atidaryti skirtukus? Koks yra klaviatūros trumpinys? Jei norėtumėte paleisti ne skirtuką, o atskirą langą, koks trumpinys tai padarytų?\n\n\n\nSusirask terminalo grafinius nustatymus ir pakeisk foną, teksto spalvą ir kitus stiliaus elementus. Rask tau patinkantį stilių. Nebijok eksperimentuoti!\n\n\n\nNors dažniausiai žymeklis yra blyksintis kvadratėlis, surask, kaip jį pakeisti į |?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#linux-failų-sistema",
    "href": "6a_linux_comands_basic.html#linux-failų-sistema",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.3 Linux failų sistema",
    "text": "5.3 Linux failų sistema\nTerminai “direktorija”, “katalogas” ir “aplankas” dažnai vartojami kaip sinonimai ir paprastai reiškia tą patį – vietą failų sistemoje, kur gali būti saugomi failai ir kiti subkatalogai. Tačiau yra keletas kultūrinių ir kontekstinių niuansų:\n\nDirektorija (angl. directory): Techninis terminas, dažniausiai vartojamas Unix/Linux bendruomenėje ir kitose techninėse aplinkose. Jis pabrėžia hierarchinę failų sistemos struktūrą.\nKatalogas: Tai dar vienas techninis terminas, dažnai vartojamas kaip sinonimas direktorijai. Šis terminas paplitęs tiek techninėje, tiek kasdieninėje kalboje.\nAplankas (angl. folder): Terminas, dažniausiai naudojamas grafinėse vartotojo sąsajose (GUI), pavyzdžiui, Windows ir Mac OS. Nors jis iš esmės reiškia tą patį kaip direktorija ar katalogas, jis dažniau vartojamas GUI kontekste.\n\nČia aš naudosiu terminą „direktorija“, nes jis yra artimiausias angliškam „directory“. Tačiau kartais galiu panaudoti ir „aplanką“ ar „katalogą“, tad nenustebk.\n\n5.3.1 sudo\nPraeitame skyriuje aptarėme, kad tam tikroms komandoms vykdyti reikia naudoti sudo, t.y., eskaluoti (pakelti) savo vartotojo privilegijas iki administratoriaus (root) lygio. Tam reikia įvesti slaptažodį. Taip užtikrinamas saugumas, kad bet kas negalėtų vykdyti pavojingų veiksmų sistemoje.\nPaprastas vartotojas (user) ir administratorius (root) Linux sistemoje turi skirtingas teises ir privilegijas:\nuser:\n\nTeisės: Turi ribotas teises, gali atlikti veiksmus tik savo namų direkorijoje (home directory) ir kitose direktorijose, kuriose turi suteiktas teises.\nPriėjimas: Negali atlikti sisteminės administracijos užduočių, pvz., negali įdiegti ar pašalinti programinės įrangos, keisti sisteminių failų ar atlikti daugumos konfigūracijos pakeitimų.\n\nroot\n\nTeisės: Turi pilną administracinę prieigą prie visos sistemos. Gali atlikti bet kokias užduotis, įskaitant sisteminių failų modifikavimą, vartotojų administravimą, programinės įrangos diegimą ir pašalinimą.\nPriėjimas: Gali atlikti bet kokias operacijas be apribojimų.\n\nPaprastas vartotojas, vykdydamas sudo, gali laikinai gauti root teises, pvz.:\nsudo apt install &lt;programa&gt;\nPerėjimas iš paprasto vartotojo į root yra galimas tik tiems vartotojams, kurie yra įtraukti į sudo grupę. Instaliuojant Linux, pirmasis vartotojas automatiškai pridedamas prie šios grupės, tačiau vėliau sukurti vartotojai gali būti pridėti į sudo grupę pagal poreikį.\n\n\n5.3.2 root direktorija\nWindows operacinėje sistemoje turbūt matei diskus, pažymėtus raidėmis, pavyzdžiui, C:, D:, E:. Tai nereiškia, kad kompiuteryje yra keli fiziniai kietieji diskai. Dažniausiai tai yra vienas kietasis diskas, padalytas į logines dalis.\n\n\n\nŠaltinis OnlineComputerTips\n\n\nPavyzdžiui, C: diske paprastai saugomi Windows failai, o vartotojai dažnai naudoja kitą diską failams saugoti. Šie „diskai“ yra visiškai atskirti vienas nuo kito.\nLinux sistemoje viskas veikia šiek tiek kitaip. Net jei kompiuteryje būtų keli fiziniai diskai, jie gali būti sujungti į vieną loginę talpą (angl. logical volume) ir „pakišti“ po root direktorija, kuri žymima /.\nRoot direktorija yra failų sistemos viršūnė, žymima /. Visi kiti failai ir direktorijos yra šios šakninės direktorijos pavaldiniai. Tai atitinka Windows C: diską.\n\n\n\nŠaltinis\n\n\nČia rasi daug subdirektorijų. Svarbiausios iš jų:\n\n/root: Root vartotojo (administratoriaus) namų direktorija.\n/etc: Konfigūracijos failai, kurie kontroliuoja įvairių programų paleidimą ir veikimą.\n/home: Paprastų vartotojų namų direktorijos, pvz., /home/justas/, /home/ruprecht/.\n/mnt: Laikina vieta prijungtoms laikmenoms, tokioms kaip kietieji diskai ar tinklo diskai.\n/media: Katalogas, kuriame pritvirtinami USB, CD ar DVD įrenginiai.\n/bin: Sisteminiai vykdomieji failai, pvz., ls, cp, mv.\n/lib: Bibliotekos, būtinos sisteminėms programoms ir komandų vykdymui.\n\nKai atidarai failų naršyklę (Linux Mint tai programa Nemo), tavo namų direktorija bus po /home/vartotojas/. Štai kaip atrodytų naršy\n/\n└── home\n    ├── user name\n\nVisada gali pasitikrinti savo buvimo vietą, paspaudžiant ant „Toggle Location Entry“:\n\n\n\n5.3.3 Praktika\n\nAtsidaryk excalidraw naršyklėje ir nupiešk /, /home/, /media/ struktūros diagramą. Įsivaizduok, kad kompiuteryje yra trys vartotojai: justas, ruprechtas ir slibinas. Nupiešk jų namų direktorijas.\nĮkišk USB laikmeną į kompiuterį, atidaryk failų naršyklę (Nemo). Turėtum pamatyti kažką panašaus. Paspausk ant USB laikmenos, tada spustelėk „Toggle Location Entry“ ir identifikuok, kurioje failų sistemos vietoje yra USB laikmena. Pridėk tai prie diagramos, kurią piešei.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#pagrindinės-komandos",
    "href": "6a_linux_comands_basic.html#pagrindinės-komandos",
    "title": "5  Pagridinės BASH komandos",
    "section": "5.4 Pagrindinės komandos",
    "text": "5.4 Pagrindinės komandos\nTu jau žinai šiek tiek apie Linux failų sistemos struktūrą. Kai atsidaray failų naršyklę (Nemo) matai šias direktorijas:\n\nDirektorijų medyje, tai atrodytų taip:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\n\n5.4.1 pwd\nKomanda pwd (angl. “print working directory”, liet. “parodyti darbinį katalogą”) parodo dabartinio darbinio katalogo pilną kelią (path). Tai naudinga komanda, jei norite sužinoti, kuriame kataloge šiuo metu dirbate.\npwd\n\nTaigi šiuo atveju darbinis katalogas yra /home/main-user\n\n5.4.1.1 Absoliutus ir relatyvus kelias (path)\nŠioje vietoje reiktų susipažinti su absoliutaus ir relatyvaus kelio samprata.\n\n5.4.1.1.1 Absoliutus kelias\nAbsoliutus kelias (angl. absolute path) yra pilnas kelias nuo šaknies katalogo (/) iki konkretaus failo ar katalogo. Jis visada nurodo tą pačią vietą, nepriklausomai nuo to, kur yra dabartinis darbinis katalogas (working directory).\nPavyzdžiai:\n/home/main-user/Documents/ataskaita.txt\n/home/main-user/Downloads/duomenys.csv\nKartais tam kad sutrumpinti kelią ir pritaikyti skriptus prie galimai kitokio vartojo vardo (ir kartu jo subkatalogo), naudoajmas ~ ženklas. Kai Shell aptinka ~, jis iškart supranta, kad turimas omenyje dabartinio vartojojo /home/vartotojas adresas.\nTaigi šie adresai yra įdentiški\n/home/main-user/Documents/ataskaita.txt\n~/Documents/ataskaita.txt\n\n\n5.4.1.1.2 Relatyvus kelias\nRelatyvus kelias (angl. relative path) yra kelias, kuris yra nurodomas atsižvelgiant į dabartinį darbinį katalogą. Relatyvus kelias neturi pradinio /, jis pradeda nurodymą nuo jūsų dabartinio katalogo.\nPavyzdžiai:\nJei esate kataloge /home/vartotojas, relatyvus kelias\nDocuments/ataskaita.txt\nnurodys failą\n/home/vartotojas/dokumentai/ataskaita`.txt\nKada naudojama kas?\n\nAbosliutus kelias dažniausiai naudojamas skriptuose, konfigūracijos failuose, dokumentacijoje ir sisteminių failų veikloje.\nRelatyvus kelias naudojamas kasdieniniame darbe su failais, vartotojo scenarijuose, bendrame naudojime ir navigacijoje bei skriptuose.\n\n\n\n\n\n5.4.2 cd\nKomanda cd (angl. change directory, liet. “pakeisti katalogą”) naudojama pereiti iš vieno katalogo į kitą. Ši komanda leidžia keisti dabartinį darbinį katalogą.\n\nPereiti į konkretų katalogą pagal absoliutų kelią:\n\ncd /home/vartotojas/Documents\n\n\nPereiti į konkretų katalogą pagal relatyvų kelią:\n\ncd dokumentai/projektai\n\nPereiti į tėvinį katalogą (parent directory) (vienu lygiu aukščiau):\ncd ..\n\nTiesa, galite pereiti ir kiek įmantriau, štai iš Downloads, pakylama į tėvinį katalogą (..), o tada einama į /Documents:\ncd ../Documents\n\nPereiti į namų katalogą:\n\ncd\ncd ~\n\n\nPereiti į ankstesnį katalogą, kuriame buvote prieš pereidami į dabartinį katalogą:\n\ncd -\n\n\n5.4.3 ls\nKomanda ls (angl. list, liet. “parodyti sąrašą”) naudojama norint peržiūrėti failų ir katalogų sąrašą dabartiniame arba nurodytame kataloge. Tai viena iš dažniausiai naudojamų komandų naviguojant failų sistemoje Linux ir Unix tipo operacinėse sistemose.\n\nParodyti dabartinio katalogo turinį:\n\nls\n\n\nParodyti konkretaus katalogo turinį:\n\nls /path/to/directory\n\n\nParodyti išsamų (ilgą) failų sąrašą su detalėmis, pvz., teisėmis,savininku, dydžiu ir paskutinio modifikavimo data:\n\nls -l\n\n\nParodyti visus failus, įskaitant paslėptus (failai, kurių pavadinimai prasideda tašku):\n\nls -a\n\n\nNaudoti ilgą sąrašą su žmogišku skaitymo formatu -h (dydžiai rodomi su B, K, M). Čia sukombinuojamas -l su -a ir -h\n\nls -lah\n\n\nParodyti katalogų turinį rekursyviai (parodyti failus ir katalogus visuose pakatalogiuose):\n\nls -R\n\n\n\n5.4.4 clear\nKomanda clear (liet. “valyti”) naudojama norint išvalyti terminalo ekraną, pašalinant visus anksčiau įvestus ir parodytus tekstinius duomenis. Tai palieka terminalą švarų ir patogesnį tolimesniam naudojimui. Ši komanda neištrina terminalo istorijos; ji tik paslenka visą tekstą į viršų, už dabartinio vaizdo ribų.\nclear\n\n\n5.4.5 history\nKomanda history (liet. “istorija”) naudojama norint parodyti visų anksčiau įvestų komandų sąrašą dabartinėje terminalo sesijoje. Tai suteikia patogų būdą sekti ir kartoti anksčiau vykdytas komandas.\nParodyti visą komandų istoriją:\nhistory\n\nJei norite parodyti tik paskutines n komandų, galite naudoti history n. Pvz., parodyti paskutines 10 komandų:\nhistory 10\n\nKartoti konkrečią komandą pagal numerį, galima įrašius ! ir komandos numerį\nhistory\n!51\n\nIštrinti komandų istoriją:\nhistory -c\n\n\n\nIntarpas: kaip naviguoti CLI\nKartais rašant ilgas komandas, mes visi padarome klaidų. Pvz parašome “Hello World” ir nuspaudžiame Enter, tik tada supratę, kad turėjome parašyti echo prieš “Hello World”.\nTokiu atveju galime su rodyklyte aukštyn pakilti, ir rodyklyte į kairę pareiti į eilutės pradžią ir prirašyti echo.\nVideo\nkartais eilutės visgi būna gana ilgos\nsud apt update & sudo apt full-upgrade -y && sudo autoremove -y && flatpak update\ndeja šįkart neįarėme sudo. Kad nereikėtų su rodyklyte tipenti ilgai… galime naudotis tam tikrais trumpiniais:\n\nCtrl-A: nušoka į eilutės pradžia\nCtrl-E nusoka į eilutės pabaigą\nCtrl-U ištrina viską į dešinė nuo kursoriaus\n\nVideo\nJeigu dar nepastebėjote, Ctrl-C ir Ctrl-V klavišų kombinacijos neveikia. Terminal nustatymuose raskite nustatyas klavišų kombinacijas, kurios atitinka įprastines Ctrl-C ir Ctrl-V kombinacijas.\nNaudojant komandinę eilutę, kartais terminalas gali „pakibti“ ir tolesnis komandų įvedimas tampa sudėtingas ar neįmanomas. Štai keletas tokių situacijų pavyzdžiųm kai parašote echo padedate kabutes, prašot pirmą žodį ir paspaudžiat enter… kadangi neudarėte kabučių, CLI laukia įvesties, t.y. kabučių. Tokiu ir panašiais atvejais, kai nebaigiate įvesti komandos, ar padarote klaidą, terminal gali pasirodyti kaip “pakibęs”.\nPabykite šias komandas po vieną:\n$ echo \"hello\n$ grep foobar\n$ yes\n$ tail\n$ cat\nNorint nutraukti “pakibusią” komanda galite su Ctrl-C (laikykite Ctrl ir paspauskite C). Tai siunčia kontrolės kodą terminalui ir nutraukia vykdomą procesą. Taigi Ctrl-C nekopijuoja, o nutraukia, šioje komandoje C=Cancel.\nKartais pamatysite ^C terminale, kuris rodo, kad Ctrl-C buvo paspausta.\nPastaba: Jei Ctrl-C neveikia, pabandykite paspausti ESC (escape) klavišą. Tai padeda daugeliu atvejų.\n\nVerta žinoti, kartais vietoj Ctrl- notacijos, jūs galite sutikti ^ notaciją, pvz ^C ^O ^X\n\n\n5.4.6 whoami\nKomanda whoami parodo dabartinio vartotojo (user) vardą, su kuriuo esate prisijungę prie sistemos. Tai paprastas ir naudingas būdas patikrinti, kokį vartotojo prisijungimą naudojate, ypač kai dirbate su keliais vartotojais toje pačioje sistemoje.\nwhoami\nŠiuo atveju, vartotojo vardas yra main-user\n\n\n\n5.4.7 $PATH\n!Atsargiai ši tema kiek sudėtingesnė, bet ją pravartu žinoti.\nKaip Shell žino, kokią programą startuoti, kai pvz tu įrašai ls? Juk negali Shell eiti epr visus tavo failus ir ieškoti, ar yra tokia programa ls? Tai užtruktų labai ilgai ir būtų neefektyvu. Tavo Bash programa yra išsaugojusi visų direktorijų sąrašą, kurias ji tikrina.\nmain-user@linux-mint:~$ $PATH\nbash: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin: No such file or directory\nKą visa tai reiškia? Kai vartotojas įrašo komanda ls Bah pirma tikrina /usr/local/sbin/ jeigu ten neranda, eina į sekandią direktoriją /usr/local/bin ir t.t. Jeigu visame sąraše šios programos nebūtų, įrašius ls nieko neįvyktų, o terminale išvystum pranešimą, su siūlymų galbūt šią programą instaliuoti (jeigu apt programa apie šią komandą kažką žino).\nsu komanda which galime pamayti, o tai kur būtent ls randasi\nmain-user@linux-mint:~$ which ls\n/usr/bin/ls\nTaigi įrašius ls bash keliavo\n\n/usr/local/sbin &lt;- nerado ls\n/usr/local/bin &lt;- nerado ls\n/usr/sbin &lt;- nerado ls\n/usr/bin &lt;- čia rado ls\n\nRetais atvejais, tau gali reikėti pridėti direktorijas prie $PATH, bet labai tikėtina, jog tik pradedant naudotis Linux CLI, tau to dar nereikės. Tačiau jeigu kada prireiks, tu žinosi, apie ką čia kalbama.\n\n\n5.4.8 which\nKomanda which naudojama norint sužinoti, kurioje vietoje (path) yra esanti tam tikra vykdomoji programa. Ji parodo visą vykdomojo failo kelią, nurodydama, kurioje direktorijoje sistema pirmiausiai ieškos šios programos pagal PATH aplinkos kintamąjį.\nKartu ši komanda naudojama norint sužinoti, ar norima komanda yra įdiegta.\nparodo kurioje vietoje yra ls programa\nwhich ls\nTaip pat galima pamatyti, ar pvz neovim programa yra instaliuota\nwhich neovim\nKadangi Terminal negrąžino jokio kelio (path), tai pasako, jog šios programos nėra.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pagridinės BASH komandos</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#keliavimas-failų-sistema",
    "href": "6a_linux_comands_basic.html#keliavimas-failų-sistema",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.4 Keliavimas failų sistema",
    "text": "5.4 Keliavimas failų sistema\nJau šiek tiek susipažinai su Linux failų sistemos struktūra. Kai atsidarai failų naršyklę (Nemo), matai šias direktorijas:\n\nDirektorijų medyje tai atrodytų taip:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\nŠiame skyriuje išmoksi, kaip sužinoti, kur esi, su komanda pwd, kaip pakeisti direktoriją su cd ir kaip atspausdinti failų bei direktorijų sąrašą su ls.\nTačiau prieš einant prie pačių komandų, tau dar reikis susipažinti su vienu svarbiu konceptu - absoliučiu ir relatyviu adresu (arba keliu, nes angliškai - path).\n\n5.4.1 Absoliutus kelias\nAbsoliutus kelias (angl. absolute path) yra pilnas kelias nuo šaknies direktorijos (/) iki konkretaus failo ar katalogo. Jis visada nurodo tą pačią vietą, nepriklausomai nuo to, kur esi šiuo metu.\nPavyzdžiui, šis kelias nurodo visą maršrutą nuo / per /home/, vartotojo namų direktoriją /justas/iki subdirektorijos Documents, kurioje yra failas data.csv:\n/home/justas/Documents/data.csv\n\n\n5.4.2 Relatyvus kelias\nRelatyvus kelias (angl. relative path) yra nurodomas atsižvelgiant į dabartinę darbinę direktoriją. Jis neturi pradinio /, todėl priklauso nuo to, kur esi.\nJeigu šiuo metu esi direktorijoje/home/justas, relatyvus kelias į failą data.csv subdirektorijoje Documents būtų:\nDocuments/data.csv\nKartais gali pamatyti relatyvų kelią su . (tašku), kuris reiškia “esama direktorija”. Taigi šis relatyvus kelias irgi tinka:\n./Documents/data.csv\n\n\n5.4.3 ~\nVartotojų vardai Linux sistemoje gali skirtis, pvz., justas, ruprechtas ir t.t. Tarkime, rašai skriptą, kuris turi veikti vartotojo Downloads direktorijoje. Tu negali žinoti vartotojo vardo, todėl naudoti absoliutų kelią /home/justas/Downloads būtų nepatogu.\nBet ir relatyvus kelias ./Downloads gali sukelti problemų, nes skriptas gali būti paleistas ne iš vartotojo namų direktorijos, o tiesiai iš Downloads direktorijos, kas sukurtų absurdišką Downloads/Downloads.\n/\n└── home\n    ├── justas\n    │   ├── Downloads\n    │     ├── ./Downloads\nŠtai čia gelbsti ~. Shell atpažįsta ~ kaip nuorodą į dabartinio vartotojo namų direktoriją.\nTaigi relatyvus kelias~/Downloads yra automatiškai keičiamas į /home/justas/Downloads, jeigu vartotojas yra justas, arba į /home/ruprecht/Downloads, jeigu vartotojo vardas yra ruprecht.\nKada naudoti ką?\n\nAbsoliutūs keliai dažniausiai naudojami skriptuose, konfigūracijų failuose, dokumentacijoje ir sisteminiuose veiksmuose.\nRelatyvūs keliai labiau tinka kasdieniam darbui su failais, naršymui ir interaktyviam scenarijų vykdymui.\n\n\n\n5.4.4 pwd\nJau kelis kartus minėjome darbinę direktoriją. Kas tai? Darbinė direktorija yra ta direktorija, kurioje šiuo metu “gyvena” shell. Įsijunk terminalą, įrašyk komandą pwd ir paspausk Enter, kad ją įvykdytum. Komanda pwd (angl. “print working directory”) parodo dabartinės darbinės direktorijos pilną kelią (path).\npwd\n\nŠiuo atveju darbinė direktorija yra /home/justas.\nTaigi, iš mano darbinės direktorijos, Downloads subdirektorijoje esantis failas data.csv man būtų pasiekiamas Downloads/data.csv keliu. Tačiau aš galiu pakeisti savo darbinę direktoriją pereidamas į kitas direktorijas su komanda cd.\n\n\n5.4.5 cd\nKomanda cd (angl. change directory) naudojama pereiti iš vienos direktorijos į kitą. Kai pereini į kitą direktoriją, pasikeičia ir darbinė direktorija, kartais dar vadinama aktyvia direktorija (angl. current directory).\nĮvedęs komandą:\ncd Downloads\nAš pereinu į Downloads subdirektoriją. Kadangi Downloads yra mano namų direktorijoje, galėjau pasinaudoti relatyviu keliu. Atkreipk dėmesį, kaip pasikeičia terminalo prompt: vietoj ~ (jau žinai, ką jis reiškia), dabar matosi ~/Downloads.\n\nDabar failas Downloads/data.csv tampa pasiekiamas tiesiog kaip data.csv.\nKomandai cd gali duoti absoliutų kelią, ir tada cd pakeis darbinę direktoriją, nesvarbu, kur tuo metu esi:\ncd /home/justas/Documents\nŠi komanda perkelia mane iš Downloads tiesiai į Documents.\n\nTačiau cd komandai gali nurodyti ir relatyvų kelią, svarbu, kad jis egzistuotų. Pavyzdžiui, aš galiu pereiti iš savo namų direktorijos į Downloads su cd Downloads/, tačiau negaliu pereiti į Documents, jei esu Downloads direktorijoje, nes Documents ten nėra. Tada gaunu klaidos pranešimą: bash: cd: Documents/: No such file or directory.\n\nPriminimui:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\nKaip jau minėjau, taškas . reiškia “čia”. Pvz., iš namų direktorijos galėčiau pereiti į Downloads su cd ./Downloads.\nYra ir .., du taškai, kurie reiškia direktoriją esančią aukščiau už dabartinę (.) direktoriją. Ji dažnai vadinama parent directory. Taigi, su komanda cd ./Downloads nuėjęs į Downloads, galiu vėl pakilti į viršų su cd ...\n\n.. taip pat gali būti naudojama pereiti relatyviai, pvz., iš Downloads į Documents. Būdamas Downloads direktorijoje, galiu naudoti komandą cd ../Documents, kad pakilčiau vienu lygiu aukščiau ir tada pereičiau į Documents.\n\n.. gali būti naudojama ir kelis kartus iš eilės, pvz., iš Downloads galima pakilti į home, naudojant cd ../...\n\nPriminimui\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\nKomandą cd gali naudoti ir be jokių argumentų, kad grįžtum į namų direktoriją, pvz., cd arba su cd ~.\n\nPereiti į ankstesnę direktoriją gali su komanda cd -. Tarkime, buvau home/justas/Downloads, perėjau į home/justas/Documents, bet supratau, kad padariau klaidą - norėčiau likti Downloads. Galiu grįžti atgal su cd -.\n\nSveikinu! Dabar jau moki naršyti po direktorijas naudojant terminalą. Nors tai gali atrodyti sudėtinga iš pradžių, laikui bėgant pastebėsi, kad paleisti terminalą su klaviatūros trumpiniu Ctrl-Alt-T ir, naudojant TAB greitesniam komandų ir argumentų užpildymui, greitai nueiti į norimą direktoriją bei redaguoti failus bus daug greičiau nei tai daryti su grafinės sąsajos (GUI) įrankiais.\nPvz., iš savo namų direktorijos pereinu į Documents, tada į project, tada į documentation, atspausdinu failų sąrašą su ls ir redaguoju failą su nano programa.\nVideo\nBet kas ta ls komanda?\n\n\n5.4.6 ls\nKomanda ls (angl. list) naudojama norint peržiūrėti failų ir katalogų sąrašą dabartinėje arba nurodytoje direktorijoje. Tai viena dažniausiai naudojamų komandų, naviguojant failų sistemoje.\nJei atidarytum failų naršyklę, pavyzdžiui, Nemo, matytum kažką panašaus:\n\nLygiai taip pat failų sąrašą gali parodyti ir terminale, įvedant komandą ls:\n\nKomanda ls gali priimti argumentą – direktorijos kelią, kurio turinį norima parodyti. Šis kelias gali būti tiek absoliutus, tiek relatyvus. Pavyzdžiui, ls /home/justas/Downloads parodys Downloads katalogo turinį. Atkreipk dėmesį į spalvas: failai yra balti, o katalogai – mėlyni.\n\nKartais pamatyti tik failų pavadinimus gali būti nepakankama. Galbūt norisi matyti daugiau informacijos, pvz., kada failai sukurti, kas turi teises juos valdyti ar matyti, ar kam jie priklauso.\n\nKaip ir failų naršyklėje, kur gali perjungti į “List View”, terminale gali naudoti komandos ls nustatymą -l, kuris išveda išsamų (ilgą) failų sąrašą su papildoma informacija: teisėmis, savininku, dydžiu ir paskutinio modifikavimo data.\n\nPavyzdžiui ką tokią eilutė reikšia, paaikšinsiu netrukus.\ndrwxr-xr-x 2 justas justas 4096 Sep 15 10:19 Desktop\nNorint pamatyti visus failus, įskaitant paslėptus (failai, kurių pavadinimai prasideda tašku), gali naudoti -a arba --all:\n\nNemo failų naršyklėje taip pat gali pamatyti paslėptus failus, jei aktyvuosi šią funkciją.\nVideo\nKai paleidi ls -l, failų dydžiai nurodomi baitais. Kartais naudingiau matyti dydžius, išreikštus žmonėms suprantamesniais vienetais, kaip kilobaitai (1000 baitų), megabaitai (1000 kilobaitų) ir t.t. Tam gali naudoti nustatymą --human-readable arba trumpinį -h - ls -lh\nŠios abi komandos ls -all -l --human-readable ir ls -alh yra teisingos, tačiau dažniau naudojamas trumpesnis variantas. Panaudojant ls -alh, galėsi matyti paslėptus failus, o failų dydžiai bus išreikšti žmonėms labiau suprantama forma.\n\nKartais gali prireikti rekursyvaus katalogo turinio peržiūros. Komanda ls -R arba ls --recursive parodys ne tik pasirinktos direktorijos, bet ir visų jos subdirektorijų turinį.\n\n\n\n5.4.7 Teisės ir tipai\nŠi eilutė rodo failų arba direktorijų sąrašą su jų detalėmis:\n\nPirmas stulpelis parodo, kokio tipo failas ar direktorija tai yra, ir kokias teises turi skirtingi vartotojai.\nPirmoji raidė gali būti:\n\nd – Direktorija (directory)\nl – Simbolinė nuoroda (link)\n- – Įprastas failas (regular file)\n\nLinux sistemoje yra trys vartotojų tipai:\n\nSavininkas – vartotojas, kuris sukūrė failą arba direktoriją. Šiuo atveju vartotojas yra justas.\nGrupė – Grupė, kuriai priklauso failo savininkas. Dažnai grupės vardas yra tas pats kaip ir savininko vartotojo vardas, pvz., justas. Vartotojai gali priklausyti kelioms grupėms, tačiau kiekvienas failas ir direktorija turi pagrindinę grupę, kuri turi tam tikras teises į tą failą arba direktoriją. Pameni minėjom, kad ne visi vartotojai priklauso sudo grupei? Čia panašiai, tik kita grupė.\nKiti (other) – Visi kiti vartotojai, kurie nėra nei savininkas, nei grupės nariai. Tai apima visus kitus sistemos vartotojus, kurie neturi specialių teisių šiam failui ar direktorijai.\n\nTeisės nurodomos pirmame stulpelyje trimis tripletais: xxx-xxx-xxx (be brūkšnių).\n\nr – Skaitymo teisė (read), leidžia matyti ir skaityti turinį.\nw – Rašymo teisė (write), leidžia perrašyti turinį.\nx – Vykdymo teisė (execute), leidžia vykdyti failą.\n\nPvz., teisės drwxr-xr-x:\n\nd – Direktorija (directory)\nrwx – Savininko teisės: skaitymas (read), rašymas (write), vykdymas (execute)\nr-x – Grupės teisės: skaitymas (read), vykdymas (execute)\nr-x – Kitų vartotojų teisės: skaitymas (read), vykdymas (execute)\n2 – Nuorodų skaičius į šią direktoriją. Tai apima nuorodą į pačią direktoriją ir bet kurias subdirektorijas. Pavyzdžiui, jei skaičius būtų 4, tai reikštų, kad direktorijoje yra trys subdirektorijos (ir arba failai) ir viena pati direktorija.\njustas – Direktorijos savininko vartotojo vardas.\njustas – Direktorijos grupės vardas.\n4096 – Direktorijos dydis baitais.\nSep 15 10:19 – Paskutinio direktorijos modifikavimo data ir laikas.\nDesktop – Direktorijos pavadinimas.\n\n\n\n5.4.8 Pagalbinės funkcijos terminale\n\n\n5.4.9 history\nKomanda history (liet. „istorija“) naudojama norint parodyti visų anksčiau įvestų komandų sąrašą dabartinėje terminalo sesijoje. Tai suteikia patogų būdą sekti ir kartoti anksčiau vykdytas komandas.\n\nJei nori parodyti tik paskutines n komandų, gali naudoti history n. Pvz., parodyti paskutines 10 komandų history 10:\n\nKartoti konkrečią komandą pagal numerį galima įrašius ! ir komandos numerį. Pavyzdžiui, jei nori pakartoti komandą, kurios numeris yra 99:\nhistory\n!99\n\nIštrinti komandų istoriją galima su history -c.\nhistory -c\nhisotry\n\n\n\n5.4.10 clear\nKomanda clear (liet. „valyti“) naudojama norint išvalyti terminalo ekraną, pašalinant visus anksčiau įvestus ir parodytus tekstinius duomenis. Tai palieka terminalą švarų ir patogesnį tolimesniam naudojimui. Svarbu: ši komanda neištrina terminalo istorijos (history); ji tik paslenka visą tekstą į viršų, už dabartinio vaizdo ribų.\nclear\n\n\n5.4.11 Ctrl-L\nAlternatyva komandos clear naudojimui yra klaviatūros trumpinys Ctrl-L. Šis trumpinys atlieka tą pačią funkciją kaip ir komanda clear, tačiau jis yra greitesnis ir patogesnis, ypač kai dirbi terminale ir nori greitai išvalyti ekraną. Naudojant Ctrl-L, terminalo ekranas bus išvalytas, tačiau terminalo istorija liks nepakitusi.\n\n\n5.4.12 Navigacija terminale\nRašant ilgas komandas, klaidos neišvengiamos. Pavyzdžiui, rašai „Hello World“ ir paspaudi Enter ⏎, tik tada supranti, kad reikėjo parašyti echo prieš „Hello World“.\nŠtai kaip tai gali ištaisyti:\n\nPakilk į ankstesnę eilutę naudodamas rodyklę į viršų ⬆️.\nPerkelk kursorių į eilutės pradžią naudodamas rodyklę į kairę ⬅️.\nPrirašyk echo ir pakartok komandą paspaudus Enter ⏎.\n\nVideo\nKartais eilutės būna gana ilgos:\nsud apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update\nJei praleidai raidę, pavyzdžiui, pirmame sudo truksta o, nereikia viską iš naujo rašyti\n\nPakilk į ankstesnę eilutę naudodamas rodyklę į viršų ⬆️.\nNaudokCtrl-A, kad perkeltum kursorių į eilutės pradžią.\n➡️ ➡️ ➡️ ir pridėti o raidę.\npabaigus taisymą tiesiog paspausti Enter ⏎ (nebūtina nueiti į eilutės pabaigą)\n\nVideo\nTavo žiniai:\n\nCtrl-A: perkelia kursorių į eilutės pradžią\nCtrl-E: perkelia kursorių į eilutės pabaigą\nCtrl-U: ištrina viską į dešinę nuo kursoriaus\n\nUžduotis:\nPastebėsi, kad Ctrl-C ir Ctrl-V neveikia taip, kaip esame įpratę. Terminalo nustatymuose (settings) rask derinį, kuris atitinka įprastines Ctrl-C ir Ctrl-V kombinacijas.Kokie jie?\n\n\n5.4.13 Ctrl-C ir Escape\nNaudojant komandinę eilutę, kartais terminalas gali „pakibti“. Pvz., jei pradėsi rašyti echo su kabutėmis, bet pamirši uždaryti kabutes, terminalas lauks, kol užbaigsi komandą.\nTokiais atvejais terminalas gali atrodyti „pakibęs“. Pabandyk paleisti šias komandas po vieną:\n$ echo \"hello\n$ grep foobar\n$ yes\n$ tail\n$ cat\nNorėdamas nutraukti „pakibusią“ komandą, naudok Ctrl-C. Šis derinys siunčia kontrolės signalą terminalui ir nutraukia vykdomą procesą. Pastaba: Ctrl-C čia reiškia „Cancel“ (nutraukti).\nKartais terminale gali pamatyti ^C, rodančią, kad buvo paspaustas Ctrl-C. Jei Ctrl-C neveikia, pabandyk ESC klavišą.\nVerta žinoti: kad kartais vietoj Ctrl- notacijos, gali sutikti ^ notaciją, pvz., ^C, ^O, ^X.\n\n\n5.4.14 Praktika\n\nKai paleidi terminalą, kurioje direktorijoje esi? Pakeisk direktoriją į Downloads. Uždaryk terminalą ir paleisk jį iš naujo. Kur dabar esi?\nIš/home/user/ direktorijos pereik į Downloads ir atspausdink direktorijos turinį naudojant ls. Užduotis:\n\nFailų dydis būtų suprantamas žmonėms.\nSąrašas būtų pateikiamas viename stulpelyje.\n\nIš /home/user/ direktorijos pereik į Documents. Iš ten atspausdink failų sąrašą Downloads (!!!) direktorijoje\n\nnaudojant absoliutų kelią\nnaudojant relatyvų kelią\n\n\nPagalbai:\nHome Directory/\n├── Desktop/\n├── Documents/\n├── Downloads/\n├── Music/\n├── Pictures/\n├── Public/\n├── Templates/\n└── Videos/\n\nNaudok clear, kad išvalytum terminalą, tada su history surask tau patinkančią komandą ir pakartok ją naudojant !n.\nVizualizuok vartotojų ir grupių santykius pagal šią lentelę. Naudok Excalidraw:\n\n\n\n\nVartotojas\nSudo grupė\nGrupė “namai”\n\n\n\n\nroot\nTaip\nTaip\n\n\njustas\nTaip\nTaip\n\n\nruprechtas\nNe\nTaip\n\n\n\n\nĮsivaizduok, kad failas /home/ruprechtas/info.txt turi tokias savybes:\n\n-rwx----- 2 ruprechtas namai 4096 Sep 15 10:19 info.txt\nAr vartotojas justas, priklausantis grupei namai, galės atidaryti ir perrašyti šį failą? Kodėl?\n\nKą reikėtų pakeisti, kad vartotojas justas galėtų matyti ir perrašyti šį failą? Atsakyk teoriškai (nes dar nežinai komandų, kuriomis tai apdaryti).\nNukopijuok ir paleisk šią komandą terminale.\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/e61bb3ab5cf28686f74a50e436b06fe6/raw | bash\nŠi komanda parsisiųs ir įvykdys skriptą, kuris sukurs test direktoriją tavo/home/username/ direktorijoje.\nPasinaudok ls, atspausdink visus failus, esančius (sub-)direktorijose ir atsakyk į šiuos klausimus:\n\nKiek yra subdirektorijų test direktorijoje?\nKiek iš viso suskaičiuoji failų? Suskaičiuok visus failus, esančius visose subdirektorijose.\nKokio tipo failų (pvz., .txt, .csv) yra daugiausia? Kurioje direktorijoje?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "6a_linux_comands_basic.html#funkcijos",
    "href": "6a_linux_comands_basic.html#funkcijos",
    "title": "5  Terminalas ir Linux failų sistema",
    "section": "5.5 Funkcijos",
    "text": "5.5 Funkcijos\nVisos skyriuje panaudotos funkcijos\n\n\n\n\n\n\n\nFunkcija\nAprašymas\n\n\n\n\nwhich\nParodo vykdomojo failo vietą\n\n\npwd\nParodo dabartinės darbinės direktorijos pilną kelią\n\n\ncd\nPakeičia dabartinę direktoriją (esamą vietą) terminale\n\n\nls\nRodo failų ir katalogų sąrašą direktorijoje\n\n\nsudo\nLeidžia vykdyti komandas su kitokio vartotojo teisėmis (dažniausiai root)\n\n\nhistory\nRodo ankstesnių komandų istoriją\n\n\nclear\nIšvalo terminalo ekraną\n\n\nCtrl-A\nPerkelia kursorių į eilutės pradžią\n\n\nCtrl-E\nPerkelia kursorių į eilutės pabaigą\n\n\nCtrl-U\nIštrina viską į kairę nuo kursoriaus\n\n\nCtrl-C\nNutraukia vykdomą komandą terminale\n\n\nCtrl-L\nIšvalo terminalo ekraną (panašu į clear)\n\n\nShift-Ctrl-C\nKopijuoja tekstą iš terminalo\n\n\nShift-Ctrl-V\nĮkelia tekstą į terminalą\n\n\nShift-Ctrl-T\nSukuria naują terminalo skirtuką\n\n\nShift-Ctrl-N\nSukuria naują terminalo langą",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#autocompletion-with-tab",
    "href": "6b_linux_comands_basic.html#autocompletion-with-tab",
    "title": "6  Pagridinės BASH komandos 2",
    "section": "6.2 autocompletion with tab",
    "text": "6.2 autocompletion with tab\nExercise Exercise How can I type less?\nOne of the shell’s power tools is tab completion. If you start typing the name of a file and then press the tab key, the shell will do its best to auto-complete the path. For example, if you type sea and press tab, it will fill in the directory name seasonal/ (with a trailing slash). If you then type a and tab, it will complete the path as seasonal/autumn.csv.\nIf the path is ambiguous, such as seasonal/s, pressing tab a second time will display a list of possibilities. Typing another character or two to make your path more specific and then pressing tab will fill in the rest of the name. Instructions 1/2 50 XP\n1\n\nRun head seasonal/autumn.csv without typing the full filename.\n2\nRun head seasonal/spring.csv without typing the full filename.\n\n6.2.1 flags\nExercise Exercise How can I control what commands do?\nYou won’t always want to look at the first 10 lines of a file, so the shell lets you change head’s behavior by giving it a command-line flag (or just “flag” for short). If you run the command:\nhead -n 3 seasonal/summer.csv\nhead will only display the first three lines of the file. If you run head -n 100, it will display the first 100 (assuming there are that many), and so on.\nA flag’s name usually indicates its purpose (for example, -n is meant to signal “number of lines”). Command flags don’t have to be a - followed by a single letter, but it’s a widely-used convention.\nNote: it’s considered good style to put all flags before any filenames, so in this course, we only accept answers that do that. Instructions 100 XP\nDisplay the first 5 lines of winter.csv in the seasonal directory.\n\n\n6.2.2 cp\nKomanda cp (angl. copy, liet. “kopijuoti”) naudojama kopijuoti failus ir direktorijas.\n\nKopijuoti failą:\n\ncp šaltinis.txt tikslas.txt\nŠi komanda kopijuoja failą šaltinis.txt į failą tikslas.txt.\n\nKopijuoti direktorija rekursyviai (su visu esančiu turiniu):\n\ncp -r šaltinis_katalogas tikslas_katalogas\nŠi komanda kopijuoja direktoriją šaltinis_katalogas ir visą jo turinį į tikslas_katalogas.\nHow can I copy files?\nYou will often want to copy files, move them into other directories to organize them, or rename them. One command to do this is cp, which is short for “copy”. If original.txt is an existing file, then:\ncp original.txt duplicate.txt\ncreates a copy of original.txt called duplicate.txt. If there already was a file called duplicate.txt, it is overwritten. If the last parameter to cp is an existing directory, then a command like:\ncp seasonal/autumn.csv seasonal/winter.csv backup\ncopies all of the files into that directory. Instructions 1/2 50 XP\n1\n\nMake a copy of seasonal/summer.csv in the backup directory (which is also in /home/repl), calling the new file summer.bck.\n2\nCopy spring.csv and summer.csv from the seasonal directory into the backup directory without changing your current working directory (/home/repl).\n\n\n6.2.3 mv\nKomanda mv (angl. move, liet. “perkelti” arba “pervadinti”) naudojama perkelti arba pervadinti failus ir katalogus. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\n\nPervadinti failą arba katalogą:\n\nŠi komanda pervadina failą ar katalogą iš senas_pavadinimas į naujas_pavadinimas.\nmv senas_pavadinimas naujas_pavadinimas\n\nPerkelti failą į kitą katalogą:\n\nŠi komanda perkelia failą failas.txt į katalogą /naujas/kelias/.\nmv failas.txt /naujas/kelias/\n\nPerkelti kelis failus į kitą katalogą:\n\nŠi komanda perkelia failus failas1.txt ir failas2.txt į katalogą /naujas/kelias/.\nmv failas1.txt failas2.txt /naujas/kelias/\n\nPerkelti katalogą ir jo turinį į kitą vietą: Ši komanda perkelia katalogą katalogas ir visą jo turinį į katalogą /naujas/kelias/.\n\nmv katalogas /naujas/kelias/\nHow can I move a file?\nWhile cp copies a file, mv moves it from one directory to another, just as if you had dragged it in a graphical file browser. It handles its parameters the same way as cp, so the command:\nmv autumn.csv winter.csv ..\nmoves the files autumn.csv and winter.csv from the current working directory up one level to its parent directory (because .. always refers to the directory above your current location). Instructions 100 XP\nYou are in /home/repl, which has sub-directories seasonal and backup. Using a single command, move spring.csv and summer.csv from seasonal to backup.\nExercise Exercise How can I rename files?\nmv can also be used to rename files. If you run:\nmv course.txt old-course.txt\nthen the file course.txt in the current working directory is “moved” to the file old-course.txt. This is different from the way file browsers work, but is often handy.\nOne warning: just like cp, mv will overwrite existing files. If, for example, you already have a file called old-course.txt, then the command shown above will replace it with whatever is in course.txt. Instructions 1/3 35 XP\n1\n\nGo into the seasonal directory.\n2\nRename the file winter.csv to be winter.csv.bck. 3\nRun ls to check that everything has worked.\n\n\n6.2.4 rm\nKomanda rm (angl. remove, liet. “pašalinti”) naudojama pašalinti failus ir katalogus. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar katalogai nėra perkeliami į šiukšlinę ir jų atkurti nebebus galima.\n\nPašalinti failą:\n\nrm failas.txt\n\nPašalinti kelis failus:\n\nrm failas1.txt failas2.txt failas3.txt\n\nPašalinti tuščią katalogą:\n\nrm -d tuščias_katalogas\n\nPašalinti katalogą ir jo turinį rekursyviai:\n\nrm -r katalogas\n\nPriverstinai pašalinti failą ar katalogą:\n\nrm -rf katalogas\nExercise Exercise How can I delete files?\nWe can copy files and move them around; to delete them, we use rm, which stands for “remove”. As with cp and mv, you can give rm the names of as many files as you’d like, so:\nrm thesis.txt backup/thesis-2017-08.txt\nremoves both thesis.txt and backup/thesis-2017-08.txt\nrm does exactly what its name says, and it does it right away: unlike graphical file browsers, the shell doesn’t have a trash can, so when you type the command above, your thesis is gone for good. Instructions 1/4 25 XP\n1\n\nYou are in /home/repl. Go into the seasonal directory.\n2\nRemove autumn.csv. 3\nGo back to your home directory. 4\nRemove seasonal/summer.csv without changing directories again.\n\n\n6.2.5 mkdir\nKomanda mkdir (angl. make directory, liet. “kurti katalogą”) naudojama norint sukurti naujus katalogus. Tai yra pagrindinė komanda, kai reikia sukurti naujus katalogus failų sistemoje.\n\nSukurti naują katalogą:\n\nmdkir projektas0\n\n\nSukurti keletą naujų katalogų vienu metu\n\nmkdir projektas1 projektas2 projektas3\n\n\nSukurti katalogų medį (hierarchiją), jei tarpiniai katalogai neegzistuoja:\n\nmkdir -p projektas0/duomenys\n\nNemo failų naršyklėje taip pat matomas rezultatas\n\nExercise Exercise How can I create and delete directories?\nmv treats directories the same way it treats files: if you are in your home directory and run mv seasonal by-season, for example, mv changes the name of the seasonal directory to by-season. However, rm works differently.\nIf you try to rm a directory, the shell prints an error message telling you it can’t do that, primarily to stop you from accidentally deleting an entire directory full of work. Instead, you can use a separate command called rmdir. For added safety, it only works when the directory is empty, so you must delete the files in a directory before you delete the directory. (Experienced users can use the -r option to rm to get the same effect; we will discuss command options in the next chapter.) Instructions 1/4 25 XP\n1\n\nWithout changing directories, delete the file agarwal.txt in the people directory.\n2\nNow that the people directory is empty, use a single command to delete it. 3\nSince a directory is not a file, you must use the command mkdir directory_name to create a new (empty) directory. Use this command to create a new directory called yearly below your home directory. 4\nNow that yearly exists, create another directory called 2017 inside it without leaving your home directory.\nExercise Exercise Wrapping up\nYou will often create intermediate files when analyzing data. Rather than storing them in your home directory, you can put them in /tmp, which is where people and programs often keep files they only need briefly. (Note that /tmp is immediately below the root directory /, not below your home directory.) This wrap-up exercise will show you how to do that. Instructions 1/4 25 XP\n1\n\nUse cd to go into /tmp.\n2\nList the contents of /tmp without typing a directory name. 3\nMake a new directory inside /tmp called scratch. 4\nMove /home/repl/people/agarwal.txt into /tmp/scratch. We suggest you use the ~ shortcut for your home directory and a relative path for the second rather than the absolute path.\n\n\n6.2.6 Intarpas: Standartinė įvestis, išvestis ir klaidos\nLinux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenų įvestį ir išvestį programose bei komandose. Šie srautai dažnai vadinami standartine įvestimi (standard input), standartine išvestimi (standard output) ir standartine klaida (standard error). Kiekvienas jų turi specifinį paskirtį ir failo aprašymo numerį.\n\n6.2.6.1 Standartinė įvestis (stdin)\n\nFailo aprašymo numeris: 0\nAprašymas: Standartinė įvestis, sutrumpinta kaip stdin, yra srautas, iš kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, stdin yra prijungta prie klaviatūros įvesties, tačiau gali būti nukreipta iš failo ar kito srauto.\nNaudojimas:\n\n# Nuskaito duomenis iš klaviatūros\ncat\nTaip pat gali būti nukreipiama iš failo:\ncat &lt; failas.txt\n\n\n6.2.6.2 Standartinė išvestis (stdout)\n\nFailo aprašymo numeris: 1\nAprašymas: Standartinė išvestis, sutrumpinta kaip stdout, yra srautas, į kurį komanda ar programa rašo išvestį. Pagal numatytuosius nustatymus, stdout yra prijungta prie terminalo ekrano.\nNaudojimas:\n\n# Spausdina į terminalą\necho \"Hello World\"\nTaip pat gali būti nukreipiama į failą:\necho \"Hello World!\" &gt; išvestis.txt\n\n\n6.2.6.3 Standartinė klaida (stderr)\n\nFailo aprašymo numeris: 2\nAprašymas: Standartinė klaida, sutrumpinta kaip stderr, yra srautas, į kurį komanda ar programa rašo klaidų pranešimus. Pagal numatytuosius nustatymus, stderr yra prijungta prie terminalo ekrano, bet gali būti nukreipta į failą ar kitą srautą.\nNaudojimas:\n\n# Nukreipia klaidų pranešimus į failą\nls non_existing_file 2&gt; klaida.log\n\n\n6.2.6.4 Praktika:\n\nPabandykite atspausdinti (nukipijuoti) su cat neegsistuojantį failą abracadabra.txt į failą, o klaidą nukreipti į failą error_logs.txt\nSu cat atspausdinkite error_logs.txt\nSu echo bei &gt; sukurkite failą abracadabra.txt pvz\n\necho \"Abracadabra is a magic word, historically used as an apotropaic incantation on amulets and common today in stage magic. It is of unknown origin.\" &gt; 'abracadabra.txt'\n\npakartokite 1 ir 2 žingsnius.\n\n\n\n\n6.2.7 touch\nKomanda touch naudojama norint sukurti tuščią failą arba pakeisti esamo failo datą ir laiką (modifikavimo ir prieigos laikus). Tai yra universali ir dažnai naudojama komanda, ypač kai reikia greitai sukurti failą arba atnaujinti failo metaduomenis.\nJei failas dar neegzistuoja, ši komanda jį sukurs. Jei failas jau yra, ji pakeis failo “paskutinio keitimo laiką” į dabartinį laiką, nekeičiant paties failo turinio.\n\nSukurti tuščią failą:\n\ntouch failas0.txt\n\n\nSukurti keletą tuščių failų vienu metu:\n\ntouch failas1.txt failas2.txt failas3.txt\n\n\nSukurti tuščią faila kitame kataloge nurodant absoliutų arba relatyvų kelią:\n\ntouch /home/user/Documents/failas4.txt\ntouch ~/Documents/failas5.txt\n\n\nPakeisti esamo failo paskutinio keitimo laiką -m abra prieigos laiką -a, arba nustatyti konkretų datą ir laiką -t:\n\ntouch -m failas.txt\ntouch -a failas.txt\ntouch -t YYYYMMDDHHMM.SS failas.txt\n\n\n6.2.8 grep\nKomanda grep (angl. global regular expression print, liet. “globalus reguliariųjų išraiškų paieškos spausdinimas”) naudojama tekstui paieškai pagal šabloną failuose arba išvestyje.\n\nIeškoti teksto failuose:\n\ngrep \"paieškos_tikslas\" failas.txt\nŠi komanda ieško “paieškos_tikslas” ir parodo atitinkančias eilutes iš failo failas.txt.\n\nIeškoti rekursyviai kataloge:\n\ngrep -r \"paieškos_tikslas\" /path/to/directory\nŠi komanda ieško “paieškos_tikslas” visame katalogo ir jo pakatalogių medyje.\n\n\n6.2.9 find\nKomanda find naudojama ieškoti failų ir katalogų pagal įvairius kriterijus.\n\nIeškoti failų dabartiniame kataloge pagal pavadinimą:\n\nfind . -name \"failas.txt\"\n\nIeškoti failų visoje sistemoje pagal pavadinimą:\n\nfind / -name \"failas.txt\"\n\n\n6.2.10 cut command\nExercise Exercise How can I select columns from a file?\nhead and tail let you select rows from a text file. If you want to select columns, you can use the command cut. It has several options (use man cut to explore them), but the most common is something like:\ncut -f 2-5,8 -d , values.csv\nwhich means “select columns 2 through 5 and columns 8, using comma as the separator”. cut uses -f (meaning “fields”) to specify columns and -d (meaning “delimiter”) to specify the separator. You need to specify the latter because some files may use spaces, tabs, or colons to separate columns.\nWhat command will select the first column (containing dates) from the file spring.csv? Instructions 50 XP Possible answers cut -d , -f 1 seasonal/spring.csv cut -d, -f1 seasonal/spring.csv Either of the above. Neither of the above, because -f must come before -d.\nExercise Exercise What can’t cut do?\ncut is a simple-minded command. In particular, it doesn’t understand quoted strings. If, for example, your file is:\nName,Age “Johel,Ranjit”,28 “Sharma,Rupinder”,26\nthen:\ncut -f 2 -d , everyone.csv\nwill produce:\nAge Ranjit” Rupinder”\nrather than everyone’s age, because it will think the comma between last and first names is a column separator.\nWhat is the output of cut -d : -f 2-4 on the line:\nfirst:second:third:\n(Note the trailing colon.) Instructions 50 XP Possible answers second second:third second:third: None of the above, because there aren’t four fields.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos 2</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#pipe",
    "href": "6b_linux_comands_basic.html#pipe",
    "title": "6  BASH komandos",
    "section": "6.2 pipe |",
    "text": "6.2 pipe |\nWhat’s a better way to combine commands?\nUsing redirection to combine commands has two drawbacks:\nIt leaves a lot of intermediate files lying around (like top.csv).\nThe commands to produce your final result are scattered across several lines of history.\nThe shell provides another tool that solves both of these problems at once called a pipe. Once again, start by running head:\nhead -n 5 seasonal/summer.csv\nInstead of sending head’s output to a file, add a vertical bar and the tail command without a filename:\nhead -n 5 seasonal/summer.csv | tail -n 3\nThe pipe symbol tells the shell to use the output of the command on the left as the input to the command on the right. Instructions 100 XP\nUse cut to select all of the tooth names from column 2 of the comma delimited file seasonal/summer.csv, then pipe the result to grep, with an inverted match, to exclude the header line containing the word “Tooth”. cut and grep were covered in detail in Chapter 2, exercises 8 and 11 respectively.\nExercise Exercise How can I combine many commands?\nYou can chain any number of commands together. For example, this command:\ncut -d , -f 1 seasonal/spring.csv | grep -v Date | head -n 10\nwill:\nselect the first column from the spring data;\nremove the header line containing the word \"Date\"; and\nselect the first 10 lines of actual data.\nInstructions 100 XP\nIn the previous exercise, you used the following command to select all the tooth names from column 2 of seasonal/summer.csv:\ncut -d , -f 2 seasonal/summer.csv | grep -v Tooth\nExtend this pipeline with a head command to only select the very first tooth name.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#grep-1",
    "href": "6b_linux_comands_basic.html#grep-1",
    "title": "6  Pagridinės BASH komandos 2",
    "section": "6.3 grep",
    "text": "6.3 grep\nHow can I select lines containing specific values?\nhead and tail select rows, cut selects columns, and grep selects lines according to what they contain. In its simplest form, grep takes a piece of text followed by one or more filenames and prints all of the lines in those files that contain that text. For example, grep bicuspid seasonal/winter.csv prints lines from winter.csv that contain “bicuspid”.\ngrep can search for patterns as well; we will explore those in the next course. What’s more important right now is some of grep’s more common flags:\n-c: print a count of matching lines rather than the lines themselves\n-h: do not print the names of files when searching multiple files\n-i: ignore case (e.g., treat \"Regression\" and \"regression\" as matches)\n-l: print the names of files that contain matches, not the matches\n-n: print line numbers for matching lines\n-v: invert the match, i.e., only show lines that don't match\nInstructions 1/3 35 XP\n1\n\nPrint the contents of all of the lines containing the word molar in seasonal/autumn.csv by running a single command while in your home directory. Don't use any flags.\n2\nInvert the match to find all of the lines that don’t contain the word molar in seasonal/spring.csv, and show their line numbers. Remember, it’s considered good style to put all of the flags before other values like filenames or the search term “molar”. 3\nCount how many lines contain the word incisor in autumn.csv and winter.csv combined. (Again, run a single command from your home directory.)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos 2</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#word-count-with-wc",
    "href": "6b_linux_comands_basic.html#word-count-with-wc",
    "title": "6  Pagridinės BASH komandos 2",
    "section": "6.2 word count with wc",
    "text": "6.2 word count with wc\nExercise Exercise How can I count the records in a file?\nThe command wc (short for “word count”) prints the number of characters, words, and lines in a file. You can make it print only one of these using -c, -w, or -l respectively. Instructions 100 XP\nCount how many records in seasonal/spring.csv have dates in July 2017 (2017-07).\nTo do this, use grep with a partial date to select the lines and pipe this result into wc with an appropriate flag to count the lines.\n\n6.2.1 touch\nKomanda touch naudojama norint sukurti tuščią failą arba pakeisti esamo failo datą ir laiką (modifikavimo ir prieigos laikus). Tai yra universali ir dažnai naudojama komanda, ypač kai reikia greitai sukurti failą arba atnaujinti failo metaduomenis.\nJei failas dar neegzistuoja, ši komanda jį sukurs. Jei failas jau yra, ji pakeis failo “paskutinio keitimo laiką” į dabartinį laiką, nekeičiant paties failo turinio.\n\nSukurti tuščią failą:\n\ntouch failas0.txt\n\n\nSukurti keletą tuščių failų vienu metu:\n\ntouch failas1.txt failas2.txt failas3.txt\n\n\nSukurti tuščią faila kitame kataloge nurodant absoliutų arba relatyvų kelią:\n\ntouch /home/user/Documents/failas4.txt\ntouch ~/Documents/failas5.txt\n\n\nPakeisti esamo failo paskutinio keitimo laiką -m abra prieigos laiką -a, arba nustatyti konkretų datą ir laiką -t:\n\ntouch -m failas.txt\ntouch -a failas.txt\ntouch -t YYYYMMDDHHMM.SS failas.txt\n\n\n6.2.2 mkdir\nKomanda mkdir (angl. make directory, liet. “kurti katalogą”) naudojama norint sukurti naujus katalogus. Tai yra pagrindinė komanda, kai reikia sukurti naujus katalogus failų sistemoje.\n\nSukurti naują katalogą:\n\nmdkir projektas0\n\n\nSukurti keletą naujų katalogų vienu metu\n\nmkdir projektas1 projektas2 projektas3\n\n\nSukurti katalogų medį (hierarchiją), jei tarpiniai katalogai neegzistuoja:\n\nmkdir -p projektas0/duomenys\n\nNemo failų naršyklėje taip pat matomas rezultatas\n\nExercise Exercise How can I create and delete directories?\nmv treats directories the same way it treats files: if you are in your home directory and run mv seasonal by-season, for example, mv changes the name of the seasonal directory to by-season. However, rm works differently.\nIf you try to rm a directory, the shell prints an error message telling you it can’t do that, primarily to stop you from accidentally deleting an entire directory full of work. Instead, you can use a separate command called rmdir. For added safety, it only works when the directory is empty, so you must delete the files in a directory before you delete the directory. (Experienced users can use the -r option to rm to get the same effect; we will discuss command options in the next chapter.) Instructions 1/4 25 XP\n1\n\nWithout changing directories, delete the file agarwal.txt in the people directory.\n2\nNow that the people directory is empty, use a single command to delete it. 3\nSince a directory is not a file, you must use the command mkdir directory_name to create a new (empty) directory. Use this command to create a new directory called yearly below your home directory. 4\nNow that yearly exists, create another directory called 2017 inside it without leaving your home directory.\nExercise Exercise Wrapping up\nYou will often create intermediate files when analyzing data. Rather than storing them in your home directory, you can put them in /tmp, which is where people and programs often keep files they only need briefly. (Note that /tmp is immediately below the root directory /, not below your home directory.) This wrap-up exercise will show you how to do that. Instructions 1/4 25 XP\n1\n\nUse cd to go into /tmp.\n2\nList the contents of /tmp without typing a directory name. 3\nMake a new directory inside /tmp called scratch. 4\nMove /home/repl/people/agarwal.txt into /tmp/scratch. We suggest you use the ~ shortcut for your home directory and a relative path for the second rather than the absolute path.\n\n\n6.2.3 cp\nPripažink, kopijuoti failą cat failas.txt &gt; kopija.txt neskamba intuityviai. Be to, kyla klausimas, o ką daryti, jeigu nori nukopijuoti ne tik failą, bet ir visą direktoriją?\nKomanda cp (angl. copy) naudojama kopijuoti failus ir direktorijas.\nPaprasčiausiu atveju, kai nori padaryti kopiją, komandai cp nurodai originalaus failo pavadinimą ir kokiu pavadinimu turėtų būti sukurta kopija. Pvz.:\ncp song_text.txt song_text_copy.txt\nJeigu failas song_text_copy.txt jau egzistuotų, tada jis būtų perrašytas, taigi cp veikia beveik kaip &gt;.\nKaip ir su &gt;bei &gt;&gt;, tu gali nurodyti, kur turėtų būti patalpinta kopija, naudojant tiek reliatyvius, tiek absoliučius adresus (path). Tokiu atveju galima vietoj failo pavadinimo nudoryti failo adresą.\ncp ~/song_text.txt ~/Downdloads/song_text_copy.txt\nJeigu cp antrasis argumentas bus ne failo, o egzistuojančios direktorijos pavadinimas, tada cp sukurs kopiją tokiu pačiu pavadinimu, kaip originalas, ir patalpins kopiją į nurodytą direktoriją.\ncp ~/song_text.txt ~/Downdloads\ncp kopijuoja ir direktorijas, tačiau tam, kad direktorija būtų nukopijuota rekursyviai (su visu esančiu turiniu), cp reikia naudoti nustatymą -r (recursive).\ncp -r šaltinis_katalogas tikslas_katalogas\n\n\n\n\n\n\nPraktika\n\n\n\n\nPadaryk vilnius_temp.txt kopiją pavadinimu vilnius_temp_copy.txt.\nPadaryk vilnius_temp.txt kopiją pavadinimu vilnius_temp_copy.txt, bet kaip argumentą nurodyk direktoriją ir failo pavadinimą. Patalpink kopiją į Downloads.\nPadaryk vilnius_temp.txt kopiją su originaliu pavadinimu, kaip antrą argumentą cp paduodant tik Downloads direktoriją.\nBūnant namų direktorijoje (~), su ls atspausdink Downloads turinį long formatu. Ar tikrai abu failai ten?\nTavo namų direktorijoje vis dar turėtų būti “test” direktorija. Padaryk jos kopiją į Documents direktoriją nepakeičiant pavadinimo. Tada vis dar būnant namų direktorijoje (~), su ls atspausdink Documents/test esnčias subdirektiras ir visus jose esančius failus.\n\n\n\n\n\n6.2.4 mv\nKomanda mv (angl. move) naudojama perkelti arba pervadinti failus ir direktorijas. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\nmv komanda gali pervadinti failą vilnius_temp.txt į kaunas_temp.txt.\nmv vilnius_temp.txt kaunas_temp.txt\nSu mv galima ir perkelti failus iš vienos direktorijos į kitą. Ši komanda perkelia failą kaunas_temp.txt į ~/Downloads.\nmv kaunas_temp.txt ~/Downloads\nmv komandai galima paduoti daugiau nei du argumentus. Ši komanda perkelia failus vilnius_temp.txt ir kaunas_temp.txt į direktoriją ~/Downloads. galima perkelti kelis failus ir net kelias direktorijas vienu metu, svarbiausia, kad paskutinis argumentas tokiu atveju būtų irgi direktorija.\nmv vilnius_temp.txt kaunas_temp.txt ~/Downloads\nPerkelti katalogą ir jo turinį į kitą vietą: Ši komanda perkelia katalogą katalogas ir visą jo turinį į katalogą /naujas/kelias/.\nmv test ~/Downloads\nPerspėjimas, kaip ir &gt; bei cp, jeigu tikslininas failas jau egzistuoja, jis bus perrašytas.\n\n\n\n\n\n\nPraktika\n\n\n\nKas nutiktų įvykdžius šią komandą?\nmv vilnius_temp.txt kaunas_temp.txt ~/Documents ~/Downloads\n\n\n\n\n6.2.5 rm\nKomanda rm (angl. remove, liet. “pašalinti”) naudojama pašalinti failus ir katalogus. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar katalogai nėra perkeliami į šiukšlinę ir jų atkurti nebebus galima.\n\nPašalinti failą:\n\nrm failas.txt\n\nPašalinti kelis failus:\n\nrm failas1.txt failas2.txt failas3.txt\n\nPašalinti tuščią katalogą:\n\nrm -d tuščias_katalogas\n\nPašalinti katalogą ir jo turinį rekursyviai:\n\nrm -r katalogas\n\nPriverstinai pašalinti failą ar katalogą:\n\nrm -rf katalogas\nExercise Exercise How can I delete files?\nWe can copy files and move them around; to delete them, we use rm, which stands for “remove”. As with cp and mv, you can give rm the names of as many files as you’d like, so:\nrm thesis.txt backup/thesis-2017-08.txt\nremoves both thesis.txt and backup/thesis-2017-08.txt\nrm does exactly what its name says, and it does it right away: unlike graphical file browsers, the shell doesn’t have a trash can, so when you type the command above, your thesis is gone for good. Instructions 1/4 25 XP\n1\n\nYou are in /home/repl. Go into the seasonal directory.\n2\nRemove autumn.csv. 3\nGo back to your home directory. 4\nRemove seasonal/summer.csv without changing directories again.\n\n\n6.2.6 grep\nHow can I select lines containing specific values?\nhead and tail select rows, cut selects columns, and grep selects lines according to what they contain. In its simplest form, grep takes a piece of text followed by one or more filenames and prints all of the lines in those files that contain that text. For example, grep bicuspid seasonal/winter.csv prints lines from winter.csv that contain “bicuspid”.\ngrep can search for patterns as well; we will explore those in the next course. What’s more important right now is some of grep’s more common flags:\n-c: print a count of matching lines rather than the lines themselves\n-h: do not print the names of files when searching multiple files\n-i: ignore case (e.g., treat \"Regression\" and \"regression\" as matches)\n-l: print the names of files that contain matches, not the matches\n-n: print line numbers for matching lines\n-v: invert the match, i.e., only show lines that don't match\nInstructions 1/3 35 XP\n1\n\nPrint the contents of all of the lines containing the word molar in seasonal/autumn.csv by running a single command while in your home directory. Don't use any flags.\n2\nInvert the match to find all of the lines that don’t contain the word molar in seasonal/spring.csv, and show their line numbers. Remember, it’s considered good style to put all of the flags before other values like filenames or the search term “molar”. 3\nCount how many lines contain the word incisor in autumn.csv and winter.csv combined. (Again, run a single command from your home directory.)\nKomanda grep (angl. global regular expression print, liet. “globalus reguliariųjų išraiškų paieškos spausdinimas”) naudojama tekstui paieškai pagal šabloną failuose arba išvestyje.\n\nIeškoti teksto failuose:\n\ngrep \"paieškos_tikslas\" failas.txt\nŠi komanda ieško “paieškos_tikslas” ir parodo atitinkančias eilutes iš failo failas.txt.\n\nIeškoti rekursyviai kataloge:\n\ngrep -r \"paieškos_tikslas\" /path/to/directory\nŠi komanda ieško “paieškos_tikslas” visame katalogo ir jo pakatalogių medyje.\n\n\n6.2.7 Intarpas: Standartinė įvestis, išvestis ir klaidos\nLinux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenų įvestį ir išvestį programose bei komandose. Šie srautai dažnai vadinami standartine įvestimi (standard input), standartine išvestimi (standard output) ir standartine klaida (standard error). Kiekvienas jų turi specifinį paskirtį ir failo aprašymo numerį.\n\n6.2.7.1 Standartinė įvestis (stdin)\n\nFailo aprašymo numeris: 0\nAprašymas: Standartinė įvestis, sutrumpinta kaip stdin, yra srautas, iš kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, stdin yra prijungta prie klaviatūros įvesties, tačiau gali būti nukreipta iš failo ar kito srauto.\nNaudojimas:\n\n# Nuskaito duomenis iš klaviatūros\ncat\nTaip pat gali būti nukreipiama iš failo:\ncat &lt; failas.txt\n\n\n6.2.7.2 Standartinė išvestis (stdout)\n\nFailo aprašymo numeris: 1\nAprašymas: Standartinė išvestis, sutrumpinta kaip stdout, yra srautas, į kurį komanda ar programa rašo išvestį. Pagal numatytuosius nustatymus, stdout yra prijungta prie terminalo ekrano.\nNaudojimas:\n\n# Spausdina į terminalą\necho \"Hello World\"\nTaip pat gali būti nukreipiama į failą:\necho \"Hello World!\" &gt; išvestis.txt\n\n\n6.2.7.3 Standartinė klaida (stderr)\n\nFailo aprašymo numeris: 2\nAprašymas: Standartinė klaida, sutrumpinta kaip stderr, yra srautas, į kurį komanda ar programa rašo klaidų pranešimus. Pagal numatytuosius nustatymus, stderr yra prijungta prie terminalo ekrano, bet gali būti nukreipta į failą ar kitą srautą.\nNaudojimas:\n\n# Nukreipia klaidų pranešimus į failą\nls non_existing_file 2&gt; klaida.log\n\n\n6.2.7.4 Praktika:\n\nPabandykite atspausdinti (nukipijuoti) su cat neegsistuojantį failą abracadabra.txt į failą, o klaidą nukreipti į failą error_logs.txt\nSu cat atspausdinkite error_logs.txt\nSu echo bei &gt; sukurkite failą abracadabra.txt pvz\n\necho \"Abracadabra is a magic word, historically used as an apotropaic incantation on amulets and common today in stage magic. It is of unknown origin.\" &gt; 'abracadabra.txt'\n\npakartokite 1 ir 2 žingsnius.\n\n\n\n\n6.2.8 cut command\nExercise Exercise How can I select columns from a file?\nhead and tail let you select rows from a text file. If you want to select columns, you can use the command cut. It has several options (use man cut to explore them), but the most common is something like:\ncut -f 2-5,8 -d , values.csv\nwhich means “select columns 2 through 5 and columns 8, using comma as the separator”. cut uses -f (meaning “fields”) to specify columns and -d (meaning “delimiter”) to specify the separator. You need to specify the latter because some files may use spaces, tabs, or colons to separate columns.\nWhat command will select the first column (containing dates) from the file spring.csv? Instructions 50 XP Possible answers cut -d , -f 1 seasonal/spring.csv cut -d, -f1 seasonal/spring.csv Either of the above. Neither of the above, because -f must come before -d.\nExercise Exercise What can’t cut do?\ncut is a simple-minded command. In particular, it doesn’t understand quoted strings. If, for example, your file is:\nName,Age “Johel,Ranjit”,28 “Sharma,Rupinder”,26\nthen:\ncut -f 2 -d , everyone.csv\nwill produce:\nAge Ranjit” Rupinder”\nrather than everyone’s age, because it will think the comma between last and first names is a column separator.\nWhat is the output of cut -d : -f 2-4 on the line:\nfirst:second:third:\n(Note the trailing colon.) Instructions 50 XP Possible answers second second:third second:third: None of the above, because there aren’t four fields.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos 2</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#wildcard",
    "href": "6b_linux_comands_basic.html#wildcard",
    "title": "6  Pagridinės BASH komandos 2",
    "section": "6.2 wildcard **",
    "text": "6.2 wildcard **\nHow can I specify many files at once?\nMost shell commands will work on multiple files if you give them multiple filenames. For example, you can get the first column from all of the seasonal data files at once like this:\ncut -d , -f 1 seasonal/winter.csv seasonal/spring.csv seasonal/summer.csv seasonal/autumn.csv\nBut typing the names of many files over and over is a bad idea: it wastes time, and sooner or later you will either leave a file out or repeat a file’s name. To make your life better, the shell allows you to use wildcards to specify a list of files with a single expression. The most common wildcard is *, which means “match zero or more characters”. Using it, we can shorten the cut command above to this:\ncut -d , -f 1 seasonal/*\nor:\ncut -d , -f 1 seasonal/*.csv\nInstructions 100 XP\nWrite a single command using head to get the first three lines from both seasonal/spring.csv and seasonal/summer.csv, a total of six lines of data, but not from the autumn or winter data files. Use a wildcard instead of spelling out the files’ names in full.\nWhat other wildcards can I use?\nThe shell has other wildcards as well, though they are less commonly used:\n? matches a single character, so 201?.txt will match 2017.txt or 2018.txt, but not 2017-01.txt.\n[...] matches any one of the characters inside the square brackets, so 201[78].txt matches 2017.txt or 2018.txt, but not 2016.txt.\n{...} matches any of the comma-separated patterns inside the curly brackets, so {*.txt, *.csv} matches any file whose name ends with .txt or .csv, but not files whose names end with .pdf.\nWhich expression would match singh.pdf and johel.txt but not sandhu.pdf or sandhu.txt?",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos 2</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#sorting-with-sort",
    "href": "6b_linux_comands_basic.html#sorting-with-sort",
    "title": "6  BASH komandos",
    "section": "6.3 sorting with sort",
    "text": "6.3 sorting with sort\nHow can I sort lines of text?\nAs its name suggests, sort puts data in order. By default it does this in ascending alphabetical order, but the flags -n and -r can be used to sort numerically and reverse the order of its output, while -b tells it to ignore leading blanks and -f tells it to fold case (i.e., be case-insensitive). Pipelines often use grep to get rid of unwanted records and then sort to put the remaining records in order. Instructions 100 XP\nRemember the combination of cut and grep to select all the tooth names from column 2 of seasonal/summer.csv?\ncut -d , -f 2 seasonal/summer.csv | grep -v Tooth\nStarting from this recipe, sort the names of the teeth in seasonal/winter.csv (not summer.csv) in descending alphabetical order. To do this, extend the pipeline with a sort step.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#remove-adjesent-duplicates",
    "href": "6b_linux_comands_basic.html#remove-adjesent-duplicates",
    "title": "6  BASH komandos",
    "section": "6.4 remove adjesent duplicates",
    "text": "6.4 remove adjesent duplicates\nHow can I remove duplicate lines?\nAnother command that is often used with sort is uniq, whose job is to remove duplicated lines. More specifically, it removes adjacent duplicated lines. If a file contains:\n2017-07-03 2017-07-03 2017-08-03 2017-08-03\nthen uniq will produce:\n2017-07-03 2017-08-03\nbut if it contains:\n2017-07-03 2017-08-03 2017-07-03 2017-08-03\nthen uniq will print all four lines. The reason is that uniq is built to work with very large files. In order to remove non-adjacent lines from a file, it would have to keep the whole file in memory (or at least, all the unique lines seen so far). By only removing adjacent duplicates, it only has to keep the most recent unique line in memory. Instructions 100 XP\nWrite a pipeline to:\nget the second column from seasonal/winter.csv,\nremove the word \"Tooth\" from the output so that only tooth names are displayed,\nsort the output so that all occurrences of a particular tooth name are adjacent; and\ndisplay each tooth name once along with a count of how often it occurs.\nThe start of your pipeline is the same as the previous exercise:\ncut -d , -f 2 seasonal/winter.csv | grep -v Tooth\nExtend it with a sort command, and use uniq -c to display unique lines with a count of how often each occurs rather than using uniq and wc.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#redirecting",
    "href": "6b_linux_comands_basic.html#redirecting",
    "title": "6  BASH komandos",
    "section": "6.5 redirecting",
    "text": "6.5 redirecting\nExercise How can I save the output of a pipe?\nThe shell lets us redirect the output of a sequence of piped commands:\ncut -d , -f 2 seasonal/*.csv | grep -v Tooth &gt; teeth-only.txt\nHowever, &gt; must appear at the end of the pipeline: if we try to use it in the middle, like this:\ncut -d , -f 2 seasonal/*.csv &gt; teeth-only.txt | grep -v Tooth\nthen all of the output from cut is written to teeth-only.txt, so there is nothing left for grep and it waits forever for some input.\nWhat happens if we put redirection at the front of a pipeline as in:\n\nresult.txt head -n 3 seasonal/winter.csv\n\nInstructions 50 XP Possible answers The command’s output is redirected to the file as usual. The shell reports it as an error. The shell waits for input forever.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#wrap-up-exercise",
    "href": "6b_linux_comands_basic.html#wrap-up-exercise",
    "title": "6  BASH komandos",
    "section": "6.6 wrap up exercise",
    "text": "6.6 wrap up exercise\nWrapping up\nTo wrap up, you will build a pipeline to find out how many records are in the shortest of the seasonal data files. Instructions 3/3 30 XP\nUse wc with appropriate parameters to list the number of lines in all of the seasonal data files. (Use a wildcard for the filenames instead of typing them all in by hand.)\nAdd another command to the previous one using a pipe to remove the line containing the word “total”. 3\nAdd two more stages to the pipeline that use sort -n and head -n 1 to find the file containing the fewest lines.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#sed",
    "href": "7_linux_comands_advanced.html#sed",
    "title": "7  BASH advanced",
    "section": "7.1 sed",
    "text": "7.1 sed",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#xed",
    "href": "7_linux_comands_advanced.html#xed",
    "title": "7  BASH advanced",
    "section": "7.2 xed",
    "text": "7.2 xed",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#find",
    "href": "7_linux_comands_advanced.html#find",
    "title": "7  BASH advanced",
    "section": "7.3 find",
    "text": "7.3 find",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#ps",
    "href": "7_linux_comands_advanced.html#ps",
    "title": "7  BASH advanced",
    "section": "7.4 ps",
    "text": "7.4 ps\n\n7.4.1 tldr",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#find-1",
    "href": "7_linux_comands_advanced.html#find-1",
    "title": "7  BASH advanced",
    "section": "7.3 find",
    "text": "7.3 find",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#wc",
    "href": "6b_linux_comands_basic.html#wc",
    "title": "6  Pagridinės BASH komandos 2",
    "section": "6.2 wc",
    "text": "6.2 wc\nKomanda wc (angl. word count) gali atspausdinti naujų eilučių , žodžių ir baitų (kiek atminties užima) skaičių faile.\n\n\n\n\n\n\n\nNustatymas\nReikšmė\n\n\n\n\n-c\nAtspausdina baitų skaičių (characters count)\n\n\n-m\nAtspausdina simbolių skaičių (characters count)\n\n\n-w\nAtspausdina žodžių skaičių (word count)\n\n\n-l\nAtspausdina eilučių skaičių (line count)\n\n\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nKiek žodžių ir kiek eilučių yra text/seneles_pasaka.txt?\nKiek eilučių yra data/temp_vilnius.txt ir kiek data/temp_kaunas.txt.\n\n\n\n\n6.2.1 touch\nKomanda touch naudojama norint sukurti tuščią failą arba pakeisti esamo failo datą ir laiką (modifikavimo ir prieigos laikus). Tai yra universali ir dažnai naudojama komanda, ypač kai reikia greitai sukurti failą arba atnaujinti failo metaduomenis.\nJei failas dar neegzistuoja, ši komanda jį sukurs. Jei failas jau yra, ji pakeis failo “paskutinio keitimo laiką” į dabartinį laiką, nekeičiant paties failo turinio.\nSukurk tuščią failą:\ntouch empty_1.txt\n\nTouch komandai gali paduoti daugiau argumentų - failų pavadinimų, atitinkamai bus sukurti visi failai.\ntouch empty_2.txt empty_3.txt empty_4.txt\n\nSuparantama vietoj failo pavadinimo, tu gali nurodyti absoliutų ar reliatyvų kelią į failą ir jeigu toks kelias egzistuoja, bus sukurtas atitinkamas faias. Jeigu toks kelias neegzistuoja, failas sukurtas nebus.\ntouch mix/empty_5.txt\ntouch tralala/empty_6.txt\n\ntouch ypatinga tuo, kad su ja galima atnaujinti ir arba pakeisti tiek priegos tiek modifikavimo laiką. Štai keli pvz.\nPakeisti tiek prieigos, tiek modifikavimo laikus į dabartinį laiką\ntouch empty_1.txt\nPakeisti tik prieigos laiką į dabartinį laiką\ntouch -a empty_1.txt\nPakeisti tik modifikavimo laiką į dabartinį laiką\ntouch -m empty_1.txt\nNustatyti tiek prieigos, tiek modifikavimo laikus į 2022 m. sausio 1 d., 12:00 PM\ntouch -t 202201011200 empty_1.txt\nNaudoti -d parinktį, kad būtų galima nustatyti laiką su daugiau lankstumo\ntouch -d \"2023-07-04 15:45\" empty_1.txt\nDabar tau ko gero kyla klausimas, o kam tai gali būti naudinga? iš tiesų, failo laikų keitimas yra kiek nišinis ir retai naudoajama funkcija. Bet štai keli pvz:\n\ntu nori išbandyti skriptą, kuris archyvuoja failus pagal jų priegos ar modifikcaimo laiką. Vietoj to, kad išbandyti tai ant tikrų failų, tu gali susigeneruoti tuščius failus su netikrais laikais ir išnaudoti šiuos failus testuojant, ar tavo skriptas veikia taip, kaip tu tikiesi.\natstatai failus iš ankstesnės atsarginės kopijos ir nori atkurti originalių failų laikus.\n\n\n\n6.2.2 mkdir\nKomanda mkdir (angl. make directory, liet. “kurti katalogą”) naudojama norint sukurti naujus katalogus. Tai yra pagrindinė komanda, kai reikia sukurti naujus katalogus failų sistemoje.\n\nSukurti naują katalogą:\n\nmdkir projektas0\n\n\nSukurti keletą naujų katalogų vienu metu\n\nmkdir projektas1 projektas2 projektas3\n\n\nSukurti katalogų medį (hierarchiją), jei tarpiniai katalogai neegzistuoja:\n\nmkdir -p projektas0/duomenys\n\nNemo failų naršyklėje taip pat matomas rezultatas\n\nExercise Exercise How can I create and delete directories?\nmv treats directories the same way it treats files: if you are in your home directory and run mv seasonal by-season, for example, mv changes the name of the seasonal directory to by-season. However, rm works differently.\nIf you try to rm a directory, the shell prints an error message telling you it can’t do that, primarily to stop you from accidentally deleting an entire directory full of work. Instead, you can use a separate command called rmdir. For added safety, it only works when the directory is empty, so you must delete the files in a directory before you delete the directory. (Experienced users can use the -r option to rm to get the same effect; we will discuss command options in the next chapter.) Instructions 1/4 25 XP\n1\n\nWithout changing directories, delete the file agarwal.txt in the people directory.\n2\nNow that the people directory is empty, use a single command to delete it. 3\nSince a directory is not a file, you must use the command mkdir directory_name to create a new (empty) directory. Use this command to create a new directory called yearly below your home directory. 4\nNow that yearly exists, create another directory called 2017 inside it without leaving your home directory.\nExercise Exercise Wrapping up\nYou will often create intermediate files when analyzing data. Rather than storing them in your home directory, you can put them in /tmp, which is where people and programs often keep files they only need briefly. (Note that /tmp is immediately below the root directory /, not below your home directory.) This wrap-up exercise will show you how to do that. Instructions 1/4 25 XP\n1\n\nUse cd to go into /tmp.\n2\nList the contents of /tmp without typing a directory name. 3\nMake a new directory inside /tmp called scratch. 4\nMove /home/repl/people/agarwal.txt into /tmp/scratch. We suggest you use the ~ shortcut for your home directory and a relative path for the second rather than the absolute path.\n\n\n6.2.3 cp\nPripažink, kopijuoti failą cat failas.txt &gt; kopija.txt neskamba intuityviai. Be to, kyla klausimas, o ką daryti, jeigu nori nukopijuoti ne tik failą, bet ir visą direktoriją?\nKomanda cp (angl. copy) naudojama kopijuoti failus ir direktorijas.\nPaprasčiausiu atveju, kai nori padaryti kopiją, komandai cp nurodai originalaus failo pavadinimą ir kokiu pavadinimu turėtų būti sukurta kopija. Pvz.:\ncp song_text.txt song_text_copy.txt\nJeigu failas song_text_copy.txt jau egzistuotų, tada jis būtų perrašytas, taigi cp veikia beveik kaip &gt;.\nKaip ir su &gt;bei &gt;&gt;, tu gali nurodyti, kur turėtų būti patalpinta kopija, naudojant tiek reliatyvius, tiek absoliučius adresus (path). Tokiu atveju galima vietoj failo pavadinimo nudoryti failo adresą.\ncp ~/song_text.txt ~/Downdloads/song_text_copy.txt\nJeigu cp antrasis argumentas bus ne failo, o egzistuojančios direktorijos pavadinimas, tada cp sukurs kopiją tokiu pačiu pavadinimu, kaip originalas, ir patalpins kopiją į nurodytą direktoriją.\ncp ~/song_text.txt ~/Downdloads\ncp kopijuoja ir direktorijas, tačiau tam, kad direktorija būtų nukopijuota rekursyviai (su visu esančiu turiniu), cp reikia naudoti nustatymą -r (recursive).\ncp -r šaltinis_katalogas tikslas_katalogas\n\n\n\n\n\n\nPraktika\n\n\n\n\nPadaryk vilnius_temp.txt kopiją pavadinimu vilnius_temp_copy.txt.\nPadaryk vilnius_temp.txt kopiją pavadinimu vilnius_temp_copy.txt, bet kaip argumentą nurodyk direktoriją ir failo pavadinimą. Patalpink kopiją į Downloads.\nPadaryk vilnius_temp.txt kopiją su originaliu pavadinimu, kaip antrą argumentą cp paduodant tik Downloads direktoriją.\nBūnant namų direktorijoje (~), su ls atspausdink Downloads turinį long formatu. Ar tikrai abu failai ten?\nTavo namų direktorijoje vis dar turėtų būti “test” direktorija. Padaryk jos kopiją į Documents direktoriją nepakeičiant pavadinimo. Tada vis dar būnant namų direktorijoje (~), su ls atspausdink Documents/test esnčias subdirektiras ir visus jose esančius failus.\n\n\n\n\n\n6.2.4 mv\nKomanda mv (angl. move) naudojama perkelti arba pervadinti failus ir direktorijas. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\nmv komanda gali pervadinti failą vilnius_temp.txt į kaunas_temp.txt.\nmv vilnius_temp.txt kaunas_temp.txt\nSu mv galima ir perkelti failus iš vienos direktorijos į kitą. Ši komanda perkelia failą kaunas_temp.txt į ~/Downloads.\nmv kaunas_temp.txt ~/Downloads\nmv komandai galima paduoti daugiau nei du argumentus. Ši komanda perkelia failus vilnius_temp.txt ir kaunas_temp.txt į direktoriją ~/Downloads. galima perkelti kelis failus ir net kelias direktorijas vienu metu, svarbiausia, kad paskutinis argumentas tokiu atveju būtų irgi direktorija.\nmv vilnius_temp.txt kaunas_temp.txt ~/Downloads\nPerkelti katalogą ir jo turinį į kitą vietą: Ši komanda perkelia katalogą katalogas ir visą jo turinį į katalogą /naujas/kelias/.\nmv test ~/Downloads\nPerspėjimas, kaip ir &gt; bei cp, jeigu tikslininas failas jau egzistuoja, jis bus perrašytas.\n\n\n\n\n\n\nPraktika\n\n\n\nKas nutiktų įvykdžius šią komandą?\nmv vilnius_temp.txt kaunas_temp.txt ~/Documents ~/Downloads\n\n\n\n\n6.2.5 rm\nKomanda rm (angl. remove, liet. “pašalinti”) naudojama pašalinti failus ir katalogus. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar katalogai nėra perkeliami į šiukšlinę ir jų atkurti nebebus galima.\n\nPašalinti failą:\n\nrm failas.txt\n\nPašalinti kelis failus:\n\nrm failas1.txt failas2.txt failas3.txt\n\nPašalinti tuščią katalogą:\n\nrm -d tuščias_katalogas\n\nPašalinti katalogą ir jo turinį rekursyviai:\n\nrm -r katalogas\n\nPriverstinai pašalinti failą ar katalogą:\n\nrm -rf katalogas\nExercise Exercise How can I delete files?\nWe can copy files and move them around; to delete them, we use rm, which stands for “remove”. As with cp and mv, you can give rm the names of as many files as you’d like, so:\nrm thesis.txt backup/thesis-2017-08.txt\nremoves both thesis.txt and backup/thesis-2017-08.txt\nrm does exactly what its name says, and it does it right away: unlike graphical file browsers, the shell doesn’t have a trash can, so when you type the command above, your thesis is gone for good. Instructions 1/4 25 XP\n1\n\nYou are in /home/repl. Go into the seasonal directory.\n2\nRemove autumn.csv. 3\nGo back to your home directory. 4\nRemove seasonal/summer.csv without changing directories again.\n\n\n6.2.6 grep\nHow can I select lines containing specific values?\nhead and tail select rows, cut selects columns, and grep selects lines according to what they contain. In its simplest form, grep takes a piece of text followed by one or more filenames and prints all of the lines in those files that contain that text. For example, grep bicuspid seasonal/winter.csv prints lines from winter.csv that contain “bicuspid”.\ngrep can search for patterns as well; we will explore those in the next course. What’s more important right now is some of grep’s more common flags:\n-c: print a count of matching lines rather than the lines themselves\n-h: do not print the names of files when searching multiple files\n-i: ignore case (e.g., treat \"Regression\" and \"regression\" as matches)\n-l: print the names of files that contain matches, not the matches\n-n: print line numbers for matching lines\n-v: invert the match, i.e., only show lines that don't match\nInstructions 1/3 35 XP\n1\n\nPrint the contents of all of the lines containing the word molar in seasonal/autumn.csv by running a single command while in your home directory. Don't use any flags.\n2\nInvert the match to find all of the lines that don’t contain the word molar in seasonal/spring.csv, and show their line numbers. Remember, it’s considered good style to put all of the flags before other values like filenames or the search term “molar”. 3\nCount how many lines contain the word incisor in autumn.csv and winter.csv combined. (Again, run a single command from your home directory.)\nKomanda grep (angl. global regular expression print, liet. “globalus reguliariųjų išraiškų paieškos spausdinimas”) naudojama tekstui paieškai pagal šabloną failuose arba išvestyje.\n\nIeškoti teksto failuose:\n\ngrep \"paieškos_tikslas\" failas.txt\nŠi komanda ieško “paieškos_tikslas” ir parodo atitinkančias eilutes iš failo failas.txt.\n\nIeškoti rekursyviai kataloge:\n\ngrep -r \"paieškos_tikslas\" /path/to/directory\nŠi komanda ieško “paieškos_tikslas” visame katalogo ir jo pakatalogių medyje.\n\n\n6.2.7 Intarpas: Standartinė įvestis, išvestis ir klaidos\nLinux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenų įvestį ir išvestį programose bei komandose. Šie srautai dažnai vadinami standartine įvestimi (standard input), standartine išvestimi (standard output) ir standartine klaida (standard error). Kiekvienas jų turi specifinį paskirtį ir failo aprašymo numerį.\n\n6.2.7.1 Standartinė įvestis (stdin)\n\nFailo aprašymo numeris: 0\nAprašymas: Standartinė įvestis, sutrumpinta kaip stdin, yra srautas, iš kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, stdin yra prijungta prie klaviatūros įvesties, tačiau gali būti nukreipta iš failo ar kito srauto.\nNaudojimas:\n\n# Nuskaito duomenis iš klaviatūros\ncat\nTaip pat gali būti nukreipiama iš failo:\ncat &lt; failas.txt\n\n\n6.2.7.2 Standartinė išvestis (stdout)\n\nFailo aprašymo numeris: 1\nAprašymas: Standartinė išvestis, sutrumpinta kaip stdout, yra srautas, į kurį komanda ar programa rašo išvestį. Pagal numatytuosius nustatymus, stdout yra prijungta prie terminalo ekrano.\nNaudojimas:\n\n# Spausdina į terminalą\necho \"Hello World\"\nTaip pat gali būti nukreipiama į failą:\necho \"Hello World!\" &gt; išvestis.txt\n\n\n6.2.7.3 Standartinė klaida (stderr)\n\nFailo aprašymo numeris: 2\nAprašymas: Standartinė klaida, sutrumpinta kaip stderr, yra srautas, į kurį komanda ar programa rašo klaidų pranešimus. Pagal numatytuosius nustatymus, stderr yra prijungta prie terminalo ekrano, bet gali būti nukreipta į failą ar kitą srautą.\nNaudojimas:\n\n# Nukreipia klaidų pranešimus į failą\nls non_existing_file 2&gt; klaida.log\n\n\n6.2.7.4 Praktika:\n\nPabandykite atspausdinti (nukipijuoti) su cat neegsistuojantį failą abracadabra.txt į failą, o klaidą nukreipti į failą error_logs.txt\nSu cat atspausdinkite error_logs.txt\nSu echo bei &gt; sukurkite failą abracadabra.txt pvz\n\necho \"Abracadabra is a magic word, historically used as an apotropaic incantation on amulets and common today in stage magic. It is of unknown origin.\" &gt; 'abracadabra.txt'\n\npakartokite 1 ir 2 žingsnius.\n\n\n\n\n6.2.8 cut command\nExercise Exercise How can I select columns from a file?\nhead and tail let you select rows from a text file. If you want to select columns, you can use the command cut. It has several options (use man cut to explore them), but the most common is something like:\ncut -f 2-5,8 -d , values.csv\nwhich means “select columns 2 through 5 and columns 8, using comma as the separator”. cut uses -f (meaning “fields”) to specify columns and -d (meaning “delimiter”) to specify the separator. You need to specify the latter because some files may use spaces, tabs, or colons to separate columns.\nWhat command will select the first column (containing dates) from the file spring.csv? Instructions 50 XP Possible answers cut -d , -f 1 seasonal/spring.csv cut -d, -f1 seasonal/spring.csv Either of the above. Neither of the above, because -f must come before -d.\nExercise Exercise What can’t cut do?\ncut is a simple-minded command. In particular, it doesn’t understand quoted strings. If, for example, your file is:\nName,Age “Johel,Ranjit”,28 “Sharma,Rupinder”,26\nthen:\ncut -f 2 -d , everyone.csv\nwill produce:\nAge Ranjit” Rupinder”\nrather than everyone’s age, because it will think the comma between last and first names is a column separator.\nWhat is the output of cut -d : -f 2-4 on the line:\nfirst:second:third:\n(Note the trailing colon.) Instructions 50 XP Possible answers second second:third second:third: None of the above, because there aren’t four fields.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos 2</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#intarpas",
    "href": "6b_linux_comands_basic.html#intarpas",
    "title": "6  Pagridinės BASH komandos 2",
    "section": "6.2 Intarpas",
    "text": "6.2 Intarpas\nHey, ką tik tu gavai užduotį. Panašias ir daug komplikuotesnes uždutis gausi ir ateityje. Todėl šioje vietoje padarykime intarpą. Pakalbėkime apie vieną svarbiausių darbo būdų programavime - darbų skaidymą (angl. break down).\nKažkada tu gali gauti labai komplikuotą užduotį ir ji atrodys neveikiama, nesuprantama. Tai normalu. Nestresuok, giliai įkvėpk, iškvpek, jeigu reikia, pasiimk popierių ir pieštuką ir pradėk dalintis darbus į logines darbų sekos dalis. pvz prieš tai buvusią užduotį glaima suskaidyti į 2 didelias dalis:\n\ndabar galima skaidyti arba išdirbti kiekvieną iš dalių\n\n&gt;&gt; operatorius nukreipia komandos išvestį į failą, pridedant (angl. append) prie failo turinio. Jei failas neegzistuoja, jis bus sukurtas.\necho \"What a beatiful morning\" &gt;&gt; day.txt\necho \"What a beatiful day\" &gt;&gt; day.txt\necho \"What a beatiful evening\" &gt;&gt; day.txt\nŠios komandos prideda tekstą “What a beautiful morning”, “What a beautiful day” ir “What a beautiful evening” prie failo day.txt galo, neperrašydamos esamo turinio. Jeigu tokio failo nėra, jis bus sukurtas.\n\n\n\n\n\n\nPraktika\n\n\n\n\nSusirask tau patinkančios dainos tekstą internete.\nNaudojant komandą echo ir operatorių &gt;, sukurk failą favorite_song.txt. Failo turinys turėtų būti kažkas panašaus į “My favorite song is ”. Pirmas 4 eilutes dainos teksto atspausdink į failą song_text.txt naudojant echo ir &gt;&gt;. Nepamiršk, kokie klaviatūros trumpiniai naudojami kopijuojant ir įkeliant tekstą į terminalą!\n\n\n\n\n6.2.1 cat\nKomanda cat(angl. concatenate, liet. “sujungti”) naudojama norint peržiūrėti, sujungti ir atspausdinti failus. Tai viena iš dažniausiai naudojamų komandų, nes ji leidžia greitai peržiūrėti failų turinį, įvesti turinį į kitus failus arba sujungti kelis failus į vieną.\nPraeitame skyriuje sukūrei du failus favorite_song.txt ir song_text.txt. Dabar juos ir naudosime.\nAtspausdink failo favorite_song.txt turinį į terminalą:\ncat favorite_song.txt\ncat leidžia ir sujungti kelių failų turinį ir atspausdinti rezultatą terminale:\ncat favorite_song.txt song_text.txt\nPraeitame skyriuje išmokai, kad komandos išvestį, ar tai būtų echo, ar ls, galima nukreipti į failą. Lygiai taip pat, tu gali nukopijuoti failą naudojant cat ir &gt; arba &gt;&gt;:\ncat favorite_song.txt &gt; megstamiausia_daina.txt\n\n\n\n\n\n\nPraktika\n\n\n\n\nNaudojant echo ir &gt;&gt;, įrašyk dar 4 eilutes mėgstamiausios dainos teksto į failą song_text_2.txt.\nSujunk abu failus song_text.txt ir song_text_2.txt, nukreipiant rezultatą į song_text_full.txt.\nPagalvok, kaip naudojant visas iki šiol žinomas komandas, galima būtų gauti song_text.txt failą, kuriame būtų pirmas ketvertas eilučių teksto ir antras ketvertas eilučių teksto?\n\n\n\n\n\n6.2.2 head ir tail\nKomandos head (galva) ir tail (uodega) yra naudojamos peržiūrėti pirmąsias arba paskutines failo eilutes. Įprastai jos atspausdina 10 eilučių teksto.\n\n\n\n\n\n\nNote\n\n\n\nDabar tavo failas song_text.txt turėtų turėti 8 eilutes teksto. Todėl tokiu pat būdu, kaip prieš tai, pridėk dar 4 eilutes teksto.\n\n\nPeržirėk pirmas 10 eilučių song_text.txt su head\nhead song_text.txt\nPeržiūrėk paskutines 10 failo eilučių:\ntail song_text.txt\nTiek head, tiek tail priima nustatymą (option) -n su argumentu, skaičiumi kiek eilučių atspausdinti.\n\nperžiūrėti pirmąsias 3 eilutes gali su komanda head -n 3 song_text.txt\nperžiūrėti paskutines 5 eilutes su tail -n 5 song_text.txt.\n\n\n\n\n\n\n\nPraktika\n\n\n\nKas nutiktų, jeigu panaudotum head arba tail su failu, kuriame nėra 10 eilučių? Pabandyk su favorite_song.txt\n\n\nNukopijuok šią komandą į savo terminalą. Ji parsiųs sekančių keletos dienų kasvalandinę orų prognozę Vilniuje ir išsaugos kaip vilnius_temp.txt failą.\ncurl -s https://api.meteo.lt/v1/places/vilnius/forecasts/long-term | jq -r \".forecastTimestamps[] | \\\"\\(.forecastTimeUtc)\\t\\(.airTemperature)\\\" \" &gt; ~/vilnius_temp.txt\nTikėtina, jog jq programa nėra instaliuota tavo kompiuteryje. Tuomet tu turėtum matyti kažką panašaus į tai:\n\nGera žinia yra ta, kad shell tau neratai nurodo, ką reikia daryti. Peržirėk shell atsakyma atidžiai ir instaliuok trūkstamą paketą ir pakartok komandą. Tada su ls įsitikink, ar failas yra tavo namų direktorijoje.\n\n\n\n\n\n\nPraktika\n\n\n\n\nNaudojant cat, atspausdink failą terminale.\nTikėtina, kad pirmosios dienos prognozių skaičius nebus lygus 24, o bus likę mažiau. Tarkime, 6 valandos. tad naudojant head, atspausdink tik “šiandienos” orų prognozę.\nDeja, šiandienos oras jau aiškus, tavo draugei Amelijai reikia rytojaus orų prognozės, todėl derinant head ir tail, išpjaustyk eilutes taip, kad galėtum nusiųsti Amelijai tik rytojaus visų valandų temperatūros prognozes. Failas, kurį turi sugeneruoti, turėtų turėti pavadinimą: amelija_vilnius_temp.txt.\n\n\n\n\n\n6.2.3 less\nPraėjusiame skyriuje jau turėjai atvejį, kai viso failo vilnius_temp.txt turinys netilpo į terminalo langą. Tikėtina, reikėjo pakeisti terminalo lango dydį arba scrollinti su pele. Dabar tau ko gero kyla klausimas, kaip galima matyti failo turinį gabaliukas po gabaliuko?\nGalima naudoti cat dideliems failams spausdinti ir tada scrollinti išvestį, bet paprastai patogiau yra rodyti failą puslapiais. Pirminė komanda šiam tikslui buvo vadinama more, bet ją pakeitė galingesnė komanda, vadinama less.\nNaudojant less failas, vienu metu rodomas vienas puslapis; galima spausti space klavišą, norint pereiti į kitą puslapį (taip pat :arrow_up: :arrow_down:) . norint išeiti - q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk vilnius_temp.txt su less, išbandyk judėjimą tekste žemyn, aukštyn ir uždaryk su q.\n\n\nJei less komandai nurodomi keli failai, gali naudoti :n (next), kad pereitum į kitą failą, :p (previous), kad grįžtum į ankstesnį, arba q, kad išeitum.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk favorite_song.txt ir vilnius_temp.txt su less, išbandyk judėjimą tekste žemyn, aukštyn, pereik tarp failų su :n ir :p bei pabaigus uždaryk less su q.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pagridinės BASH komandos 2</span>"
    ]
  },
  {
    "objectID": "6b_linux_comands_basic.html#failų-ir-direktorijų-valdymas",
    "href": "6b_linux_comands_basic.html#failų-ir-direktorijų-valdymas",
    "title": "6  BASH komandos",
    "section": "",
    "text": "By J. Howard Miller - U.S. National Archives and Records Administration\n\n\n\n\nPatikrink, ar turi curl, su which curl.\nPatikrink, ar turi jq, su which jq.\n\n\n\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/b4bfc0d672a859afc0fe28f1e721e167/raw | bash\n\n\n\n\n\n\n\n\nTip\n\n\n\nPasikartok komandas cd, prisimink absoliutų ir reliatyvų kelią, bei ką reiškia ~, . ir ... Šiame skyriuje taip pat dažnai reikės naudoti ls, tad pasikartok šią komandą ir jos nustatymus dabar.\n\n\n\n\n\n\n\n6.1.1 echo\nKomanda echo naudojama norint atspausdinti vartotojo įvestį (input) terminale (dar vadinamą standartine išvestimi, angl. standard output). Tai paprasta, bet galinga komanda, dažnai naudojama skriptuose pranešimams rodyti arba kintamųjų reikšmėms tikrinti.\nNors nėra būtina tekstą apskliausti kabutėmis, dėl geresnio aiškumo ir įskaitomumo patartina tai daryti.\necho Hello World!\necho 'Hello World!'\necho \"Hello World!\"\nReikėtų atkreipti dėmesį, jog dvigubos kabutės (\" \") ir viengubos kabutės (' '’) šiek tiek skiriasi. Tekstas, esantis viengubose kabutėse (' '), atspausdinamas paraidžiui, nepaisant ten esančių kintamųjų. Tuo tarpu tekstas, esantis dvigubose kabutėse (\" \"), yra interpretuojamas, ir Shell leidžia naudoti kintamųjų vertes.\nPabandyk šias komandas, kurios naudoja kintamąjį $USER, atspausdinantį shell sesijos vartotojo vardą:\necho My username is $USER\necho 'My username is $USER'\necho \"My username is $USER\"\nAr pastebi, kuo skiriasi išvestis?\n\n\n\n6.1.2 &gt; ir &gt;&gt; operatoriai\n&gt; ir &gt;&gt; operatoriai naudojami išvesties nukreipimui (angl. output redirection). Jie nukreipia komandos išvestį (angl. output) į failą, o ne į terminalą. Šie operatoriai yra esminiai dirbant su failais ir automatizuojant užduotis skriptuose.\n&gt; operatorius nukreipia komandos išvestį į failą, perrašydamas jo turinį, jei failas jau egzistuoja. Jei failas neegzistuoja, jis bus sukurtas.\nŠi komanda sukuria (arba perrašo) failą hello_world.txt su tekstu “Hello World!”.\necho \"Hello World!\" &gt; hello_world.txt\nKaip echo komanda ir jos argumentas “Hello World!” buvo nukreipti į tekstinį failą, taip galime nukreipti ir kitų komandų išvestis į failus. Operatoriaus &gt; argumentas nebūtinai turi būti tik failo pavadinimas, tai gali būti ir failo pavadinimas su absoliučiu ar reliatyviu adresu.\nls &gt; mix/direktorijos_turinys.txt\nŠi komanda nukreipia ls komandos išvestį į failą direktorijos_turinys.txt, kuris yra mix subdirektorijoje. Atsidaryk šį failą ir patikrink, ar jis susikūrė teisingai. Turėtum matyti kažką panašaus į šį vaizdą:\n\n\n\n\n\n\n\nPraktika\n\n\n\nLiekant shell_part_2 direktorijoje, atspausdink namų direktorijos (angl. home directory) turinį su visais paslėptais failais, ilguoju formatu ir žmonėms geriau suprantamais failų ir direktorijų dydžiais, ir nukreipk išvestį į mix subdirektorijoje esantį failą direktorijos_turinys.txt, jį perrašant.\n\n\n\nIntarpas\nHey, ką tik gavai užduotį. Ateityje gausi panašias ir dar sudėtingesnes užduotis. Todėl šioje vietoje padarykime intarpą. Pakalbėkime apie vieną svarbiausių darbo būdų programavime (ir ne tik!) – darbų skaidymą (angl. break down).\nKartais gali gauti labai sudėtingą užduotį, kuri iš pradžių atrodys neįveikiama ar nesuprantama. Tai visiškai normalu. Nestresuok – giliai įkvėpk, iškvėpk, jei reikia, pasiimk popierių ir pieštuką ir pradėk skaidyti darbus į logines sekas. Pvz., prieš tai buvusią užduotį galima suskaidyti į tris dalis:\n\nreikia failų ir direktorijų sąrašo\natspausdinti perrašant\nfailo pavdinimas\n\n\nDabar galima skaidyti ar toliau detalizuoti kiekvieną iš šių dalių.\n\nls -alh pagamina sąrašą ilguoju, žmonėms suprantamų dydžių formatu\n&gt; perrašo\ndirektorijos_turinys.txt bus pavadinimas\n\n\nTačiau dabartinė darbinė direktorija yra ~/shell_part_2, todėl reikia\n\nls -alh kaip argumentą paduoti ~ arba atitinmai /home/username\ndirektorijos_turinys.txt turi būti mix subdirektorijoje\n\n\nSkaidant užduotį į mažesnes dalis, vis labiau suprasi, ką reikia padaryti. Turint daugiau patirties, geriau žinosi, kiek laiko gali prireikti kiekvienam žingsniui.\nPvz., duomenų analitikas gali gauti užduotį: suprognozuoti sekančių metų ledų pardavimus. Analitikas, žinodamas, kad ledų pardavimai priklauso nuo lauko temperatūros, gali suskaidyti darbus taip:\n\nImportuoti istorinius tam tikros vietos temperatūros duomenis\nPrognozuoti sekančių metų kiekvienos dienos temperatūras\nApskaičiuoti kiekvienos dienos pardavimus\nAprašyti duomenis ir pateikti juos užsakovui suprantamu formatu\n\n\n\n\nPhoto by Kamaji Ogino\n\n\nKiekvieną iš šių žingsnių analitikas gali suskaidyti į dar daugiau mažesnių užduočių.\nKodėl tai svarbu? Visų pirma, tai padeda geriau suprasti, ką reikia padaryti, ir kiek tai gali užtrukti. Kiekvienas žingsnis tampa atskiru procesu, ir jei nepavyksta vienas metodas, gali bandyti kitą.\nDarbų skaidymas yra intuityvus procesas kasdieniame darbe ir tu jau šį metodą ir taip taikai pasąmoningai, bet kai gauname naujas ir labai sudėtingas užduotis, vis tiek verta prisiminti šią strategiją, nes kartais mes pamirštame, kaip ji padeda išvengti pasimetimo.\n\n&gt;&gt; operatorius nukreipia komandos išvestį į failą, pridedant (angl. append) prie failo turinio. Jei failas neegzistuoja, jis bus sukurtas.\necho \"What a beatiful morning\" &gt;&gt; day.txt\necho \"What a beatiful day\" &gt;&gt; day.txt\necho \"What a beatiful evening\" &gt;&gt; day.txt\nŠios komandos prideda tekstą “What a beautiful morning”, “What a beautiful day” ir “What a beautiful evening” prie failo day.txt galo, neperrašydamos esamo turinio. Jei tokio failo nėra, jis bus sukurtas.\n\n\n\n\n\n\nPraktika\n\n\n\n\nSusirask tau patinkančios dainos tekstą internete.\nNaudojant komandą echo ir operatorių &gt;, sukurk failą favorite_song.txt. Failo turinys turėtų būti panašus į “My favorite song is ”.\nPirmas keturias dainos eilutes atspausdink į failą song_text.txt naudojant echo ir &gt;&gt;. Nepamiršk, kokie klaviatūros trumpiniai naudojami kopijuojant ir įkeliant tekstą į terminalą!\n\n\n\n\n\n6.1.3 cat\nKomanda cat (angl. concatenate, liet. „sujungti“) naudojama peržiūrėti, sujungti ir atspausdinti failus. Tai viena iš pagrindinių Linux komandų, nes leidžia greitai peržiūrėti failų turinį, įvesti turinį į kitus failus arba sujungti kelis failus į vieną.\nPraeitame skyriuje sukūrei du failus favorite_song.txt ir song_text.txt. Dabar juos ir naudosime.\nAtspausdink failo favorite_song.txt turinį į terminalą:\ncat favorite_song.txt\nPas mane tai atrodo taip:\n\ncat leidžia sujungti kelių failų turinį ir atspausdinti rezultatą terminale:\ncat favorite_song.txt song_text.txt\n\nKaip praeitame skyriuje išmokai, komandos išvestį (nesvarbu, ar tai būtų echo, ar ls) galima nukreipti į failą. Lygiai taip pat gali nukopijuoti failą naudojant cat ir &gt; arba &gt;&gt;:\ncat favorite_song.txt &gt; favorite_song_2.txt\nŠi komanda nukopijuoja failo favorite_song.txt turinį į naują failą favorite_song_2.txt, perrašydama jo turinį, jei toks failas jau egzistuoja.\n\n\n\n\n\n\nPraktika\n\n\n\n\nNaudojant echo ir &gt;&gt;, įrašyk dar 4 eilutes mėgstamiausios dainos teksto į failą song_text_2.txt.\nSujunk failus song_text.txt ir song_text_2.txt, nukreipiant rezultatą į song_text_full.txt:\nPagalvok, kaip naudojant visas iki šiol žinomas komandas, būtų galima gauti song_text.txt failą, kuriame būtų pirmas ketvertas eilučių ir antras ketvertas eilučių teksto?\n\n\n\n\n\n6.1.4 head ir tail\nKomandos head (galva) ir tail (uodega) naudojamos peržiūrėti pirmąsias arba paskutines failo eilutes. Įprastai jos atspausdina 10 eilučių teksto.\n\n\n\n\n\n\nNote\n\n\n\nDabar tavo failas song_text.txt turėtų turėti 8 eilutes teksto. Todėl tokiu pat būdu, kaip prieš tai, pridėk dar 4 eilutes teksto, kad turėtum bent 12.\n\n\nPeržiūrėk pirmas 10 eilučių song_text.txt su head:\nhead song_text.txt\nPeržiūrėk paskutines 10 failo eilučių:\ntail song_text.txt\nTiek head, tiek tail priima nustatymą (option) -n su argumentu, nurodančiu, kiek eilučių atspausdinti:\n\nNorint peržiūrėti pirmas 3 eilutes, naudok komandą: head -n 3 song_text.txt\nNorint peržiūrėti paskutines 5 eilutes, naudok komandą: tail -n 5 song_text.txt.\n\n\n\n\n\n\n\nPraktika\n\n\n\nKas nutiktų, jei panaudotum head arba tail su failu, kuriame nėra 10 eilučių? Pabandyk su favorite_song.txt\n\n\n\n\n\n\n\n\nPraktika\n\n\n\nDabar dirbsi su failu data/temp_vilnius.txt.\n\nNaudojant cat, atspausdink visą failą terminale\nPirmosios dienos prognozės gali turėti mažiau nei 24 valandas (pvz., likusios 6 valandos). Naudojant head, atspausdink tik šiandienos orų prognozes\nKadangi šiandienos oras jau aiškus, tavo draugei Amelijai reikia rytojaus orų prognozės. Derinant head ir tail, išfiltruok eilutes taip ir sukurk tarpinius failus, kad būtų nusiųstos tik rytojaus 24 valandų temperatūros prognozės. Rezultatą išsaugok į failą amelija_vilnius_temp.txt subdirektorijoje data. Naudojant cat įsitikink, jog turi tik rytojaus temperatūras.\n\n\n\n\n\n6.1.5 less\nPraėjusiame skyriuje jau turėjai atvejį, kai viso failo vilnius_temp.txt turinys netilpo į terminalo langą. Tikėtina, reikėjo pakeisti terminalo lango dydį arba slinkti su pele. Dabar tau galbūt kyla klausimas, kaip būtų galima matyti failo turinį gabaliukais?\nNors gali naudoti cat dideliems failams atspausdinti ir tada slinkti išvestį, paprastai patogiau failą rodyti puslapiais. Tam pirminė komanda buvo more, bet ją pakeitė galingesnė komanda less.\nNaudojant less &lt;failas&gt;, vienu metu matysi tik vieną failo puslapį. Spaudžiant ␣ (space) klavišą, pereisi į kitą puslapį; gali taip pat naudoti ↓ ir ↑ klavišus, kad judėtum po vieną eilutę žemyn arba aukštyn. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk data/vilnius_temp.txt su less, išbandyk judėjimą tekste žemyn, aukštyn ir uždaryk programą su q.\n\n\nJei less komandai nurodysi kelis failus, gali naudoti :n (next) pereiti prie kito failo, o :p (previous) sugrįžti prie ankstesnio failo. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk failus favorite_song.txt, data/vilnius_temp.txt ir text/seneles_pasaka.txt su less. Išbandyk judėjimą tekste žemyn, aukštyn, pereik tarp failų naudojant :n ir :p bei pabaigoje uždaryk less su q\n\n\n\n\n6.1.6 wc\nKomanda wc (angl. word count) naudojama atspausdinti naujų eilučių, žodžių ir baitų skaičių faile.\n\n\n\n\n\n\n\nNustatymas\nReikšmė\n\n\n\n\n-c\nAtspausdina baitų skaičių (angl. byte count), kiek vietos užima failas\n\n\n-m\nAtspausdina simbolių skaičių (angl. character count)\n\n\n-w\nAtspausdina žodžių skaičių (angl. word count)\n\n\n-l\nAtspausdina eilučių skaičių (angl. line count)\n\n\n\nPastaba: -c ir -m gali atspausdinti skirtingus rezultatus priklausomai nuo failo koduotės, nes simbolis gali užimti daugiau nei vieną baitą (pvz., specialūs lietuviški simboliai).\n\n\n\n\n\n\nPraktika\n\n\n\n\nKiek žodžių ir kiek eilučių yra text/seneles_pasaka.txt?\nKiek eilučių yra data/temp_vilnius.txt ir kiek data/temp_kaunas.txt?\n\n\n\n\n\n6.1.7 touch\nKomanda touch naudojama kuriant tuščią failą arba keičiant esamo failo metaduomenis, pvz., modifikavimo ar prieigos laiką. Ji yra universali ir ypač naudinga tais atvejais, kai reikia greitai sukurti failą arba atnaujinti failo laikus be jo turinio keitimo.\nJei failas neegzistuoja, touch jį sukurs. Jei failas jau yra, komanda tiesiog pakeis failo “paskutinio keitimo laiką” (modification time) į dabartinį laiką, nesikeičiant turinio.\nSukurk tuščią failą:\ntouch empty_1.txt\n\nJei nurodysi kelis failų pavadinimus, touch sukurs visus iš karto:\ntouch empty_2.txt empty_3.txt empty_4.txt\n\nJeigu failo pavadinimas yra nurodytas su absoliučiu ar reliatyviu keliu, failas bus sukurtas atitinkamoje direktorijoje, jei tokia direktorija egzistuoja. Jei direktorija neegzistuoja, bus pranešta apie klaidą, ir failas nebus sukurtas.\ntouch mix/empty_5.txt\ntouch tralala/empty_6.txt\n\ntouch taip pat leidžia atnaujinti failo prieigos arba modifikavimo laiką. Štai keli pavyzdžiai:\n\nAtnaujinti tiek prieigos, tiek modifikavimo laikus į dabartinį laiką:\n\ntouch empty_1.txt\n\nAtnaujinti tik prieigos laiką:\n\ntouch -a empty_1.txt\n\nAtnaujinti tik modifikavimo laiką:\n\ntouch -m empty_1.txt\n\nNustatyti tiek prieigos, tiek modifikavimo laikus į konkrečią datą, pvz., 2022 m. sausio 1 d., 12:00 val.:\n\ntouch -t 202201011200 empty_1.txt\n\nNaudoti -d parinktį, norint lankstesnio laiko nustatymo:\n\ntouch -d \"2023-07-04 15:45\" empty_1.txt\nDabar gali kilti klausimas - kam tai naudinga? Iš tiesų, failų laikų keitimas gali atrodyti nišinis, tačiau tai naudinga tam tikrais atvejais:\n\nJei nori išbandyti skriptą, kuris rūšiuoja ar archyvuoja failus pagal jų prieigos ar modifikavimo laiką, gali generuoti tuščius failus su netikrais laikais ir patikrinti, ar skriptas veikia teisingai.\nJei atstatai failus iš atsarginės kopijos, gali norėti atkurti ir jų originalius prieigos bei modifikavimo laikus, kad išsaugotum failų istoriją tiksliai tokia, kokia buvo prieš atsargines kopijas.\n\n\n\n6.1.8 mkdir\nKomanda mkdir (angl. make directory) naudojama naujų direktorijų kūrimui.\nNaują direktoriją gali sukurti taip:\nmkdir projektas1\nKaip ir su komanda touch, gali sukurti kelias direktorijas vienu metu, nurodant pavadinimus arba kelius į jas:\nmkdir projektas2 mix/projektas3\n\nKartais reikia sukurti direktorijų medį (hierarchiją). Jei tarpinės direktorijos dar neegzistuoja, gali naudoti -p argumentą, kuris automatiškai sukurs ir tarpines direktorijas. Pavyzdžiui:\nmkdir -p projektas0/duomenys\n\n\n\n\n\n\n\nPraktika\n\n\n\nNetrukus norėsime sukurti tam tikrų failų atsargines kopijas. Kaip pasiruošimą, užtikrink, kad shell_part_2 direktorijoje būtų:\n\nbackup/data\nbackup/text\n\nSukurk jas naudojant -p, nurodant abi direktorijas kaip du argumentus vienoje komandoje (vienoje eilutėje).\n\n\n\n\n6.1.9 cp\nPripažink, kopijuoti failą su cat failas.txt &gt; kopija.txt nėra labai intuityvu. O ką daryti, jei nori nukopijuoti ne tik failą, bet ir visą direktoriją?\nKomanda cp (angl. copy) naudojama failams ir direktorijoms kopijuoti.\nPaprasčiausiu atveju, kai nori sukurti failo kopiją, komandai cp nurodai originalaus failo pavadinimą ir kokiu pavadinimu turėtų būti sukurta kopija.\ncp song_text.txt song_text_copy.txt\nJei failas song_text_copy.txt jau egzistuotų, jis būtų perrašytas. Taigi cp veikia panašiai kaip &gt;.\nKaip ir su visomis BASH komandomis, gali naudoti tiek reliatyvius, tiek absoliučius kelius (angl. path). Pavyzdžiui, kopiją gali perkelti į kitą direktoriją:\ncp ./song_text.txt ./mix/song_text_copy.txt\n\nJeigu kaip antrąjį argumentą nurodysi egzistuojančios direktorijos pavadinimą, cp sukurs kopiją tokiu pačiu pavadinimu kaip originalas ir patalpins ją į nurodytą direktoriją. Šįkart praleidžiam\ncp song_text.txt mix\n\ncp gali kopijuoti ir direktorijas, tačiau tam, kad visa direktorija būtų nukopijuota rekursyviai (su visu turiniu), reikia naudoti nustatymą -r (recursive). Jeigu pamirši -r direktorija nebus nukopijuota!\ncp -r mix mix_copy\n\nKada naudoti cp -a?\nNustatymas -a (arba archive) naudojamas, kai reikia nukopijuoti failus ir direktorijas kartu su jų metaduomenimis (pvz., failo leidimais, nuosavybe, laikais). Tai naudinga, kai nori išsaugoti visas originalaus failo ar katalogo savybes. -a iš esmės yra kombinuotas cp -r (rekursija) ir kitų nustatymų rinkinys, kuris užtikrina, kad išsaugomi visi atributai.\ncp -a mix mix_copy_2\nDabar palyging metaduominis su ls -l.\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nPadaryk temp_vilnius.txt kopiją pavadinimu temp_vilnius.txt, bet kaip argumentą nurodyk direktoriją ir failo pavadinimą. Patalpink kopiją į backup/data.\nPadaryk temp_kaunas.txt ir temp_klaipeda.txt kopiją vienoje komandoje su originaliu pavadinimu, kaip trečią argumentą cp paduodant tik backup/data direktoriją.\nPadaryk text direktorijos kopiją su visu jos turinu į backup direktoriją. Išsaugok visus metaduomenis.\nTeorinis klausimas: kas nutiktų jeigu panaudotum cp -r text backup/text?\nAr darant temp_ failų atsargines kopijas išsaugojai metaduomenis? jeigu ne, pakartok komandas tik su teisingu nustatymu ir įsitikink, ar iš tiesų metaduomenys tokie pat!\n\n\n\n\n\n6.1.10 mv\nKomanda mv (angl. move) naudojama perkelti arba pervadinti failus ir direktorijas. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\nPvz., naudojant mv, gali pervadinti failą temp_vilnius.txt į temp_alytus.txt:\nmv data/temp_vilnius.txt data/temp_alytus.txt\n\nTaip pat su mv gali perkelti failus iš vienos direktorijos į kitą. Ši komanda perkelia failą temp_kaunas.txt į mix:\nmv data/temp_kaunas.txt mix\n\nmv komandai galima paduoti daugiau nei du argumentus. Pavyzdžiui, ši komanda perkelia failus temp_alytus.txt ir seneles_pasaka.txt į direktoriją mix. Čia svarbu, kad paskutinis argumentas būtų egzistuojanti direktorija:\nmv data/temp_alytus.txt text/seneles_pasaka.txt mix\nmv taip pat gali būti naudojama perkelti direktoriją ir visą jos turinį. Pavyzdžiui, ši komanda perkelia direktoriją mix_copy į mix:\nmv mix_copy mix\nPastaba: dirbant su direktorijomis:\n\njeigu mv origin target jeigu target neegzistuoja, tada mv pervadins direktoriją origin į target\njeigu mv origin target jeigu target egzistuoja, tada mv perkels origin į target direktoriją\n\nSvarbu: kaip ir naudojant &gt; ar cp, jeigu tikslinis failas jau egzistuoja, jis bus perrašytas, nebent pridėsi -i (interaktyvų režimą), kad būtų paprašyta patvirtinimo prieš perrašant.\n\n\n\n\n\n\nPraktika\n\n\n\n\nTeorinis klausimas: Kas nutiktų, jei įvykdytum šią komandą?\n\nmv vilnius_temp.txt kaunas_temp.txt ~/Documents ~/Downloads\n\nPerkelk Alytaus ir Kauno temperatūrų failus atgal iš mix į data naudojant mv. Pervadink Alytaus failą atgal į Vilniaus\nAtsidaryk Nemo ir rankiniu būdu ištrink data direktoriją. Dabar su terminal, padaryk backup/data kopiją (su cp ir reikalaingais nustatymais), jog vėl atsirastų /shell_part_2/data.\n\n\n\n\n\n6.1.11 rm\nTavo shell_part_2 direktorijoje dabar tikrai daug failų ir subdirektorijų, kurių nebereikia. Laikas įvesti šiek tiek tvarkos!\nKomanda rm (angl. remove) naudojama pašalinti failus ir direktorijas. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar direktorijos nėra perkeliami į šiukšliadėžę ir jų atkurti nebebus galima.\nNorint pašalinti failą, rm komandai paduodamas argumentas - failo pavadinimas arba absoliutus, arba reliatyvus kelias į failą.\nrm day.txt\nrm mix/empty_5.txt\nKomandai rm galima paduoti ir kelis failus vienu metu:\nrm empty_1.txt empty_2.txt \nTuščią direktoriją (kai joje nėra jokių kitų failų ar subdirektorijų) galima pašalinti arba naudojant rmdir (kuri yra mkdir priešingybė), arba su rm, nurodant nustatymą -d.\nrm -d projektas1\nrmdir projektas2\n\nTiesiog pašalinti direktoriją, kurioje yra kažkas, su rm arba rm -d nepavyks, nes BASH bando apsaugoti vartotoją nuo rizikos netyčia ištrinti daugiau failų nei reikia.\n\nJei reikia ištrinti visą direktoriją su visu jos turiniu, naudojamas parametras -r (recursive).\nrm -r projektas0\nKartais gali nutikti, jog rm -r negalės ištrinti direktorijos dėl failų teisių ar kitų kliūčių. Tokiu atveju pridedamas nustatymas -f (force), kuris priverstinai ištrina failus.\nrm -rf mix_copy_2\nintarpas: Wildcard’ų naudojimas *\nKartais BASH komandose norisi pažymėti arba pasirinkti daugiau nei vieną failą. Kaip jau matei, tiek cat, tiek cp, mv, rm, less komandos kuo puikiausiai dirba su keliais failais. Tad kyla klausimas, kaip tai padaryti efektyviau naudojant wildcard simbolius.\nPvz., tu galėtum rašyti:\nrm empty_1.txt empty_2.txt\nTačiau yra akivaizdu, jog šiuose failų pavadinimuose yra tam tikras dėsningumas – jie prasideda empty_ ir baigiasi .txt.\nBASH, kaip ir daugelyje kitų programavimo kalbų, yra vadinamieji wildcard - simboliai, kurie leidžia užpildyti vieną ar daugiau ženklų.\nPavyzdžiui, * simbolis pakeičia bet kokį skaičių ženklų. Taigi, galima būtų parašyti:\nrm empty_*.txt\nWildcard’ų simboliai:\n\n* reiškia jokio, vieną arba daugiau simbolių.\n? reiškia tiksliai vieną simbolį, pvz., 201?.txt galėtų atitikti 2017.txt, 2018.txt, bet ne 2017-01.txt.\n[...] reiškia vieną iš pateiktų simbolių, pvz., 201[78].txt atitiks 2017.txt arba 2018.txt, bet ne 2016.txt.\n{} reiškia vieną iš nurodytų reikšmių, pvz., rm {.txt,.csv} atitiks visus failus, kurių pavadinimas baigiasi .txt arba .csv, bet ne .pdf.\n\n\n\n\n\n\n\nPraktika\n\n\n\nTeorinė užduotis - pasakyk, kas nutiktų visais šiais atvejais:\n\nrm song*.txt\nrm *song*.txt\nrm *.txt\nrm *.*\nrm ./*\nrm *\nrm data/*\nrm text/*.txt\nPasitikrink atsakymą naudojant ChatGPT!\n\nPraktinė užduotis - naudojantis wildcard ištrink iš shell_part_2 visus failus:\n\nkurių pavadinime yra žodis song, neproklausomai nuo pozicijos ir failo tipo\nkurių failo tipas yra .txt\nvisus failus esančius mix subdirektorijoje. Tam gali prireikti papildomo nustatymo rm komandai, nes mix gali būti direktorijos!\nsubdirektorijas data ir text. O tada naudodojant cp ir būtinai reikiamą nustatymą metaduomenų išlaikymui, atkurti iš backup\n\n\n\nAtlikus visus valymus turėtum turėti:\n\n\n\n6.1.12 grep\nKartais tau gali prireikti nuskaityti tik tam tikras failo eilutes, kuriose yra konkretus tekstas. Komanda grep (angl. global regular expression print, liet. „globalus reguliariųjų išraiškų paieškos spausdinimas“) naudojama teksto paieškai pagal šabloną failuose arba išvestyje.\nPavyzdžiui, ši komanda surastų visas eilutes data/seneles_pasaka, kuriose yra žodis „Apie“:\ngrep Apie text/seneles_pasaka.text\n\nSuprantama, gali pateikti kelis failus vienu metu. Šiuo atveju komanda grep suras visas eilutes, kuriose yra 14:00:00 abiejuose jai pateiktuose failuose ir atitinkamas eilutes atspausdins tau į terminalą.\ngrep 14:00:00 data/temp_vilnius.txt data/temp_kaunas.txt \n\ngrep priima ir tam tikrus nustatymus, kurie padeda atlikti paiešką efektyviau:\n\n-c: atspausdina, kiek eilučių atitinka tavo pateiktą kriterijų.\n-h: neatspausdina failų pavadinimų, kuriuose rasti atitikimai, kai pateiki keli failai.\n-i: ignoruoja didžiąsias ir mažąsias raides (pvz., įrašius -i apie, ras ir „Apie“, „apie“, „APIE“ ir t.t.).\n-l: atspausdina tik failų pavadinimus, kuriuose rasti atitikimai.\n-n: atspausdina eilučių numerius šalia pačios eilutės.\n-v: ieško eilučių, kuriose nėra raktinio paieškos kriterijaus.\n\n\n\n\n\n\n\nPraktika\n\n\n\nDirbk su data/seneles_pasaka.txt\n\nKurios eilutės turi paminėtą žodį „pasaka“ (tik su mažąja raide)?\nKurios eilutės turi paminėtą žodį „pasaka“ (nesvarbu, ar rašyta didžiosiomis, ar mažosiomis raidėmis)?\nKiek eilučių (ieškome skaičiaus) turi paminėtą žodį „apie“, nepriklausomai nuo rašybos?\nKiek eilučių (ieškome skaičiaus) nepamini žodžio „apie“, nepriklausomai nuo rašybos?\n\n\n\nPastaba: komanda grep ieško tekstinės atitikties failuose, todėl ji nepriima loginių operatorių kaip &gt;, =, ar &lt;. Visgi, grep leidžia naudoti reguliarias išraiškas (regular expressions), kurios leidžia dar smulkiau atrinkti tekstą.\nŠtai kaip būtų galima panaudoti grep su reguliariomis išraiškomis, norint surasti visas eilutes, kuriose yra vienas skaitmuo prieš tašką, visuose temp_ failuose:\ngrep -P '\\t[0-9]\\.[0-9]' data/temp_*.txt\n\nĮ reguliarias išraiškas dabar neverta gilintis išsamiau, bet svarbu žinoti, kad jos egzistuoja ir gali būti labai naudingos dirbant su tekstiniais duomenimis. Jeigu kiltų noras pasibandyti, siūlau naudti https://regexr.com/.\n\n\n6.1.13 cut\nKartais tau gali prireikti išfiltruoti ne eilutes, o stulpelius. Pvz., komanda head data/temp_vilnius.txt parodo tarsi 3 stulpelius: datą, laiką ir temperatūrą. Pastebima, kad tarp datos ir laiko yra mažas tarpas (greičiausiai „space“), o tarp laiko ir temperatūros – didelis tarpas (tikėtina, “tab”). Tai šiek tiek apsunkina darbą, kol nesusipažinai su sed komanda, bet tai nereiškia, jog negalime išskaidyti failo į stulpelius pagal skirtingus skirtukus, pvz., „space“ ir „tab“.\n\nKomandai cut reikia tam tikrų nustatymų. Pagrindiniai nustatymai:\n\n-d (delimiter) – skirtukas, kuris skiria stulpelius. Pagal nutylėjimą skirtukas yra tabuliacija (tab), tad šio nustatymo keisti nereikia. Jeigu norėtum naudoti kitą skirtuką, pvz., tarpo ženklą, turėtum naudoti -d \" \". Jeigu skirtukas būtų kablelis, naudotum -d \",\" ir t.t.\n-f (fields) – nurodo, kuriuos stulpelius (laukelius) nori pasirinkti. Pvz., -f 2 pasirinktų antrą stulpelį, -f 2-5 pasirinktų nuo antro iki penkto stulpelio, o -f 2-5,8 pasirinktų antrą, trečią, ketvirtą, penktą ir aštuntą stulpelius.\n\nŠi komanda priima „space“ kaip skirtuką ir atspausdina pirmąjį stulpelį:\ncut -d \" \" -f 1 data/temp_vilnius.txt\n\nŠi komanda priima „tab“ kaip skirtuką ir atspausdina antrąjį stulpelį:\ncut -f 2  data/temp_vilnius.txt\n\nJeigu norėtum gauti tik metus, galėtum nurodyti skirtuką „-“ ir pasirinkti pirmąjį stulpelį:\ncut -d \"-\" -f 1 data/temp_vilnius.txt \n\n\n\n\n\n\n\nPraktika\n\n\n\nProgramuojant ir dirbant su duomenimis, svarbu išmokti išnaudoti AI galimybes. Šioje praktikoje tu turi nueiti į ChatGPT ir parašyti kažką panašaus:\n\nSugeneruok 25 eilučių .csv failą, kurio skirtukas būtų “,” su šiais stulpeliais:\n\nuser_id,\nage (18-99)\ncountry_code (LT, LV, EE)\norders (0-250)\n\n\nChatGPT sugeneruos .csv failą ir leis jį atsisiųsti. Šiam sugeneravimui ChatGPT pasinaudos Python programavimo kalba. Tu galėtum išsaugoti grąžintą kodą ir naudoti jį ateityje, nes tavo kompiuteryje šis kodas taip pat veiktų. Bet prie Python mes dar grįšime vėliau.\nPerkelk failą iš ~/Downloads į ~/shell_part_2/data. Tarkime, failas vadinasi sample_data.csv.\nVideo\nTurint failą:\n\nPervadink failą į balt_customers.csv.\nNaudojant žinomomis komandomis tyrinėk failą data/balt_customers.csv:\n\nKiek jame eilučių?\nKoks skirtukas naudojamas?\nKokie duomenys yra pirmoje eilutėje (antraštė ar duomenys)?\nKiek ir kurios eilutės yra duomenys?\n\n\nUžduotis: Tu dirbi su klientais iš Estijos (EE). Turi parašyti visiems klientams iš Estijos el. laišką ir pranešti apie jų užsakymų skaičių. Laiško rašymą perims programa, tačiau tu jai turi pateikti failą customers_ee.csv, kuris turėtų atrodyti taip (tavo duomenys gali skirtis dėl atsitiktinio jų sugeneravimo):\n\nKad įgyvendintum šią užduotį, tau prireiks komandų: head, cut, &gt; &gt;&gt;, cat ir grep bei sukurti kelis tarpinius failus, kuriuos vėliau galėsi ištrinti. Taip pat patarčiau bandyt skaidyti darbus :)\nSėkmės!\n\n\n\n\n6.1.14 Intarpas: Standartinė įvestis, išvestis ir klaidos\nIki šiol mes naudojome sąvokas, tokias kaip įvestis (input) ir išvestis (output). Įvestis buvo tai, ką tu įvedi klaviatūra į terminalą, o išvestis – tai, ką BASH atspausdina terminale arba ką tu nukreipi į failą naudodant &gt; arba &gt;&gt;. Tačiau iki šiol formaliai neaptarėme BASH srautų.\nLinux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenų įvestį ir išvestį programose bei komandose. Šie srautai vadinami standartine įvestimi (standard input), standartine išvestimi (standard output) ir standartine klaida (standard error). Kiekvienas srautas turi specifinę paskirtį ir failo aprašymo numerį.\nSvarbu: Linux’e viskas yra failai, net srautai (input/output) traktuojami kaip failai.\n\n6.1.14.1 Standartinė įvestis (stdin)\nStandartinė įvestis, sutrumpinta kaip stdin, yra srautas, iš kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, stdin yra prijungta prie klaviatūros, tačiau gali būti nukreipta iš failo ar kito srauto.\nPabandyk įrašyti cat, paspausti Enter, ir tada įvesk kelis žodžius, vis paspausdžiant Enter. Terminale matysi tekstą, kurį įvedi, nes jis bus perduotas kaip įvestis cat komandai, kuri atspausdins šį tekstą. Todėl matysi dvigubai tai, ką įvedei.\ncat\nNutraukti cat įvestį gali su Ctrl-D arba Ctrl-C.\nVideo\nĮvestis taip pat gali būti perduodama iš failo į komandą. Pavyzdžiui, komandai cat galime nurodyti failą taip:\ncat &lt; data/customers_ee.csv\nKodėl veikia &lt;?\nSimbolis &lt; nurodo komandai, kad vietoje įprastos įvesties iš klaviatūros naudotų failą kaip įvesties šaltinį. Pvz., cat &lt; data/customers_ee.csv reiškia, kad cat komanda skaitys duomenis iš failo data/customers_ee.csv, o ne iš klaviatūros.\n\nStandartinės įvesties aprašymo numeris: 0. Vėliau pamatysi, kam tie skaičiai naudingi.\n\n\n6.1.14.2 Standartinė išvestis (stdout)\nStandartinė išvestis, sutrumpinta kaip stdout, yra srautas, į kurį komanda ar programa rašo išvestį. Dirbant terminale, stdout prijungta prie terminalo ekrano. Pavyzdžiui, įrašius šią komandą, terminale atspausdinamas „Hello World“:\necho \"Hello World\"\nGalima nukreipti standartinę išvestį ne į terminalo langą, bet į failą, kaip jau esame darę anksčiau:\necho \"Hello World!\" &gt; hello_world.txt\nStandartinė išvestis turi numerį 1. Tai reiškia\necho \"Hello World!\" 1&gt; hello_world.txt\njog stdout srautas (1), kurį generuoja echo komanda, siunčiamas į failą hello_world.txt. Mes panaudojom srauto numerį, kad pasakyti kurį srautą siųsti į failą.\n\n\n6.1.14.3 Standartinė klaida (stderr)\nKai komanda negali atlikti tam tikro veiksmo, ji sugeneruoja klaidos pranešimą, kuris siunčiamas į standartinį klaidos srautą (stderr). Standartinės klaidos srautas turi numerį 2, ir jį taip pat galima nukreipti į failą.\nPabandyk komandą ls su neegzistuojančia direktorija, pvz.,:\nls abc\n\nKlaidos pranešimas bus išspausdintas terminale. Tačiau galime nukreipti tik klaidos srautą į failą:\nls abc 2&gt; error.log\nTerminale klaidos nebus matyti, bet gali naudoti komandas head arba cat, kad pažiūrėtum, kas yra error.log faile.\n\n\n\n\n6.1.15 Kaip visą tai taikyti praktikoje?\nĮsivaizduok, kad turi komandą ls, kuri kartais sugeneruoja išvestį, kurią nori nukreipti į list.txt, o klaidas – į error.log. Tam galėtum naudoti:\nls &lt;direktorija1&gt; &lt;direktorija2&gt; &lt;direktorija3&gt; 1&gt;&gt;list.txt 2&gt;&gt;error.log\nIšbandyk šią komandą su egzistuojančia ir neegzistuojančia direktorija (prieš tai su rm ištrink error.log jeigu toks egzistuoja)\nls -l data abc text 1&gt; list.txt 2&gt; error.log\n\nKartais gali prireikti, kad abu srautai būtų nukreipti į tą patį failą. Pvz., jeigu kas 10 minučių matuoji kompiuterio temperatūrą, gali nukreipti tiek stdout, tiek stderr į failą:\nkomanda 1&gt;temp.log 2&gt;&1\nArba gali klaidos srautą nukreipti į temp.log, o standartinę išvestį – į klaidų srautą:\nkomanda 2&gt;temp.log 1&gt;&2\nSimbolis & nurodo, kad mes kalbame apie srautą, o ne apie failo vardą. Kai rašai, pvz., 1&gt;&2, tai reiškia, kad standartinę išvestį (stdout, 1) nukreipi ne į failą, o į standartinį klaidų srautą (stderr, 2). Tai leidžia abu srautus sujungti ir siųsti į tą patį tikslą. Jei & nebūtų, sistema galvotų, kad „2“ yra failo pavadinimas, o ne kitas srautas. Analogiškai, 2&gt;&1 reiškia, kad klaidų srautas (stderr, 2) nukreipiamas į išvesties srautą (stdout, 1).\n\n\n6.1.16 pipe |\nIki šiol, kai reikėdavo vienos komandos išvestį panaudoti kitoje komandoje, pavyzdžiui, išfiltravus Estijos vartotojus su grep EE data/balt_customers.csv, turėjai juos išsaugoti į tarpinį failą (pvz., temporal.csv), o tik tada paduoti rezultatą į cut -d \",\" -f 1,4 temporal.csv, kad gautum norimą rezultatą. Tai yra neefektyvus metodas, nes:\n\nLieka daug tarpinių failų.\nKomandos būna suskaidytos per kelias eilutes, todėl jas sunku peržiūrėti su history.\n\nBASH siūlo kelis būdus, kaip efektyviau panaudoti vienos komandos rezultatus kitose, pavyzdžiui, su xargs arba kitais įrankiais. Tačiau dažniausiai naudojamas metodas yra pipe (angl. “vamzdis”).\n| (pipe) – tai vertikalus brūkšnys, kuris sujungia komandas į vieną srautą, kur vienos komandos išvestis tampa kitos komandos įvestimi.\n\nPabandyk sujungti šias komandas:\n\ngrep EE data/balt_customers.csv - išfiltruoti tik EE vartotojus.\nPanaudoti |, kuris pavers pirmosios komandos išvestį antrosios komandos įvestimi.\ncut -d \",\" -f 1,4 – iškirpti pirmą ir ketvirtą stulpelius.\nGalutinį rezultatą su &gt; nukreipk į failą data/customers_ee_2.csv.\n\n\ngrep EE data/balt_customers.csv | cut -d \",\" -f 1,4 &gt; data/customers_ee_2.csv\nPirma pabandyk paleisti komandą be &gt;, kad pamatytum rezultatą terminale:\n\nDabar paleisk pilną komandą, nukreipiančią išvestį į failą:\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nTerminale atspausdink pirmas 3 eilutes, kuriose yra žodis „Apie“ iš failo data/seneles_pasaka.txt.\nTerminale atspausdingk paskutines 3 eilutes kuriose yra 00:00:00 faile data/temp_vilnius.txt\n\n\n\n\n\n6.1.17 sort\nTu darai nuostabią pažangą ir jau moki naudoti grep, cut, head, tail, su kuriomis gali išfiltruoti eilutes, stulpelius ir t.t. Naudojant |, jau moki sujungti kelias komandas į vieną. Tačiau ko tu dar nemoki – kaip išrikiuoti reikšmes. Čia pravers komanda sort.\nsort labai gerai sąveikauja su pipe |.\nPagrindiniai nustatymai:\n\n-r – nuo didžiausios iki mažiausios reikšmės.\n-n – rikiuoti skaičius.\n-h – rikiuoti pagal dydį, jei dydis pateiktas human readable skaičiais (pvz., KB, MB, GB).\n-t – nurodo, koks yra skirtukas tarp stulpelių (delimiter).\n-k – pagal kurį stulpelį rikiuoti.\n\nSukurk šį failą:\necho -e \"A,101\\nB,3\\nC,2\\nD,40\" &gt; tosort\nAr pastebėjai, tosort neturi indikacijos, koks tai failas, nei .csv, nei .txt. Nieko tokio Linux operacinėje sistemoje, komandos veikia kuo puikiausiai ir be failo tipo indikatoriaus.\n\nPagal nutylėjimą sort priims failą kaip argumentą ir rikiuos pagal pirmą stulpelį. sort -r apsuks rikiavimo eigą.\nsort tosort\nsort -r tosort\n\nJei nori, kad BASH suprastų failą kaip turintį skirtingus stulpelius, turi nurodyti, koks yra skirtukas (delimiter) su -t \",\". Tuomet galima rikiuoti pagal konkretų stulpelį su -k 2. Jei nepridėsi -n, sort rikiuos taip, lyg skaičiai būtų tekstas, t.y., vertins pagal pirmą skaitmenį, tada pagal antrą ir t.t. Pridėjus -n, skaičiai vertinami kaip skaičiai.\nGalima apsieiti ir be kabučių aplink skirtuką, o -n pridėti prie -k 2, kad būtų rikiuojama pagal skaičius. Galų gale, tai tavo pasirinkimas.\nsort -t \",\" -k 2 tosort\nsort -t \",\" -k 2 -n tosort\nsort -t, -k2n tosort\n\n\n\n\n\n\n\nPraktika\n\n\n\nUžduotis: Įsivaizduok, kad esi IT administratorė arba administratorius, atsakingas už sistemų stebėjimą. Tau reikia periodiškai siųsti sąrašą su 5 didžiausiais failais ar direktorijomis pagal dydį namų direktorijoje (~). Šis sąrašas turėtų apimti visus paslėptus failus (kurie prasideda su “.” savo pavadinime), o dydis turėtų būti human readable formatu, o ne baitais. Taip pat norisi, kad maksimalus gylis būtų 1, t.y., jog būtų žiūrima į ~ ir vieną lygį giliau, t.y. ~/direktorija/.\nKadangi šią užduotį reikia atlikti kasdien, nusprendei sukurti ilgą BASH komandą.\nPagalba: Prieš pradedant nueik į ChatGPT ir paprašyk:\n\nPaaiškink man “du” komanda Linux ir jos nustatymus. Man reiktų matyti failus human readable formatu. Pateik kelis pvz.\n\nPerskaityk ką tau gražins ChatGPT, jeigu reikia pasitisklink užduodant papildomus klausimus.\n\nPabandyk sukurti komandų seką (pipeline) su du, sort, head. Eksperimentuok su nustatymais.\nKai terminalo lange matysi reikiamą išvestį, naudok echo, apskliausk visą komandą kabutėmis ir nukreipk į failą pavadinimu list_du_homedir.sh. Taigi, tai turėtų atrodyti daugmaž taip:\necho \"komanda komanda komanda\" &gt; list_du_homedir.sh\nO dabar pabandyk\nbash list_du_homedir.sh\narba su pipe\ncat list_du_homedir.sh | bash\nSveikinu, ką tik sukūrei savo pirmą skriptą! Tai komandų rinkinys, kurį gali perduoti BASH, ir jis jį įvykdys.\n\n\n\n\n6.1.18 sed\nsed komanda Linux sistemoje yra srauto redaktorius (stream editor), naudojamas tekstui apdoroti ir manipuliuoti. Ji leidžia atlikti įvairius teksto pakeitimus, pvz., ieškoti ir pakeisti žodžius, ištrinti eilutes arba modifikuoti tekstą pagal tam tikras taisykles, nespausdinant teksto į terminalą.\nVienas paprasčiausių būdų naudoti sed – tai pakeisti tam tikrą tekstą kitu tekstu: tam naudojama tokia sintaksė sed 's/ką keisti/kuo pakeisti/'.\nTaigi, ši komanda pakeičia „rytas“ į „vakaras“:\necho \"Labas rytas\" | sed 's/rytas/vakaras/'\nsed nėra agresyvi komanda, todėl ankstesnė komanda pakeičia tik pirmą rastą atitikmenį:\necho \"Labas rytas, pasakė senelė kai atėjo rytas\" | sed 's/rytas/vakaras/'\nMatyti, kad tik pirmas „rytas“ pakeistas į „vakaras“, o antrasis ne. Jei nori, kad visi atitikmenys būtų pakeisti, reikia pridėti nustatymą g:\necho \"Labas rytas, pasakė senelė kai atėjo rytas\" | sed 's/rytas/vakaras/g' \nSu sed taip pat galima ištrinti eilutes. Pavyzdžiui, jei ls -l komanda atspausdina „total …“, galima tai ištrinti naudojant sed '1d':\nls -l\nls -l |sed '1d'\nVietoje 1, kuris nurodo, kurią eilutę trinti, galima nurodyti ir diapazoną, pvz., nuo 1 iki 3 su sed '1,3d':\nls -l | sed '1,3d'\nTaip pat galima įterpti naujas eilutes:\nls -l | sed '3a/nauja eilutė'\nPora įdomybių:\nSu sed gali naudoti regular expressions. Štai keletas reikšmių:\n\n^ reiškia eilutės pradžią.\n$ reiškia eilutės pabaigą.\n\\t reiškia tabuliaciją (naudoti su sed -E).\n\\s reiškia tarpą (naudoti su sed -E).\n\nPvz., pridėti veiduką prieš kiekvieną eilutę:\nsed 's/^/😀/g' text/seneles_pasaka.txt\nJei nori, kad sed ignoruotų raidžių dydžius, pridėk nustatymą I. Tai panašu į grep -i.\necho Labas Rytas | sed 's/rytas/Vakaras/'\necho Labas Rytas | sed 's/rytas/Vakaras/I'\n\n\n\n\n\n\nPraktika\n\n\n\n\nDirbk su data/seneles_pasaka.txt. Tavo tikslas – padaryti pasaką labiau patrauklią vaikams, pakeičiant žodžius simboliais. Naudok sed komandą ir pakeisk šiuos žodžius į atitinkamus simbolius. Sujunk visas sed komandas į viena pipeline naudojant |.\n\nŽąsiną moliūgą – 🦢🎃 Vilką – 🐺 Baltą mešką – 🐻‍❄️ Joną – 👦🏻 Eglę - 🌲 Žalčio – 🐍 Ragana - 🧙‍♀️ Pamotė pikta – 😡\nIšsaugok pasaką kaip text/seneles_pasaka_emojies.txt\n\n\ndata/temp_vilnius.txt ir kitų miestų failai turi kelias problemas, kurias turėtum ištaisyti:\n\nVilniaus faile kiekvienos eilutės pradžioje įrašyk „Vilnius “ (su tarpeliu po miesto pavadinimo). Kituose miestuose atitinkmai “Kaunas” ir “Klaipėda”\nDabar pirmieji du skirtukai yra tarpai, o antrasis – tabuliacija. Paleisk sed komandą du kartus: vieną kartą pakeisk tarpus (space) į kablelius, o antrą kartą – tabuliacijas į kablelius.\nIšsaugok Vilniaus, Kauno, ir Klaipėdos failus kaip temp_vilnius.csv, temp_kaunas.csv, temp_klaipeda.csv (vietoje .txt naudok .csv plėtinį).\nKiekvienas miestas turėtų turėti visą komandą vienoje eilutėje naudojant |.\n\n\n\nSujunk visus Vilniaus, Kauno ir Klaipėdos failus į vieną ir pavadink rezultatą temp_lietuva.csv.\nPabandyk atidaryti šį failą su LibreOffice Calc:\n\nlibreoffice --calc temp_lietuva.csv\n\nPavaizduok sekančių dienų temperatūras.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#file-permissions-and-ownership",
    "href": "7_linux_comands_advanced.html#file-permissions-and-ownership",
    "title": "7  BASH advanced",
    "section": "8.1 1. File Permissions and Ownership",
    "text": "8.1 1. File Permissions and Ownership\n\nUnderstanding Permissions\n\nRecap of r, w, x permissions.\n\nCommands to Manage Permissions\n\nchmod: Change file permissions.\nchown: Change file ownership.\nchgrp: Change group ownership.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#environment-variables",
    "href": "7_linux_comands_advanced.html#environment-variables",
    "title": "7  BASH advanced",
    "section": "8.2 2. Environment Variables",
    "text": "8.2 2. Environment Variables\n\nIntroduction to Environment Variables\n\nImportance and usage in scripting.\n\nCommands\n\nexport: Set environment variables.\nenv, printenv: Display environment variables.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#text-processing-tools",
    "href": "7_linux_comands_advanced.html#text-processing-tools",
    "title": "7  BASH advanced",
    "section": "8.3 3. Text Processing Tools",
    "text": "8.3 3. Text Processing Tools\n\nAdvanced Text Processing\n\nawk: Basic usage for pattern scanning and processing.\npaste: Merging lines of files.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#basic-networking-commands",
    "href": "7_linux_comands_advanced.html#basic-networking-commands",
    "title": "7  BASH advanced",
    "section": "8.4 4. Basic Networking Commands",
    "text": "8.4 4. Basic Networking Commands\n\nNetworking Basics\n\nping: Checking network connectivity.\ncurl or wget: Fetching files or data from the web.\nnc: Networking tool for reading/writing data across network connections.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#job-control-light-coverage",
    "href": "7_linux_comands_advanced.html#job-control-light-coverage",
    "title": "7  BASH advanced",
    "section": "8.5 5. Job Control (Light Coverage)",
    "text": "8.5 5. Job Control (Light Coverage)\n\nUnderstanding Job Control\n\nOverview of foreground and background processes.\nBasic commands: jobs, bg, fg, kill.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#command-history-and-aliases",
    "href": "7_linux_comands_advanced.html#command-history-and-aliases",
    "title": "7  BASH advanced",
    "section": "8.6 6. Command History and Aliases",
    "text": "8.6 6. Command History and Aliases\n\nManaging Command History\n\nhistory: Viewing command history.\n\nCreating Shortcuts\n\nalias: Define shortcuts for commands.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#file-compression-and-archiving",
    "href": "7_linux_comands_advanced.html#file-compression-and-archiving",
    "title": "7  BASH advanced",
    "section": "8.7 7. File Compression and Archiving",
    "text": "8.7 7. File Compression and Archiving\n\nFile Management\n\ntar: Archive files and directories.\ngzip: Compress files.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#disk-usage-commands",
    "href": "7_linux_comands_advanced.html#disk-usage-commands",
    "title": "7  BASH advanced",
    "section": "8.8 8. Disk Usage Commands",
    "text": "8.8 8. Disk Usage Commands\n\nDisk Usage Overview\n\ndf: Report file system disk space usage.\ndu: Estimate file and directory space usage.\nncdu: Disk usage analyzer with a text-based interface.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#secure-file-transfer",
    "href": "7_linux_comands_advanced.html#secure-file-transfer",
    "title": "7  BASH advanced",
    "section": "8.9 9. Secure File Transfer",
    "text": "8.9 9. Secure File Transfer\n\nTransferring Files Securely\n\nscp: Secure copy protocol.\nrsync: Efficiently transfer files and directories.\nssh: Secure shell for remote access.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#command-execution-and-debugging",
    "href": "7_linux_comands_advanced.html#command-execution-and-debugging",
    "title": "7  BASH advanced",
    "section": "8.10 10. Command Execution and Debugging",
    "text": "8.10 10. Command Execution and Debugging\n\nCommand Substitution\n\neval: Execute commands stored in variables.\n\nDebugging Scripts\n\nIntroduction to debugging scripts (using set -x for tracing execution).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_linux_comands_advanced.html#wrap-up",
    "href": "7_linux_comands_advanced.html#wrap-up",
    "title": "7  BASH advanced",
    "section": "8.11 Wrap-Up",
    "text": "8.11 Wrap-Up\n\nIntegration and Practice\n\nCombine learned commands in small exercises to reinforce concepts.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  }
]