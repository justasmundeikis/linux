[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Linux ir programavimas",
    "section": "",
    "text": "Įvadas",
    "crumbs": [
      "Linux Basics",
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#operacinė-sistema",
    "href": "index.html#operacinė-sistema",
    "title": "Linux ir programavimas",
    "section": "Operacinė sistema",
    "text": "Operacinė sistema\nKai tu įjungi savo telefoną, kompiuterį ar mikrokompiuterį, jame pasileidžia programa - instrukcijų rinkinys, kuris nurodo, kaip tavo prietaisas turi veikti. Ši programa nurodo, pavyzdžiui, įjungus prietaisą pradėti šviesti ekranui, paspaudus klavišus abc suprasti, kad tu rašai, arba įjungus elektros kabelį pradėti krauti bateriją.\n\n\n\nKompiuteris. Autorius: Alessandro Oliverio\n\n\nŠis instrukcijų rinkinys dar nėra visavertė operacinė sistema. Tai yra vadinamasis branduolys (angl. - kernel), kuris nurodo, kaip turi veikti kompiuterinė įranga tarpusavyje.\nŠalia branduolio yra ir kita programinė įranga, kuri leidžia tau naudotis prietaisu - tai įvairiausios programos, pvz., skambinimo programėlė, kalkuliatorius, interneto naršyklė. Visa ši programinė įranga kartu su branduoliu sudaro operacinę sistemą (angl - operating system, arba - OS).\nTaigi operacinė sistema (OS) yra programinė įranga, kuri valdo kompiuterinės įrangos ir programų išteklius. Ji veikia kaip tarpininkė tarp vartotojo ir kompiuterio aparatūros. Pagrindinės populiarios operacinės sistemos yra Windows, UNIX šeimos OS - macOS, ir Linux.\n\nWindows: Microsoft korporacijos sukurta populiariausia operacinė sistema, naudojama tiek namų, tiek verslo kompiuteriuose. Ji žinoma dėl savo patogumo ir plataus programų pasirinkimo.\nmacOS: Apple korporacijos operacinė sistema, naudojama Mac kompiuteriuose. Ji žinoma dėl savo dizaino, stabilumo ir integracijos su Apple ekosistema.\nLinux: Atviro kodo operacinė sistema, kurią gali keisti ir dalintis visi norintys. Ją naudoja dauguma serverių ir technologijų entuziastų.",
    "crumbs": [
      "Linux Basics",
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#ubuntu-skoniai",
    "href": "index.html#ubuntu-skoniai",
    "title": "Linux ir programavimas",
    "section": "Ubuntu skoniai",
    "text": "Ubuntu skoniai\nLinux yra atviro kodo operacinė sistema, todėl ją gali keisti ir dalintis visi norintys. Dėl to yra nemažai programuotojų, kurie nusprendžia pasidalinti savo pagamintais Linux variantais, vadinamais distribucijomis.\n\n\n\nLinux distribucijų medis\n\n\nKai tu įjungi telefoną arba kompiuterį, branduolys užtikrina, kad visi kompiuterio komponentai galėtų tarpusavyje bendrauti. Vis dar trūksta programų, kurios rodytų vaizdus ekrane, leistų įvesti tekstą ir pan. Tam yra reikalingos papildomos programos, dauguma jų buvo sukurtos GNU projekto metu. Tačiau tik branduolys ir GNU programos dar neleistų visavertiškai naudotis kompiuteriu, todėl papildomai diegiamos įvairios reikalingos programos, kurios padaro operacinę sistemą praktiška ir gražiai atrodančia.\nTaigi, pilną operacinę sistemą, dar kartais vadinamą Linux distribucija (distribution), sudaro:\n\nLinux branduolys (kernel)\nGNU programos\nPapildomos programos ir grafinis dizainas",
    "crumbs": [
      "Linux Basics",
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#kodėl-linux",
    "href": "index.html#kodėl-linux",
    "title": "Linux ir programavimas",
    "section": "Kodėl Linux",
    "text": "Kodėl Linux\nGrįžkime prie klausimo - “Kodėl Linux”?\n\nSaugumas: Linux dažnai laikoma saugesne operacine sistema dėl savo architektūros ir mažesnio virusų kiekio.\nServeriai: Linux arba jai giminingos UNIX sistemos veikia beveik visuose pasaulio serveriuose. Greičiausiai net tavo namuose yra ne vienas įrenginys, kuriame veikia Linux.\nUniversalumas: tiek iOS, tiek Android taip pat veikia UNIX pagrindu.\nLankstumas ir pritaikomumas: Linux leidžia tau būti labiau savarankiškam ir geriau suprasti, kaip veikia kompiuteriai. Tuo pačiu metu išmoksti dalykų, kurių nemoka kiti.\nProgramavimas: Linux yra gera pradžia kelionei į Python ir kitas programavimo kalbas, kurios naudojamos programuojant robotus, kuriant interneto svetaines ar atliekant skaičiavimus su dideliais duomenų kiekiais.\n\nŠiais laikais vis daugiau ir daugiau profesijų kasdienėje veikloje reikia programavimo. Buhelteriai naudojasi Python,kad greičiau apdorotų duomenis. Architektai ir inžinieriai, kad teisingai apskaičiuotų pastato konstrukcijas. Transporto srauto specialistai, kad planuotų ir valdytų automobilių srautus, o NASA darbuotojai, kad valdytų į kosmoosą kylančias raketas.\nTaigi Linux ir tam tikra prasme - programavimas, paruošia tave 21-ajam amžiui.\nNegana to, Linux veikia ant tokių paprastų mikrokompiuterių kaip Raspberry Pi Zero ir gali atgaivinti net 10-20 metų senumo nešiojamą kompiuterį. Taigi, tai padeda tausoti gamtą, nes savo technika gali naudotis ilgiau.\nBet yra ir kita medalio pusė. Ne visos tavo įprastos programos veikia Linux. Pavyzdžiui, Adobe produktai tiesiog neveikia Linux aplinkoje. Microsoft Excel ir Word taip pat nėra pritaikyti Linux. Jei tavo mokslui ar darbui yra būtinos tam tikros programos, Linux gali neatitikti tavo lūkesčių. Tačiau reikia žinoti, kad daugelis šių programų turi analogus Linux aplinkoje. Dažniausiai jie yra atviro kodo ir nemokami.",
    "crumbs": [
      "Linux Basics",
      "Įvadas"
    ]
  },
  {
    "objectID": "index.html#linux-mint",
    "href": "index.html#linux-mint",
    "title": "Linux ir programavimas",
    "section": "Linux Mint",
    "text": "Linux Mint\nKaip jau minėjau, yra daug Linux distribucijų. Šiame vadovėlyje naudosime vieną iš paprasčiausių - Linux Mint distribuciją, kuri sukurta Ubuntu pagrindu.\nJą galima parsisiųsti iš linuxmint.com. Kaip ją instaliuoti, gali šiek tiek skirtis priklausomai nuo kompiuterio, tad geriausia šioje vietoje tiesiog paieškoti vaizdo įrašo Youtube svetainėje.",
    "crumbs": [
      "Linux Basics",
      "Įvadas"
    ]
  },
  {
    "objectID": "1_linux_configure.html",
    "href": "1_linux_configure.html",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "",
    "text": "1.1 Intro",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#themes",
    "href": "1_linux_configure.html#themes",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.2 Themes",
    "text": "1.2 Themes",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#backgrounds",
    "href": "1_linux_configure.html#backgrounds",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.3 Backgrounds",
    "text": "1.3 Backgrounds",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#menu",
    "href": "1_linux_configure.html#menu",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.4 Menu",
    "text": "1.4 Menu",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#panel",
    "href": "1_linux_configure.html#panel",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.5 Panel",
    "text": "1.5 Panel",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#firewall",
    "href": "1_linux_configure.html#firewall",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.6 Firewall",
    "text": "1.6 Firewall",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#languages",
    "href": "1_linux_configure.html#languages",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.7 Languages",
    "text": "1.7 Languages",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#keyboard",
    "href": "1_linux_configure.html#keyboard",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.8 Keyboard",
    "text": "1.8 Keyboard",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#time",
    "href": "1_linux_configure.html#time",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.9 Time",
    "text": "1.9 Time",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "1_linux_configure.html#tips-tricks",
    "href": "1_linux_configure.html#tips-tricks",
    "title": "1  Linux pirmieji žingnsiai",
    "section": "1.10 Tips & Tricks",
    "text": "1.10 Tips & Tricks",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Linux pirmieji žingnsiai</span>"
    ]
  },
  {
    "objectID": "2_linux_update.html",
    "href": "2_linux_update.html",
    "title": "2  Linux atnaujinimas",
    "section": "",
    "text": "2.1 Pradžia\nVisuose kompiuteriuose yra daugybė įvairių programų. Pavyzdžiui, jau susipažinome su Terminal ir Files programomis. Taip pat išmokome naudoti kai kurias įdiegtas komandas: echo, cat, ir base64. Šių programų kūrėjai dažnai atnaujina savo programas, tad norėdami pasinaudoti naujausiomis funkcijomis ir pataisymais, turime įdiegti šiuos atnaujinimus (angl. - update).\nŠioje pamokoje sužinosime:\nBe to, išmoksime:\nŠis skyrius padės išmokti, kaip efektyviai tvarkytis su programomis ir jų atnaujinimais, kad kompiuteris visada būtų naujausias ir veiktų be trikdžių.",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "2_linux_update.html#pradžia",
    "href": "2_linux_update.html#pradžia",
    "title": "2  Linux atnaujinimas",
    "section": "",
    "text": "Kas yra veidrodiniai serveriai (angl. - mirrors).\nKaip atnaujinti programas naudojant Update Manager programą.\nKaip atlikti programų atnaujinimus naudojant terminalą.\n\n\n\nKaip įdiegti (angl. - install) programas naudojant Software Manager ir terminalą.\nKuo skiriasi System Package nuo Flatpak programų.\nKaip pašalinti (angl. - uninstall) nebereikalingas programas, kad kompiuteris būtų švaresnis ir veiktų sklandžiau.",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "2_linux_update.html#update-manager",
    "href": "2_linux_update.html#update-manager",
    "title": "2  Linux atnaujinimas",
    "section": "2.2 Update Manager",
    "text": "2.2 Update Manager\nUpdate Manager yra programa, kuri padeda atnaujinti kitas programas tavo kompiuteryje. Ji pati praneša, kai laikas atnaujinti programas. Kai internete yra prieinami atnaujinimai, dešiniame kampe atsiranda skydelio su raudonu tašku piktograma (raudonas taškas reiškia, kad yra naujų atnaujinimų).\n\n\nBet jei nematai šios piktogramos, gali paleisti “Update Manager” programą per Menu:\n.\nPirmą kartą paleidus šią programą, gali pamatyti tokį langą, kuris paaiškina, ką ji daro. Drąsiai spausk ant OK.\n\nJei pamatysi, kad pačiai programai reikia atnaujinimo, spausk ant “Apply the Update” (lt. - įdiegti atnaujinimą). Taip pat gali matyti užrašą switch to a local mirror, kol kas spausk No. Kas yra veidrodžiai (angl. - mirrors), pakalbėsime netrukus.\n\nJei paspaudus “Apply the Update” kompiuteris paprašys tavo slaptažodžio, įvesk jį. Taip kompiuteris įsitikina, kad tik tu ar kitas vartotojas, kuriam priklauso šis kompiuteris, gali atlikti pakeitimus. Drąsiai įvesk savo slaptažodį ir spausk Authenticate (lt. - patvirtinti tapatybę).\n\nNetrukus pamatysi vaizdą, kuris gali atrodyti panašiai - vienas ar keli, o gal net daugybė skirtingų programų atnaujinimų, kuriuos gali įdiegti savo kompiuteriui. Tačiau kol kas dar nieko nespauskime. Susipažinkime su tuo, ką čia matome:\n\n\n\nType - kokio tipo yra atnaujinimas? Jie gali būti:\n\nSecurity update - saugumo atnaujinimas. Jo simbolis yra skydelis. Tai svarbiausias atnaujinimas, kurį reikia kuo skubiau įdiegti, kad kompiuteris būtų saugus.\nKernel update - pagrindinės Linux sistemos atnaujinimas. Jo simbolis yra žaibas. Šie atnaujinimai pagerina, kaip veikia pats kompiuteris. Ar ekranas rodo gerai? Ar veikia pelė? Ir t.t.\nSoftware update - programų atnaujinimai. Tai atnaujinimai, kuriuos programų kūrėjai sukuria, kad jų programos veiktų geriau, turėtų daugiau funkcijų ir pan.\n\n\nŠiame lange taip pat gali paspausti ant:\n\n\nClear - išvalyti visus pasirinktus atnaujinimus\nSelect All - pasirinkti visus atnaujinimus\nRefresh - atnaujinti sąrašą atnaujinimų, kurie yra prieinami\nInstall Updates - įdiegti pasirinktus atnaujinimus\n\nBet kaip kompiuteris žino, kokias programas atnaujinti? Ir iš kur jis jas atsisiunčia?\n\n2.2.1 Mirrors ir Updates\nVeidrodėli, veidrodėli, kas pasaulyje gražiausia?\n\nPradėkime nuo pradžių…\nĮsivaizduok, kad programuotoja, kuri kuria programas, dirba iš namų, kaip ir tu. Po ilgos darbo savaitės, ji nusprendžia: “Viskas, programos atnaujinimas paruoštas. Ištaisyta klaida, įdiegti nauji patobulinimai”.\n\n(Nuotraukoje Jaime Gunther, kuri 38 metų nusprendė, kad mokysis savarankiškai programuoti ir tapo programuotoja)\nBet dabar įsivaizduok, kad keli milijonai žmonių bandytų parsisiųsti iš jos kompiuterio šiuos atnaujinimus. Jos kompiuteris negalėtų to atlaikyti, ir viskas strigtų bei vyktų labai lėtai.\nTodėl programuotoja naudoja serverius veidrodžius (angl. - mirrors).\n\nKas yra serveris? Serveris yra didelis kompiuteris, kuris pastatytas specialiose vietose ir gali aptarnauti milijonus žmonių vienu metu. (daugiau nuotraukų gali rasti čia)\n\n\n\nKodėl jie vadinami veidrodžiais (angl. - mirrors)? Nes jie atspindi tuos programinius pakeitimus, kuriuos programuotoja padarė savo namuose. Kai ji kažką atnaujina, šie serveriai iškart tai atspindi, ir tu gali parsisiųsti atnaujinimus neapkraudamas programuotojos namų kompiuterio!\n\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuris turi sąrašą, kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs, priklauso programų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitikrinti ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasties kartais tavo kompiuteris paklausia, ar nori prisijungti prie vietinių veidrodinių serverių - “Do you want to switch to a local mirror?”\nDabar kyla klausimas, o kaip tavo kompiuteris žino, iš kurio serverio parsisiųsti? Tavo kompiuteryje yra kodas, kuriame yra sarašas kaip rasti visus šiuos serverius.\nNuo to, kaip toli serveris nuo tavęs nutolęs, priklauso prgramų ir atnaujinimų parsisiuntimo greitis. Todėl labai svarbu kartais pasitiktrinti, ar pasirinkti artimiausi serveriai. Būtent dėl šios priežasies, kartais tavo kompiuteris paklausia, ar nori prisijngti prie lokalių veidrodžių.\nKaip tai padaryti?\n\nSpausk ant “Edit” (pakeitimai) ir tada ant “Software Sources” (programų šaltiniai).\nKompiuteris vėl paprašys tavo slaptažodžio, įvesk jį.\nAtsidariusiame naujame lange pamatysi Main ir Base veidrodžius. Jie gali būti nustatyti ne visai ten, kur gyveni tu.\nSpustelk pele prie Main. Atsidarys langas, kuriame bus serveriai, surūšiuoti pagal tai, kaip arti tavęs jie yra (pagal atsisiuntimo greitį). Tu pamatysi, kad po kelių sekundžių sąrašo viršus nebekinta. Tau nereikia laukti, kol kompiuteris parsisiųs visų serverių informaciją. Pasirink patį pirmą serverį\nPakartok tai su Base serveriu.\nSpustelk ant “Update the mirrors” (atnaujinti veidrodinius serverius). Tai gali truputį užtrukti.\nAtnaujinus, pamatysi, kad buvusius serverius pakeitė kiti, tavo pasirinkti serveriai.\nDabar gali uždaryti šį langą.\n\nVisas procesas šiame video:\nVideo\nDabar gali atnaujinti programas, paspaudus ant Install Updates. Gali atsirasti papildomi langai, kur paklaus, ar tikrai nori įdiegti atnaujinimus, gali paprašyti ir įvesti tavo slaptažodį dar kartą. Visur drąsiai sakyk “taip” ir įrašyk savo slaptažodį.\nTačiau yra ir kitas būdas! Naudojant Terminal.\nVeidrodinių serverių atnaujinimas yra būtinas net kai įdiegi atnaujinimus per Terminalą. Tad retkarčiais pasitikrink, ar pasirinkti vis dar sparčiausi veidroriniai serveriai.\n\n\n2.2.2 Atnaujinimų instalivimas per Terminal\nKodėl kartais geriau įdiegti atnaujinimus per Terminal programą? Visų pirma - tu praktikuojiesi BASH kalbos žinias! Visų antra, vėliau išmoksi, kaip vos kelių klavišų paspaudimu tai padaryti daug greičiau nei spaudant su pele ir naudojant Update Manager programą.\nŠtai taip atrodo kodas, kurį reikės įrašyti:\nsudo apt update && \nsudo apt full-upgrade -y && \nsudo apt autoremove -y && \nflatpak update\nDabar tavo galvoje gal atrodo taip:\n\nPradėkime nuo pradžių ir eikime per visas komandas, kad jas suprastume. Kai suprasi - pamatysi, kad viskas gana paprasta.\nMes galime visas komandas surašyti į vieną eilutę, bet paprastumo dėlei, terminale įrašyk komandą po komandos, kaip pateiktia žemiau.\n\nsudo apt update.\n\n\nčia iššaukiama komanda apt. Tai yra programa, kuri rūpinasi programų atnaujinimu.\nupdate yra argumentas, ką programa turi daryti. Priešingai nei atrodo, ji neatnaujina programų. Ką ji padaro, tai palygina tavo kompiuterio programas su tuo, kas yra veidrodiniuose serveriuose (mirror). Jeigu ji aptinka skirtumą, nes, pvz., serveryje programa yra naujesnė, apt tave informuos apie galimus atnaujinimus.\nO kas yra sudo? Atsimeni, kai Update Manager tavęs prašė įrašyti tavo slaptažodį? Kai tu jį įrašydavai, kompiuteris suprasdavo, jog tu turi kompiuterio administratoriaus teises. sudo padaro tą patį. Ši komanda pasako, kad po jo sekantis kodas būtų įvykdytas su kompiuterio administratoriaus teisėmis ir apsaugo, kad svetimi žmonės nieko negalėtų padaryti tavo kompiuteriui.\n\nSpausk Enter. Paleidus šią komandą, Terminal tavęs paprašys įrašyti savo slaptažodį. Jį rašant tu nieko nematysi (juk nenori, kad sėdint kavinėje, kas nors pamatytų tavo slaptažodį?). Įvesk ir spausk Enter dar kartą. Jeigu savo slaptažodį įvesi neteisingai - terminalas tau tai pasakys, tad galėsi bandyti dar kartą.\nJeigu tavo kompiuteriui yra pasiekiami atnaujinimai - tu pamatysi, kiek jų.\n\n\nsudo apt full-upgrade -y.\n\n\nŠi dalis pasako, kad sudo - elkis kaip administratorius\napt naudok programų atnaujinimų programą.\nfull-upgrade - atnaujink visas programas.\n-y yra nustatymas, panašus į ką jau matėme su base64 -d, tik šį kartą jis reiškia yes (lt - taip). Jeigu jo nepanaudotum, Terminal programa tavęs paklaustų, kokius atnaujinimus siūlo padaryti ir dar kartą klaustų, ar tikrai nori viską įdiegti. Tam kad išvengti šio papildomo klausimo, iš karto pasakome - yes.\n\nJeigu tu rašai šią komandą iškart po to, kai jau naudojai sudo apt update, Terminal programa tavęs gali ir nebeprašyti dar kartą įrašyti savo slaptažodį.\nPriklausomai nuo to, kiek yra atnaujinimų, šis procesas gali užtrukti kelioliką sekundžių, bet gali ir kelioliką minučių.\nVideo\n\nsudo apt autoremove -y.\n\n\nsudo ir apt jau žinome.\nauto-remove - šis nustatymas pasako apt komandai, kad jeigu yra kažkokių programų, kurios po atnaujinimo nebereikalingos, jas ištrintų. Nebijok, apt programa yra labai protinga ir atsargiai atsirenka, ką trinti ir ko ne.\n-y nustatymas pasako yes (taip), kad nereiktų patvirtinimo.\n\n\n\nflatpak update - kiek kita komanda. Čia mes iššaukiame programą flatpak, kuri, kaip ir programa apt, moka instaliuoti programas. Tačiau ją atnaujinti užtenka vos šių dviejų žodžių.\n\n\n\nO ką gi reiškia && toje ilgoje komandoje? Kai mes rašome komandas po vieną, kaip padarėme dabar, mes patys matome, ar nutiko kas nors netikėto, ar įvyko kokia nors klaida ir t.t. Tam, kad kompiuteris žinotų, jog tik padarius sudo apt update ir negavus jokių klaidų, jis eitų prie sekančios komandos sudo apt full-upgrade -y ir taip toliau, reikia šias komandas sujungti su &&. Jeigu prieš tai buvusi komanda nepavyktų, kompiuteris nutrauktų visas likusias komandas.",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "2_linux_update.html#žodynėlis",
    "href": "2_linux_update.html#žodynėlis",
    "title": "2  Linux atnaujinimas",
    "section": "2.3 Žodynėlis",
    "text": "2.3 Žodynėlis\n\n\n\n\n\n\n\n\nKomanda\nApibrėžimas\nPavyzdys\n\n\n\n\nsudo apt update\nKomanda, kuri atnaujina paketų sąrašą iš visų saugyklų, kad būtų galima gauti informaciją apie naujausias programinės įrangos versijas.\nPaleidus sudo apt update, sistema patikrina, ar yra naujų programinės įrangos paketų atnaujinimų.\n\n\nsudo apt full-upgrade\nKomanda, kuri atnaujina visus įdiegtus paketus į naujausias galimas versijas, automatiškai pašalindama arba įdiegdama paketus, kai reikia.\nNaudojant sudo apt full-upgrade, jūsų sistema bus atnaujinta į naujausias programinės įrangos versijas.\n\n\nsudo autoremove\nKomanda, kuri pašalina nereikalingus paketus, kurie buvo įdiegti kaip priklausomybės, bet dabar nebėra reikalingi.\nPaleidus sudo autoremove, bus pašalinti nereikalingi bibliotekų paketai, siekiant atlaisvinti vietos diske.\n\n\nflatpak update\nKomanda, kuri atnaujina visus įdiegtus Flatpak programas į naujausias versijas.\nNaudojant flatpak update, jūsų Flatpak programos bus atnaujintos į naujausias versijas.\n\n\nsudo apt install &lt;name&gt;\nKomanda, kuri įdiegia nurodytą programinės įrangos paketą iš saugyklos.\nPaleidus sudo apt install vim, bus įdiegta vim redaktoriaus programa.\n\n\nsudo apt remove &lt;name&gt;\nKomanda, kuri pašalina nurodytą programinės įrangos paketą iš sistemos.\nNaudojant sudo apt remove vim, bus pašalinta vim redaktoriaus programa.\n\n\nflatpak install &lt;name&gt;\nKomanda, kuri įdiegia nurodytą Flatpak programą iš Flatpak saugyklos.\nPaleidus flatpak install flathub org.gimp.GIMP, bus įdiegta GIMP programa.\n\n\nflatpak remove &lt;name&gt;\nKomanda, kuri pašalina nurodytą Flatpak programą iš sistemos.\nNaudojant flatpak remove org.gimp.GIMP, bus pašalinta GIMP programa.\n\n\n-y\nParametras, kuris automatiškai atsako “taip” į visus klausimus, kuriuos komanda gali užduoti, taip palengvinant automatizuotą diegimą ar pašalinimą.\nKomandoje sudo apt install -y vim, parametras -y užtikrina, kad diegimo procesas vyks be vartotojo įsikišimo.\n\n\n&&\nLoginis operatorius, naudojamas sujungti kelias komandas taip, kad antroji komanda būtų vykdoma tik tuo atveju, jei pirmoji komanda baigiasi sėkmingai.\nKomandoje sudo apt update && sudo apt upgrade, sudo apt upgrade bus vykdoma tik tada, jei sudo apt update sėkmingai baigiasi.",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linux atnaujinimas</span>"
    ]
  },
  {
    "objectID": "3_linux_software.html",
    "href": "3_linux_software.html",
    "title": "3  Linux programos",
    "section": "",
    "text": "4 Programų instaliavimas\nProgramų instaliavimas Linux yra gana paprastas. Užtenka susirasti ir atsidaryti Software Manager.\nJam atsidarius, iškart matome daug programų pasiūlymų. Drąsiai panaršyk šiame lange. Ar matai ką nors tave dominančio?",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "3_linux_software.html#sisteminių-paketų-instaliavimas",
    "href": "3_linux_software.html#sisteminių-paketų-instaliavimas",
    "title": "3  Linux programos",
    "section": "4.1 Sisteminių paketų instaliavimas",
    "text": "4.1 Sisteminių paketų instaliavimas\nSisteminis paketas (angl. System Package) - tai programa, kurią Linux kūrėjai patikrino ir pritaikė tavo kompiuterio veikimui. Šios programos valdomos per apt programą.\nKita programų instaliavimo sistema yra Flatpak, su ja susipažinsime vėliau.\nĮdiekime “Bloboats” žaidimą.\nPaieškos viršuje įrašyk Bloboats ir paspausk ant programos piktogramos.\n\nKaip matai, sekantis langas parodo, jog tai System Package ir leidžia tau šią programą įdiegti. Spausk ant Install.\n\nSoftware Manager programa informuos tave, jei reikia įdiegti papildomas programas.\n\nJei taip nutiktų, spausk ant Continue, o tada įrašyk savo slaptažodį ir spausk ant Authenticate. Prisimeni, kai tu įrašai savo slaptažodį, kompiuteris komandas vykdo kaip sudo :)\n\nDabar gali spausti ant Launch (lt - paleisti), arba rasi šią programą tarp visų programų.",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "3_linux_software.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "href": "3_linux_software.html#sisteminių-paketų-įdiegimas-terminal-lange",
    "title": "3  Linux programos",
    "section": "4.2 Sisteminių paketų įdiegimas Terminal lange",
    "text": "4.2 Sisteminių paketų įdiegimas Terminal lange\nSusiraskime kitą programą - 3dchess. Kaip matai, jos pavadinimas kompiuteriui yra parašytas šio lango apačioje:\n\nAtsidaryk terminalą ir įrašyk šią komandą, daug kas jau tau bus matyta:\nsudo apt install 3dchess\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia įdiegti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\ninstall - komanda, pasakanti apt, ką turi daryti, šįkart įdiegti naują programą.\n3dchess - argumentas, pasakantis, kokią programą įdiegti.\n\nMes taip pat galėjome pridėti -y, bet šįkart to nepadarysime. Pažiūrėkime, kas nutinka. Ar pastebėjai kompiuterio reikalavimą patvirtinti, jog tikrai nori instaliuoti šią programą? Do you want to Continue [Y/n]\nVideo\nKaip matai, kompiuteris manęs klausė, ar tikrai noriu, ir teko įrašyti Y raidę ir spustelėti Enter. Tiesa, kai matai [Y/n] tai reiškia, kad jeigu tiesiog paspausi Enter - kompiuteris galvos, kad tu renkiesi Y (Yes trumpinys), tad rašyti Yes tau net nereikia. Kartais tu gali pamatyti [N/y]. Taigi tas pasirinkimas, kuris parašytas didžiąja raide - bus automatiškai pasirinktas jeigu nieko neįrašysi, bet pasupausi Enter klavišą.\nJeigu būčiau įrašęs komandą\nsudo apt install 3dchess -y\nTerminal programa manęs neprašytų patvirtinti mano pasirinkimo. Nes priejus šiam klausimui Do you want to Continue [Y/n], nustatymas -y pasakytų iškart Yes.",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "3_linux_software.html#flatpak",
    "href": "3_linux_software.html#flatpak",
    "title": "3  Linux programos",
    "section": "4.3 Flatpak",
    "text": "4.3 Flatpak\nFlatpak yra kitoks būdas instaliuoti programas. Kai tu instaliuoji Flatpak programą, tu atsisiunti ne tik pačią programą, bet ir visas kitas programas, kurios reikalingos, kad pagrindinė programa veiktų. Pabandykime tai paaiškinti kitaip.\nĮsivaizduok, kad tavo kompiuteris yra kaip namas. Namai turi kambarius, virtuvę, vonią ir t.t. Dabar įsivaizduok, kad nori naujos spintos. Kai tu parsisiunti spintą kaip System Package (sisteminį paketą), tai tarsi parsiveži ją iš IKEA parduotuvės ir pastatai savo kambaryje.\nFlatpak programos veikia kitaip. Kai tu atsisiunti Flatpak programą, tai tarsi parsineštum visą didelę palapinę, kurioje yra ne tik tavo spinta, bet ir visa kita - virtuvė, vonia ir dar keli kambariai. Kodėl taip daroma?\nKartais programoms reikia kitų programų, kad jos veiktų gerai. Tavo kompiuteryje ne visada yra visos šios reikalingos programos. Todėl kai parsisiunti Flatpak programą, ji atsisiunčia viską, ko jai reikia, kad veiktų be problemų. Tai reiškia, kad gauni naujesnę ir geriau veikiančią programą. Tačiau ši didelė palapinė užima daugiau vietos tavo kompiuteryje, nes joje yra viskas, ko reikia programai.\nPavyzdžiui, susiraskime programą “hedgewars”. Pasirink bet kurią piktogramą.\n\nKaip matai, šalia “System Package” arba “Flatpak” yra nedidelis trikampiukas. Paspaudus ant jo, pamatysi, jog gali įdiegti šią programą ir kitu formatu.\nTaip atrodo System Package:\n\nO štai taip Flatpak. Atkreipk dėmesį į programos versijos skirtumus ir kiek vietos reikia kompiuteryje.\n\nKaip System Package ši programa užima 194 MB vietos tavo kompiuteryje, o kaip Flatpak - 3.7 GB. 3.7 GB atitinka 3700 MB. Taigi beveik 20 kartų daugiau vietos. Tai reiškia, kad Flatpak programai reikia daugiau vietos, nes ji atsisiunčia viską, ko jai reikia.\nGera žinia yra ta, kad kai instaliuosi kitą programą su Flatpak, labai tikėtina, kad kita programa jau galės naudotis kai kuriais dalykais iš pirmosios palapinės. Tada naujai programai reikės mažiau vietos.\nFlatpak programas taip pat galima instaliuoti per Terminal programą.\nTačiau tai šiek tiek skiriasi:\n\nnereikia naudoti sudo\nvietoj apt reikia naudoti flatpak\nnaudojame install\nprogramos pavadinimą galima pasiimti iš Software Manager, bet daugiau Flatpak programų galima rasti ir flathub.org tinklapyje.\n\nVideo",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "3_linux_software.html#software-manager",
    "href": "3_linux_software.html#software-manager",
    "title": "3  Linux programos",
    "section": "5.1 Software Manager",
    "text": "5.1 Software Manager\nPirmiausia pažiūrėkime, kaip ištrinti programas naudojant Software Manager.\n\nAtidaryk Software Manager.\nPaspaudus ant trijų brūkšnelių spausk ant “Show Installed Application” (lt. parodyk įdiegtas programas).\n\n\n\nSurask programą, kurią nori ištrinti, ir spausk ant jos pavadinimo ar piktogramos.\n\n\n\nAtsidariusiame lange spausk ant Remove (lt. pašalinti).\n\n\n\nSoftware Manager programa paprašys patvirtinimo. Spausk Continue, įvesk savo slaptažodį ir spausk Authenticate.",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "3_linux_software.html#menu",
    "href": "3_linux_software.html#menu",
    "title": "3  Linux programos",
    "section": "5.2 Menu",
    "text": "5.2 Menu\nKitas būdas ištrinti programas yra per Menu.\n\nAtidaryk meniu, kur randi visas savo programas.\nDešiniu pelės klavišu spustelk ant programos, kurią nori ištrinti. Prasiskleis papildomas meniu.\nPasirink Uninstall (lt. pašalinti).\nPasirodys patvirtinimo langas. Pasirink OK, įvesk savo slaptažodį ir spausk Authenticate.\n\nVideo",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "3_linux_software.html#terminalas",
    "href": "3_linux_software.html#terminalas",
    "title": "3  Linux programos",
    "section": "5.3 Terminalas",
    "text": "5.3 Terminalas\nProgramas taip pat galima ištrinti per terminalą.\n\n5.3.1 Sisteminis paketas\nNorėdami ištrinti sisteminį paketą, naudokime apt programą. Pavyzdžiui, jei nori ištrinti programą “3dchess”:\n\nAtidaryk terminalą.\nĮrašyk šią komandą: sudo apt remove 3dchess\n\nPaaiškinkime, kas čia yra kas:\n\nsudo - pakelia tavo teises iki administratoriaus ir leidžia ištrinti programas.\napt - programa, kuri įdiegia, atnaujina ir pašalina programas.\nremove - komanda, pasakanti apt, kad reikia ištrinti programą.\n3dchess - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "3_linux_software.html#flatpak-1",
    "href": "3_linux_software.html#flatpak-1",
    "title": "3  Linux programos",
    "section": "5.4 Flatpak",
    "text": "5.4 Flatpak\nPer Terminal irgi galime ištrinti Flatpak programą. Pavyzdžiui, jei nori ištrinti programą org.hedgewars.Hedgewars:\nflatpak uninstall org.hedgewars.Hedgewars\nPaaiškinkime, kas čia yra kas:\n\nflatpak - programa, kuri įdiegia, atnaujina ir pašalina Flatpak programas.\nuninstall - komanda, pasakanti flatpak, kad reikia ištrinti programą.\norg.hedgewars.Hedgewars - argumentas, pasakantis, kokią programą ištrinti.\n\nKompiuteris gali paprašyti patvirtinimo. Įrašyk Y ir spausk Enter.",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "3_linux_software.html#kodėl-per-terminal",
    "href": "3_linux_software.html#kodėl-per-terminal",
    "title": "3  Linux programos",
    "section": "5.5 Kodėl per Terminal?",
    "text": "5.5 Kodėl per Terminal?\nKo gero tau dabar kyla klausimas, kodėl verta mokėti atnaujinti, įdiegti ir ištrinti programas naudojant Terminal?\nNaudoti Terminal gali atrodyti sudėtingiau nei spustelėti pelę, tačiau jis turi daug privalumų.\n\nTerminal leidžia tau atlikti daugybę užduočių labai greitai. Užuot naršant per meniu ir ieškant reikiamų funkcijų, tu gali tiesiog įvesti kelias komandas ir tavo darbas bus atliktas.\nTerminal suteikia daugiau galimybių ir lankstumo. Kai kuriuos dalykus gali padaryti tik per Terminal. Be to, Terminal naudoti gali būti smagu! Tai tarsi magija – tu rašai komandas, o kompiuteris jas vykdo.\nTerminal naudojimas gali padėti tau geriau suprasti, kaip veikia tavo kompiuteris. Kai tu įrašai komandas ir matai, kaip jos veikia, tu pradedi suvokti, kas vyksta tavo kompiuterio viduje.\nTerminal naudojimas gali padėti tau tapti tikru kompiuterių ekspertu. Ir kas žino, galbūt ateityje tave sudomins programavimo, duomenų analitikos ar tiesiog inžinerijos mokslai? Labai daug profesijų pradeda nautodi programavimą kasdieniuose savo darbuose. Aplinkosaugininkai gali tyrinėti kaip keičiasi klimatas ir kaip kinta gamta, buhalteriai gali paspasrtinti ataskaitų ruošimą, architektai apskaičiuoti kaip statyti namą, jog jis nesugriųtų vykstant žemės drebėjimui, robotikos specialistai - kaip sukonstruoti robotoą, kuris važinėja ir tyrinėja Marso planeta…\n\nSkamba truputį sudėtingai, tiesa? Pateiksiu tau pavyzdį. Įsivaizduok, kad tu turi draugę vardu Pelenė. Pelenė irgi turi kompiuterį, bet nežino, kaip įdiegti programas. Tačiau jūs norite kartu žaisti tą patį žaidimą - lenktyniauti žaidžiant Super Tux Cart. Ką daryti?\nTu gali jai parašyti žinutę ir pasakyti, kad nukopijuotų ir paleistų štai tokį kodą:\nsudo apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update && flatpak install net.supertuxkart.SuperTuxKart -y\nNa štai, jeigu jūs turite paskyras Super Tux Cart, dabar galite nuotoliniu būdu lenktyniauti kartu.\nDar neturi paskyros ir elektroninio pašto adreso? Sekančioje pamokoje tai ir susikursime.",
    "crumbs": [
      "Linux Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Linux programos</span>"
    ]
  },
  {
    "objectID": "5_terminal_filesystem.html",
    "href": "5_terminal_filesystem.html",
    "title": "4  Terminalas ir Linux failų sistema",
    "section": "",
    "text": "4.1 Shell ir Terminalas\nŠiek tiek istorijos… Senais laikais kompiuteriai buvo milžiniški. Kad būtų patogiau (santykinai) su jais dirbti, žmonės prisėsdavo prie ekrano su klaviatūra, kuris buvo sujungtas su kompiuteriu. Ši instaliacija – ekranas su klaviatūra – buvo vadinama terminalu. Darbuotojai rašydavo komandas, o kompiuteris jas vykdydavo ir grąžindavo rezultatus. Tais laikais buvo rašomos komandos, nes kompiuteriai dar nebuvo tokie galingi ir neturėjo GUI (graphical user interface, lt - grafinės vartotojo sąsajos). Taigi, terminalas buvo CLI (command line interface, lt- komandų eilutės sąsaja), nes priimdavo komandas. Tai yra vartotojo sąsaja, kurioje komandos įvedamos (input) tekstu, o rezultatai rodomi kaip teksto išvestis (output). Skirtingai nuo GUI, kur naudojami vizualiniai elementai, tokie kaip langai ir mygtukai, CLI leidžia tiesiogiai rašyti instrukcijas, kurias vykdo sistema.\nKiek vėliau, atsiradus ekranams…\nŠiais laikais, kai norime, kad kompiuteris vykdytų komandas, taip pat naudojamės terminalu, tik jau ne fiziniu, o program, kuri emuliuoja fizinį terminalą.\nPrograma, kuri priima ir vykdo komandas, bendrai vadinama Shell. Ji priima komandas, išverčia jas į kompiuterio suprantamą kalbą ir liepia kompiuteriui jas įvykdyti. Po to, gavusi rezultatus, ji juos parodo terminale. Yra keletas skirtingų Shell “kalbų” arba tipų. Populiariausi Shell tipai, tokie kaip Bash (Bourne Again Shell), yra standartinė kiekvienos Linux sistemos dalis. Zsh (Z Shell) yra standartinis Shell MacOS sistemose, tačiau jis vis labiau populiarėja ir tarp Linux vartotojų.\nShell programos leidžia automatizuoti įvairias užduotis ir vykdyti sudėtingas komandas. Be to, Shell turi programavimo kalbos savybių, leidžiančių rašyti skriptus – failus su komandomis, kurios vykdomos viena po kitos.\nTaigi terminalas yra CLI programa, kuri leidžia pasiekti Shell sąsają. Jį galima įsivaizduoti kaip langą kompiuteryje, per kurį įvedi komandas ir matai jų rezultatus. Terminalo programos naudojamos įvairiose operacinėse sistemose, nes jos leidžia efektyviau valdyti sistemą nei daugelis grafinių vartotojo sąsajų. Naudodajantis terminalu, gali atlikti įvairias užduotis greičiau ir tiksliau.\nAtidaryk terminalo programą ir įrašyk šią komandą. Ji parodys, kur yra Shell ir koks būtent Shell tipas naudojamas.\nAtsakymas (output) parodo vykdomojo Shell failo vietą – Shell programą, kuri šiuo metu naudojama tavo terminale. Iš output taip pat gali matyti, koks tai Shell tipas. Šiuo atveju, tai Bash.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "5_terminal_filesystem.html#shell-ir-terminalas",
    "href": "5_terminal_filesystem.html#shell-ir-terminalas",
    "title": "4  Terminalas ir Linux failų sistema",
    "section": "",
    "text": "The IBM 2741 Terminal IBM\n\n\n\n\n\n\n22.0 IBM Modell 360 / 370 IBM\n\n\n\n\n\n\n\nwhich $SHELL",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "5_terminal_filesystem.html#iš-ko-susideda-cli-komanda",
    "href": "5_terminal_filesystem.html#iš-ko-susideda-cli-komanda",
    "title": "4  Terminalas ir Linux failų sistema",
    "section": "4.2 Iš ko susideda CLI komanda?",
    "text": "4.2 Iš ko susideda CLI komanda?\nAtsidaryk terminalo programą. Štai ką turėtum pamatyti:\n\n\n\nTerminal su matomu prompt\n\n\n\nPrompt\n\nTerminale iškart matai prompt – tai teksto eilutė, kuri nurodo, kad sistema yra pasirengusi priimti komandą. Ši eilutė dažniausiai rodo informaciją apie dabartinę direktoriją, vartotojo vardą ar kitus naudingus duomenis. Pavyzdžiui:\njustas@linux-pc:~$\nČia rodoma: vartotojo vardas @ kompiuterio pavadinimas. Simbolis ~ nurodo aktyvią darbinę direktoriją (namų direktoriją), o $ reiškia, kad sistema laukia įvesties (todėl ir vadinama prompt – iššaukimas). Kas yra darbinė direktorija, sužinosime vėliau.\nŠtai pavyzdys, kai Shell yra užsiėmęs ir nėra pasirengęs priimti tavo komandos:\n\n\n\nTerminal vykdo užduotį\n\n\n\nŽymeklis (Cursor)\n\nMirksintis žymeklis (cursor) rodo, kad terminalas pasirengęs priimti kitą įvestį ir nurodo, kurioje vietoje eilutėje bus įrašas.\n\nKomanda (command)\n\nKomanda (angl. command) yra specifinis nurodymas, kurį vartotojas įveda, kad būtų atliktas tam tikras veiksmas sistemoje. Komandos gali būti naudojamos įvairiems veiksmams atlikti, pvz., failų kopijavimui, direktorijų kūrimui ar informacijos rodymui. Pavyzdžiui, komanda ls rodo dabartinės direktorijos failus ir subdirektorijas:\nls\nKai kurios komandos turi subkomandas. Pavyzdžiui, apt yra komanda, atsakinga už programinės įrangos (angl. software) valdymą, tačiau ji naudojama su subkomandomis:\n\napt update:: Atnaujina prieinamų programų sąrašą.\napt install: Instaliuoja nurodytą paketą.\napt remove: Pašalina nurodytą paketą.\napt upgrade: Atnaujina visus diegtus paketus į naujausias versijas\n\nKad bet kas negalėtų instaliuoti programų, ši komanda turi būti vykdoma su administratoriaus teisėmis, pasitelkiant komandą sudo. Todėl kartais naudojamos kelios komandos iš eilės:\nsudo apt update\nsudo apt install cowsay\n\nPasirinkimai ir argumentai (Option, Argument)\n\nPasirinkimas (angl. option) ir argumentas (angl. argument) yra papildomi parametrai, kurie gali būti pridėti prie komandos, siekiant tiksliau nurodyti, kaip komanda turėtų būti vykdoma.\nPasirinkimas (option): Pasirinkimas modifikuoja komandos elgesį. Jis dažnai pridedamas prie komandos su brūkšneliu (-) arba dvigubu brūkšneliu (--). Pavyzdžiui, naudojant ls -l, -l yra pasirinkimas, kuris rodo failų sąrašą ilgąja forma. Naudojant sutrumpintus pasirinkimus, naudojamas vienas brūkšnys -, o išrašant pilną pavadinimą – dvigubas brūkšnys --.\nArgumentas (argument): Argumentas yra papildoma informacija, kurią komanda naudoja veikimui. Pvz., ls Documents nurodo, kad komanda ls turėtų parodyti direktorijos Documents turinį. Šiuo atveju Documents yra argumentas.\n\n\n4.2.1 Praktika\n\nIdentifikuok užklausą (prompt), komandą (command), pasirinkimą (option) ir argumentą (argumentą). Nepanikuok, jei nepažįsti pačių komandų.\n\nmain-user@linux-mint:~$ sudo apt install -y cowsay\nmain-user@linux-mint:~$ cd Downloads\nmain-user@linux-mint:~$ rm -rf test/\nmain-user@linux-mint:~$ ls -alh /home/user/Downloads\nmain-user@linux-mint:~$ mkdir -p /project/data\n\nSurask būdą, kaip sukurti skirtukus (tabs) terminalo lange. Kartais yra labai patogu turėti kelis skirtingus terminalo skirtukus. Pavyzdžiui, viename galite stebėti kompiuterio temperatūrą, kitame valdyti ir paleisti programas, o trečiame - stebėti, ar sistema nefiksuoja kokių nors klaidų. Bet kaip atidaryti skirtukus? Koks yra klaviatūros trumpinys? Jei norėtumėte paleisti ne skirtuką, o atskirą langą, koks trumpinys tai padarytų?\n\n\n\nSusirask terminalo grafinius nustatymus ir pakeisk foną, teksto spalvą ir kitus stiliaus elementus. Rask tau patinkantį stilių. Nebijok eksperimentuoti!\n\n\n\nNors dažniausiai žymeklis yra blyksintis kvadratėlis, surask, kaip jį pakeisti į |?",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "5_terminal_filesystem.html#linux-failų-sistema",
    "href": "5_terminal_filesystem.html#linux-failų-sistema",
    "title": "4  Terminalas ir Linux failų sistema",
    "section": "4.3 Linux failų sistema",
    "text": "4.3 Linux failų sistema\nTerminai “direktorija”, “katalogas” ir “aplankas” dažnai vartojami kaip sinonimai ir paprastai reiškia tą patį – vietą failų sistemoje, kur gali būti saugomi failai ir kiti subkatalogai. Tačiau yra keletas kultūrinių ir kontekstinių niuansų:\n\nDirektorija (angl. directory): Techninis terminas, dažniausiai vartojamas Unix/Linux bendruomenėje ir kitose techninėse aplinkose. Jis pabrėžia hierarchinę failų sistemos struktūrą.\nKatalogas: Tai dar vienas techninis terminas, dažnai vartojamas kaip sinonimas direktorijai. Šis terminas paplitęs tiek techninėje, tiek kasdieninėje kalboje.\nAplankas (angl. folder): Terminas, dažniausiai naudojamas grafinėse vartotojo sąsajose (GUI), pavyzdžiui, Windows ir Mac OS. Nors jis iš esmės reiškia tą patį kaip direktorija ar katalogas, jis dažniau vartojamas GUI kontekste.\n\nČia aš naudosiu terminą „direktorija“, nes jis yra artimiausias angliškam „directory“. Tačiau kartais galiu panaudoti ir „aplanką“ ar „katalogą“, tad nenustebk.\n\n4.3.1 sudo\nPraeitame skyriuje aptarėme, kad tam tikroms komandoms vykdyti reikia naudoti sudo, t.y., eskaluoti (pakelti) savo vartotojo privilegijas iki administratoriaus (root) lygio. Tam reikia įvesti slaptažodį. Taip užtikrinamas saugumas, kad bet kas negalėtų vykdyti pavojingų veiksmų sistemoje.\nPaprastas vartotojas (user) ir administratorius (root) Linux sistemoje turi skirtingas teises ir privilegijas:\nuser:\n\nTeisės: Turi ribotas teises, gali atlikti veiksmus tik savo namų direkorijoje (home directory) ir kitose direktorijose, kuriose turi suteiktas teises.\nPriėjimas: Negali atlikti sisteminės administracijos užduočių, pvz., negali įdiegti ar pašalinti programinės įrangos, keisti sisteminių failų ar atlikti daugumos konfigūracijos pakeitimų.\n\nroot\n\nTeisės: Turi pilną administracinę prieigą prie visos sistemos. Gali atlikti bet kokias užduotis, įskaitant sisteminių failų modifikavimą, vartotojų administravimą, programinės įrangos diegimą ir pašalinimą.\nPriėjimas: Gali atlikti bet kokias operacijas be apribojimų.\n\nPaprastas vartotojas, vykdydamas sudo, gali laikinai gauti root teises, pvz.:\nsudo apt install &lt;programa&gt;\nPerėjimas iš paprasto vartotojo į root yra galimas tik tiems vartotojams, kurie yra įtraukti į sudo grupę. Instaliuojant Linux, pirmasis vartotojas automatiškai pridedamas prie šios grupės, tačiau vėliau sukurti vartotojai gali būti pridėti į sudo grupę pagal poreikį.\n\n\n4.3.2 root direktorija\nWindows operacinėje sistemoje turbūt matei diskus, pažymėtus raidėmis, pavyzdžiui, C:, D:, E:. Tai nereiškia, kad kompiuteryje yra keli fiziniai kietieji diskai. Dažniausiai tai yra vienas kietasis diskas, padalytas į logines dalis.\n\n\n\nŠaltinis OnlineComputerTips\n\n\nPavyzdžiui, C: diske paprastai saugomi Windows failai, o vartotojai dažnai naudoja kitą diską failams saugoti. Šie „diskai“ yra visiškai atskirti vienas nuo kito.\nLinux sistemoje viskas veikia šiek tiek kitaip. Net jei kompiuteryje būtų keli fiziniai diskai, jie gali būti sujungti į vieną loginę talpą (angl. logical volume) ir „pakišti“ po root direktorija, kuri žymima /.\nRoot direktorija yra failų sistemos viršūnė, žymima /. Visi kiti failai ir direktorijos yra šios šakninės direktorijos pavaldiniai. Tai atitinka Windows C: diską.\n\n\n\nŠaltinis\n\n\nČia rasi daug subdirektorijų. Svarbiausios iš jų:\n\n/root: Root vartotojo (administratoriaus) namų direktorija.\n/etc: Konfigūracijos failai, kurie kontroliuoja įvairių programų paleidimą ir veikimą.\n/home: Paprastų vartotojų namų direktorijos, pvz., /home/justas/, /home/ruprecht/.\n/mnt: Laikina vieta prijungtoms laikmenoms, tokioms kaip kietieji diskai ar tinklo diskai.\n/media: Katalogas, kuriame pritvirtinami USB, CD ar DVD įrenginiai.\n/bin: Sisteminiai vykdomieji failai, pvz., ls, cp, mv.\n/lib: Bibliotekos, būtinos sisteminėms programoms ir komandų vykdymui.\n\nKai atidarai failų naršyklę (Linux Mint tai programa Nemo), tavo namų direktorija bus po /home/vartotojas/. Štai kaip atrodytų naršy\n/\n└── home\n    ├── user name\n\nVisada gali pasitikrinti savo buvimo vietą, paspaudžiant ant „Toggle Location Entry“:\n\n\n\n4.3.3 Praktika\n\nAtsidaryk excalidraw naršyklėje ir nupiešk /, /home/, /media/ struktūros diagramą. Įsivaizduok, kad kompiuteryje yra trys vartotojai: justas, ruprechtas ir slibinas. Nupiešk jų namų direktorijas.\nĮkišk USB laikmeną į kompiuterį, atidaryk failų naršyklę (Nemo). Turėtum pamatyti kažką panašaus. Paspausk ant USB laikmenos, tada spustelėk „Toggle Location Entry“ ir identifikuok, kurioje failų sistemos vietoje yra USB laikmena. Pridėk tai prie diagramos, kurią piešei.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "5_terminal_filesystem.html#keliavimas-failų-sistema",
    "href": "5_terminal_filesystem.html#keliavimas-failų-sistema",
    "title": "4  Terminalas ir Linux failų sistema",
    "section": "4.4 Keliavimas failų sistema",
    "text": "4.4 Keliavimas failų sistema\nJau šiek tiek susipažinai su Linux failų sistemos struktūra. Kai atsidarai failų naršyklę (Nemo), matai šias direktorijas:\n\nDirektorijų medyje tai atrodytų taip:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\nŠiame skyriuje išmoksi, kaip sužinoti, kur esi, su komanda pwd, kaip pakeisti direktoriją su cd ir kaip atspausdinti failų bei direktorijų sąrašą su ls.\nTačiau prieš einant prie pačių komandų, tau dar reikis susipažinti su vienu svarbiu konceptu - absoliučiu ir relatyviu adresu (arba keliu, nes angliškai - path).\n\n4.4.1 Absoliutus kelias\nAbsoliutus kelias (angl. absolute path) yra pilnas kelias nuo šaknies direktorijos (/) iki konkretaus failo ar katalogo. Jis visada nurodo tą pačią vietą, nepriklausomai nuo to, kur esi šiuo metu.\nPavyzdžiui, šis kelias nurodo visą maršrutą nuo / per /home/, vartotojo namų direktoriją /justas/iki subdirektorijos Documents, kurioje yra failas data.csv:\n/home/justas/Documents/data.csv\n\n\n4.4.2 Relatyvus kelias\nRelatyvus kelias (angl. relative path) yra nurodomas atsižvelgiant į dabartinę darbinę direktoriją. Jis neturi pradinio /, todėl priklauso nuo to, kur esi.\nJeigu šiuo metu esi direktorijoje/home/justas, relatyvus kelias į failą data.csv subdirektorijoje Documents būtų:\nDocuments/data.csv\nKartais gali pamatyti relatyvų kelią su . (tašku), kuris reiškia “esama direktorija”. Taigi šis relatyvus kelias irgi tinka:\n./Documents/data.csv\n\n\n4.4.3 ~\nVartotojų vardai Linux sistemoje gali skirtis, pvz., justas, ruprechtas ir t.t. Tarkime, rašai skriptą, kuris turi veikti vartotojo Downloads direktorijoje. Tu negali žinoti vartotojo vardo, todėl naudoti absoliutų kelią /home/justas/Downloads būtų nepatogu.\nBet ir relatyvus kelias ./Downloads gali sukelti problemų, nes skriptas gali būti paleistas ne iš vartotojo namų direktorijos, o tiesiai iš Downloads direktorijos, kas sukurtų absurdišką Downloads/Downloads.\n/\n└── home\n    ├── justas\n    │   ├── Downloads\n    │     ├── ./Downloads\nŠtai čia gelbsti ~. Shell atpažįsta ~ kaip nuorodą į dabartinio vartotojo namų direktoriją.\nTaigi relatyvus kelias~/Downloads yra automatiškai keičiamas į /home/justas/Downloads, jeigu vartotojas yra justas, arba į /home/ruprecht/Downloads, jeigu vartotojo vardas yra ruprecht.\nKada naudoti ką?\n\nAbsoliutūs keliai dažniausiai naudojami skriptuose, konfigūracijų failuose, dokumentacijoje ir sisteminiuose veiksmuose.\nRelatyvūs keliai labiau tinka kasdieniam darbui su failais, naršymui ir interaktyviam scenarijų vykdymui.\n\n\n\n4.4.4 pwd\nJau kelis kartus minėjome darbinę direktoriją. Kas tai? Darbinė direktorija yra ta direktorija, kurioje šiuo metu “gyvena” shell. Įsijunk terminalą, įrašyk komandą pwd ir paspausk Enter, kad ją įvykdytum. Komanda pwd (angl. “print working directory”) parodo dabartinės darbinės direktorijos pilną kelią (path).\npwd\n\nŠiuo atveju darbinė direktorija yra /home/justas.\nTaigi, iš mano darbinės direktorijos, Downloads subdirektorijoje esantis failas data.csv man būtų pasiekiamas Downloads/data.csv keliu. Tačiau aš galiu pakeisti savo darbinę direktoriją pereidamas į kitas direktorijas su komanda cd.\n\n\n4.4.5 cd\nKomanda cd (angl. change directory) naudojama pereiti iš vienos direktorijos į kitą. Kai pereini į kitą direktoriją, pasikeičia ir darbinė direktorija, kartais dar vadinama aktyvia direktorija (angl. current directory).\nĮvedęs komandą:\ncd Downloads\nAš pereinu į Downloads subdirektoriją. Kadangi Downloads yra mano namų direktorijoje, galėjau pasinaudoti relatyviu keliu. Atkreipk dėmesį, kaip pasikeičia terminalo prompt: vietoj ~ (jau žinai, ką jis reiškia), dabar matosi ~/Downloads.\n\nDabar failas Downloads/data.csv tampa pasiekiamas tiesiog kaip data.csv.\nKomandai cd gali duoti absoliutų kelią, ir tada cd pakeis darbinę direktoriją, nesvarbu, kur tuo metu esi:\ncd /home/justas/Documents\nŠi komanda perkelia mane iš Downloads tiesiai į Documents.\n\nTačiau cd komandai gali nurodyti ir relatyvų kelią, svarbu, kad jis egzistuotų. Pavyzdžiui, aš galiu pereiti iš savo namų direktorijos į Downloads su cd Downloads/, tačiau negaliu pereiti į Documents, jei esu Downloads direktorijoje, nes Documents ten nėra. Tada gaunu klaidos pranešimą: bash: cd: Documents/: No such file or directory.\n\nPriminimui:\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\n    │   ├── Music\n    │   ├── Pictures\n    │   ├── Public\n    │   ├── Templates\n    │   └── Videos\nKaip jau minėjau, taškas . reiškia “čia”. Pvz., iš namų direktorijos galėčiau pereiti į Downloads su cd ./Downloads.\nYra ir .., du taškai, kurie reiškia direktoriją esančią aukščiau už dabartinę (.) direktoriją. Ji dažnai vadinama parent directory. Taigi, su komanda cd ./Downloads nuėjęs į Downloads, galiu vėl pakilti į viršų su cd ...\n\n.. taip pat gali būti naudojama pereiti relatyviai, pvz., iš Downloads į Documents. Būdamas Downloads direktorijoje, galiu naudoti komandą cd ../Documents, kad pakilčiau vienu lygiu aukščiau ir tada pereičiau į Documents.\n\n.. gali būti naudojama ir kelis kartus iš eilės, pvz., iš Downloads galima pakilti į home, naudojant cd ../...\n\nPriminimui\n/\n└── home\n    ├── justas\n    │   ├── Desktop\n    │   ├── Documents\n    │   ├── Downloads\nKomandą cd gali naudoti ir be jokių argumentų, kad grįžtum į namų direktoriją, pvz., cd arba su cd ~.\n\nPereiti į ankstesnę direktoriją gali su komanda cd -. Tarkime, buvau home/justas/Downloads, perėjau į home/justas/Documents, bet supratau, kad padariau klaidą - norėčiau likti Downloads. Galiu grįžti atgal su cd -.\n\nSveikinu! Dabar jau moki naršyti po direktorijas naudojant terminalą. Nors tai gali atrodyti sudėtinga iš pradžių, laikui bėgant pastebėsi, kad paleisti terminalą su klaviatūros trumpiniu Ctrl-Alt-T ir, naudojant TAB greitesniam komandų ir argumentų užpildymui, greitai nueiti į norimą direktoriją bei redaguoti failus bus daug greičiau nei tai daryti su grafinės sąsajos (GUI) įrankiais.\nPvz., iš savo namų direktorijos pereinu į Documents, tada į project, tada į documentation, atspausdinu failų sąrašą su ls ir redaguoju failą su nano programa.\nVideo\nBet kas ta ls komanda?\n\n\n4.4.6 ls\nKomanda ls (angl. list) naudojama norint peržiūrėti failų ir katalogų sąrašą dabartinėje arba nurodytoje direktorijoje. Tai viena dažniausiai naudojamų komandų, naviguojant failų sistemoje.\nJei atidarytum failų naršyklę, pavyzdžiui, Nemo, matytum kažką panašaus:\n\nLygiai taip pat failų sąrašą gali parodyti ir terminale, įvedant komandą ls:\n\nKomanda ls gali priimti argumentą – direktorijos kelią, kurio turinį norima parodyti. Šis kelias gali būti tiek absoliutus, tiek relatyvus. Pavyzdžiui, ls /home/justas/Downloads parodys Downloads katalogo turinį. Atkreipk dėmesį į spalvas: failai yra balti, o katalogai – mėlyni.\n\nKartais pamatyti tik failų pavadinimus gali būti nepakankama. Galbūt norisi matyti daugiau informacijos, pvz., kada failai sukurti, kas turi teises juos valdyti ar matyti, ar kam jie priklauso.\n\nKaip ir failų naršyklėje, kur gali perjungti į “List View”, terminale gali naudoti komandos ls nustatymą -l, kuris išveda išsamų (ilgą) failų sąrašą su papildoma informacija: teisėmis, savininku, dydžiu ir paskutinio modifikavimo data.\n\nPavyzdžiui ką tokią eilutė reikšia, paaikšinsiu netrukus.\ndrwxr-xr-x 2 justas justas 4096 Sep 15 10:19 Desktop\nNorint pamatyti visus failus, įskaitant paslėptus (failai, kurių pavadinimai prasideda tašku), gali naudoti -a arba --all:\n\nNemo failų naršyklėje taip pat gali pamatyti paslėptus failus, jei aktyvuosi šią funkciją.\nVideo\nKai paleidi ls -l, failų dydžiai nurodomi baitais. Kartais naudingiau matyti dydžius, išreikštus žmonėms suprantamesniais vienetais, kaip kilobaitai (1000 baitų), megabaitai (1000 kilobaitų) ir t.t. Tam gali naudoti nustatymą --human-readable arba trumpinį -h - ls -lh\nŠios abi komandos ls -all -l --human-readable ir ls -alh yra teisingos, tačiau dažniau naudojamas trumpesnis variantas. Panaudojant ls -alh, galėsi matyti paslėptus failus, o failų dydžiai bus išreikšti žmonėms labiau suprantama forma.\n\nKartais gali prireikti rekursyvaus katalogo turinio peržiūros. Komanda ls -R arba ls --recursive parodys ne tik pasirinktos direktorijos, bet ir visų jos subdirektorijų turinį.\n\n\n\n4.4.7 Teisės ir tipai\nŠi eilutė rodo failų arba direktorijų sąrašą su jų detalėmis:\n\nPirmas stulpelis parodo, kokio tipo failas ar direktorija tai yra, ir kokias teises turi skirtingi vartotojai.\nPirmoji raidė gali būti:\n\nd – Direktorija (directory)\nl – Simbolinė nuoroda (link)\n- – Įprastas failas (regular file)\n\nLinux sistemoje yra trys vartotojų tipai:\n\nSavininkas – vartotojas, kuris sukūrė failą arba direktoriją. Šiuo atveju vartotojas yra justas.\nGrupė – Grupė, kuriai priklauso failo savininkas. Dažnai grupės vardas yra tas pats kaip ir savininko vartotojo vardas, pvz., justas. Vartotojai gali priklausyti kelioms grupėms, tačiau kiekvienas failas ir direktorija turi pagrindinę grupę, kuri turi tam tikras teises į tą failą arba direktoriją. Pameni minėjom, kad ne visi vartotojai priklauso sudo grupei? Čia panašiai, tik kita grupė.\nKiti (other) – Visi kiti vartotojai, kurie nėra nei savininkas, nei grupės nariai. Tai apima visus kitus sistemos vartotojus, kurie neturi specialių teisių šiam failui ar direktorijai.\n\nTeisės nurodomos pirmame stulpelyje trimis tripletais: xxx-xxx-xxx (be brūkšnių).\n\nr – Skaitymo teisė (read), leidžia matyti ir skaityti turinį.\nw – Rašymo teisė (write), leidžia perrašyti turinį.\nx – Vykdymo teisė (execute), leidžia vykdyti failą.\n\nPvz., teisės drwxr-xr-x:\n\nd – Direktorija (directory)\nrwx – Savininko teisės: skaitymas (read), rašymas (write), vykdymas (execute)\nr-x – Grupės teisės: skaitymas (read), vykdymas (execute)\nr-x – Kitų vartotojų teisės: skaitymas (read), vykdymas (execute)\n2 – Nuorodų skaičius į šią direktoriją. Tai apima nuorodą į pačią direktoriją ir bet kurias subdirektorijas. Pavyzdžiui, jei skaičius būtų 4, tai reikštų, kad direktorijoje yra trys subdirektorijos (ir arba failai) ir viena pati direktorija.\njustas – Direktorijos savininko vartotojo vardas.\njustas – Direktorijos grupės vardas.\n4096 – Direktorijos dydis baitais.\nSep 15 10:19 – Paskutinio direktorijos modifikavimo data ir laikas.\nDesktop – Direktorijos pavadinimas.\n\n\n\n4.4.8 Pagalbinės funkcijos terminale\n\n\n4.4.9 history\nKomanda history (liet. „istorija“) naudojama norint parodyti visų anksčiau įvestų komandų sąrašą dabartinėje terminalo sesijoje. Tai suteikia patogų būdą sekti ir kartoti anksčiau vykdytas komandas.\n\nJei nori parodyti tik paskutines n komandų, gali naudoti history n. Pvz., parodyti paskutines 10 komandų history 10:\n\nKartoti konkrečią komandą pagal numerį galima įrašius ! ir komandos numerį. Pavyzdžiui, jei nori pakartoti komandą, kurios numeris yra 99:\nhistory\n!99\n\nIštrinti komandų istoriją galima su history -c.\nhistory -c\nhisotry\n\n\n\n4.4.10 clear\nKomanda clear (liet. „valyti“) naudojama norint išvalyti terminalo ekraną, pašalinant visus anksčiau įvestus ir parodytus tekstinius duomenis. Tai palieka terminalą švarų ir patogesnį tolimesniam naudojimui. Svarbu: ši komanda neištrina terminalo istorijos (history); ji tik paslenka visą tekstą į viršų, už dabartinio vaizdo ribų.\nclear\n\n\n4.4.11 Ctrl-L\nAlternatyva komandos clear naudojimui yra klaviatūros trumpinys Ctrl-L. Šis trumpinys atlieka tą pačią funkciją kaip ir komanda clear, tačiau jis yra greitesnis ir patogesnis, ypač kai dirbi terminale ir nori greitai išvalyti ekraną. Naudojant Ctrl-L, terminalo ekranas bus išvalytas, tačiau terminalo istorija liks nepakitusi.\n\n\n4.4.12 Navigacija terminale\nRašant ilgas komandas, klaidos neišvengiamos. Pavyzdžiui, rašai „Hello World“ ir paspaudi Enter ⏎, tik tada supranti, kad reikėjo parašyti echo prieš „Hello World“.\nŠtai kaip tai gali ištaisyti:\n\nPakilk į ankstesnę eilutę naudodamas rodyklę į viršų ⬆️.\nPerkelk kursorių į eilutės pradžią naudodamas rodyklę į kairę ⬅️.\nPrirašyk echo ir pakartok komandą paspaudus Enter ⏎.\n\nVideo\nKartais eilutės būna gana ilgos:\nsud apt update && sudo apt full-upgrade -y && sudo apt autoremove -y && flatpak update\nJei praleidai raidę, pavyzdžiui, pirmame sudo truksta o, nereikia viską iš naujo rašyti\n\nPakilk į ankstesnę eilutę naudodamas rodyklę į viršų ⬆️.\nNaudokCtrl-A, kad perkeltum kursorių į eilutės pradžią.\n➡️ ➡️ ➡️ ir pridėti o raidę.\npabaigus taisymą tiesiog paspausti Enter ⏎ (nebūtina nueiti į eilutės pabaigą)\n\nVideo\nTavo žiniai:\n\nCtrl-A: perkelia kursorių į eilutės pradžią\nCtrl-E: perkelia kursorių į eilutės pabaigą\nCtrl-U: ištrina viską į dešinę nuo kursoriaus\n\nUžduotis:\nPastebėsi, kad Ctrl-C ir Ctrl-V neveikia taip, kaip esame įpratę. Terminalo nustatymuose (settings) rask derinį, kuris atitinka įprastines Ctrl-C ir Ctrl-V kombinacijas.Kokie jie?\n\n\n4.4.13 Ctrl-C ir Escape\nNaudojant komandinę eilutę, kartais terminalas gali „pakibti“. Pvz., jei pradėsi rašyti echo su kabutėmis, bet pamirši uždaryti kabutes, terminalas lauks, kol užbaigsi komandą.\nTokiais atvejais terminalas gali atrodyti „pakibęs“. Pabandyk paleisti šias komandas po vieną:\n$ echo \"hello\n$ grep foobar\n$ yes\n$ tail\n$ cat\nNorėdamas nutraukti „pakibusią“ komandą, naudok Ctrl-C. Šis derinys siunčia kontrolės signalą terminalui ir nutraukia vykdomą procesą. Pastaba: Ctrl-C čia reiškia „Cancel“ (nutraukti).\nKartais terminale gali pamatyti ^C, rodančią, kad buvo paspaustas Ctrl-C. Jei Ctrl-C neveikia, pabandyk ESC klavišą.\nVerta žinoti: kad kartais vietoj Ctrl- notacijos, gali sutikti ^ notaciją, pvz., ^C, ^O, ^X.\n\n\n4.4.14 Praktika\n\nKai paleidi terminalą, kurioje direktorijoje esi? Pakeisk direktoriją į Downloads. Uždaryk terminalą ir paleisk jį iš naujo. Kur dabar esi?\nIš/home/user/ direktorijos pereik į Downloads ir atspausdink direktorijos turinį naudojant ls. Užduotis:\n\nFailų dydis būtų suprantamas žmonėms.\nSąrašas būtų pateikiamas viename stulpelyje.\n\nIš /home/user/ direktorijos pereik į Documents. Iš ten atspausdink failų sąrašą Downloads (!!!) direktorijoje\n\nnaudojant absoliutų kelią\nnaudojant relatyvų kelią\n\n\nPagalbai:\nHome Directory/\n├── Desktop/\n├── Documents/\n├── Downloads/\n├── Music/\n├── Pictures/\n├── Public/\n├── Templates/\n└── Videos/\n\nNaudok clear, kad išvalytum terminalą, tada su history surask tau patinkančią komandą ir pakartok ją naudojant !n.\nVizualizuok vartotojų ir grupių santykius pagal šią lentelę. Naudok Excalidraw:\n\n\n\n\nVartotojas\nSudo grupė\nGrupė “namai”\n\n\n\n\nroot\nTaip\nTaip\n\n\njustas\nTaip\nTaip\n\n\nruprechtas\nNe\nTaip\n\n\n\n\nĮsivaizduok, kad failas /home/ruprechtas/info.txt turi tokias savybes:\n\n-rwx----- 2 ruprechtas namai 4096 Sep 15 10:19 info.txt\nAr vartotojas justas, priklausantis grupei namai, galės atidaryti ir perrašyti šį failą? Kodėl?\n\nKą reikėtų pakeisti, kad vartotojas justas galėtų matyti ir perrašyti šį failą? Atsakyk teoriškai (nes dar nežinai komandų, kuriomis tai apdaryti).\nNukopijuok ir paleisk šią komandą terminale.\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/e61bb3ab5cf28686f74a50e436b06fe6/raw | bash\nŠi komanda parsisiųs ir įvykdys skriptą, kuris sukurs test direktoriją tavo/home/username/ direktorijoje.\nPasinaudok ls, atspausdink visus failus, esančius (sub-)direktorijose ir atsakyk į šiuos klausimus:\n\nKiek yra subdirektorijų test direktorijoje?\nKiek iš viso suskaičiuoji failų? Suskaičiuok visus failus, esančius visose subdirektorijose.\nKokio tipo failų (pvz., .txt, .csv) yra daugiausia? Kurioje direktorijoje?",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "5_terminal_filesystem.html#funkcijos",
    "href": "5_terminal_filesystem.html#funkcijos",
    "title": "4  Terminalas ir Linux failų sistema",
    "section": "4.5 Funkcijos",
    "text": "4.5 Funkcijos\nVisos skyriuje panaudotos funkcijos\n\n\n\n\n\n\n\nFunkcija\nAprašymas\n\n\n\n\nwhich\nParodo vykdomojo failo vietą\n\n\npwd\nParodo dabartinės darbinės direktorijos pilną kelią\n\n\ncd\nPakeičia dabartinę direktoriją (esamą vietą) terminale\n\n\nls\nRodo failų ir katalogų sąrašą direktorijoje\n\n\nsudo\nLeidžia vykdyti komandas su kitokio vartotojo teisėmis (dažniausiai root)\n\n\nhistory\nRodo ankstesnių komandų istoriją\n\n\nclear\nIšvalo terminalo ekraną\n\n\nCtrl-A\nPerkelia kursorių į eilutės pradžią\n\n\nCtrl-E\nPerkelia kursorių į eilutės pabaigą\n\n\nCtrl-U\nIštrina viską į kairę nuo kursoriaus\n\n\nCtrl-C\nNutraukia vykdomą komandą terminale\n\n\nCtrl-L\nIšvalo terminalo ekraną (panašu į clear)\n\n\nShift-Ctrl-C\nKopijuoja tekstą iš terminalo\n\n\nShift-Ctrl-V\nĮkelia tekstą į terminalą\n\n\nShift-Ctrl-T\nSukuria naują terminalo skirtuką\n\n\nShift-Ctrl-N\nSukuria naują terminalo langą",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Terminalas ir Linux failų sistema</span>"
    ]
  },
  {
    "objectID": "6_bash_comands_basic.html",
    "href": "6_bash_comands_basic.html",
    "title": "5  BASH komandos",
    "section": "",
    "text": "5.1 Failų ir direktorijų valdymas\nPraėjusiame skyriuje išmokai naviguoti terminale naudojant komandas pwd ir cd. Sužinojai apie Linux failų sistemą: kaip matyti visų failų ir katalogų sąrašą naudojant ls komandą, bei tai, kad Linux sistemoje vartotojai turi skirtingas teises, priklauso grupėms, ir kiekvienas failas turi savininko, grupės, bei kitų vartotojų teises naudotis tuo failu ar katalogu. Taip pat išmokai svarbių klaviatūros trumpinių, kaip peršokti į komandinės eilutės pradžią (Ctrl-A), pabaigą (Ctrl-E), nutrinti dalį (Ctrl-U), kaip kopijuoti ir įklijuoti į terminalą naudojant Ctrl-Shift-C ir Ctrl-Shift-V. Išmokai dirbti su terminalo istorija naudojant history ir kartoti komandas su !n.\nŠiame skyriuje skirsi dėmesį darbui su failais ir direktorijomis. Tu išmoksi kurti failus ir direktorijas, juos kopijuoti, perkelti, ištrinti. Taip pat išmoksi sujungti kelias komandas. Ir šio skyriaus pabaigoje pamatysi, kad tavo BASH įgūdžiai tampa dar stipresni!\nPrieš pradedant, įsitikink, kad turi keletą svarbių programų: jq ir curl. Kaip ir praėjusiame skyriuje, kai ieškojaiwhich $SHELL, komanda tau parodė, kur yra binary failas (programa). Dabar padaryk tą patį:\nJei tavo kompiuteris aptinka šias programas, terminalas atspausdins vietą, kur jos yra įdiegtos. Jei terminalas jų neranda, įdiek curl ir jq kaip sisteminius paketus naudojant apt. Jei pamiršai, kaip tai daryti, pakartok ankstesnę medžiagą.\nKai tai atliksi, nukopijuok ir paleisk šią komandą savo terminale - ji sukurs direktoriją shell_2_dalis tavo namų direktorijoje kartu su visais šiam skyriui reikalingais failais:\nJeigu viskas gerai, turėtum pamatyti:\nSu ls komanda atspausdink long formatu savo home directory turinį. Paaiškink visas šios eilutės reikšmes.\nPakeisk savo darbinę direktoriją į ~/shell_2_dalis. Kaip pasikeitė tavo prompt? Paaiškink, kas čia yra kas.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "6_bash_comands_basic.html#failų-ir-direktorijų-valdymas",
    "href": "6_bash_comands_basic.html#failų-ir-direktorijų-valdymas",
    "title": "5  BASH komandos",
    "section": "",
    "text": "By J. Howard Miller - U.S. National Archives and Records Administration\n\n\n\n\nPatikrink, ar turi curl, su which curl.\nPatikrink, ar turi jq, su which jq.\n\n\n\n\ncurl -s https://gist.githubusercontent.com/justasmundeikis/b4bfc0d672a859afc0fe28f1e721e167/raw | bash\n\n\n\n\n\n\n\n\nTip\n\n\n\nPasikartok komandas cd, prisimink absoliutų ir reliatyvų kelią, bei ką reiškia ~, . ir ... Šiame skyriuje taip pat dažnai reikės naudoti ls, tad pasikartok šią komandą ir jos nustatymus dabar.\n\n\n\n\n\n\n\n5.1.1 echo\nKomanda echo naudojama norint atspausdinti vartotojo įvestį (input) terminale (dar vadinamą standartine išvestimi, angl. standard output). Tai paprasta, bet galinga komanda, dažnai naudojama skriptuose pranešimams rodyti arba kintamųjų reikšmėms tikrinti.\nNors nėra būtina tekstą apskliausti kabutėmis, dėl geresnio aiškumo ir įskaitomumo patartina tai daryti.\necho Hello World!\necho 'Hello World!'\necho \"Hello World!\"\nReikėtų atkreipti dėmesį, jog dvigubos kabutės (\" \") ir viengubos kabutės (' '’) šiek tiek skiriasi. Tekstas, esantis viengubose kabutėse (' '), atspausdinamas paraidžiui, nepaisant ten esančių kintamųjų. Tuo tarpu tekstas, esantis dvigubose kabutėse (\" \"), yra interpretuojamas, ir Shell leidžia naudoti kintamųjų vertes.\nPabandyk šias komandas, kurios naudoja kintamąjį $USER, atspausdinantį shell sesijos vartotojo vardą:\necho My username is $USER\necho 'My username is $USER'\necho \"My username is $USER\"\nAr pastebi, kuo skiriasi išvestis?\n\n\n\n5.1.2 &gt; ir &gt;&gt; operatoriai\n&gt; ir &gt;&gt; operatoriai naudojami išvesties nukreipimui (angl. output redirection). Jie nukreipia komandos išvestį (angl. output) į failą, o ne į terminalą. Šie operatoriai yra esminiai dirbant su failais ir automatizuojant užduotis skriptuose.\n&gt; operatorius nukreipia komandos išvestį į failą, perrašydamas jo turinį, jei failas jau egzistuoja. Jei failas neegzistuoja, jis bus sukurtas.\nŠi komanda sukuria (arba perrašo) failą hello_world.txt su tekstu “Hello World!”.\necho \"Hello World!\" &gt; hello_world.txt\nKaip echo komanda ir jos argumentas “Hello World!” buvo nukreipti į tekstinį failą, taip galime nukreipti ir kitų komandų išvestis į failus. Operatoriaus &gt; argumentas nebūtinai turi būti tik failo pavadinimas, tai gali būti ir failo pavadinimas su absoliučiu ar reliatyviu adresu.\nls &gt; mix/direktorijos_turinys.txt\nŠi komanda nukreipia ls komandos išvestį į failą direktorijos_turinys.txt, kuris yra mix subdirektorijoje. Atsidaryk šį failą ir patikrink, ar jis susikūrė teisingai. Turėtum matyti kažką panašaus į šį vaizdą:\n\n\n\n\n\n\n\nPraktika\n\n\n\nLiekant shell_part_2 direktorijoje, atspausdink namų direktorijos (angl. home directory) turinį su visais paslėptais failais, ilguoju formatu ir žmonėms geriau suprantamais failų ir direktorijų dydžiais, ir nukreipk išvestį į mix subdirektorijoje esantį failą direktorijos_turinys.txt, jį perrašant.\n\n\n\nIntarpas\nHey, ką tik gavai užduotį. Ateityje gausi panašias ir dar sudėtingesnes užduotis. Todėl šioje vietoje padarykime intarpą. Pakalbėkime apie vieną svarbiausių darbo būdų programavime (ir ne tik!) – darbų skaidymą (angl. break down).\nKartais gali gauti labai sudėtingą užduotį, kuri iš pradžių atrodys neįveikiama ar nesuprantama. Tai visiškai normalu. Nestresuok – giliai įkvėpk, iškvėpk, jei reikia, pasiimk popierių ir pieštuką ir pradėk skaidyti darbus į logines sekas. Pvz., prieš tai buvusią užduotį galima suskaidyti į tris dalis:\n\nreikia failų ir direktorijų sąrašo\natspausdinti perrašant\nfailo pavdinimas\n\n\nDabar galima skaidyti ar toliau detalizuoti kiekvieną iš šių dalių.\n\nls -alh pagamina sąrašą ilguoju, žmonėms suprantamų dydžių formatu\n&gt; perrašo\ndirektorijos_turinys.txt bus pavadinimas\n\n\nTačiau dabartinė darbinė direktorija yra ~/shell_part_2, todėl reikia\n\nls -alh kaip argumentą paduoti ~ arba atitinmai /home/username\ndirektorijos_turinys.txt turi būti mix subdirektorijoje\n\n\nSkaidant užduotį į mažesnes dalis, vis labiau suprasi, ką reikia padaryti. Turint daugiau patirties, geriau žinosi, kiek laiko gali prireikti kiekvienam žingsniui.\nPvz., duomenų analitikas gali gauti užduotį: suprognozuoti sekančių metų ledų pardavimus. Analitikas, žinodamas, kad ledų pardavimai priklauso nuo lauko temperatūros, gali suskaidyti darbus taip:\n\nImportuoti istorinius tam tikros vietos temperatūros duomenis\nPrognozuoti sekančių metų kiekvienos dienos temperatūras\nApskaičiuoti kiekvienos dienos pardavimus\nAprašyti duomenis ir pateikti juos užsakovui suprantamu formatu\n\n\n\n\nPhoto by Kamaji Ogino\n\n\nKiekvieną iš šių žingsnių analitikas gali suskaidyti į dar daugiau mažesnių užduočių.\nKodėl tai svarbu? Visų pirma, tai padeda geriau suprasti, ką reikia padaryti, ir kiek tai gali užtrukti. Kiekvienas žingsnis tampa atskiru procesu, ir jei nepavyksta vienas metodas, gali bandyti kitą.\nDarbų skaidymas yra intuityvus procesas kasdieniame darbe ir tu jau šį metodą ir taip taikai pasąmoningai, bet kai gauname naujas ir labai sudėtingas užduotis, vis tiek verta prisiminti šią strategiją, nes kartais mes pamirštame, kaip ji padeda išvengti pasimetimo.\n\n&gt;&gt; operatorius nukreipia komandos išvestį į failą, pridedant (angl. append) prie failo turinio. Jei failas neegzistuoja, jis bus sukurtas.\necho \"What a beatiful morning\" &gt;&gt; day.txt\necho \"What a beatiful day\" &gt;&gt; day.txt\necho \"What a beatiful evening\" &gt;&gt; day.txt\nŠios komandos prideda tekstą “What a beautiful morning”, “What a beautiful day” ir “What a beautiful evening” prie failo day.txt galo, neperrašydamos esamo turinio. Jei tokio failo nėra, jis bus sukurtas.\n\n\n\n\n\n\nPraktika\n\n\n\n\nSusirask tau patinkančios dainos tekstą internete.\nNaudojant komandą echo ir operatorių &gt;, sukurk failą favorite_song.txt. Failo turinys turėtų būti panašus į “My favorite song is ”.\nPirmas keturias dainos eilutes atspausdink į failą song_text.txt naudojant echo ir &gt;&gt;. Nepamiršk, kokie klaviatūros trumpiniai naudojami kopijuojant ir įkeliant tekstą į terminalą!\n\n\n\n\n\n5.1.3 cat\nKomanda cat (angl. concatenate, liet. „sujungti“) naudojama peržiūrėti, sujungti ir atspausdinti failus. Tai viena iš pagrindinių Linux komandų, nes leidžia greitai peržiūrėti failų turinį, įvesti turinį į kitus failus arba sujungti kelis failus į vieną.\nPraeitame skyriuje sukūrei du failus favorite_song.txt ir song_text.txt. Dabar juos ir naudosime.\nAtspausdink failo favorite_song.txt turinį į terminalą:\ncat favorite_song.txt\nPas mane tai atrodo taip:\n\ncat leidžia sujungti kelių failų turinį ir atspausdinti rezultatą terminale:\ncat favorite_song.txt song_text.txt\n\nKaip praeitame skyriuje išmokai, komandos išvestį (nesvarbu, ar tai būtų echo, ar ls) galima nukreipti į failą. Lygiai taip pat gali nukopijuoti failą naudojant cat ir &gt; arba &gt;&gt;:\ncat favorite_song.txt &gt; favorite_song_2.txt\nŠi komanda nukopijuoja failo favorite_song.txt turinį į naują failą favorite_song_2.txt, perrašydama jo turinį, jei toks failas jau egzistuoja.\n\n\n\n\n\n\nPraktika\n\n\n\n\nNaudojant echo ir &gt;&gt;, įrašyk dar 4 eilutes mėgstamiausios dainos teksto į failą song_text_2.txt.\nSujunk failus song_text.txt ir song_text_2.txt, nukreipiant rezultatą į song_text_full.txt:\nPagalvok, kaip naudojant visas iki šiol žinomas komandas, būtų galima gauti song_text.txt failą, kuriame būtų pirmas ketvertas eilučių ir antras ketvertas eilučių teksto?\n\n\n\n\n\n5.1.4 head ir tail\nKomandos head (galva) ir tail (uodega) naudojamos peržiūrėti pirmąsias arba paskutines failo eilutes. Įprastai jos atspausdina 10 eilučių teksto.\n\n\n\n\n\n\nNote\n\n\n\nDabar tavo failas song_text.txt turėtų turėti 8 eilutes teksto. Todėl tokiu pat būdu, kaip prieš tai, pridėk dar 4 eilutes teksto, kad turėtum bent 12.\n\n\nPeržiūrėk pirmas 10 eilučių song_text.txt su head:\nhead song_text.txt\nPeržiūrėk paskutines 10 failo eilučių:\ntail song_text.txt\nTiek head, tiek tail priima nustatymą (option) -n su argumentu, nurodančiu, kiek eilučių atspausdinti:\n\nNorint peržiūrėti pirmas 3 eilutes, naudok komandą: head -n 3 song_text.txt\nNorint peržiūrėti paskutines 5 eilutes, naudok komandą: tail -n 5 song_text.txt.\n\n\n\n\n\n\n\nPraktika\n\n\n\nKas nutiktų, jei panaudotum head arba tail su failu, kuriame nėra 10 eilučių? Pabandyk su favorite_song.txt\n\n\n\n\n\n\n\n\nPraktika\n\n\n\nDabar dirbsi su failu data/temp_vilnius.txt.\n\nNaudojant cat, atspausdink visą failą terminale\nPirmosios dienos prognozės gali turėti mažiau nei 24 valandas (pvz., likusios 6 valandos). Naudojant head, atspausdink tik šiandienos orų prognozes\nKadangi šiandienos oras jau aiškus, tavo draugei Amelijai reikia rytojaus orų prognozės. Derinant head ir tail, išfiltruok eilutes taip ir sukurk tarpinius failus, kad būtų nusiųstos tik rytojaus 24 valandų temperatūros prognozės. Rezultatą išsaugok į failą amelija_temp_vilnius.txt subdirektorijoje data. Naudojant cat įsitikink, jog turi tik rytojaus temperatūras.\n\n\n\n\n\n5.1.5 less\nPraėjusiame skyriuje jau turėjai atvejį, kai viso failo temp_vilnius.txt turinys netilpo į terminalo langą. Tikėtina, reikėjo pakeisti terminalo lango dydį arba slinkti su pele. Dabar tau galbūt kyla klausimas, kaip būtų galima matyti failo turinį gabaliukais?\nNors gali naudoti cat dideliems failams atspausdinti ir tada slinkti išvestį, paprastai patogiau failą rodyti puslapiais. Tam pirminė komanda buvo more, bet ją pakeitė galingesnė komanda less.\nNaudojant less &lt;failas&gt;, vienu metu matysi tik vieną failo puslapį. Spaudžiant ␣ (space) klavišą, pereisi į kitą puslapį; gali taip pat naudoti ↓ ir ↑ klavišus, kad judėtum po vieną eilutę žemyn arba aukštyn. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk data/temp_vilnius.txt su less, išbandyk judėjimą tekste žemyn, aukštyn ir uždaryk programą su q.\n\n\nJei less komandai nurodysi kelis failus, gali naudoti :n (next) pereiti prie kito failo, o :p (previous) sugrįžti prie ankstesnio failo. Norint išeiti, spausk q.\n\n\n\n\n\n\nPraktika\n\n\n\nAtsidaryk failus favorite_song.txt, data/temp_vilnius.txt ir text/seneles_pasaka.txt su less. Išbandyk judėjimą tekste žemyn, aukštyn, pereik tarp failų naudojant :n ir :p bei pabaigoje uždaryk less su q\n\n\n\n\n5.1.6 wc\nKomanda wc (angl. word count) naudojama atspausdinti naujų eilučių, žodžių ir baitų skaičių faile.\n\n\n\n\n\n\n\nNustatymas\nReikšmė\n\n\n\n\n-c\nAtspausdina baitų skaičių (angl. byte count), kiek vietos užima failas\n\n\n-m\nAtspausdina simbolių skaičių (angl. character count)\n\n\n-w\nAtspausdina žodžių skaičių (angl. word count)\n\n\n-l\nAtspausdina eilučių skaičių (angl. line count)\n\n\n\nPastaba: -c ir -m gali atspausdinti skirtingus rezultatus priklausomai nuo failo koduotės, nes simbolis gali užimti daugiau nei vieną baitą (pvz., specialūs lietuviški simboliai).\n\n\n\n\n\n\nPraktika\n\n\n\n\nKiek žodžių ir kiek eilučių yra text/seneles_pasaka.txt?\nKiek eilučių yra data/temp_vilnius.txt ir kiek data/temp_kaunas.txt?\n\n\n\n\n\n5.1.7 touch\nKomanda touch naudojama kuriant tuščią failą arba keičiant esamo failo metaduomenis, pvz., modifikavimo ar prieigos laiką. Ji yra universali ir ypač naudinga tais atvejais, kai reikia greitai sukurti failą arba atnaujinti failo laikus be jo turinio keitimo.\nJei failas neegzistuoja, touch jį sukurs. Jei failas jau yra, komanda tiesiog pakeis failo “paskutinio keitimo laiką” (modification time) į dabartinį laiką, nesikeičiant turinio.\nSukurk tuščią failą:\ntouch empty_1.txt\n\nJei nurodysi kelis failų pavadinimus, touch sukurs visus iš karto:\ntouch empty_2.txt empty_3.txt empty_4.txt\n\nJeigu failo pavadinimas yra nurodytas su absoliučiu ar reliatyviu keliu, failas bus sukurtas atitinkamoje direktorijoje, jei tokia direktorija egzistuoja. Jei direktorija neegzistuoja, bus pranešta apie klaidą, ir failas nebus sukurtas.\ntouch mix/empty_5.txt\ntouch tralala/empty_6.txt\n\ntouch taip pat leidžia atnaujinti failo prieigos arba modifikavimo laiką. Štai keli pavyzdžiai:\n\nAtnaujinti tiek prieigos, tiek modifikavimo laikus į dabartinį laiką:\n\ntouch empty_1.txt\n\nAtnaujinti tik prieigos laiką:\n\ntouch -a empty_1.txt\n\nAtnaujinti tik modifikavimo laiką:\n\ntouch -m empty_1.txt\n\nNustatyti tiek prieigos, tiek modifikavimo laikus į konkrečią datą, pvz., 2022 m. sausio 1 d., 12:00 val.:\n\ntouch -t 202201011200 empty_1.txt\n\nNaudoti -d parinktį, norint lankstesnio laiko nustatymo:\n\ntouch -d \"2023-07-04 15:45\" empty_1.txt\nDabar gali kilti klausimas - kam tai naudinga? Iš tiesų, failų laikų keitimas gali atrodyti nišinis, tačiau tai naudinga tam tikrais atvejais:\n\nJei nori išbandyti skriptą, kuris rūšiuoja ar archyvuoja failus pagal jų prieigos ar modifikavimo laiką, gali generuoti tuščius failus su netikrais laikais ir patikrinti, ar skriptas veikia teisingai.\nJei atstatai failus iš atsarginės kopijos, gali norėti atkurti ir jų originalius prieigos bei modifikavimo laikus, kad išsaugotum failų istoriją tiksliai tokia, kokia buvo prieš atsargines kopijas.\n\n\n\n5.1.8 mkdir\nKomanda mkdir (angl. make directory) naudojama naujų direktorijų kūrimui.\nNaują direktoriją gali sukurti taip:\nmkdir projektas1\nKaip ir su komanda touch, gali sukurti kelias direktorijas vienu metu, nurodant pavadinimus arba kelius į jas:\nmkdir projektas2 mix/projektas3\n\nKartais reikia sukurti direktorijų medį (hierarchiją). Jei tarpinės direktorijos dar neegzistuoja, gali naudoti -p argumentą, kuris automatiškai sukurs ir tarpines direktorijas. Pavyzdžiui:\nmkdir -p projektas0/duomenys\n\n\n\n\n\n\n\nPraktika\n\n\n\nNetrukus norėsime sukurti tam tikrų failų atsargines kopijas. Kaip pasiruošimą, užtikrink, kad shell_part_2 direktorijoje būtų:\n\nbackup/data\nbackup/text\n\nSukurk jas naudojant -p, nurodant abi direktorijas kaip du argumentus vienoje komandoje (vienoje eilutėje).\n\n\n\n\n5.1.9 cp\nPripažink, kopijuoti failą su cat failas.txt &gt; kopija.txt nėra labai intuityvu. O ką daryti, jei nori nukopijuoti ne tik failą, bet ir visą direktoriją?\nKomanda cp (angl. copy) naudojama failams ir direktorijoms kopijuoti.\nPaprasčiausiu atveju, kai nori sukurti failo kopiją, komandai cp nurodai originalaus failo pavadinimą ir kokiu pavadinimu turėtų būti sukurta kopija.\ncp song_text.txt song_text_copy.txt\nJei failas song_text_copy.txt jau egzistuotų, jis būtų perrašytas. Taigi cp veikia panašiai kaip &gt;.\nKaip ir su visomis BASH komandomis, gali naudoti tiek reliatyvius, tiek absoliučius kelius (angl. path). Pavyzdžiui, kopiją gali perkelti į kitą direktoriją:\ncp ./song_text.txt ./mix/song_text_copy.txt\n\nJeigu kaip antrąjį argumentą nurodysi egzistuojančios direktorijos pavadinimą, cp sukurs kopiją tokiu pačiu pavadinimu kaip originalas ir patalpins ją į nurodytą direktoriją. Šįkart praleidžiam\ncp song_text.txt mix\n\ncp gali kopijuoti ir direktorijas, tačiau tam, kad visa direktorija būtų nukopijuota rekursyviai (su visu turiniu), reikia naudoti nustatymą -r (recursive). Jeigu pamirši -r direktorija nebus nukopijuota!\ncp -r mix mix_copy\n\nKada naudoti cp -a?\nNustatymas -a (arba archive) naudojamas, kai reikia nukopijuoti failus ir direktorijas kartu su jų metaduomenimis (pvz., failo leidimais, nuosavybe, laikais). Tai naudinga, kai nori išsaugoti visas originalaus failo ar katalogo savybes. -a iš esmės yra kombinuotas cp -r (rekursija) ir kitų nustatymų rinkinys, kuris užtikrina, kad išsaugomi visi atributai.\ncp -a mix mix_copy_2\nDabar palyging metaduominis su ls -l.\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nPadaryk temp_vilnius.txt kopiją pavadinimu temp_vilnius.txt, bet kaip argumentą nurodyk direktoriją ir failo pavadinimą. Patalpink kopiją į backup/data.\nPadaryk temp_kaunas.txt ir temp_klaipeda.txt kopiją vienoje komandoje su originaliu pavadinimu, kaip trečią argumentą cp paduodant tik backup/data direktoriją.\nPadaryk text direktorijos kopiją su visu jos turinu į backup direktoriją. Išsaugok visus metaduomenis.\nTeorinis klausimas: kas nutiktų jeigu panaudotum cp -r text backup/text?\nAr darant temp_ failų atsargines kopijas išsaugojai metaduomenis? jeigu ne, pakartok komandas tik su teisingu nustatymu ir įsitikink, ar iš tiesų metaduomenys tokie pat!\n\n\n\n\n\n5.1.10 mv\nKomanda mv (angl. move) naudojama perkelti arba pervadinti failus ir direktorijas. Tai universali komanda, skirta tiek failų ir katalogų vietos keitimui, tiek jų pavadinimų modifikavimui.\nPvz., naudojant mv, gali pervadinti failą temp_vilnius.txt į temp_alytus.txt:\nmv data/temp_vilnius.txt data/temp_alytus.txt\n\nTaip pat su mv gali perkelti failus iš vienos direktorijos į kitą. Ši komanda perkelia failą temp_kaunas.txt į mix:\nmv data/temp_kaunas.txt mix\n\nmv komandai galima paduoti daugiau nei du argumentus. Pavyzdžiui, ši komanda perkelia failus temp_alytus.txt ir seneles_pasaka.txt į direktoriją mix. Čia svarbu, kad paskutinis argumentas būtų egzistuojanti direktorija:\nmv data/temp_alytus.txt text/seneles_pasaka.txt mix\nmv taip pat gali būti naudojama perkelti direktoriją ir visą jos turinį. Pavyzdžiui, ši komanda perkelia direktoriją mix_copy į mix:\nmv mix_copy mix\nPastaba: dirbant su direktorijomis:\n\njeigu mv origin target jeigu target neegzistuoja, tada mv pervadins direktoriją origin į target\njeigu mv origin target jeigu target egzistuoja, tada mv perkels origin į target direktoriją\n\nSvarbu: kaip ir naudojant &gt; ar cp, jeigu tikslinis failas jau egzistuoja, jis bus perrašytas, nebent pridėsi -i (interaktyvų režimą), kad būtų paprašyta patvirtinimo prieš perrašant.\n\n\n\n\n\n\nPraktika\n\n\n\n\nTeorinis klausimas: Kas nutiktų, jei įvykdytum šią komandą?\n\nmv temp_vilnius.txt temp_kaunas.txt ~/Documents ~/Downloads\n\nPerkelk Alytaus ir Kauno temperatūrų failus atgal iš mix į data naudojant mv. Pervadink Alytaus failą atgal į Vilniaus\nAtsidaryk Nemo ir rankiniu būdu ištrink data direktoriją. Dabar su terminal, padaryk backup/data kopiją (su cp ir reikalaingais nustatymais), jog vėl atsirastų /shell_part_2/data.\n\n\n\n\n\n5.1.11 rm\nTavo shell_part_2 direktorijoje dabar tikrai daug failų ir subdirektorijų, kurių nebereikia. Laikas įvesti šiek tiek tvarkos!\nKomanda rm (angl. remove) naudojama pašalinti failus ir direktorijas. Tai galinga komanda, todėl ja reikia naudotis atsargiai, nes pašalinti failai ar direktorijos nėra perkeliami į šiukšliadėžę ir jų atkurti nebebus galima.\nNorint pašalinti failą, rm komandai paduodamas argumentas - failo pavadinimas arba absoliutus, arba reliatyvus kelias į failą.\nrm day.txt\nrm mix/empty_5.txt\nKomandai rm galima paduoti ir kelis failus vienu metu:\nrm empty_1.txt empty_2.txt \nTuščią direktoriją (kai joje nėra jokių kitų failų ar subdirektorijų) galima pašalinti arba naudojant rmdir (kuri yra mkdir priešingybė), arba su rm, nurodant nustatymą -d.\nrm -d projektas1\nrmdir projektas2\n\nTiesiog pašalinti direktoriją, kurioje yra kažkas, su rm arba rm -d nepavyks, nes BASH bando apsaugoti vartotoją nuo rizikos netyčia ištrinti daugiau failų nei reikia.\n\nJei reikia ištrinti visą direktoriją su visu jos turiniu, naudojamas parametras -r (recursive).\nrm -r projektas0\nKartais gali nutikti, jog rm -r negalės ištrinti direktorijos dėl failų teisių ar kitų kliūčių. Tokiu atveju pridedamas nustatymas -f (force), kuris priverstinai ištrina failus.\nrm -rf mix_copy_2\nintarpas: Wildcard’ų naudojimas *\nKartais BASH komandose norisi pažymėti arba pasirinkti daugiau nei vieną failą. Kaip jau matei, tiek cat, tiek cp, mv, rm, less komandos kuo puikiausiai dirba su keliais failais. Tad kyla klausimas, kaip tai padaryti efektyviau naudojant wildcard simbolius.\nPvz., tu galėtum rašyti:\nrm empty_1.txt empty_2.txt\nTačiau yra akivaizdu, jog šiuose failų pavadinimuose yra tam tikras dėsningumas – jie prasideda empty_ ir baigiasi .txt.\nBASH, kaip ir daugelyje kitų programavimo kalbų, yra vadinamieji wildcard - simboliai, kurie leidžia užpildyti vieną ar daugiau ženklų.\nPavyzdžiui, * simbolis pakeičia bet kokį skaičių ženklų. Taigi, galima būtų parašyti:\nrm empty_*.txt\nWildcard’ų simboliai:\n\n* reiškia jokio, vieną arba daugiau simbolių.\n? reiškia tiksliai vieną simbolį, pvz., 201?.txt galėtų atitikti 2017.txt, 2018.txt, bet ne 2017-01.txt.\n[...] reiškia vieną iš pateiktų simbolių, pvz., 201[78].txt atitiks 2017.txt arba 2018.txt, bet ne 2016.txt.\n{} reiškia vieną iš nurodytų reikšmių, pvz., rm {.txt,.csv} atitiks visus failus, kurių pavadinimas baigiasi .txt arba .csv, bet ne .pdf.\n\n\n\n\n\n\n\nPraktika\n\n\n\nTeorinė užduotis - pasakyk, kas nutiktų visais šiais atvejais:\n\nrm song*.txt\nrm *song*.txt\nrm *.txt\nrm *.*\nrm ./*\nrm *\nrm data/*\nrm text/*.txt\nPasitikrink atsakymą naudojant ChatGPT!\n\nPraktinė užduotis - naudojantis wildcard ištrink iš shell_part_2 visus failus:\n\nkurių pavadinime yra žodis song, neproklausomai nuo pozicijos ir failo tipo\nkurių failo tipas yra .txt\nvisus failus esančius mix subdirektorijoje. Tam gali prireikti papildomo nustatymo rm komandai, nes mix gali būti direktorijos!\nsubdirektorijas data ir text. O tada naudodojant cp ir būtinai reikiamą nustatymą metaduomenų išlaikymui, atkurti iš backup\n\n\n\nAtlikus visus valymus turėtum turėti:\n\n\n\n5.1.12 grep\nKartais tau gali prireikti nuskaityti tik tam tikras failo eilutes, kuriose yra konkretus tekstas. Komanda grep (angl. global regular expression print, liet. „globalus reguliariųjų išraiškų paieškos spausdinimas“) naudojama teksto paieškai pagal šabloną failuose arba išvestyje.\nPavyzdžiui, ši komanda surastų visas eilutes data/seneles_pasaka, kuriose yra žodis „Apie“:\ngrep Apie text/seneles_pasaka.text\n\nSuprantama, gali pateikti kelis failus vienu metu. Šiuo atveju komanda grep suras visas eilutes, kuriose yra 14:00:00 abiejuose jai pateiktuose failuose ir atitinkamas eilutes atspausdins tau į terminalą.\ngrep 14:00:00 data/temp_vilnius.txt data/temp_kaunas.txt \n\ngrep priima ir tam tikrus nustatymus, kurie padeda atlikti paiešką efektyviau:\n\n-c: atspausdina, kiek eilučių atitinka tavo pateiktą kriterijų.\n-h: neatspausdina failų pavadinimų, kuriuose rasti atitikimai, kai pateiki keli failai.\n-i: ignoruoja didžiąsias ir mažąsias raides (pvz., įrašius -i apie, ras ir „Apie“, „apie“, „APIE“ ir t.t.).\n-l: atspausdina tik failų pavadinimus, kuriuose rasti atitikimai.\n-n: atspausdina eilučių numerius šalia pačios eilutės.\n-v: ieško eilučių, kuriose nėra raktinio paieškos kriterijaus.\n\n\n\n\n\n\n\nPraktika\n\n\n\nDirbk su data/seneles_pasaka.txt\n\nKurios eilutės turi paminėtą žodį „pasaka“ (tik su mažąja raide)?\nKurios eilutės turi paminėtą žodį „pasaka“ (nesvarbu, ar rašyta didžiosiomis, ar mažosiomis raidėmis)?\nKiek eilučių (ieškome skaičiaus) turi paminėtą žodį „apie“, nepriklausomai nuo rašybos?\nKiek eilučių (ieškome skaičiaus) nepamini žodžio „apie“, nepriklausomai nuo rašybos?\n\n\n\nPastaba: komanda grep ieško tekstinės atitikties failuose, todėl ji nepriima loginių operatorių kaip &gt;, =, ar &lt;. Visgi, grep leidžia naudoti reguliarias išraiškas (regular expressions), kurios leidžia dar smulkiau atrinkti tekstą.\nŠtai kaip būtų galima panaudoti grep su reguliariomis išraiškomis, norint surasti visas eilutes, kuriose yra vienas skaitmuo prieš tašką, visuose temp_ failuose:\ngrep -P '\\t[0-9]\\.[0-9]' data/temp_*.txt\n\nĮ reguliarias išraiškas dabar neverta gilintis išsamiau, bet svarbu žinoti, kad jos egzistuoja ir gali būti labai naudingos dirbant su tekstiniais duomenimis. Jeigu kiltų noras pasibandyti, siūlau naudti https://regexr.com/.\n\n\n5.1.13 cut\nKartais tau gali prireikti išfiltruoti ne eilutes, o stulpelius. Pvz., komanda head data/temp_vilnius.txt parodo tarsi 3 stulpelius: datą, laiką ir temperatūrą. Pastebima, kad tarp datos ir laiko yra mažas tarpas (greičiausiai „space“), o tarp laiko ir temperatūros – didelis tarpas (tikėtina, “tab”). Tai šiek tiek apsunkina darbą, kol nesusipažinai su sed komanda, bet tai nereiškia, jog negalime išskaidyti failo į stulpelius pagal skirtingus skirtukus, pvz., „space“ ir „tab“.\n\nKomandai cut reikia tam tikrų nustatymų. Pagrindiniai nustatymai:\n\n-d (delimiter) – skirtukas, kuris skiria stulpelius. Pagal nutylėjimą skirtukas yra tabuliacija (tab), tad šio nustatymo keisti nereikia. Jeigu norėtum naudoti kitą skirtuką, pvz., tarpo ženklą, turėtum naudoti -d \" \". Jeigu skirtukas būtų kablelis, naudotum -d \",\" ir t.t.\n-f (fields) – nurodo, kuriuos stulpelius (laukelius) nori pasirinkti. Pvz., -f 2 pasirinktų antrą stulpelį, -f 2-5 pasirinktų nuo antro iki penkto stulpelio, o -f 2-5,8 pasirinktų antrą, trečią, ketvirtą, penktą ir aštuntą stulpelius.\n\nŠi komanda priima „space“ kaip skirtuką ir atspausdina pirmąjį stulpelį:\ncut -d \" \" -f 1 data/temp_vilnius.txt\n\nŠi komanda priima „tab“ kaip skirtuką ir atspausdina antrąjį stulpelį:\ncut -f 2  data/temp_vilnius.txt\n\nJeigu norėtum gauti tik metus, galėtum nurodyti skirtuką „-“ ir pasirinkti pirmąjį stulpelį:\ncut -d \"-\" -f 1 data/temp_vilnius.txt \n\n\n\n\n\n\n\nPraktika\n\n\n\nProgramuojant ir dirbant su duomenimis, svarbu išmokti išnaudoti AI galimybes. Šioje praktikoje tu turi nueiti į ChatGPT ir parašyti kažką panašaus:\n\nSugeneruok 25 eilučių .csv failą, kurio skirtukas būtų “,” su šiais stulpeliais:\n\nuser_id,\nage (18-99)\ncountry_code (LT, LV, EE)\norders (0-250)\n\n\nChatGPT sugeneruos .csv failą ir leis jį atsisiųsti. Šiam sugeneravimui ChatGPT pasinaudos Python programavimo kalba. Tu galėtum išsaugoti grąžintą kodą ir naudoti jį ateityje, nes tavo kompiuteryje šis kodas taip pat veiktų. Bet prie Python mes dar grįšime vėliau.\nPerkelk failą iš ~/Downloads į ~/shell_part_2/data. Tarkime, failas vadinasi sample_data.csv.\nVideo\nTurint failą:\n\nPervadink failą į balt_customers.csv.\nNaudojant žinomomis komandomis tyrinėk failą data/balt_customers.csv:\n\nKiek jame eilučių?\nKoks skirtukas naudojamas?\nKokie duomenys yra pirmoje eilutėje (antraštė ar duomenys)?\nKiek ir kurios eilutės yra duomenys?\n\n\nUžduotis: Tu dirbi su klientais iš Estijos (EE). Turi parašyti visiems klientams iš Estijos el. laišką ir pranešti apie jų užsakymų skaičių. Laiško rašymą perims programa, tačiau tu jai turi pateikti failą customers_ee.csv, kuris turėtų atrodyti taip (tavo duomenys gali skirtis dėl atsitiktinio jų sugeneravimo):\n\nKad įgyvendintum šią užduotį, tau prireiks komandų: head, cut, &gt; &gt;&gt;, cat ir grep bei sukurti kelis tarpinius failus, kuriuos vėliau galėsi ištrinti. Taip pat patarčiau bandyt skaidyti darbus :)\nSėkmės!\n\n\n\n\n5.1.14 Intarpas: Standartinė įvestis, išvestis ir klaidos\nIki šiol mes naudojome sąvokas, tokias kaip įvestis (input) ir išvestis (output). Įvestis buvo tai, ką tu įvedi klaviatūra į terminalą, o išvestis – tai, ką BASH atspausdina terminale arba ką tu nukreipi į failą naudodant &gt; arba &gt;&gt;. Tačiau iki šiol formaliai neaptarėme BASH srautų.\nLinux ir Unix sistemose yra trys pagrindiniai srautai, kurie valdo duomenų įvestį ir išvestį programose bei komandose. Šie srautai vadinami standartine įvestimi (standard input), standartine išvestimi (standard output) ir standartine klaida (standard error). Kiekvienas srautas turi specifinę paskirtį ir failo aprašymo numerį.\nSvarbu: Linux’e viskas yra failai, net srautai (input/output) traktuojami kaip failai.\n\n5.1.14.1 Standartinė įvestis (stdin)\nStandartinė įvestis, sutrumpinta kaip stdin, yra srautas, iš kurio komanda ar programa gauna duomenis. Pagal numatytuosius nustatymus, stdin yra prijungta prie klaviatūros, tačiau gali būti nukreipta iš failo ar kito srauto.\nPabandyk įrašyti cat, paspausti Enter, ir tada įvesk kelis žodžius, vis paspausdžiant Enter. Terminale matysi tekstą, kurį įvedi, nes jis bus perduotas kaip įvestis cat komandai, kuri atspausdins šį tekstą. Todėl matysi dvigubai tai, ką įvedei.\ncat\nNutraukti cat įvestį gali su Ctrl-D arba Ctrl-C.\nVideo\nĮvestis taip pat gali būti perduodama iš failo į komandą. Pavyzdžiui, komandai cat galime nurodyti failą taip:\ncat &lt; data/customers_ee.csv\nKodėl veikia &lt;?\nSimbolis &lt; nurodo komandai, kad vietoje įprastos įvesties iš klaviatūros naudotų failą kaip įvesties šaltinį. Pvz., cat &lt; data/customers_ee.csv reiškia, kad cat komanda skaitys duomenis iš failo data/customers_ee.csv, o ne iš klaviatūros.\n\nStandartinės įvesties aprašymo numeris: 0. Vėliau pamatysi, kam tie skaičiai naudingi.\n\n\n5.1.14.2 Standartinė išvestis (stdout)\nStandartinė išvestis, sutrumpinta kaip stdout, yra srautas, į kurį komanda ar programa rašo išvestį. Dirbant terminale, stdout prijungta prie terminalo ekrano. Pavyzdžiui, įrašius šią komandą, terminale atspausdinamas „Hello World“:\necho \"Hello World\"\nGalima nukreipti standartinę išvestį ne į terminalo langą, bet į failą, kaip jau esame darę anksčiau:\necho \"Hello World!\" &gt; hello_world.txt\nStandartinė išvestis turi numerį 1. Tai reiškia\necho \"Hello World!\" 1&gt; hello_world.txt\njog stdout srautas (1), kurį generuoja echo komanda, siunčiamas į failą hello_world.txt. Mes panaudojom srauto numerį, kad pasakyti kurį srautą siųsti į failą.\n\n\n5.1.14.3 Standartinė klaida (stderr)\nKai komanda negali atlikti tam tikro veiksmo, ji sugeneruoja klaidos pranešimą, kuris siunčiamas į standartinį klaidos srautą (stderr). Standartinės klaidos srautas turi numerį 2, ir jį taip pat galima nukreipti į failą.\nPabandyk komandą ls su neegzistuojančia direktorija, pvz.,:\nls abc\n\nKlaidos pranešimas bus išspausdintas terminale. Tačiau galime nukreipti tik klaidos srautą į failą:\nls abc 2&gt; error.log\nTerminale klaidos nebus matyti, bet gali naudoti komandas head arba cat, kad pažiūrėtum, kas yra error.log faile.\n\n\n\n\n5.1.15 Kaip visą tai taikyti praktikoje?\nĮsivaizduok, kad turi komandą ls, kuri kartais sugeneruoja išvestį, kurią nori nukreipti į list.txt, o klaidas – į error.log. Tam galėtum naudoti:\nls &lt;direktorija1&gt; &lt;direktorija2&gt; &lt;direktorija3&gt; 1&gt;&gt;list.txt 2&gt;&gt;error.log\nIšbandyk šią komandą su egzistuojančia ir neegzistuojančia direktorija (prieš tai su rm ištrink error.log jeigu toks egzistuoja)\nls -l data abc text 1&gt; list.txt 2&gt; error.log\n\nKartais gali prireikti, kad abu srautai būtų nukreipti į tą patį failą. Pvz., jeigu kas 10 minučių matuoji kompiuterio temperatūrą, gali nukreipti tiek stdout, tiek stderr į failą:\nkomanda 1&gt;temp.log 2&gt;&1\nArba gali klaidos srautą nukreipti į temp.log, o standartinę išvestį – į klaidų srautą:\nkomanda 2&gt;temp.log 1&gt;&2\nSimbolis & nurodo, kad mes kalbame apie srautą, o ne apie failo vardą. Kai rašai, pvz., 1&gt;&2, tai reiškia, kad standartinę išvestį (stdout, 1) nukreipi ne į failą, o į standartinį klaidų srautą (stderr, 2). Tai leidžia abu srautus sujungti ir siųsti į tą patį tikslą. Jei & nebūtų, sistema galvotų, kad „2“ yra failo pavadinimas, o ne kitas srautas. Analogiškai, 2&gt;&1 reiškia, kad klaidų srautas (stderr, 2) nukreipiamas į išvesties srautą (stdout, 1).\n\n\n5.1.16 pipe |\nIki šiol, kai reikėdavo vienos komandos išvestį panaudoti kitoje komandoje, pavyzdžiui, išfiltravus Estijos vartotojus su grep EE data/balt_customers.csv, turėjai juos išsaugoti į tarpinį failą (pvz., temporal.csv), o tik tada paduoti rezultatą į cut -d \",\" -f 1,4 temporal.csv, kad gautum norimą rezultatą. Tai yra neefektyvus metodas, nes:\n\nLieka daug tarpinių failų.\nKomandos būna suskaidytos per kelias eilutes, todėl jas sunku peržiūrėti su history.\n\nBASH siūlo kelis būdus, kaip efektyviau panaudoti vienos komandos rezultatus kitose, pavyzdžiui, su xargs arba kitais įrankiais. Tačiau dažniausiai naudojamas metodas yra pipe (angl. “vamzdis”).\n| (pipe) – tai vertikalus brūkšnys, kuris sujungia komandas į vieną srautą, kur vienos komandos išvestis tampa kitos komandos įvestimi.\n\nPabandyk sujungti šias komandas:\n\ngrep EE data/balt_customers.csv - išfiltruoti tik EE vartotojus.\nPanaudoti |, kuris pavers pirmosios komandos išvestį antrosios komandos įvestimi.\ncut -d \",\" -f 1,4 – iškirpti pirmą ir ketvirtą stulpelius.\nGalutinį rezultatą su &gt; nukreipk į failą data/customers_ee_2.csv.\n\n\ngrep EE data/balt_customers.csv | cut -d \",\" -f 1,4 &gt; data/customers_ee_2.csv\nPirma pabandyk paleisti komandą be &gt;, kad pamatytum rezultatą terminale:\n\nDabar paleisk pilną komandą, nukreipiančią išvestį į failą:\n\n\n\n\n\n\n\nPraktika\n\n\n\n\nTerminale atspausdink pirmas 3 eilutes, kuriose yra žodis „Apie“ iš failo data/seneles_pasaka.txt.\nTerminale atspausdingk paskutines 3 eilutes kuriose yra 00:00:00 faile data/temp_vilnius.txt\n\n\n\n\n\n5.1.17 sort\nTu darai nuostabią pažangą ir jau moki naudoti grep, cut, head, tail, su kuriomis gali išfiltruoti eilutes, stulpelius ir t.t. Naudojant |, jau moki sujungti kelias komandas į vieną. Tačiau ko tu dar nemoki – kaip išrikiuoti reikšmes. Čia pravers komanda sort.\nsort labai gerai sąveikauja su pipe |.\nPagrindiniai nustatymai:\n\n-r – nuo didžiausios iki mažiausios reikšmės.\n-n – rikiuoti skaičius.\n-h – rikiuoti pagal dydį, jei dydis pateiktas human readable skaičiais (pvz., KB, MB, GB).\n-t – nurodo, koks yra skirtukas tarp stulpelių (delimiter).\n-k – pagal kurį stulpelį rikiuoti.\n\nSukurk šį failą:\necho -e \"A,101\\nB,3\\nC,2\\nD,40\" &gt; tosort\nAr pastebėjai, tosort neturi indikacijos, koks tai failas, nei .csv, nei .txt. Nieko tokio Linux operacinėje sistemoje, komandos veikia kuo puikiausiai ir be failo tipo indikatoriaus.\n\nPagal nutylėjimą sort priims failą kaip argumentą ir rikiuos pagal pirmą stulpelį. sort -r apsuks rikiavimo eigą.\nsort tosort\nsort -r tosort\n\nJei nori, kad BASH suprastų failą kaip turintį skirtingus stulpelius, turi nurodyti, koks yra skirtukas (delimiter) su -t \",\". Tuomet galima rikiuoti pagal konkretų stulpelį su -k 2. Jei nepridėsi -n, sort rikiuos taip, lyg skaičiai būtų tekstas, t.y., vertins pagal pirmą skaitmenį, tada pagal antrą ir t.t. Pridėjus -n, skaičiai vertinami kaip skaičiai.\nGalima apsieiti ir be kabučių aplink skirtuką, o -n pridėti prie -k 2, kad būtų rikiuojama pagal skaičius. Galų gale, tai tavo pasirinkimas.\nsort -t \",\" -k 2 tosort\nsort -t \",\" -k 2 -n tosort\nsort -t, -k2n tosort\n\n\n\n\n\n\n\nPraktika\n\n\n\nUžduotis: Įsivaizduok, kad esi IT administratorė arba administratorius, atsakingas už sistemų stebėjimą. Tau reikia periodiškai siųsti sąrašą su 5 didžiausiais failais ar direktorijomis pagal dydį namų direktorijoje (~). Šis sąrašas turėtų apimti visus paslėptus failus (kurie prasideda su “.” savo pavadinime), o dydis turėtų būti human readable formatu, o ne baitais. Taip pat norisi, kad maksimalus gylis būtų 1, t.y., jog būtų žiūrima į ~ ir vieną lygį giliau, t.y. ~/direktorija/.\nKadangi šią užduotį reikia atlikti kasdien, nusprendei sukurti ilgą BASH komandą.\nPagalba: Prieš pradedant nueik į ChatGPT ir paprašyk:\n\nPaaiškink man “du” komanda Linux ir jos nustatymus. Man reiktų matyti failus human readable formatu. Pateik kelis pvz.\n\nPerskaityk ką tau gražins ChatGPT, jeigu reikia pasitisklink užduodant papildomus klausimus.\n\nPabandyk sukurti komandų seką (pipeline) su du, sort, head. Eksperimentuok su nustatymais.\nKai terminalo lange matysi reikiamą išvestį, naudok echo, apskliausk visą komandą kabutėmis ir nukreipk į failą pavadinimu list_du_homedir.sh. Taigi, tai turėtų atrodyti daugmaž taip:\necho \"komanda komanda komanda\" &gt; list_du_homedir.sh\nO dabar pabandyk\nbash list_du_homedir.sh\narba su pipe\ncat list_du_homedir.sh | bash\nSveikinu, ką tik sukūrei savo pirmą skriptą! Tai komandų rinkinys, kurį gali perduoti BASH, ir jis jį įvykdys.\n\n\n\n\n5.1.18 sed\nsed komanda Linux sistemoje yra srauto redaktorius (stream editor), naudojamas tekstui apdoroti ir manipuliuoti. Ji leidžia atlikti įvairius teksto pakeitimus, pvz., ieškoti ir pakeisti žodžius, ištrinti eilutes arba modifikuoti tekstą pagal tam tikras taisykles, nespausdinant teksto į terminalą.\nVienas paprasčiausių būdų naudoti sed – tai pakeisti tam tikrą tekstą kitu tekstu: tam naudojama tokia sintaksė sed 's/ką keisti/kuo pakeisti/'.\nTaigi, ši komanda pakeičia „rytas“ į „vakaras“:\necho \"Labas rytas\" | sed 's/rytas/vakaras/'\nsed nėra agresyvi komanda, todėl ankstesnė komanda pakeičia tik pirmą rastą atitikmenį:\necho \"Labas rytas, pasakė senelė kai atėjo rytas\" | sed 's/rytas/vakaras/'\nMatyti, kad tik pirmas „rytas“ pakeistas į „vakaras“, o antrasis ne. Jei nori, kad visi atitikmenys būtų pakeisti, reikia pridėti nustatymą g:\necho \"Labas rytas, pasakė senelė kai atėjo rytas\" | sed 's/rytas/vakaras/g' \nSu sed taip pat galima ištrinti eilutes. Pavyzdžiui, jei ls -l komanda atspausdina „total …“, galima tai ištrinti naudojant sed '1d':\nls -l\nls -l |sed '1d'\nVietoje 1, kuris nurodo, kurią eilutę trinti, galima nurodyti ir diapazoną, pvz., nuo 1 iki 3 su sed '1,3d':\nls -l | sed '1,3d'\nTaip pat galima įterpti naujas eilutes:\nls -l | sed '3a/nauja eilutė'\nPora įdomybių:\nSu sed gali naudoti regular expressions. Štai keletas reikšmių:\n\n^ reiškia eilutės pradžią.\n$ reiškia eilutės pabaigą.\n\\t reiškia tabuliaciją (naudoti su sed -E).\n\\s reiškia tarpą (naudoti su sed -E).\n\nPvz., pridėti veiduką prieš kiekvieną eilutę:\nsed 's/^/😀/g' text/seneles_pasaka.txt\nJei nori, kad sed ignoruotų raidžių dydžius, pridėk nustatymą I. Tai panašu į grep -i.\necho Labas Rytas | sed 's/rytas/Vakaras/'\necho Labas Rytas | sed 's/rytas/Vakaras/I'\n\n\n\n\n\n\nPraktika\n\n\n\n\nDirbk su data/seneles_pasaka.txt. Tavo tikslas – padaryti pasaką labiau patrauklią vaikams, pakeičiant žodžius simboliais. Naudok sed komandą ir pakeisk šiuos žodžius į atitinkamus simbolius. Sujunk visas sed komandas į viena pipeline naudojant |.\n\nŽąsiną moliūgą – 🦢🎃 Vilką – 🐺 Baltą mešką – 🐻‍❄️ Joną – 👦🏻 Eglę - 🌲 Žalčio – 🐍 Ragana - 🧙‍♀️ Pamotė pikta – 😡\nIšsaugok pasaką kaip text/seneles_pasaka_emojies.txt\n\n\ndata/temp_vilnius.txt ir kitų miestų failai turi kelias problemas, kurias turėtum ištaisyti:\n\nVilniaus faile kiekvienos eilutės pradžioje įrašyk „Vilnius “ (su tarpeliu po miesto pavadinimo). Kituose miestuose atitinkmai “Kaunas” ir “Klaipėda”\nDabar pirmieji du skirtukai yra tarpai, o antrasis – tabuliacija. Paleisk sed komandą du kartus: vieną kartą pakeisk tarpus (space) į kablelius, o antrą kartą – tabuliacijas į kablelius.\nIšsaugok Vilniaus, Kauno, ir Klaipėdos failus kaip temp_vilnius.csv, temp_kaunas.csv, temp_klaipeda.csv (vietoje .txt naudok .csv plėtinį).\nKiekvienas miestas turėtų turėti visą komandą vienoje eilutėje naudojant |.\n\n\n\nSujunk visus Vilniaus, Kauno ir Klaipėdos failus į vieną ir pavadink rezultatą temp_lietuva.csv.\nPabandyk atidaryti šį failą su LibreOffice Calc:\n\nlibreoffice --calc temp_lietuva.csv\n\nPavaizduok sekančių dienų temperatūras.\n\n * Pabandyk atsidaryti visus tris pavienius failus su Excel Power Query ir apdorojus duomenis sukurti dashboard to slicer filtrais ir grafikais.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>BASH komandos</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html",
    "href": "7_bash_comands_advanced.html",
    "title": "6  BASH advanced",
    "section": "",
    "text": "6.1 Pagalba sau\nPraeitame skyriuje susipažinai su daug komandų, kurios tau kuria pagrindą darbui su SHELL. Tu išmokai daug programų, su daug skirtingų nustatymų, tačiau kaip gali įsivaizduoti, tu tikrai neišmokai VISKO. Todėl prieš judant toliau, pradėkie turputi nuo to, kaip padėti sau, kai pastringi: kai neprisemeni kokias opcijas naudoti ir t.t.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#pagalba-sau",
    "href": "7_bash_comands_advanced.html#pagalba-sau",
    "title": "6  BASH advanced",
    "section": "",
    "text": "6.1.1 help\nvienas papraščiausių būdų rasti greitai paaiškinimą, kaip veika tam tikra komanda pasinaudoti help, dažniausiai help iššaukiama taip\nkomanda --help\nkaip pameni, -- naudoji prieš tuos nustatymus, kurie išrašyti pilnai, trumpiniams naudjoamas vienas -.\ntada tau terminale bus atspaudintas visas su šia komanda susijęs pagalbos tekstas.\ndažniausiai help sudaro:\n\n…\n….\n…..\n\nPabandyk rasti pagalba šioms komandoms: ls, cp, rm, sed.\n\n\n6.1.2 man\nExercise Exercise How can I get help for a command?\nTo find out what commands do, people used to use the man command (short for “manual”). For example, the command man head brings up this information:\nHEAD(1) BSD General Commands Manual HEAD(1)\nNAME head – display first lines of a file\nSYNOPSIS head [-n count | -c bytes] [file …]\nDESCRIPTION This filter displays the first count lines or bytes of each of the specified files, or of the standard input if no files are specified. If count is omitted it defaults to 10.\n If more than a single file is specified, each file is preceded by\n a header consisting of the string ``==&gt; XXX &lt;=='' where ``XXX''\n is the name of the file.\nSEE ALSO tail(1)\nman automatically invokes less, so you may need to press spacebar to page through the information and :q to quit.\nThe one-line description under NAME tells you briefly what the command does, and the summary under SYNOPSIS lists all the flags it understands. Anything that is optional is shown in square brackets […], either/or alternatives are separated by |, and things that can be repeated are shown by …, so head’s manual page is telling you that you can either give a line count with -n or a byte count with -c, and that you can give it any number of filenames.\nThe problem with the Unix manual is that you have to know what you’re looking for. If you don’t, you can search Stack Overflow, ask a question on DataCamp’s Slack channels, or look at the SEE ALSO sections of the commands you already know. Instructions 1/2 50 XP\n1\n\nRead the manual page for the tail command to find out what putting a + sign in front of the number used with the -n flag does. (Remember to press spacebar to page down and/or type q to quit.)\n2\nUse tail with the flag -n +7 to display all but the first six lines of seasonal/spring.csv.\n\n\n6.1.3 find\nKomanda find naudojama ieškoti failų ir katalogų pagal įvairius kriterijus.\n\nIeškoti failų dabartiniame kataloge pagal pavadinimą:\n\nfind . -name \"failas.txt\"\n\nIeškoti failų visoje sistemoje pagal pavadinimą:\n\nfind / -name \"failas.txt\"\n\n\n6.1.4 chmod\nKomanda chmod (angl. change mode, liet. “keisti režimą”) naudojama keisti failų ir katalogų teises.\n\nSuteikti vykdymo teisę failui:\n\nchmod +x failas.sh\n\nNustatyti konkrečias teises:\n\n\nchmod 755 failas.txt\n\n\n6.1.5 chown\nKomanda chown (angl. change owner, liet. “keisti savininką”) naudojama keisti failų ir katalogų savininką.\n\nKeisti failo savininką:\n\n\nsudo chown naujas_savininkas failas.txt\n\nKeisti failo savininką ir grupę:\n\n\nsudo chown naujas_savininkas:nauja_grupė failas.txt\n\n\n6.1.6 ps ir top\nKomandos ps ir top naudojamos valdyti ir stebėti procesus sistemoje.\n\nParodyti veikiančius procesus su ps:\n\nps aux\nRealiu laiku sekti procesus su top:\ntop",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#sed",
    "href": "7_bash_comands_advanced.html#sed",
    "title": "6  BASH advanced",
    "section": "6.2 sed",
    "text": "6.2 sed",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#xed",
    "href": "7_bash_comands_advanced.html#xed",
    "title": "6  BASH advanced",
    "section": "6.3 xed",
    "text": "6.3 xed",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#find-1",
    "href": "7_bash_comands_advanced.html#find-1",
    "title": "6  BASH advanced",
    "section": "6.4 find",
    "text": "6.4 find",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#ps",
    "href": "7_bash_comands_advanced.html#ps",
    "title": "6  BASH advanced",
    "section": "6.5 ps",
    "text": "6.5 ps\n\n6.5.1 tldr",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#file-permissions-and-ownership",
    "href": "7_bash_comands_advanced.html#file-permissions-and-ownership",
    "title": "6  BASH advanced",
    "section": "7.1 1. File Permissions and Ownership",
    "text": "7.1 1. File Permissions and Ownership\n\nUnderstanding Permissions\n\nRecap of r, w, x permissions.\n\nCommands to Manage Permissions\n\nchmod: Change file permissions.\nchown: Change file ownership.\nchgrp: Change group ownership.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#environment-variables",
    "href": "7_bash_comands_advanced.html#environment-variables",
    "title": "6  BASH advanced",
    "section": "7.2 2. Environment Variables",
    "text": "7.2 2. Environment Variables\n\nIntroduction to Environment Variables\n\nImportance and usage in scripting.\n\nCommands\n\nexport: Set environment variables.\nenv, printenv: Display environment variables.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#text-processing-tools",
    "href": "7_bash_comands_advanced.html#text-processing-tools",
    "title": "6  BASH advanced",
    "section": "7.3 3. Text Processing Tools",
    "text": "7.3 3. Text Processing Tools\n\nAdvanced Text Processing\n\nawk: Basic usage for pattern scanning and processing.\npaste: Merging lines of files.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#basic-networking-commands",
    "href": "7_bash_comands_advanced.html#basic-networking-commands",
    "title": "6  BASH advanced",
    "section": "7.4 4. Basic Networking Commands",
    "text": "7.4 4. Basic Networking Commands\n\nNetworking Basics\n\nping: Checking network connectivity.\ncurl or wget: Fetching files or data from the web.\nnc: Networking tool for reading/writing data across network connections.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#job-control-light-coverage",
    "href": "7_bash_comands_advanced.html#job-control-light-coverage",
    "title": "6  BASH advanced",
    "section": "7.5 5. Job Control (Light Coverage)",
    "text": "7.5 5. Job Control (Light Coverage)\n\nUnderstanding Job Control\n\nOverview of foreground and background processes.\nBasic commands: jobs, bg, fg, kill.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#command-history-and-aliases",
    "href": "7_bash_comands_advanced.html#command-history-and-aliases",
    "title": "6  BASH advanced",
    "section": "7.6 6. Command History and Aliases",
    "text": "7.6 6. Command History and Aliases\n\nManaging Command History\n\nhistory: Viewing command history.\n\nCreating Shortcuts\n\nalias: Define shortcuts for commands.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#file-compression-and-archiving",
    "href": "7_bash_comands_advanced.html#file-compression-and-archiving",
    "title": "6  BASH advanced",
    "section": "7.7 7. File Compression and Archiving",
    "text": "7.7 7. File Compression and Archiving\n\nFile Management\n\ntar: Archive files and directories.\ngzip: Compress files.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#disk-usage-commands",
    "href": "7_bash_comands_advanced.html#disk-usage-commands",
    "title": "6  BASH advanced",
    "section": "7.8 8. Disk Usage Commands",
    "text": "7.8 8. Disk Usage Commands\n\nDisk Usage Overview\n\ndf: Report file system disk space usage.\ndu: Estimate file and directory space usage.\nncdu: Disk usage analyzer with a text-based interface.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#secure-file-transfer",
    "href": "7_bash_comands_advanced.html#secure-file-transfer",
    "title": "6  BASH advanced",
    "section": "7.9 9. Secure File Transfer",
    "text": "7.9 9. Secure File Transfer\n\nTransferring Files Securely\n\nscp: Secure copy protocol.\nrsync: Efficiently transfer files and directories.\nssh: Secure shell for remote access.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#command-execution-and-debugging",
    "href": "7_bash_comands_advanced.html#command-execution-and-debugging",
    "title": "6  BASH advanced",
    "section": "7.10 10. Command Execution and Debugging",
    "text": "7.10 10. Command Execution and Debugging\n\nCommand Substitution\n\neval: Execute commands stored in variables.\n\nDebugging Scripts\n\nIntroduction to debugging scripts (using set -x for tracing execution).",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "7_bash_comands_advanced.html#wrap-up",
    "href": "7_bash_comands_advanced.html#wrap-up",
    "title": "6  BASH advanced",
    "section": "7.11 Wrap-Up",
    "text": "7.11 Wrap-Up\n\nIntegration and Practice\n\nCombine learned commands in small exercises to reinforce concepts.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BASH advanced</span>"
    ]
  },
  {
    "objectID": "8_bash_advanced2.html",
    "href": "8_bash_advanced2.html",
    "title": "7  BASH advanced 2",
    "section": "",
    "text": "7.0.1 whoami\nKomanda whoami parodo dabartinio vartotojo (user) vardą, su kuriuo esate prisijungę prie sistemos. Tai paprastas ir naudingas būdas patikrinti, kokį vartotojo prisijungimą naudojate, ypač kai dirbate su keliais vartotojais toje pačioje sistemoje.",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "8_bash_advanced2.html#locate",
    "href": "8_bash_advanced2.html#locate",
    "title": "7  BASH advanced 2",
    "section": "7.1 locate",
    "text": "7.1 locate",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "8_bash_advanced2.html#whereis",
    "href": "8_bash_advanced2.html#whereis",
    "title": "7  BASH advanced 2",
    "section": "7.2 whereis",
    "text": "7.2 whereis",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "8_bash_advanced2.html#path-1",
    "href": "8_bash_advanced2.html#path-1",
    "title": "7  BASH advanced 2",
    "section": "7.3 path",
    "text": "7.3 path",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "8_bash_advanced2.html#man",
    "href": "8_bash_advanced2.html#man",
    "title": "7  BASH advanced 2",
    "section": "7.4 man",
    "text": "7.4 man",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "8_bash_advanced2.html#help",
    "href": "8_bash_advanced2.html#help",
    "title": "7  BASH advanced 2",
    "section": "7.5 –help",
    "text": "7.5 –help",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  },
  {
    "objectID": "8_bash_advanced2.html#tldr",
    "href": "8_bash_advanced2.html#tldr",
    "title": "7  BASH advanced 2",
    "section": "7.6 tldr",
    "text": "7.6 tldr\nman puslapiai yra begalo išsamūs, tačiau jie ir ganėtinai ilgi. &lt;command&gt; --help arba &lt;command&gt; -h kartais būna gani trumpi ir aiškūs pagalbos puslpiai, tačiau jeigu komanda turi daug nustatymų ir argumentų, net --help puslapiai gali būti perdaug sudėtingi, ypač pačioje pradžioje naudojantis Linux.\nInstaliuok programa yt-dlp ir paleisk jos --help puslapį. Gana ilgas tiesa?\nKita programa, kuri stengiasi padėti CLI naudotojams, yra tldr (akronimias reiškiantis “too long;didn’t read it” = santrauka)\ninstaliuok programa tldr ir paleisk ją su argumentu yt-dlp\ntldr yt-dlp\nŠi programa pateikia dažniausius komandos naudjimo scenarijus ir labai trumpą paaiškinimą apie komandą. Tad tai dar vienas instrumentas tavo arsenale, primiršus prismint kaip veikia komanda, ką ji daro ir kokie nustatymai ir argumentai yra galimi. 5. Pabandyk tldr tldr",
    "crumbs": [
      "Bash and Terminal",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>BASH advanced 2</span>"
    ]
  }
]